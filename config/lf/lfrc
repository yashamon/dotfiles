set ratios 1:2:3
set filesep " "
set shell pwsh 
# set shell "C:\\Users\\yasha\\scoop\\shims\\nu.exe"

# Shell commands with multiline definitions and/or positional arguments and/or
# quotes do not work in Windows. For anything but the simplest shell commands,
# it is recommended to create separate script files and simply call them here
# in commands or mappings.
#
# Also, the default keybindings are defined using cmd syntax (i.e. '%EDITOR%')
# which does not work with powershell. Therefore, you need to override these
# keybindings with explicit choices accordingly.
# change the default open command to work in powerShell
cmd open &start $Env:f
# set filesep " "
# change the editor used in default editor keybinding
# There is no builtin terminal editor installed in Windows. The default editor
# mapping uses 'notepad' which launches in a separate GUI window. You may
# instead install a terminal editor of your choice and replace the default
# editor keybinding accordingly.
# change the pager used in default pager keybinding
# The standard pager used in Windows is 'more' which is not a very capable
# pager. You may instead install a pager of your choice and replace the default
# pager keybinding accordingly.
map i $less $Env:f
map Y %echo $Env:fx | clip 
# change the shell used in default shell keybinding
map w $pwsh
# change 'doc' command to use a different pager
cmd doc $lf -doc | less
# leave some space at the top and the bottom of the screen
set scrolloff 10
# use enter for shell commands
map <enter> shell
# set previewer "D:\\lf_scripts\\preview.bat"
# set cleaner ~/.config/lf/cleaner
# set previewer ~/.config/lf/preview
# interpreter for shell commands
# set shellopts '-euy'
# set ifs "\n"
# set filesep "\n"  # default already
set hidden  
# cmd trash &{{
# set -- $(cat ~/.local/shahe/lf/files)
#     trash-put "$@" .;;
#     rm ~/.local/share/lf/files
#     lf -remote "send clear"
#     lf -remote "send reload"
#     lf -remote "send echomsg "deletesucess""
# }}

cmd trash $pwsh -c lfcdTrash.ps1 $Env:fx
# cmd trash recycle-bin $Env:fx
# set previewer stpv
# set cleaner stpvimgclr
# &stpvimg --listen $id 
map . mark-load
# cmd aj %lf -remote "send $id cd '$(autojump $1)'"
map gmd push %mkdir<space> 
map gt push %touch<space>
map gch push %chmod<space>
# map m push %mv<space>"$fs"<space>

cmd spaste &{{
set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    case "$mode" in
        copy)
            rsync -a --no-compress --ignore-existing -- "$@" .;;
        move) mv -n -- "$@" .;; 
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"  
    lf -remote "send reload" 
    lf -remote "send echomsg "copysucess""
}}

# set previewer ~/.config/lf/preview
# set cleaner ~/.config/lf/cleaner
cmd namepaste $cp-p --lf-paste $id  
# map gc :namepaste
map p $pwsh -c robocopy $Env:fx .
map gp :paste
cmd findfile $sh -c nu "C:\Users\yasha\dotfiles\scripts\findfile.nu"
map <a-f> :findfile

cmd findfileroot ${{
    res="$(fd . '/' -H | fzf --reverse --header='Jump to location')"
    if [ -d "$res" ]; then
        cmd="cd"
    else 
        cmd="select"                                                       
    fi
    lf -remote "send $id cd $HOME"
    lf -remote "send $id $cmd \"$res\""
}}
map gf :findfileroot

# map <a-f> fzffile   
# map <a-r> fzffileroot  
map d :cut
map D :trash
map gd :delete

cmd fzf_jump $nu "C:\Users\yasha\dotfiles\scripts\lfsimplejump.nu"
#
# ${{
#    $res= fd . -H -I -d 1 | fzf --reverse --header='Jump to location'
#  if (  Test-Path -Path "$res" -PathType Container )
#      { $cmd= "cd" }
#  else 
#     { $cmd="select" }                                                       
#  lf -remote "send $id $cmd \"$res\"" 
map f :fzf_jump

cmd fasd_dir ${{
   res="$(fasd -dl | grep -iv cache | fzf 2>/dev/tty | sed 's/\\/\\\\/g;s/"/\\"/g')"
   if [ -d "$res" ]; then
      cmd="cd"
   else
      cmd="select"
   fi
 lf -remote "send $id $cmd \"$res\""
 }}

# map  :fasd_dir
map J  :fasd_dir 
cmd Jhomedir  $nu "C:\Users\yasha\dotfiles\scripts\jumpdir.nu"
map <a-j> :Jhomedir

cmd Jrootdir  $nu "C:\Users\yasha\dotfiles\scripts\jumprootdir.nu"
map gj :Jrootdir


set scrolloff 10
# use enter for shell commands
map <enter> shell

# execute current file (must be executable)
map x $$Env:f
map X !$Env:f

# dedicated keys for file opener actions
map o &mimeopen $Env:f 
map O $mimeopen --ask $Env:f 

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
# cmd open ${{
#     test -L $f && f=$(readlink -f $f)
#     case $(file --mime-type $f -b) in
#         text/*) nvim $fx;;
#         *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
#     esac
# }}
map e %remotelf.ps1 $Env:f.Trim('"') 
map n %neovide $Env:f.Trim('"') 
map gn %neovide $Env:f.Trim('"') 
# define a custom 'rename' command without prompt for overwrite 
cmd spastename &{{
set -- $(cat ~/.local/share/lf/files)
   #  lf -remote "send echomsg "inputdestination""  
   #  lf -remote "send echomsg "inputdestination"" 
   # destination = "$(read varname ; echo $varname)"
    mode="$1"
    shift
    case "$mode" in
        copy)
            cp -r --backup=t "$@" .;;
        move) 
      mv -n --backup=t "$@" .;;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
    lf -remote "send reload" 
    lf -remote "send echomsg "copysucessblah""
}}
cmd echod $pwsh -nop -c echo $1 > blah

cmd rename $pwsh -nop -c mv $Env:f.Trim('"') $args[0]

# cmd cpmove %[ -e $destination ] && printf "file exists" || spastename $f $1

map r push %mv<space>$Env:f.Trim('"')<space>
map gc :spastename

# make sure trash folder exists
# %mkdir -p ~/.trash

# move current file or selected files to trash folder
# (also see 'man mv' for backup/overwrite options)
# cmd trash %set -f; mv $fx ~/.trash

# define a custom 'delete' command
# cmd delete ${{
#     set -f
#     printf "$fx\n"
#     printf "delete?[y/n]"
#     read ans
#     [ $ans = "y" ] && rm -rf $fx
# }}

# use '<delete>' key for either 'trash' or 'delete' command
# map <delete> trash
# map <delete> delete

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract $& "bash /mnt/c/Users/yasha/dotfilesscripts/lfcdextract.sh"
map gE :extract
# compress current file or selected files with tar and gunzip
# cmd tar ${param 
#     set -f
#     mkdir $1
#     cp -r $fx $1
#     tar czf $1.tar.gz $1
#     rm -rf $1
# }

# compress current file or selected files with zip
# cmd zip ${param ([string]$f) 
#     set -f
#     mkdir $f
#     cp -r $Env:fx $f
#     zip -r $f.zip $f
#     rm -rf $f
# }.Invoke($Args)

map gz zip
# cmd open ${{
#     case "$f" in
#         *.tar.bz|*.tar.bz2|*.tbz|*.tbz2|*.tar.gz|*.tgz|*.tar.xz|*.txz|*.zip|*.rar|*.iso)
#             mntdir="$f-archivemount"
#             [ ! -d "$mntdir" ] && {
#                 mkdir "$mntdir"
#                 archivemount "$f" "$mntdir"
#                 echo "$mntdir" >> "/tmp/__lf_archivemount_$id"
#             }
#             lf -remote "send $id cd \"$mntdir\""
#             lf -remote "send $id reload"
#             ;;
#         *)
#             for f in $fx; do
#                 $OPENER $f > /dev/null 2> /dev/null &
#             done;;
#     esac
# }}


cmd zle-cd %printf 'cd %q && zle reset-prompt\n' "$PWD" >&$ZLE_FIFO

cmd zle-insert-relative %{{
    for f in $fx; do
        printf 'LBUFFER+="${LBUFFER:+ }${(q)$(realpath %q --relative-to=$PWD)}"\n' "$f" >&$ZLE_FIFO
    done
}}

cmd zle-insert-absolute %{{
    for f in $fx; do
        printf 'LBUFFER+="${LBUFFER:+ }%q"\n' "$f" >&$ZLE_FIFO
    done
}}

cmd zle-init :{{
    map . zle-cd
    map a zle-insert-relative
    map A zle-insert-absolute
}}

&[[ -n "$ZLE_FIFO" ]] && lf -remote "send $id zle-init"


# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %pwsh -nop -c C:\Users\yasha\dotfiles\scripts\lfLn.ps1 $Env:fx
map P :link


cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-basename $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard

cmd yank-basename-without-extension ${{
    echo "$fx" |
      xargs -r -d '\n' basename -a |
      awk -e '{
        for (i=length($0); i > 0; i--) {
          if (substr($0, i, 1) == ".") {
            if (i == 1) print $0
            else print substr($0, 0, i-1)

            break
          }
        }

        if (i == 0)
          print $0
      }' |
      if [ -n "$fs" ]; then cat; else tr -d '\n'; fi |
      xclip -i -selection clipboard
}}
map gy :yank-path 


cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    [ -n "$fs" ] && fs="$(ls)"
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}} 


# Unmap the default binding
# map r
# Rename the file with a completely different name
# map rc push :rename<space>
# Edit the current filename
map ra ${{
	# get 'basename' of the selection
	filename="${f##*/}"
	# quote it so we won't deal with quotes in the lf -remote command
	filename="$(printf '%q' "$filename")"
	filename="${filename// /<space>}"
	lf -remote "send $id push :rename<space>$filename"
}}
# Edit filename before the extension
# map r ${{
# 	# get 'basename' of the selection
# 	filename="${f##*/}"
# 	# quote it so we won't deal with quotes in the lf -remote command
# 	filename="$(printf '%q' "$filename")"
# 	filename="${filename// /<space>}"
# 	lf -remote "send $id push :rename<space>$filename<a-b><c-b>"
# }} 

# map q quitcd
# cmd quitcd ${{
# 	echo "1" > "$LF_SHELLCD_TEMPDIR/changecwd"
# 	lf -remote "send $id quit"
# }}
# push mw
# map q push 'w:quit<enter>
# map Q push :quit<enter>
# cmd fzffile ${{
#     res="$(fd . $HOME -H -I | fzf --reverse --header='Jump to location')"
#     if [ -d "$res" ]; then
#         cmd="cd"
#     else 
#         cmd="select"                                                       
#     fi
#     lf -remote "send $id cd $HOME"
#     lf -remote "send $id $cmd \"$res\""
# }}
# cmd fzf_jump $& \"C:\Users\yasha\blah.ps1\"
# map f push $& "C:\Users\yasha\blah.ps1"

