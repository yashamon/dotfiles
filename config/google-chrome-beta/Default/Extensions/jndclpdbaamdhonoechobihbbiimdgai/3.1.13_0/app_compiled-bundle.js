//googleclient/chrome/chromeos_recovery/chrome_app/closuredevfix.js
/**
 * @fileoverview Provides constants for running Closure uncompiled in a packaged
 * app.  Packaged apps don't support adding script tags through document.write,
 * so have to add explicit script tags instead.
 */


/**
 * Overrides the import script to import via explicit script tags instead of
 * document.write for packaged apps.
 *
 * @param {string} src - The source URL.
 * @return {boolean} Whether the import was successful.
 */
var CLOSURE_IMPORT_SCRIPT = function(src) {
  var script = document.createElement('script');
  script.src = src;
  script.type = 'text/javascript';
  document.getElementsByTagName('head')[0].appendChild(script);
  return true;
};


/**
 * deps.js is not needed, so no need to force loading of deps.js.
 */
var CLOSURE_NO_DEPS = true;

//javascript/closure/base.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will attempt to load Closure's deps file, unless
 * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects
 * to include their own deps file(s) from different locations.
 *
 * Avoid including base.js more than once. This is strictly discouraged and not
 * supported. goog.require(...) won't work properly in that case.
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};

/**
 * Reference to the global object.
 * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-global-object
 *
 * More info on this implementation here:
 * https://docs.google.com/document/d/1NAeW4Wk7I7FV0Y2tcUFvQdGMc89k2vdgSXInw8_nvCI/edit
 *
 * @const
 * @suppress {undefinedVars} self won't be referenced unless `this` is falsy.
 * @type {!Global}
 */
goog.global =
    // Check `this` first for backwards compatibility.
    // Valid unless running as an ES module or in a function wrapper called
    //   without setting `this` properly.
    // Note that base.js can't usefully be imported as an ES module, but it may
    // be compiled into bundles that are loadable as ES modules.
    this ||
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/self
    // For in-page browser environments and workers.
    self;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, `CLOSURE_UNCOMPILED_DEFINES` may be defined before
 * loading base.js.  If a key is defined in `CLOSURE_UNCOMPILED_DEFINES`,
 * `goog.define` will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name The name of the object that this file defines.
 * @param {*=} object The object to expose at the end of the path.
 * @param {boolean=} overwriteImplicit If object is set and a previous call
 *     implicitly constructed the namespace given by name, this parameter
 *     controls whether object should overwrite the implicitly constructed
 *     namespace or be merged into it. Defaults to false.
 * @param {?Object=} objectToExportTo The object to add the path to; if this
 *     field is not specified, its value defaults to `goog.global`.
 * @private
 */
goog.exportPath_ = function(name, object, overwriteImplicit, objectToExportTo) {
  var parts = name.split('.');
  var cur = objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && typeof cur.execScript != 'undefined') {
    cur.execScript('var ' + parts[0]);
  }

  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && object !== undefined) {
      if (!overwriteImplicit && goog.isObject(object) &&
          goog.isObject(cur[part])) {
        // Merge properties on object (the input parameter) with the existing
        // implicitly defined namespace, so as to not clobber previously
        // defined child namespaces.
        for (var prop in object) {
          if (object.hasOwnProperty(prop)) {
            cur[part][prop] = object[prop];
          }
        }
      } else {
        // Either there is no existing implicit namespace, or overwriteImplicit
        // is set to true, so directly assign object (the input parameter) to
        // the namespace.
        cur[part] = object;
      }
    } else if (cur[part] && cur[part] !== Object.prototype[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler options or the
 * value set in the CLOSURE_DEFINES object. Returns the defined value so that it
 * can be used safely in modules. Note that the value type MUST be either
 * boolean, number, or string.
 *
 * @param {string} name The distinguished name to provide.
 * @param {T} defaultValue
 * @return {T} The defined value.
 * @template T
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;
    var defines = goog.global.CLOSURE_DEFINES;
    if (uncompiledDefines &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (uncompiledDefines).nodeType === undefined &&
        Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) {
      value = uncompiledDefines[name];
    } else if (
        defines &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (defines).nodeType === undefined &&
        Object.prototype.hasOwnProperty.call(defines, name)) {
      value = defines[name];
    }
  }
  return value;
};


/**
 * @define {number} Integer year indicating the set of browser features that are
 * guaranteed to be present.  This is defined to include exactly features that
 * work correctly on all "modern" browsers that are stable on January 1 of the
 * specified year.  For example,
 * ```js
 * if (goog.FEATURESET_YEAR >= 2019) {
 *   // use APIs known to be available on all major stable browsers Jan 1, 2019
 * } else {
 *   // polyfill for older browsers
 * }
 * ```
 * This is intended to be the primary define for removing
 * unnecessary browser compatibility code (such as ponyfills and workarounds),
 * and should inform the default value for most other defines:
 * ```js
 * const ASSUME_NATIVE_PROMISE =
 *     goog.define('ASSUME_NATIVE_PROMISE', goog.FEATURESET_YEAR >= 2016);
 * ```
 *
 * The default assumption is that IE9 is the lowest supported browser, which was
 * first available Jan 1, 2012.
 *
 * TODO(mathiasb): Reference more thorough documentation when it's available.
 */
goog.FEATURESET_YEAR = goog.define('goog.FEATURESET_YEAR', 2012);


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production. It can be easily stripped
 * by specifying --define goog.DEBUG=false to the Closure Compiler aka
 * JSCompiler. For example, most toString() methods should be declared inside an
 * "if (goog.DEBUG)" conditional because they are generally used for debugging
 * purposes and it is difficult for the JSCompiler to statically determine
 * whether they are used.
 */
goog.DEBUG = goog.define('goog.DEBUG', true);


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as a compiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he).
 *
 * MOE:begin_intracomment_strip
 * See http://g3doc/i18n/identifiers/g3doc/synonyms.
 * MOE:end_intracomment_strip
 */
goog.LOCALE = goog.define('goog.LOCALE', 'en');  // default to en


/**
 * This method is intended to be used for bookkeeping purposes.  We would
 * like to distinguish uses of goog.LOCALE used for code stripping purposes
 * and uses of goog.LOCALE for other uses (such as URL parameters).
 *
 * This allows us to ban direct uses of goog.LOCALE and to ensure that all
 * code has been transformed to our new localization build scheme.
 *
 * @return {string}
 *
 */
goog.getLocale = function() {
  return goog.LOCALE;
};


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the compiler.
 */
goog.TRUSTED_SITE = goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */
goog.DISALLOW_TEST_ONLY_CODE =
    goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);


/**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */
goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING =
    goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);


/**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * deprecated Use goog.module (see b/159289405)
 */
goog.provide = function(name) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.provide cannot be used within a module.');
  }
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
  }

  goog.constructNamespace_(name);
};


/**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {?Object=} object The object to embed in the namespace.
 * @param {boolean=} overwriteImplicit If object is set and a previous call
 *     implicitly constructed the namespace given by name, this parameter
 *     controls whether opt_obj should overwrite the implicitly constructed
 *     namespace or be merged into it. Defaults to false.
 * @private
 */
goog.constructNamespace_ = function(name, object, overwriteImplicit) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name, object, overwriteImplicit);
};


/**
 * According to the CSP3 spec a nonce must be a valid base64 string.
 * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value
 * @private @const
 */
goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;


/**
 * Returns CSP nonce, if set for any script tag.
 * @param {?Window=} opt_window The window context used to retrieve the nonce.
 *     Defaults to global context.
 * @return {string} CSP nonce or empty string if no nonce is present.
 * @private
 */
goog.getScriptNonce_ = function(opt_window) {
  var doc = (opt_window || goog.global).document;
  var script = doc.querySelector && doc.querySelector('script[nonce]');
  if (script) {
    // Try to get the nonce from the IDL property first, because browsers that
    // implement additional nonce protection features (currently only Chrome) to
    // prevent nonce stealing via CSS do not expose the nonce via attributes.
    // See https://github.com/whatwg/html/issues/2369
    var nonce = script['nonce'] || script.getAttribute('nonce');
    if (nonce && goog.NONCE_PATTERN_.test(nonce)) {
      return nonce;
    }
  }
  return '';
};


/**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;


/**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 * MOE:begin_intracomment_strip
 * See the goog.module announcement at http://go/goog.module-announce
 * MOE:end_intracomment_strip
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 * @return {void}
 */
goog.module = function(name) {
  if (typeof name !== 'string' || !name ||
      name.search(goog.VALID_MODULE_RE_) == -1) {
    throw new Error('Invalid module identifier');
  }
  if (!goog.isInGoogModuleLoader_()) {
    throw new Error(
        'Module ' + name + ' has been loaded incorrectly. Note, ' +
        'modules cannot be loaded as normal scripts. They require some kind of ' +
        'pre-processing step. You\'re likely trying to load a module via a ' +
        'script tag or as a part of a concatenated bundle without rewriting the ' +
        'module. For more info see: ' +
        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw new Error('goog.module may only be called once per module.');
  }

  // Store the module name for the loader.
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (name in goog.loadedModules_) {
      return goog.loadedModules_[name].exports;
    } else if (!goog.implicitNamespaces_[name]) {
      var ns = goog.getObjectByName(name);
      return ns != null ? ns : null;
    }
  }
  return null;
};


/**
 * Types of modules the debug loader can load.
 * @enum {string}
 */
goog.ModuleType = {
  ES6: 'es6',
  GOOG: 'goog'
};


/**
 * @private {?{
 *   moduleName: (string|undefined),
 *   declareLegacyNamespace:boolean,
 *   type: ?goog.ModuleType
 * }}
 */
goog.moduleLoaderState_ = null;


/**
 * @private
 * @return {boolean} Whether a goog.module or an es6 module is currently being
 *     initialized.
 */
goog.isInModuleLoader_ = function() {
  return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
};


/**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */
goog.isInGoogModuleLoader_ = function() {
  return !!goog.moduleLoaderState_ &&
      goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
};


/**
 * @private
 * @return {boolean} Whether an es6 module is currently being initialized.
 */
goog.isInEs6ModuleLoader_ = function() {
  var inLoader = !!goog.moduleLoaderState_ &&
      goog.moduleLoaderState_.type == goog.ModuleType.ES6;

  if (inLoader) {
    return true;
  }

  var jscomp = goog.global['$jscomp'];

  if (jscomp) {
    // jscomp may not have getCurrentModulePath if this is a compiled bundle
    // that has some of the runtime, but not all of it. This can happen if
    // optimizations are turned on so the unused runtime is removed but renaming
    // and Closure pass are off (so $jscomp is still named $jscomp and the
    // goog.provide/require calls still exist).
    if (typeof jscomp.getCurrentModulePath != 'function') {
      return false;
    }

    // Bundled ES6 module.
    return !!jscomp.getCurrentModulePath();
  }

  return false;
};


/**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInGoogModuleLoader_()) {
    throw new Error(
        'goog.module.declareLegacyNamespace must be called from ' +
        'within a goog.module');
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw new Error(
        'goog.module must be called prior to ' +
        'goog.module.declareLegacyNamespace.');
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};


/**
 * Associates an ES6 module with a Closure module ID so that is available via
 * goog.require. The associated ID  acts like a goog.module ID - it does not
 * create any global names, it is merely available via goog.require /
 * goog.module.get / goog.forwardDeclare / goog.requireType. goog.require and
 * goog.module.get will return the entire module as if it was import *'d. This
 * allows Closure files to reference ES6 modules for the sake of migration.
 *
 * @param {string} namespace
 * @suppress {missingProvide}
 */
goog.declareModuleId = function(namespace) {
  if (!COMPILED) {
    if (!goog.isInEs6ModuleLoader_()) {
      throw new Error(
          'goog.declareModuleId may only be called from ' +
          'within an ES6 module');
    }
    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) {
      throw new Error(
          'goog.declareModuleId may only be called once per module.');
    }
    if (namespace in goog.loadedModules_) {
      throw new Error(
          'Module with namespace "' + namespace + '" already exists.');
    }
  }
  if (goog.moduleLoaderState_) {
    // Not bundled - debug loading.
    goog.moduleLoaderState_.moduleName = namespace;
  } else {
    // Bundled - not debug loading, no module loader state.
    var jscomp = goog.global['$jscomp'];
    if (!jscomp || typeof jscomp.getCurrentModulePath != 'function') {
      throw new Error(
          'Module with namespace "' + namespace +
          '" has been loaded incorrectly.');
    }
    var exports = jscomp.require(jscomp.getCurrentModulePath());
    goog.loadedModules_[namespace] = {
      exports: exports,
      type: goog.ModuleType.ES6,
      moduleId: namespace
    };
  }
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || '';
    throw new Error(
        'Importing test-only code into non-debug environment' +
        (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 * Before using goog.forwardDeclare, please read the documentation at
 * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to
 * understand the options and tradeoffs when working with forward declarations.
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 * @deprecated See go/noforwarddeclaration, Use `goog.requireType` instead.
 */
goog.forwardDeclare = function(name) {};


/**
 * Forward declare type information. Used to assign types to goog.global
 * referenced object that would otherwise result in unknown type references
 * and thus block property disambiguation.
 */
goog.forwardDeclare('Document');
goog.forwardDeclare('HTMLScriptElement');
goog.forwardDeclare('XMLHttpRequest');


if (!COMPILED) {
  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return (name in goog.loadedModules_) ||
        (!goog.implicitNamespaces_[name] && goog.getObjectByName(name) != null);
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */
  goog.implicitNamespaces_ = {'goog.module': true};

  // NOTE: We add goog.module as an implicit namespace as goog.module is defined
  // here and because the existing module package has not been moved yet out of
  // the goog.module namespace. This satisifies both the debug loader and
  // ahead-of-time dependency management.
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var i = 0; i < parts.length; i++) {
    cur = cur[parts[i]];
    if (cur == null) {
      return null;
    }
  }
  return cur;
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
 *     how the file must be loaded.  The boolean 'true' is equivalent
 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
 */
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
  if (!COMPILED && goog.DEPENDENCIES_ENABLED) {
    goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags);
  }
};


// MOE:begin_strip
/**
 * Whether goog.require should throw an exception if it fails.
 * @type {boolean}
 */
goog.useStrictRequires = false;


// MOE:end_strip


// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// MOE:begin_strip
// Internally: http://go/deps-files and http://go/be#js_deps
// MOE:end_strip
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work was done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.ENABLE_DEBUG_LOADER = goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * @param {string} msg
 * @private
 */
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console['error'](msg);
  }
};


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system.
 *
 * Note that all calls to goog.require will be stripped by the compiler.
 *
 * @see goog.provide
 * @param {string} namespace Namespace (as was given in goog.provide,
 *     goog.module, or goog.declareModuleId) in the form
 *     "goog.package.part".
 * @return {?} If called within a goog.module or ES6 module file, the associated
 *     namespace or module otherwise null.
 */
goog.require = function(namespace) {
  if (!COMPILED) {
    // Might need to lazy load on old IE.
    if (goog.ENABLE_DEBUG_LOADER) {
      goog.debugLoader_.requested(namespace);
    }

    // If the object already exists we do not need to do anything.
    if (goog.isProvided_(namespace)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(namespace);
      }
    } else if (goog.ENABLE_DEBUG_LOADER) {
      var moduleLoaderState = goog.moduleLoaderState_;
      goog.moduleLoaderState_ = null;
      try {
        goog.debugLoader_.load_(namespace);
      } finally {
        goog.moduleLoaderState_ = moduleLoaderState;
      }
    }

    return null;
  }
};


/**
 * Requires a symbol for its type information. This is an indication to the
 * compiler that the symbol may appear in type annotations, yet it is not
 * referenced at runtime.
 *
 * When called within a goog.module or ES6 module file, the return value may be
 * assigned to or destructured into a variable, but it may not be otherwise used
 * in code outside of a type annotation.
 *
 * Note that all calls to goog.requireType will be stripped by the compiler.
 *
 * @param {string} namespace Namespace (as was given in goog.provide,
 *     goog.module, or goog.declareModuleId) in the form
 *     "goog.package.part".
 * @return {?}
 */
goog.requireType = function(namespace) {
  // Return an empty object so that single-level destructuring of the return
  // value doesn't crash at runtime when using the debug loader. Multi-level
  // destructuring isn't supported.
  return {};
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to attempt to load Closure's deps file. By default, when uncompiled,
 * deps files will attempt to be loaded.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The first parameter the script source, which is a relative URI. The second,
 * optional parameter is the script contents, in the event the script needed
 * transformation. It should return true if the script was imported, false
 * otherwise.
 * @type {(function(string, string=): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 * @deprecated use '()=>{}' or 'function(){}' instead.
 */
goog.nullFunction = function() {};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 * @deprecated Use "@abstract" annotation instead of goog.abstractMethod in new
 *     code. See
 *     https://github.com/google/closure-compiler/wiki/@abstract-classes-and-methods
 */
goog.abstractMethod = function() {
  throw new Error('unimplemented abstract method');
};


/**
 * Adds a `getInstance` static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 * @suppress {missingProperties} 'instance_' isn't a property on 'Function'
 *     but we don't have a better type to use here.
 */
goog.addSingletonGetter = function(ctor) {
  // instance_ is immediately set to prevent issues with sealed constructors
  // such as are encountered when a constructor is returned as the export object
  // of a goog.module in unoptimized code.
  // Delcare type to avoid conformance violations that ctor.instance_ is unknown
  /** @type {undefined|!Object} @suppress {underscore} */
  ctor.instance_ = undefined;
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    // Cast to avoid conformance violations that ctor.instance_ is unknown
    return /** @type {!Object|undefined} */ (ctor.instance_) = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the `goog.testing.singleton` module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * @define {boolean} Whether to load goog.modules using `eval` when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of `eval` is banned
 * so we provide an alternative.
 */
goog.LOAD_MODULE_USING_EVAL = goog.define('goog.LOAD_MODULE_USING_EVAL', true);


/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.SEAL_MODULE_EXPORTS = goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);


/**
 * The registry of initialized modules:
 * The module identifier or path to module exports map.
 * @private @const {!Object<string, {exports:?,type:string,moduleId:string}>}
 */
goog.loadedModules_ = {};


/**
 * True if the debug loader enabled and used.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


/**
 * @define {string} How to decide whether to transpile.  Valid values
 * are 'always', 'never', and 'detect'.  The default ('detect') is to
 * use feature detection to determine which language levels need
 * transpilation.
 */
// NOTE(sdh): we could expand this to accept a language level to bypass
// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but
// would leave ES3 and ES5 files alone.
goog.TRANSPILE = goog.define('goog.TRANSPILE', 'detect');

/**
 * @define {boolean} If true assume that ES modules have already been
 * transpiled by the jscompiler (in the same way that transpile.js would
 * transpile them - to jscomp modules). Useful only for servers that wish to use
 * the debug loader and transpile server side. Thus this is only respected if
 * goog.TRANSPILE is "never".
 */
goog.ASSUME_ES_MODULES_TRANSPILED =
    goog.define('goog.ASSUME_ES_MODULES_TRANSPILED', false);


/**
 * @define {string} If a file needs to be transpiled what the output language
 * should be. By default this is the highest language level this file detects
 * the current environment supports. Generally this flag should not be set, but
 * it could be useful to override. Example: If the current environment supports
 * ES6 then by default ES7+ files will be transpiled to ES6, unless this is
 * overridden.
 *
 * Valid values include: es3, es5, es6, es7, and es8. Anything not recognized
 * is treated as es3.
 *
 * Note that setting this value does not force transpilation. Just if
 * transpilation occurs this will be the output. So this is most useful when
 * goog.TRANSPILE is set to 'always' and then forcing the language level to be
 * something lower than what the environment detects.
 */
goog.TRANSPILE_TO_LANGUAGE = goog.define('goog.TRANSPILE_TO_LANGUAGE', '');


/**
 * @define {string} Path to the transpiler.  Executing the script at this
 * path (relative to base.js) should define a function $jscomp.transpile.
 */
goog.TRANSPILER = goog.define('goog.TRANSPILER', 'transpile.js');


/**
 * @define {string} Trusted Types policy name. If non-empty then Closure will
 * use Trusted Types.
 */
goog.TRUSTED_TYPES_POLICY_NAME =
    goog.define('goog.TRUSTED_TYPES_POLICY_NAME', 'goog');


/**
 * @package {?boolean}
 * Visible for testing.
 */
goog.hasBadLetScoping = null;


/**
 * @param {function(?):?|string} moduleDef The module definition.
 */
goog.loadModule = function(moduleDef) {
  // NOTE: we allow function definitions to be either in the from
  // of a string to eval (which keeps the original source intact) or
  // in a eval forbidden environment (CSP) we allow a function definition
  // which in its body must call `goog.module`, and return the exports
  // of the module.
  var previousState = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {
      moduleName: '',
      declareLegacyNamespace: false,
      type: goog.ModuleType.GOOG
    };
    var origExports = {};
    var exports = origExports;
    if (typeof moduleDef === 'function') {
      exports = moduleDef.call(undefined, exports);
    } else if (typeof moduleDef === 'string') {
      exports = goog.loadModuleFromSource_.call(undefined, exports, moduleDef);
    } else {
      throw new Error('Invalid module definition');
    }

    var moduleName = goog.moduleLoaderState_.moduleName;
    if (typeof moduleName === 'string' && moduleName) {
      // Don't seal legacy namespaces as they may be used as a parent of
      // another namespace
      if (goog.moduleLoaderState_.declareLegacyNamespace) {
        // Whether exports was overwritten via default export assignment.
        // This is important for legacy namespaces as it dictates whether
        // previously a previously loaded implicit namespace should be clobbered
        // or not.
        var isDefaultExport = origExports !== exports;
        goog.constructNamespace_(moduleName, exports, isDefaultExport);
      } else if (
          goog.SEAL_MODULE_EXPORTS && Object.seal &&
          typeof exports == 'object' && exports != null) {
        Object.seal(exports);
      }

      var data = {
        exports: exports,
        type: goog.ModuleType.GOOG,
        moduleId: goog.moduleLoaderState_.moduleName
      };
      goog.loadedModules_[moduleName] = data;
    } else {
      throw new Error('Invalid module name \"' + moduleName + '\"');
    }
  } finally {
    goog.moduleLoaderState_ = previousState;
  }
};


/**
 * @private @const
 */
goog.loadModuleFromSource_ =
    /** @type {function(!Object, string):?} */ (function(exports) {
      // NOTE: we avoid declaring parameters or local variables here to avoid
      // masking globals or leaking values into the module definition.
      'use strict';
      eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(arguments[1]));
      return exports;
    });


/**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */
goog.normalizePath_ = function(path) {
  var components = path.split('/');
  var i = 0;
  while (i < components.length) {
    if (components[i] == '.') {
      components.splice(i, 1);
    } else if (
        i && components[i] == '..' && components[i - 1] &&
        components[i - 1] != '..') {
      components.splice(--i, 2);
    } else {
      i++;
    }
  }
  return components.join('/');
};


/**
 * Provides a hook for loading a file when using Closure's goog.require() API
 * with goog.modules.  In particular this hook is provided to support Node.js.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_LOAD_FILE_SYNC;


/**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {?string} File contents, or null if load failed.
 * @private
 */
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    try {
      /** @type {XMLHttpRequest} */
      var xhr = new goog.global['XMLHttpRequest']();
      xhr.open('get', src, false);
      xhr.send();
      // NOTE: Successful http: requests have a status of 200, but successful
      // file: requests may have a status of zero.  Any other status, or a
      // thrown exception (particularly in case of file: requests) indicates
      // some sort of error, which we treat as a missing or unavailable file.
      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;
    } catch (err) {
      // No need to rethrow or log, since errors should show up on their own.
      return null;
    }
  }
};


/**
 * Lazily retrieves the transpiler and applies it to the source.
 * @param {string} code JS code.
 * @param {string} path Path to the code.
 * @param {string} target Language level output.
 * @return {string} The transpiled code.
 * @private
 */
goog.transpile_ = function(code, path, target) {
  var jscomp = goog.global['$jscomp'];
  if (!jscomp) {
    goog.global['$jscomp'] = jscomp = {};
  }
  var transpile = jscomp.transpile;
  if (!transpile) {
    var transpilerPath = goog.basePath + goog.TRANSPILER;
    var transpilerCode = goog.loadFileSync_(transpilerPath);
    if (transpilerCode) {
      // This must be executed synchronously, since by the time we know we
      // need it, we're about to load and write the ES6 code synchronously,
      // so a normal script-tag load will be too slow. Wrapped in a function
      // so that code is eval'd in the global scope.
      (function() {
        (0, eval)(transpilerCode + '\n//# sourceURL=' + transpilerPath);
      }).call(goog.global);
      // Even though the transpiler is optional, if $gwtExport is found, it's
      // a sign the transpiler was loaded and the $jscomp.transpile *should*
      // be there.
      if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&
          !goog.global['$gwtExport']['$jscomp']['transpile']) {
        throw new Error(
            'The transpiler did not properly export the "transpile" ' +
            'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));
      }
      // transpile.js only exports a single $jscomp function, transpile. We
      // grab just that and add it to the existing definition of $jscomp which
      // contains the polyfills.
      goog.global['$jscomp'].transpile =
          goog.global['$gwtExport']['$jscomp']['transpile'];
      jscomp = goog.global['$jscomp'];
      transpile = jscomp.transpile;
    }
  }
  if (!transpile) {
    // The transpiler is an optional component.  If it's not available then
    // replace it with a pass-through function that simply logs.
    var suffix = ' requires transpilation but no transpiler was found.';
    // MOE:begin_strip
    suffix +=  // Provide a more appropriate message internally.
        ' Please add "//javascript/closure:transpiler" as a data ' +
        'dependency to ensure it is included.';
    // MOE:end_strip
    transpile = jscomp.transpile = function(code, path) {
      // TODO(sdh): figure out some way to get this error to show up
      // in test results, noting that the failure may occur in many
      // different ways, including in loadModule() before the test
      // runner even comes up.
      goog.logToConsole_(path + suffix);
      return code;
    };
  }
  // Note: any transpilation errors/warnings will be logged to the console.
  return transpile(code, path, target);
};

//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {?} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;

  if (s != 'object') {
    return s;
  }

  if (!value) {
    return 'null';
  }

  if (Array.isArray(value)) {
    return 'array';
  }
  return s;
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. Note that for this function neither strings nor functions are
 * considered "array-like".
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  // We do not use goog.isObject here in order to exclude function values.
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into `getUid`. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.
  return Object.prototype.hasOwnProperty.call(obj, goog.UID_PROPERTY_) &&
      obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using `goog.getUid` in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if (obj !== null && 'removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }

  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (typeof obj.clone === 'function') {
      return obj.clone();
    }
    if (typeof Map !== 'undefined' && obj instanceof Map) {
      return new Map(obj);
    } else if (typeof Set !== 'undefined' && obj instanceof Set) {
      return new Set(obj);
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 * @deprecated use `=> {}` or Function.prototype.bind instead.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like goog.bind(), except that a 'this object' is not required. Useful when
 * the target function is already bound.
 *
 * Usage:
 * var g = goog.partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(/** @type {?} */ (this), newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 *
 * NOTE: Some have advocated for the use of goog.mixin to setup classes
 * with multiple inheritence (traits, mixins, etc).  However, as it simply
 * uses "for in", this is not compatible with ES6 classes whose methods are
 * non-enumerable.  Changing this, would break cases where non-enumerable
 * properties are not expected.
 *
 * @param {Object} target Target.
 * @param {Object} source Source.
 * @deprecated Prefer Object.assign
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 * @deprecated Use Date.now
 */
goog.now = function() {
  return Date.now();
};


/**
 * Evals JavaScript in the global scope.
 *
 * Throws an exception if neither execScript or eval is defined.
 * @param {string|!TrustedScript} script JavaScript string.
 */
goog.globalEval = function(script) {
  (0, eval)(script);
};


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;



/**
 * A hook for modifying the default behavior goog.getCssName. The function
 * if present, will receive the standard output of the goog.getCssName as
 * its input.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAP_FN;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x = 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  // String() is used for compatibility with compiled soy where the passed
  // className can be non-string objects.
  if (String(className).charAt(0) == '.') {
    throw new Error(
        'className passed in goog.getCssName must not start with ".".' +
        ' You passed: ' + className);
  }

  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename =
        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  var result =
      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);

  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further
  // processing of the class name.
  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {
    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
  }

  return result;
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --process_closure_primitives flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * This function produces a string which should be treated as plain text. Use
 * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to
 * produce SafeHtml.
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @param {{html: (boolean|undefined),
 *         unescapeHtmlEntities: (boolean|undefined)}=} opt_options Options:
 *     html: Escape '<' in str to '&lt;'. Used by Closure Templates where the
 *     generated code size and performance is critical which is why {@link
 *     goog.html.SafeHtmlFormatter} is not used. The value must be literal true
 *     or false.
 *     unescapeHtmlEntities: Unescape common html entities: &gt;, &lt;, &apos;,
 *     &quot; and &amp;. Used for messages not in HTML context, such as with
 *     `textContent` property.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values, opt_options) {
  if (opt_options && opt_options.html) {
    // Note that '&' is not replaced because the translation can contain HTML
    // entities.
    str = str.replace(/</g, '&lt;');
  }
  if (opt_options && opt_options.unescapeHtmlEntities) {
    // Note that "&amp;" must be the last to avoid "creating" new entities.
    str = str.replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&apos;/g, '\'')
              .replace(/&quot;/g, '"')
              .replace(/&amp;/g, '&');
  }
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return (opt_values != null && key in opt_values) ? opt_values[key] :
                                                         match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {?Object=} objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, objectToExportTo) {
  goog.exportPath_(
      publicPath, object, /* overwriteImplicit= */ true, objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {!Function} childCtor Child class.
 * @param {!Function} parentCtor Parent class.
 * @suppress {strictMissingProperties} superClass_ and base is not defined on
 *    Function.
 * @deprecated Use ECMAScript class syntax instead.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {}
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 * MOE:begin_intracomment_strip
 * See the goog.scope document at http://go/goog.scope
 *
 * For more on goog.scope deprecation, see the style guide entry:
 * http://go/jsstyle#appendices-legacy-exceptions-goog-scope
 * MOE:end_intracomment_strip
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 * @deprecated Use goog.module instead.
 */
goog.scope = function(fn) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.scope is not supported within a module.');
  }
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}


//==============================================================================
// goog.defineClass implementation
//==============================================================================


/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 * @deprecated Use ECMAScript class syntax instead.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw new Error(
          'cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {{
 *   constructor: (!Function|undefined),
 *   statics: (Object|undefined|function(Function):void)
 * }}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by goog.defineClass should
 *     be sealed when possible.
 *
 * When sealing is disabled the constructor function will not be wrapped by
 * goog.defineClass, making it incompatible with ES6 class methods.
 */
goog.defineClass.SEAL_CLASS_INSTANCES =
    goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {
    // Do now wrap the constructor when sealing is disabled. Angular code
    // depends on this for injection to work properly.
    return ctr;
  }

  // NOTE: The sealing behavior has been removed

  /**
   * @this {Object}
   * @return {?}
   */
  var wrappedCtr = function() {
    // Don't seal an instance of a subclass when it calls the constructor of
    // its super class as there is most likely still setup to do.
    var instance = ctr.apply(this, arguments) || this;
    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];

    return instance;
  };

  return wrappedCtr;
};



// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
  'toLocaleString', 'toString', 'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properties from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};

/**
 * Returns the parameter.
 * @param {string} s
 * @return {string}
 * @private
 */
goog.identity_ = function(s) {
  return s;
};


/**
 * Creates Trusted Types policy if Trusted Types are supported by the browser.
 * The policy just blesses any string as a Trusted Type. It is not visibility
 * restricted because anyone can also call trustedTypes.createPolicy directly.
 * However, the allowed names should be restricted by a HTTP header and the
 * reference to the created policy should be visibility restricted.
 * @param {string} name
 * @return {?TrustedTypePolicy}
 */
goog.createTrustedTypesPolicy = function(name) {
  var policy = null;
  var policyFactory = goog.global.trustedTypes;
  if (!policyFactory || !policyFactory.createPolicy) {
    return policy;
  }
  // trustedTypes.createPolicy throws if called with a name that is already
  // registered, even in report-only mode. Until the API changes, catch the
  // error not to break the applications functionally. In such case, the code
  // will fall back to using regular Safe Types.
  // TODO(koto): Remove catching once createPolicy API stops throwing.
  try {
    policy = policyFactory.createPolicy(name, {
      createHTML: goog.identity_,
      createScript: goog.identity_,
      createScriptURL: goog.identity_
    });
  } catch (e) {
    goog.logToConsole_(e.message);
  }
  return policy;
};

// There's a bug in the compiler where without collapse properties the
// Closure namespace defines do not guard code correctly. To help reduce code
// size also check for !COMPILED even though it redundant until this is fixed.
if (!COMPILED && goog.DEPENDENCIES_ENABLED) {
  // MOE:begin_strip
  // TODO(b/67050526) This object is obsolete but some people are relying on
  // it internally. Keep it around until we migrate them.
  /**
   * @private
   * @type {{
   *   loadFlags: !Object<string, !Object<string, string>>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */
  goog.dependencies_ = {
    loadFlags: {},  // 1 to 1

    nameToPath: {},  // 1 to 1

    requires: {},  // 1 to many

    // Used when resolving dependencies to prevent us from visiting file
    // twice.
    visited: {},

    written: {},  // Used to keep track of script files we have written.

    deferred: {}  // Used to track deferred module evaluations in old IEs
  };

  /**
   * @return {!Object}
   * @private
   */
  goog.getLoader_ = function() {
    return {
      dependencies_: goog.dependencies_,
      writeScriptTag_: goog.writeScriptTag_
    };
  };


  /**
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      /** @type {!HTMLDocument} */
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page. This does not apply to the CSP-compliant method
      // of writing script tags.
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
          doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      var nonceAttr = '';
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        nonceAttr = ' nonce="' + nonce + '"';
      }

      if (opt_sourceText === undefined) {
        var script = '<script src="' + src + '"' + nonceAttr + '></' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      } else {
        var script = '<script' + nonceAttr + '>' +
            goog.protectScriptTag_(opt_sourceText) + '</' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      }
      return true;
    } else {
      return false;
    }
  };
  // MOE:end_strip


  /**
   * Tries to detect whether the current browser is Edge, based on the user
   * agent. This matches only pre-Chromium Edge.
   * @see https://docs.microsoft.com/en-us/microsoft-edge/web-platform/user-agent-string
   * @return {boolean} True if the current browser is Edge.
   * @private
   */
  goog.isEdge_ = function() {
    var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?
        goog.global.navigator.userAgent :
        '';
    var edgeRe = /Edge\/(\d+)(\.\d)*/i;
    return !!userAgent.match(edgeRe);
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    /** @type {!Document} */
    var doc = goog.global.document;
    return doc != null && 'write' in doc;  // XULDocument misses write.
  };


  /**
   * We'd like to check for if the document readyState is 'loading'; however
   * there are bugs on IE 10 and below where the readyState being anything other
   * than 'complete' is not reliable.
   * @return {boolean}
   * @private
   */
  goog.isDocumentLoading_ = function() {
    // attachEvent is available on IE 6 thru 10 only, and thus can be used to
    // detect those browsers.
    /** @type {!HTMLDocument} */
    var doc = goog.global.document;
    return doc.attachEvent ? doc.readyState != 'complete' :
                             doc.readyState == 'loading';
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH != undefined &&
        // Anti DOM-clobbering runtime check (b/37736576).
        typeof goog.global.CLOSURE_BASE_PATH === 'string') {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    /** @type {!Document} */
    var doc = goog.global.document;
    // If we have a currentScript available, use it exclusively.
    var currentScript = doc.currentScript;
    if (currentScript) {
      var scripts = [currentScript];
    } else {
      var scripts = doc.getElementsByTagName('SCRIPT');
    }
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);
      var src = script.src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };

  goog.findBasePath_();

  /** @struct @constructor @final */
  goog.Transpiler = function() {
    /** @private {?Object<string, boolean>} */
    this.requiresTranspilation_ = null;
    /** @private {string} */
    this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;
  };


  // MOE:begin_strip
  // LINT.IfChange
  // MOE:end_strip
  /**
   * Returns a newly created map from language mode string to a boolean
   * indicating whether transpilation should be done for that mode as well as
   * the highest level language that this environment supports.
   *
   * Guaranteed invariant:
   * For any two modes, l1 and l2 where l2 is a newer mode than l1,
   * `map[l1] == true` implies that `map[l2] == true`.
   *
   * Note this method is extracted and used elsewhere, so it cannot rely on
   * anything external (it should easily be able to be transformed into a
   * standalone, top level function).
   *
   * @private
   * @return {{
   *   target: string,
   *   map: !Object<string, boolean>
   * }}
   */
  goog.Transpiler.prototype.createRequiresTranspilation_ = function() {
    var transpilationTarget = 'es3';
    var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};
    var transpilationRequiredForAllLaterModes = false;

    /**
     * Adds an entry to requiresTranspliation for the given language mode.
     *
     * IMPORTANT: Calls must be made in order from oldest to newest language
     * mode.
     * @param {string} modeName
     * @param {function(): boolean} isSupported Returns true if the JS engine
     *     supports the given mode.
     */
    function addNewerLanguageTranspilationCheck(modeName, isSupported) {
      if (transpilationRequiredForAllLaterModes) {
        requiresTranspilation[modeName] = true;
      } else if (isSupported()) {
        transpilationTarget = modeName;
        requiresTranspilation[modeName] = false;
      } else {
        requiresTranspilation[modeName] = true;
        transpilationRequiredForAllLaterModes = true;
      }
    }

    /**
     * Does the given code evaluate without syntax errors and return a truthy
     * result?
     */
    function /** boolean */ evalCheck(/** string */ code) {
      try {
        return !!eval(goog.CLOSURE_EVAL_PREFILTER_.createScript(code));
      } catch (ignored) {
        return false;
      }
    }

    // Identify ES3-only browsers by their incorrect treatment of commas.
    addNewerLanguageTranspilationCheck('es5', function() {
      return evalCheck('[1,].length==1');
    });
    addNewerLanguageTranspilationCheck('es6', function() {
      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:
      // https://github.com/Microsoft/ChakraCore/issues/1496.
      // MOE:begin_strip
      // TODO(joeltine): Our internal web-testing version of Edge will need to
      // be updated before we can remove this check. See http://b/34945376.
      // MOE:end_strip
      if (goog.isEdge_()) {
        // The Reflect.construct test below is flaky on Edge. It can sometimes
        // pass or fail on 40 15.15063, so just exit early for Edge and treat
        // it as ES5. Until we're on a more up to date version just always use
        // ES5. See https://github.com/Microsoft/ChakraCore/issues/3217.
        return false;
      }
      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]
      //   (a) default params (specifically shadowing locals),
      //   (b) destructuring, (c) block-scoped functions,
      //   (d) for-of (const), (e) new.target/Reflect.construct
      var es6fullTest =
          'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +
          'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +
          'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +
          'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +
          '==3}';

      return evalCheck('(()=>{"use strict";' + es6fullTest + '})()');
    });
    // ** and **= are the only new features in 'es7'
    addNewerLanguageTranspilationCheck('es7', function() {
      return evalCheck('2**3==8');
    });
    // async functions are the only new features in 'es8'
    addNewerLanguageTranspilationCheck('es8', function() {
      return evalCheck('async()=>1,1');
    });
    addNewerLanguageTranspilationCheck('es9', function() {
      return evalCheck('({...rest}={}),1');
    });
    // optional catch binding, unescaped unicode paragraph separator in strings
    addNewerLanguageTranspilationCheck('es_2019', function() {
      return evalCheck('let r;try{r="\u2029"}catch{};r');
    });
    // optional chaining, nullish coalescing
    // untested/unsupported: bigint, import meta
    addNewerLanguageTranspilationCheck('es_2020', function() {
      return evalCheck('null?.x??1');
    });
    addNewerLanguageTranspilationCheck('es_next', function() {
      return false;  // assume it always need to transpile
    });
    return {target: transpilationTarget, map: requiresTranspilation};
  };
  // MOE:begin_strip
  // LINT.ThenChange(//depot/google3/java/com/google/testing/web/devtools/updatebrowserinfo/requires_transpilation.js)
  // MOE:end_strip


  /**
   * Determines whether the given language needs to be transpiled.
   * @param {string} lang
   * @param {string|undefined} module
   * @return {boolean}
   */
  goog.Transpiler.prototype.needsTranspile = function(lang, module) {
    if (goog.TRANSPILE == 'always') {
      return true;
    } else if (goog.TRANSPILE == 'never') {
      return false;
    } else if (!this.requiresTranspilation_) {
      var obj = this.createRequiresTranspilation_();
      this.requiresTranspilation_ = obj.map;
      this.transpilationTarget_ = this.transpilationTarget_ || obj.target;
    }
    if (lang in this.requiresTranspilation_) {
      if (this.requiresTranspilation_[lang]) {
        return true;
      } else if (
          goog.inHtmlDocument_() && module == 'es6' &&
          !('noModule' in goog.global.document.createElement('script'))) {
        return true;
      } else {
        return false;
      }
    } else {
      throw new Error('Unknown language mode: ' + lang);
    }
  };


  /**
   * Lazily retrieves the transpiler and applies it to the source.
   * @param {string} code JS code.
   * @param {string} path Path to the code.
   * @return {string} The transpiled code.
   */
  goog.Transpiler.prototype.transpile = function(code, path) {
    // TODO(johnplaisted): We should delete goog.transpile_ and just have this
    // function. But there's some compile error atm where goog.global is being
    // stripped incorrectly without this.
    return goog.transpile_(code, path, this.transpilationTarget_);
  };


  /** @private @final {!goog.Transpiler} */
  goog.transpiler_ = new goog.Transpiler();

  /**
   * Rewrites closing script tags in input to avoid ending an enclosing script
   * tag.
   *
   * @param {string} str
   * @return {string}
   * @private
   */
  goog.protectScriptTag_ = function(str) {
    return str.replace(/<\/(SCRIPT)/ig, '\\x3c/$1');
  };


  /**
   * A debug loader is responsible for downloading and executing javascript
   * files in an unbundled, uncompiled environment.
   *
   * This can be custimized via the setDependencyFactory method, or by
   * CLOSURE_IMPORT_SCRIPT/CLOSURE_LOAD_FILE_SYNC.
   *
   * @struct @constructor @final @private
   */
  goog.DebugLoader_ = function() {
    /** @private @const {!Object<string, !goog.Dependency>} */
    this.dependencies_ = {};
    /** @private @const {!Object<string, string>} */
    this.idToPath_ = {};
    /** @private @const {!Object<string, boolean>} */
    this.written_ = {};
    /** @private @const {!Array<!goog.Dependency>} */
    this.loadingDeps_ = [];
    /** @private {!Array<!goog.Dependency>} */
    this.depsToLoad_ = [];
    /** @private {boolean} */
    this.paused_ = false;
    /** @private {!goog.DependencyFactory} */
    this.factory_ = new goog.DependencyFactory(goog.transpiler_);
    /** @private @const {!Object<string, !Function>} */
    this.deferredCallbacks_ = {};
    /** @private @const {!Array<string>} */
    this.deferredQueue_ = [];
  };

  /**
   * @param {!Array<string>} namespaces
   * @param {function(): undefined} callback Function to call once all the
   *     namespaces have loaded.
   */
  goog.DebugLoader_.prototype.bootstrap = function(namespaces, callback) {
    var cb = callback;
    function resolve() {
      if (cb) {
        goog.global.setTimeout(cb, 0);
        cb = null;
      }
    }

    if (!namespaces.length) {
      resolve();
      return;
    }

    var deps = [];
    for (var i = 0; i < namespaces.length; i++) {
      var path = this.getPathFromDeps_(namespaces[i]);
      if (!path) {
        throw new Error('Unregonized namespace: ' + namespaces[i]);
      }
      deps.push(this.dependencies_[path]);
    }

    var require = goog.require;
    var loaded = 0;
    for (var i = 0; i < namespaces.length; i++) {
      require(namespaces[i]);
      deps[i].onLoad(function() {
        if (++loaded == namespaces.length) {
          resolve();
        }
      });
    }
  };


  /**
   * Loads the Closure Dependency file.
   *
   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base
   * loaded, setDependencyFactory called, and then this called. i.e. allows
   * custom loading of the deps file.
   */
  goog.DebugLoader_.prototype.loadClosureDeps = function() {
    // Circumvent addDependency, which would try to transpile deps.js if
    // transpile is set to always.
    var relPath = 'deps.js';
    this.depsToLoad_.push(this.factory_.createDependency(
        goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {},
        false));
    this.loadDeps_();
  };


  /**
   * Notifies the debug loader when a dependency has been requested.
   *
   * @param {string} absPathOrId Path of the dependency or goog id.
   * @param {boolean=} opt_force
   */
  goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {
    var path = this.getPathFromDeps_(absPathOrId);
    if (path &&
        (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {
      var callback = this.deferredCallbacks_[path];
      if (callback) {
        delete this.deferredCallbacks_[path];
        callback();
      }
    }
  };


  /**
   * Sets the dependency factory, which can be used to create custom
   * goog.Dependency implementations to control how dependencies are loaded.
   *
   * @param {!goog.DependencyFactory} factory
   */
  goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {
    this.factory_ = factory;
  };


  /**
   * Travserses the dependency graph and queues the given dependency, and all of
   * its transitive dependencies, for loading and then starts loading if not
   * paused.
   *
   * @param {string} namespace
   * @private
   */
  goog.DebugLoader_.prototype.load_ = function(namespace) {
    if (!this.getPathFromDeps_(namespace)) {
      var errorMessage = 'goog.require could not find: ' + namespace;
      goog.logToConsole_(errorMessage);
    } else {
      var loader = this;

      var deps = [];

      /** @param {string} namespace */
      var visit = function(namespace) {
        var path = loader.getPathFromDeps_(namespace);

        if (!path) {
          throw new Error('Bad dependency path or symbol: ' + namespace);
        }

        if (loader.written_[path]) {
          return;
        }

        loader.written_[path] = true;

        var dep = loader.dependencies_[path];
        // MOE:begin_strip
        if (goog.dependencies_.written[dep.relativePath]) {
          return;
        }
        // MOE:end_strip
        for (var i = 0; i < dep.requires.length; i++) {
          if (!goog.isProvided_(dep.requires[i])) {
            visit(dep.requires[i]);
          }
        }

        deps.push(dep);
      };

      visit(namespace);

      var wasLoading = !!this.depsToLoad_.length;
      this.depsToLoad_ = this.depsToLoad_.concat(deps);

      if (!this.paused_ && !wasLoading) {
        this.loadDeps_();
      }
    }
  };


  /**
   * Loads any queued dependencies until they are all loaded or paused.
   *
   * @private
   */
  goog.DebugLoader_.prototype.loadDeps_ = function() {
    var loader = this;
    var paused = this.paused_;

    while (this.depsToLoad_.length && !paused) {
      (function() {
        var loadCallDone = false;
        var dep = loader.depsToLoad_.shift();

        var loaded = false;
        loader.loading_(dep);

        var controller = {
          pause: function() {
            if (loadCallDone) {
              throw new Error('Cannot call pause after the call to load.');
            } else {
              paused = true;
            }
          },
          resume: function() {
            if (loadCallDone) {
              loader.resume_();
            } else {
              // Some dep called pause and then resume in the same load call.
              // Just keep running this same loop.
              paused = false;
            }
          },
          loaded: function() {
            if (loaded) {
              throw new Error('Double call to loaded.');
            }

            loaded = true;
            loader.loaded_(dep);
          },
          pending: function() {
            // Defensive copy.
            var pending = [];
            for (var i = 0; i < loader.loadingDeps_.length; i++) {
              pending.push(loader.loadingDeps_[i]);
            }
            return pending;
          },
          /**
           * @param {goog.ModuleType} type
           */
          setModuleState: function(type) {
            goog.moduleLoaderState_ = {
              type: type,
              moduleName: '',
              declareLegacyNamespace: false
            };
          },
          /** @type {function(string, string, string=)} */
          registerEs6ModuleExports: function(
              path, exports, opt_closureNamespace) {
            if (opt_closureNamespace) {
              goog.loadedModules_[opt_closureNamespace] = {
                exports: exports,
                type: goog.ModuleType.ES6,
                moduleId: opt_closureNamespace || ''
              };
            }
          },
          /** @type {function(string, ?)} */
          registerGoogModuleExports: function(moduleId, exports) {
            goog.loadedModules_[moduleId] = {
              exports: exports,
              type: goog.ModuleType.GOOG,
              moduleId: moduleId
            };
          },
          clearModuleState: function() {
            goog.moduleLoaderState_ = null;
          },
          defer: function(callback) {
            if (loadCallDone) {
              throw new Error(
                  'Cannot register with defer after the call to load.');
            }
            loader.defer_(dep, callback);
          },
          areDepsLoaded: function() {
            return loader.areDepsLoaded_(dep.requires);
          }
        };

        try {
          dep.load(controller);
        } finally {
          loadCallDone = true;
        }
      })();
    }

    if (paused) {
      this.pause_();
    }
  };


  /** @private */
  goog.DebugLoader_.prototype.pause_ = function() {
    this.paused_ = true;
  };


  /** @private */
  goog.DebugLoader_.prototype.resume_ = function() {
    if (this.paused_) {
      this.paused_ = false;
      this.loadDeps_();
    }
  };


  /**
   * Marks the given dependency as loading (load has been called but it has not
   * yet marked itself as finished). Useful for dependencies that want to know
   * what else is loading. Example: goog.modules cannot eval if there are
   * loading dependencies.
   *
   * @param {!goog.Dependency} dep
   * @private
   */
  goog.DebugLoader_.prototype.loading_ = function(dep) {
    this.loadingDeps_.push(dep);
  };


  /**
   * Marks the given dependency as having finished loading and being available
   * for require.
   *
   * @param {!goog.Dependency} dep
   * @private
   */
  goog.DebugLoader_.prototype.loaded_ = function(dep) {
    for (var i = 0; i < this.loadingDeps_.length; i++) {
      if (this.loadingDeps_[i] == dep) {
        this.loadingDeps_.splice(i, 1);
        break;
      }
    }

    for (var i = 0; i < this.deferredQueue_.length; i++) {
      if (this.deferredQueue_[i] == dep.path) {
        this.deferredQueue_.splice(i, 1);
        break;
      }
    }

    if (this.loadingDeps_.length == this.deferredQueue_.length &&
        !this.depsToLoad_.length) {
      // Something has asked to load these, but they may not be directly
      // required again later, so load them now that we know we're done loading
      // everything else. e.g. a goog module entry point.
      while (this.deferredQueue_.length) {
        this.requested(this.deferredQueue_.shift(), true);
      }
    }

    dep.loaded();
  };


  /**
   * @param {!Array<string>} pathsOrIds
   * @return {boolean}
   * @private
   */
  goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {
    for (var i = 0; i < pathsOrIds.length; i++) {
      var path = this.getPathFromDeps_(pathsOrIds[i]);
      if (!path ||
          (!(path in this.deferredCallbacks_) &&
           !goog.isProvided_(pathsOrIds[i]))) {
        return false;
      }
    }

    return true;
  };


  /**
   * @param {string} absPathOrId
   * @return {?string}
   * @private
   */
  goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {
    if (absPathOrId in this.idToPath_) {
      return this.idToPath_[absPathOrId];
    } else if (absPathOrId in this.dependencies_) {
      return absPathOrId;
    } else {
      return null;
    }
  };


  /**
   * @param {!goog.Dependency} dependency
   * @param {!Function} callback
   * @private
   */
  goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {
    this.deferredCallbacks_[dependency.path] = callback;
    this.deferredQueue_.push(dependency.path);
  };


  /**
   * Interface for goog.Dependency implementations to have some control over
   * loading of dependencies.
   *
   * @record
   */
  goog.LoadController = function() {};


  /**
   * Tells the controller to halt loading of more dependencies.
   */
  goog.LoadController.prototype.pause = function() {};


  /**
   * Tells the controller to resume loading of more dependencies if paused.
   */
  goog.LoadController.prototype.resume = function() {};


  /**
   * Tells the controller that this dependency has finished loading.
   *
   * This causes this to be removed from pending() and any load callbacks to
   * fire.
   */
  goog.LoadController.prototype.loaded = function() {};


  /**
   * List of dependencies on which load has been called but which have not
   * called loaded on their controller. This includes the current dependency.
   *
   * @return {!Array<!goog.Dependency>}
   */
  goog.LoadController.prototype.pending = function() {};


  /**
   * Registers an object as an ES6 module's exports so that goog.modules may
   * require it by path.
   *
   * @param {string} path Full path of the module.
   * @param {?} exports
   * @param {string=} opt_closureNamespace Closure namespace to associate with
   *     this module.
   */
  goog.LoadController.prototype.registerEs6ModuleExports = function(
      path, exports, opt_closureNamespace) {};


  /**
   * Sets the current module state.
   *
   * @param {goog.ModuleType} type Type of module.
   */
  goog.LoadController.prototype.setModuleState = function(type) {};


  /**
   * Clears the current module state.
   */
  goog.LoadController.prototype.clearModuleState = function() {};


  /**
   * Registers a callback to call once the dependency is actually requested
   * via goog.require + all of the immediate dependencies have been loaded or
   * all other files have been loaded. Allows for lazy loading until
   * require'd without pausing dependency loading, which is needed on old IE.
   *
   * @param {!Function} callback
   */
  goog.LoadController.prototype.defer = function(callback) {};


  /**
   * @return {boolean}
   */
  goog.LoadController.prototype.areDepsLoaded = function() {};


  /**
   * Basic super class for all dependencies Closure Library can load.
   *
   * This default implementation is designed to load untranspiled, non-module
   * scripts in a web broswer.
   *
   * For transpiled non-goog.module files {@see goog.TranspiledDependency}.
   * For goog.modules see {@see goog.GoogModuleDependency}.
   * For untranspiled ES6 modules {@see goog.Es6ModuleDependency}.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   */
  goog.Dependency = function(
      path, relativePath, provides, requires, loadFlags) {
    /** @const */
    this.path = path;
    /** @const */
    this.relativePath = relativePath;
    /** @const */
    this.provides = provides;
    /** @const */
    this.requires = requires;
    /** @const */
    this.loadFlags = loadFlags;
    /** @private {boolean} */
    this.loaded_ = false;
    /** @private {!Array<function()>} */
    this.loadCallbacks_ = [];
  };


  /**
   * @return {string} The pathname part of this dependency's path if it is a
   *     URI.
   */
  goog.Dependency.prototype.getPathName = function() {
    var pathName = this.path;
    var protocolIndex = pathName.indexOf('://');
    if (protocolIndex >= 0) {
      pathName = pathName.substring(protocolIndex + 3);
      var slashIndex = pathName.indexOf('/');
      if (slashIndex >= 0) {
        pathName = pathName.substring(slashIndex + 1);
      }
    }
    return pathName;
  };


  /**
   * @param {function()} callback Callback to fire as soon as this has loaded.
   * @final
   */
  goog.Dependency.prototype.onLoad = function(callback) {
    if (this.loaded_) {
      callback();
    } else {
      this.loadCallbacks_.push(callback);
    }
  };


  /**
   * Marks this dependency as loaded and fires any callbacks registered with
   * onLoad.
   * @final
   */
  goog.Dependency.prototype.loaded = function() {
    this.loaded_ = true;
    var callbacks = this.loadCallbacks_;
    this.loadCallbacks_ = [];
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i]();
    }
  };


  /**
   * Whether or not document.written / appended script tags should be deferred.
   *
   * @private {boolean}
   */
  goog.Dependency.defer_ = false;


  /**
   * Map of script ready / state change callbacks. Old IE cannot handle putting
   * these properties on goog.global.
   *
   * @private @const {!Object<string, function(?):undefined>}
   */
  goog.Dependency.callbackMap_ = {};


  /**
   * @param {function(...?):?} callback
   * @return {string}
   * @private
   */
  goog.Dependency.registerCallback_ = function(callback) {
    var key = Math.random().toString(32);
    goog.Dependency.callbackMap_[key] = callback;
    return key;
  };


  /**
   * @param {string} key
   * @private
   */
  goog.Dependency.unregisterCallback_ = function(key) {
    delete goog.Dependency.callbackMap_[key];
  };


  /**
   * @param {string} key
   * @param {...?} var_args
   * @private
   * @suppress {unusedPrivateMembers}
   */
  goog.Dependency.callback_ = function(key, var_args) {
    if (key in goog.Dependency.callbackMap_) {
      var callback = goog.Dependency.callbackMap_[key];
      var args = [];
      for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      callback.apply(undefined, args);
    } else {
      var errorMessage = 'Callback key ' + key +
          ' does not exist (was base.js loaded more than once?).';
      // MOE:begin_strip
      // TODO(johnplaisted): Some people internally are mistakenly loading
      // base.js twice, and this can happen while a dependency is loading,
      // wiping out state.
      goog.logToConsole_(errorMessage);
      // MOE:end_strip
      // MOE:insert throw Error(errorMessage);
    }
  };


  /**
   * Starts loading this dependency. This dependency can pause loading if it
   * needs to and resume it later via the controller interface.
   *
   * When this is loaded it should call controller.loaded(). Note that this will
   * end up calling the loaded method of this dependency; there is no need to
   * call it explicitly.
   *
   * @param {!goog.LoadController} controller
   */
  goog.Dependency.prototype.load = function(controller) {
    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    if (!goog.inHtmlDocument_()) {
      goog.logToConsole_(
          'Cannot use default debug loader outside of HTML documents.');
      if (this.relativePath == 'deps.js') {
        // Some old code is relying on base.js auto loading deps.js failing with
        // no error before later setting CLOSURE_IMPORT_SCRIPT.
        // CLOSURE_IMPORT_SCRIPT should be set *before* base.js is loaded, or
        // CLOSURE_NO_DEPS set to true.
        goog.logToConsole_(
            'Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, ' +
            'or setting CLOSURE_NO_DEPS to true.');
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    /** @type {!HTMLDocument} */
    var doc = goog.global.document;

    // If the user tries to require a new symbol after document load,
    // something has gone terribly wrong. Doing a document.write would
    // wipe out the page. This does not apply to the CSP-compliant method
    // of writing script tags.
    if (doc.readyState == 'complete' &&
        !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
      // Certain test frameworks load base.js multiple times, which tries
      // to write deps.js each time. If that happens, just fail silently.
      // These frameworks wipe the page between each load of base.js, so this
      // is OK.
      var isDeps = /\bdeps.js$/.test(this.path);
      if (isDeps) {
        controller.loaded();
        return;
      } else {
        throw Error('Cannot write "' + this.path + '" after document load');
      }
    }

    var nonce = goog.getScriptNonce_();
    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
        goog.isDocumentLoading_()) {
      var key;
      var callback = function(script) {
        if (script.readyState && script.readyState != 'complete') {
          script.onload = callback;
          return;
        }
        goog.Dependency.unregisterCallback_(key);
        controller.loaded();
      };
      key = goog.Dependency.registerCallback_(callback);

      var defer = goog.Dependency.defer_ ? ' defer' : '';
      var nonceAttr = nonce ? ' nonce="' + nonce + '"' : '';
      var script = '<script src="' + this.path + '"' + nonceAttr + defer +
          ' id="script-' + key + '"><\/script>';

      script += '<script' + nonceAttr + '>';

      if (goog.Dependency.defer_) {
        script += 'document.getElementById(\'script-' + key +
            '\').onload = function() {\n' +
            '  goog.Dependency.callback_(\'' + key + '\', this);\n' +
            '};\n';
      } else {
        script += 'goog.Dependency.callback_(\'' + key +
            '\', document.getElementById(\'script-' + key + '\'));';
      }

      script += '<\/script>';

      doc.write(
          goog.TRUSTED_TYPES_POLICY_ ?
              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
              script);
    } else {
      var scriptEl =
          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));
      scriptEl.defer = goog.Dependency.defer_;
      scriptEl.async = false;

      // If CSP nonces are used, propagate them to dynamically created scripts.
      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.
      if (nonce) {
        scriptEl.nonce = nonce;
      }

      if (goog.DebugLoader_.IS_OLD_IE_) {
        // Execution order is not guaranteed on old IE, halt loading and write
        // these scripts one at a time, after each loads.
        controller.pause();
        scriptEl.onreadystatechange = function() {
          if (scriptEl.readyState == 'loaded' ||
              scriptEl.readyState == 'complete') {
            controller.loaded();
            controller.resume();
          }
        };
      } else {
        scriptEl.onload = function() {
          scriptEl.onload = null;
          controller.loaded();
        };
      }

      scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?
          goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) :
          this.path;
      doc.head.appendChild(scriptEl);
    }
  };


  /**
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides Should be an empty array.
   *     TODO(johnplaisted) add support for adding closure namespaces to ES6
   *     modules for interop purposes.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   * @extends {goog.Dependency}
   */
  goog.Es6ModuleDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.Es6ModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
  };
  goog.inherits(goog.Es6ModuleDependency, goog.Dependency);


  /**
   * @override
   * @param {!goog.LoadController} controller
   */
  goog.Es6ModuleDependency.prototype.load = function(controller) {
    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) {
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }

    if (!goog.inHtmlDocument_()) {
      goog.logToConsole_(
          'Cannot use default debug loader outside of HTML documents.');
      controller.pause();
      return;
    }

    /** @type {!HTMLDocument} */
    var doc = goog.global.document;

    var dep = this;

    // TODO(johnplaisted): Does document.writing really speed up anything? Any
    // difference between this and just waiting for interactive mode and then
    // appending?
    function write(src, contents) {
      var nonceAttr = '';
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        nonceAttr = ' nonce="' + nonce + '"';
      }

      if (contents) {
        var script = '<script type="module" crossorigin' + nonceAttr + '>' +
            contents + '</' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      } else {
        var script = '<script type="module" crossorigin src="' + src + '"' +
            nonceAttr + '></' +
            'script>';
        doc.write(
            goog.TRUSTED_TYPES_POLICY_ ?
                goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
                script);
      }
    }

    function append(src, contents) {
      var scriptEl =
          /** @type {!HTMLScriptElement} */ (doc.createElement('script'));
      scriptEl.defer = true;
      scriptEl.async = false;
      scriptEl.type = 'module';
      scriptEl.setAttribute('crossorigin', true);

      // If CSP nonces are used, propagate them to dynamically created scripts.
      // This is necessary to allow nonce-based CSPs without 'strict-dynamic'.
      var nonce = goog.getScriptNonce_();
      if (nonce) {
        scriptEl.nonce = nonce;
      }

      if (contents) {
        scriptEl.text = goog.TRUSTED_TYPES_POLICY_ ?
            goog.TRUSTED_TYPES_POLICY_.createScript(contents) :
            contents;
      } else {
        scriptEl.src = goog.TRUSTED_TYPES_POLICY_ ?
            goog.TRUSTED_TYPES_POLICY_.createScriptURL(src) :
            src;
      }

      doc.head.appendChild(scriptEl);
    }

    var create;

    if (goog.isDocumentLoading_()) {
      create = write;
      // We can ONLY call document.write if we are guaranteed that any
      // non-module script tags document.written after this are deferred.
      // Small optimization, in theory document.writing is faster.
      goog.Dependency.defer_ = true;
    } else {
      create = append;
    }

    // Write 4 separate tags here:
    // 1) Sets the module state at the correct time (just before execution).
    // 2) A src node for this, which just hopefully lets the browser load it a
    //    little early (no need to parse #3).
    // 3) Import the module and register it.
    // 4) Clear the module state at the correct time. Guaranteed to run even
    //    if there is an error in the module (#3 will not run if there is an
    //    error in the module).
    var beforeKey = goog.Dependency.registerCallback_(function() {
      goog.Dependency.unregisterCallback_(beforeKey);
      controller.setModuleState(goog.ModuleType.ES6);
    });
    create(undefined, 'goog.Dependency.callback_("' + beforeKey + '")');

    // TODO(johnplaisted): Does this really speed up anything?
    create(this.path, undefined);

    var registerKey = goog.Dependency.registerCallback_(function(exports) {
      goog.Dependency.unregisterCallback_(registerKey);
      controller.registerEs6ModuleExports(
          dep.path, exports, goog.moduleLoaderState_.moduleName);
    });
    create(
        undefined,
        'import * as m from "' + this.path + '"; goog.Dependency.callback_("' +
            registerKey + '", m)');

    var afterKey = goog.Dependency.registerCallback_(function() {
      goog.Dependency.unregisterCallback_(afterKey);
      controller.clearModuleState();
      controller.loaded();
    });
    create(undefined, 'goog.Dependency.callback_("' + afterKey + '")');
  };


  /**
   * Superclass of any dependency that needs to be loaded into memory,
   * transformed, and then eval'd (goog.modules and transpiled files).
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor @abstract
   * @extends {goog.Dependency}
   */
  goog.TransformedDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.TransformedDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
    /** @private {?string} */
    this.contents_ = null;

    /**
     * Whether to lazily make the synchronous XHR (when goog.require'd) or make
     * the synchronous XHR when initially loading. On FireFox 61 there is a bug
     * where an ES6 module cannot make a synchronous XHR (rather, it can, but if
     * it does then no other ES6 modules will load after).
     *
     * tl;dr we lazy load due to bugs on older browsers and eager load due to
     * bugs on newer ones.
     *
     * https://bugzilla.mozilla.org/show_bug.cgi?id=1477090
     *
     * @private @const {boolean}
     */
    this.lazyFetch_ = !goog.inHtmlDocument_() ||
        !('noModule' in goog.global.document.createElement('script'));
  };
  goog.inherits(goog.TransformedDependency, goog.Dependency);


  /**
   * @override
   * @param {!goog.LoadController} controller
   */
  goog.TransformedDependency.prototype.load = function(controller) {
    var dep = this;

    function fetch() {
      dep.contents_ = goog.loadFileSync_(dep.path);

      if (dep.contents_) {
        dep.contents_ = dep.transform(dep.contents_);
        if (dep.contents_) {
          dep.contents_ += '\n//# sourceURL=' + dep.path;
        }
      }
    }

    if (goog.global.CLOSURE_IMPORT_SCRIPT) {
      fetch();
      if (this.contents_ &&
          goog.global.CLOSURE_IMPORT_SCRIPT('', this.contents_)) {
        this.contents_ = null;
        controller.loaded();
      } else {
        controller.pause();
      }
      return;
    }


    var isEs6 = this.loadFlags['module'] == goog.ModuleType.ES6;

    if (!this.lazyFetch_) {
      fetch();
    }

    function load() {
      if (dep.lazyFetch_) {
        fetch();
      }

      if (!dep.contents_) {
        // loadFileSync_ or transform are responsible. Assume they logged an
        // error.
        return;
      }

      if (isEs6) {
        controller.setModuleState(goog.ModuleType.ES6);
      }

      var namespace;

      try {
        var contents = dep.contents_;
        dep.contents_ = null;
        goog.globalEval(goog.CLOSURE_EVAL_PREFILTER_.createScript(contents));
        if (isEs6) {
          namespace = goog.moduleLoaderState_.moduleName;
        }
      } finally {
        if (isEs6) {
          controller.clearModuleState();
        }
      }

      if (isEs6) {
        // Due to circular dependencies this may not be available for require
        // right now.
        goog.global['$jscomp']['require']['ensure'](
            [dep.getPathName()], function() {
              controller.registerEs6ModuleExports(
                  dep.path,
                  goog.global['$jscomp']['require'](dep.getPathName()),
                  namespace);
            });
      }

      controller.loaded();
    }

    // Do not fetch now; in FireFox 47 the synchronous XHR doesn't block all
    // events. If we fetched now and then document.write'd the contents the
    // document.write would be an eval and would execute too soon! Instead write
    // a script tag to fetch and eval synchronously at the correct time.
    function fetchInOwnScriptThenLoad() {
      /** @type {!HTMLDocument} */
      var doc = goog.global.document;

      var key = goog.Dependency.registerCallback_(function() {
        goog.Dependency.unregisterCallback_(key);
        load();
      });

      var nonce = goog.getScriptNonce_();
      var nonceAttr = nonce ? ' nonce="' + nonce + '"' : '';
      var script = '<script' + nonceAttr + '>' +
          goog.protectScriptTag_('goog.Dependency.callback_("' + key + '");') +
          '</' +
          'script>';
      doc.write(
          goog.TRUSTED_TYPES_POLICY_ ?
              goog.TRUSTED_TYPES_POLICY_.createHTML(script) :
              script);
    }

    // If one thing is pending it is this.
    var anythingElsePending = controller.pending().length > 1;

    // If anything else is loading we need to lazy load due to bugs in old IE.
    // Specifically script tags with src and script tags with contents could
    // execute out of order if document.write is used, so we cannot use
    // document.write. Do not pause here; it breaks old IE as well.
    var useOldIeWorkAround =
        anythingElsePending && goog.DebugLoader_.IS_OLD_IE_;

    // Additionally if we are meant to defer scripts but the page is still
    // loading (e.g. an ES6 module is loading) then also defer. Or if we are
    // meant to defer and anything else is pending then defer (those may be
    // scripts that did not need transformation and are just script tags with
    // defer set to true, and we need to evaluate after that deferred script).
    var needsAsyncLoading = goog.Dependency.defer_ &&
        (anythingElsePending || goog.isDocumentLoading_());

    if (useOldIeWorkAround || needsAsyncLoading) {
      // Note that we only defer when we have to rather than 100% of the time.
      // Always defering would work, but then in theory the order of
      // goog.require calls would then matter. We want to enforce that most of
      // the time the order of the require calls does not matter.
      controller.defer(function() {
        load();
      });
      return;
    }
    // TODO(johnplaisted): Externs are missing onreadystatechange for
    // HTMLDocument.
    /** @type {?} */
    var doc = goog.global.document;

    var isInternetExplorerOrEdge = goog.inHtmlDocument_() &&
        ('ActiveXObject' in goog.global || goog.isEdge_());

    // Don't delay in any version of IE or pre-Chromium Edge. There's a bug
    // around this that will cause out of order script execution. This means
    // that on older IE ES6 modules will load too early (while the document is
    // still loading + the dom is not available). The other option is to load
    // too late (when the document is complete and the onload even will never
    // fire). This seems to be the lesser of two evils as scripts already act
    // like the former.
    if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() &&
        !isInternetExplorerOrEdge) {
      goog.Dependency.defer_ = true;
      // Transpiled ES6 modules still need to load like regular ES6 modules,
      // aka only after the document is interactive.
      controller.pause();
      var oldCallback = doc.onreadystatechange;
      doc.onreadystatechange = function() {
        if (doc.readyState == 'interactive') {
          doc.onreadystatechange = oldCallback;
          load();
          controller.resume();
        }
        if (typeof oldCallback === 'function') {
          oldCallback.apply(undefined, arguments);
        }
      };
    } else {
      // Always eval on old IE.
      if (goog.DebugLoader_.IS_OLD_IE_ || !goog.inHtmlDocument_() ||
          !goog.isDocumentLoading_()) {
        load();
      } else {
        fetchInOwnScriptThenLoad();
      }
    }
  };


  /**
   * @param {string} contents
   * @return {string}
   * @abstract
   */
  goog.TransformedDependency.prototype.transform = function(contents) {};


  /**
   * Any non-goog.module dependency which needs to be transpiled before eval.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @param {!goog.Transpiler} transpiler
   * @struct @constructor
   * @extends {goog.TransformedDependency}
   */
  goog.TranspiledDependency = function(
      path, relativePath, provides, requires, loadFlags, transpiler) {
    goog.TranspiledDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
    /** @protected @const*/
    this.transpiler = transpiler;
  };
  goog.inherits(goog.TranspiledDependency, goog.TransformedDependency);


  /**
   * @override
   * @param {string} contents
   * @return {string}
   */
  goog.TranspiledDependency.prototype.transform = function(contents) {
    // Transpile with the pathname so that ES6 modules are domain agnostic.
    return this.transpiler.transpile(contents, this.getPathName());
  };


  /**
   * An ES6 module dependency that was transpiled to a jscomp module outside
   * of the debug loader, e.g. server side.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @struct @constructor
   * @extends {goog.TransformedDependency}
   */
  goog.PreTranspiledEs6ModuleDependency = function(
      path, relativePath, provides, requires, loadFlags) {
    goog.PreTranspiledEs6ModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
  };
  goog.inherits(
      goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency);


  /**
   * @override
   * @param {string} contents
   * @return {string}
   */
  goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(
      contents) {
    return contents;
  };


  /**
   * A goog.module, transpiled or not. Will always perform some minimal
   * transformation even when not transpiled to wrap in a goog.loadModule
   * statement.
   *
   * @param {string} path Absolute path of this script.
   * @param {string} relativePath Path of this script relative to goog.basePath.
   * @param {!Array<string>} provides goog.provided or goog.module symbols
   *     in this file.
   * @param {!Array<string>} requires goog symbols or relative paths to Closure
   *     this depends on.
   * @param {!Object<string, string>} loadFlags
   * @param {boolean} needsTranspile
   * @param {!goog.Transpiler} transpiler
   * @struct @constructor
   * @extends {goog.TransformedDependency}
   */
  goog.GoogModuleDependency = function(
      path, relativePath, provides, requires, loadFlags, needsTranspile,
      transpiler) {
    goog.GoogModuleDependency.base(
        this, 'constructor', path, relativePath, provides, requires, loadFlags);
    /** @private @const */
    this.needsTranspile_ = needsTranspile;
    /** @private @const */
    this.transpiler_ = transpiler;
  };
  goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);


  /**
   * @override
   * @param {string} contents
   * @return {string}
   */
  goog.GoogModuleDependency.prototype.transform = function(contents) {
    if (this.needsTranspile_) {
      contents = this.transpiler_.transpile(contents, this.getPathName());
    }

    if (!goog.LOAD_MODULE_USING_EVAL || goog.global.JSON === undefined) {
      return '' +
          'goog.loadModule(function(exports) {' +
          '"use strict";' + contents +
          '\n' +  // terminate any trailing single line comment.
          ';return exports' +
          '});' +
          '\n//# sourceURL=' + this.path + '\n';
    } else {
      return '' +
          'goog.loadModule(' +
          goog.global.JSON.stringify(
              contents + '\n//# sourceURL=' + this.path + '\n') +
          ');';
    }
  };


  /**
   * Whether the browser is IE9 or earlier, which needs special handling
   * for deferred modules.
   * @const @private {boolean}
   */
  goog.DebugLoader_.IS_OLD_IE_ = !!(
      !goog.global.atob && goog.global.document && goog.global.document['all']);


  /**
   * @param {string} relPath
   * @param {!Array<string>|undefined} provides
   * @param {!Array<string>} requires
   * @param {boolean|!Object<string>=} opt_loadFlags
   * @see goog.addDependency
   */
  goog.DebugLoader_.prototype.addDependency = function(
      relPath, provides, requires, opt_loadFlags) {
    provides = provides || [];
    relPath = relPath.replace(/\\/g, '/');
    var path = goog.normalizePath_(goog.basePath + relPath);
    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
      opt_loadFlags = opt_loadFlags ? {'module': goog.ModuleType.GOOG} : {};
    }
    var dep = this.factory_.createDependency(
        path, relPath, provides, requires, opt_loadFlags,
        goog.transpiler_.needsTranspile(
            opt_loadFlags['lang'] || 'es3', opt_loadFlags['module']));
    this.dependencies_[path] = dep;
    for (var i = 0; i < provides.length; i++) {
      this.idToPath_[provides[i]] = path;
    }
    this.idToPath_[relPath] = path;
  };


  /**
   * Creates goog.Dependency instances for the debug loader to load.
   *
   * Should be overridden to have the debug loader use custom subclasses of
   * goog.Dependency.
   *
   * @param {!goog.Transpiler} transpiler
   * @struct @constructor
   */
  goog.DependencyFactory = function(transpiler) {
    /** @protected @const */
    this.transpiler = transpiler;
  };


  /**
   * @param {string} path Absolute path of the file.
   * @param {string} relativePath Path relative to closure’s base.js.
   * @param {!Array<string>} provides Array of provided goog.provide/module ids.
   * @param {!Array<string>} requires Array of required goog.provide/module /
   *     relative ES6 module paths.
   * @param {!Object<string, string>} loadFlags
   * @param {boolean} needsTranspile True if the file needs to be transpiled
   *     per the goog.Transpiler.
   * @return {!goog.Dependency}
   */
  goog.DependencyFactory.prototype.createDependency = function(
      path, relativePath, provides, requires, loadFlags, needsTranspile) {
    // MOE:begin_strip
    var provide, require;
    for (var i = 0; provide = provides[i]; i++) {
      goog.dependencies_.nameToPath[provide] = relativePath;
      goog.dependencies_.loadFlags[relativePath] = loadFlags;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(relativePath in goog.dependencies_.requires)) {
        goog.dependencies_.requires[relativePath] = {};
      }
      goog.dependencies_.requires[relativePath][require] = true;
    }
    // MOE:end_strip

    if (loadFlags['module'] == goog.ModuleType.GOOG) {
      return new goog.GoogModuleDependency(
          path, relativePath, provides, requires, loadFlags, needsTranspile,
          this.transpiler);
    } else if (needsTranspile) {
      return new goog.TranspiledDependency(
          path, relativePath, provides, requires, loadFlags, this.transpiler);
    } else {
      if (loadFlags['module'] == goog.ModuleType.ES6) {
        if (goog.TRANSPILE == 'never' && goog.ASSUME_ES_MODULES_TRANSPILED) {
          return new goog.PreTranspiledEs6ModuleDependency(
              path, relativePath, provides, requires, loadFlags);
        } else {
          return new goog.Es6ModuleDependency(
              path, relativePath, provides, requires, loadFlags);
        }
      } else {
        return new goog.Dependency(
            path, relativePath, provides, requires, loadFlags);
      }
    }
  };


  /** @private @const */
  goog.debugLoader_ = new goog.DebugLoader_();


  /**
   * Loads the Closure Dependency file.
   *
   * Exposed a public function so CLOSURE_NO_DEPS can be set to false, base
   * loaded, setDependencyFactory called, and then this called. i.e. allows
   * custom loading of the deps file.
   */
  goog.loadClosureDeps = function() {
    goog.debugLoader_.loadClosureDeps();
  };


  /**
   * Sets the dependency factory, which can be used to create custom
   * goog.Dependency implementations to control how dependencies are loaded.
   *
   * Note: if you wish to call this function and provide your own implemnetation
   * it is a wise idea to set CLOSURE_NO_DEPS to true, otherwise the dependency
   * file and all of its goog.addDependency calls will use the default factory.
   * You can call goog.loadClosureDeps to load the Closure dependency file
   * later, after your factory is injected.
   *
   * @param {!goog.DependencyFactory} factory
   */
  goog.setDependencyFactory = function(factory) {
    goog.debugLoader_.setDependencyFactory(factory);
  };


  /**
   * Trusted Types policy for the debug loader.
   * @private @const {?TrustedTypePolicy}
   */
  goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ?
      goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#base') :
      null;

  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.debugLoader_.loadClosureDeps();
  }


  /**
   * Bootstraps the given namespaces and calls the callback once they are
   * available either via goog.require. This is a replacement for using
   * `goog.require` to bootstrap Closure JavaScript. Previously a `goog.require`
   * in an HTML file would guarantee that the require'd namespace was available
   * in the next immediate script tag. With ES6 modules this no longer a
   * guarantee.
   *
   * @param {!Array<string>} namespaces
   * @param {function(): ?} callback Function to call once all the namespaces
   *     have loaded. Always called asynchronously.
   */
  goog.bootstrap = function(namespaces, callback) {
    goog.debugLoader_.bootstrap(namespaces, callback);
  };
}


if (!COMPILED) {
  var isChrome87 = false;
  // Cannot run check for Chrome <87 bug in case of strict CSP environments.
  // TODO(aaronshim): Remove once Chrome <87 bug is no longer a problem.
  try {
    isChrome87 = eval(goog.global.trustedTypes.emptyScript) !==
        goog.global.trustedTypes.emptyScript;
  } catch (err) {
  }

  /**
   * Trusted Types for running dev servers.
   *
   * @private @const
   */
  goog.CLOSURE_EVAL_PREFILTER_ =
      // Detect Chrome <87 bug with TT and eval.
      goog.global.trustedTypes && isChrome87 &&
          goog.createTrustedTypesPolicy('goog#base#devonly#eval') ||
      {createScript: goog.identity_};
}

//third_party/javascript/closure/debug/error.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw DebugError(msg) directly, Error(msg) is
 * sufficient.
 */

goog.module('goog.debug.Error');
goog.module.declareLegacyNamespace();



/**
 * Base class for custom error objects.
 * @param {*=} msg The message associated with the error.
 * @param {{
 *    message: (?|undefined),
 *    name: (?|undefined),
 *    lineNumber: (?|undefined),
 *    fileName: (?|undefined),
 *    stack: (?|undefined),
 *    cause: (?|undefined),
 * }=} cause The original error object to chain with.
 * @constructor
 * @extends {Error}
 */
function DebugError(msg = undefined, cause = undefined) {
  // Attempt to ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, DebugError);
  } else {
    const stack = new Error().stack;
    if (stack) {
      /** @override */
      this.stack = stack;
    }
  }

  if (msg) {
    /** @override */
    this.message = String(msg);
  }

  if (cause !== undefined) {
    /** @type {?} */
    this.cause = cause;
  }

  /**
   * Whether to report this error to the server. Setting this to false will
   * cause the error reporter to not report the error back to the server,
   * which can be useful if the client knows that the error has already been
   * logged on the server.
   * @type {boolean}
   */
  this.reportErrorToServer = true;
}
goog.inherits(DebugError, Error);


/** @override @type {string} */
DebugError.prototype.name = 'CustomError';


exports = DebugError;

;return exports;});

//third_party/javascript/closure/dom/nodetype.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

//third_party/javascript/closure/asserts/asserts.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package are given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will make the compiler treat <code>foo</code> as non-nullable. Similarly,
 * <code>goog.asserts.assertNumber(foo)</code> informs the compiler about the
 * type of <code>foo</code>. Where applicable, such assertions are preferable to
 * casts by jsdoc with <code>@type</code>.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo());
 * goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 * Additionally, note the compiler will consider the type to be "tightened" for
 * all statements <em>after</em> the assertion. For example:
 * <code>
 * const /** ?Object &#ast;/ value = foo();
 * goog.asserts.assert(value);
 * // "value" is of type {!Object} at this point.
 * </code>
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.asserts.ENABLE_ASSERTS =
    goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  'use strict';
  goog.debug.Error.call(this, goog.asserts.subs_(messagePattern, messageArgs));

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override @type {string} */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * The default error handler.
 * @param {!goog.asserts.AssertionError} e The exception to be handled.
 * @return {void}
 */
goog.asserts.DEFAULT_ERROR_HANDLER = function(e) {
  'use strict';
  throw e;
};


/**
 * The handler responsible for throwing or logging assertion errors.
 * @private {function(!goog.asserts.AssertionError)}
 */
goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} pattern The string containing the pattern.
 * @param {!Array<*>} subs The items to substitute into the pattern.
 * @return {string} A copy of `str` in which each occurrence of
 *     {@code %s} has been replaced an argument from `var_args`.
 * @private
 */
goog.asserts.subs_ = function(pattern, subs) {
  'use strict';
  var splitParts = pattern.split('%s');
  var returnString = '';

  // Replace up to the last split part. We are inserting in the
  // positions between split parts.
  var subLast = splitParts.length - 1;
  for (var i = 0; i < subLast; i++) {
    // keep unsupplied as '%s'
    var sub = (i < subs.length) ? subs[i] : '%s';
    returnString += splitParts[i] + sub;
  }
  return returnString + splitParts[subLast];
};


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ = function(
    defaultMessage, defaultArgs, givenMessage, givenArgs) {
  'use strict';
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  var e = new goog.asserts.AssertionError('' + message, args || []);
  goog.asserts.errorHandler_(e);
};


/**
 * Sets a custom error handler that can be used to customize the behavior of
 * assertion failures, for example by turning all assertion failures into log
 * messages.
 * @param {function(!goog.asserts.AssertionError)} errorHandler
 * @return {void}
 */
goog.asserts.setErrorHandler = function(errorHandler) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_ = errorHandler;
  }
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @template T
 * @param {T} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {T} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 * @closurePrimitive {asserts.truthy}
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_(
        '', null, opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Checks if `value` is `null` or `undefined` if goog.asserts.ENABLE_ASSERTS is
 * true.
 *
 * @param {T} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {R} `value` with its type narrowed to exclude `null` and `undefined`.
 *
 * @template T
 * @template R :=
 *     mapunion(T, (V) =>
 *         cond(eq(V, 'null'),
 *             none(),
 *             cond(eq(V, 'undefined'),
 *                 none(),
 *                 V)))
 *  =:
 *
 * @throws {!goog.asserts.AssertionError} When `value` is `null` or `undefined`.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertExists = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && value == null) {
    goog.asserts.doAssertFailure_(
        'Expected to exist: %s.', [value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return value;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.asserts.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {void}
 * @throws {goog.asserts.AssertionError} Failure.
 * @closurePrimitive {asserts.fail}
 */
goog.asserts.fail = function(opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_(new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1)));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && typeof value !== 'number') {
    goog.asserts.doAssertFailure_(
        'Expected number but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && typeof value !== 'string') {
    goog.asserts.doAssertFailure_(
        'Expected string but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && typeof value !== 'function') {
    goog.asserts.doAssertFailure_(
        'Expected function but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_(
        'Expected object but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array<?>} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && !Array.isArray(value)) {
    goog.asserts.doAssertFailure_(
        'Expected array but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array<?>} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && typeof value !== 'boolean') {
    goog.asserts.doAssertFailure_(
        'Expected boolean but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not an Element.
 * @closurePrimitive {asserts.matchesReturn}
 * @deprecated Use goog.asserts.dom.assertIsElement instead.
 */
goog.asserts.assertElement = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS &&
      (!goog.isObject(value) ||
       /** @type {!Node} */ (value).nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_(
        'Expected Element but got %s: %s.', [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * Do not use this to ensure a value is an HTMLElement or a subclass! Cross-
 * document DOM inherits from separate - though identical - browser classes, and
 * such a check will unexpectedly fail. Please use the methods in
 * goog.asserts.dom for these purposes.
 *
 * @param {?} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {T}
 * @template T
 * @closurePrimitive {asserts.matchesReturn}
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_(
        'Expected instanceof %s but got %s.',
        [goog.asserts.getType_(type), goog.asserts.getType_(value)],
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks whether the value is a finite number, if goog.asserts.ENABLE_ASSERTS
 * is true.
 *
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not a number, or is
 *     a non-finite number such as NaN, Infinity or -Infinity.
 * @return {number} The value initially passed in.
 */
goog.asserts.assertFinite = function(value, opt_message, var_args) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS &&
      (typeof value != 'number' || !isFinite(value))) {
    goog.asserts.doAssertFailure_(
        'Expected %s to be a finite number but it is not.', [value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};

/**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 * @private
 */
goog.asserts.getType_ = function(value) {
  'use strict';
  if (value instanceof Function) {
    return value.displayName || value.name || 'unknown type name';
  } else if (value instanceof Object) {
    return /** @type {string} */ (value.constructor.displayName) ||
        value.constructor.name || Object.prototype.toString.call(value);
  } else {
    return value === null ? 'null' : typeof value;
  }
};

//third_party/javascript/closure/debug/entrypointregistry.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A global registry for entry points into a program,
 * so that they can be instrumented. Each module should register their
 * entry points with this registry. Designed to be compiled out
 * if no instrumentation is requested.
 *
 * Entry points may be registered before or after a call to
 * goog.debug.entryPointRegistry.monitorAll. If an entry point is registered
 * later, the existing monitor will instrument the new entry point.
 */

goog.provide('goog.debug.EntryPointMonitor');
goog.provide('goog.debug.entryPointRegistry');

goog.require('goog.asserts');


/**
 * @interface
 */
goog.debug.entryPointRegistry.EntryPointMonitor = function() {};


/**
 * Instruments a function.
 *
 * @param {!Function} fn A function to instrument.
 * @return {!Function} The instrumented function.
 */
goog.debug.entryPointRegistry.EntryPointMonitor.prototype.wrap;


/**
 * Try to remove an instrumentation wrapper created by this monitor.
 * If the function passed to unwrap is not a wrapper created by this
 * monitor, then we will do nothing.
 *
 * Notice that some wrappers may not be unwrappable. For example, if other
 * monitors have applied their own wrappers, then it will be impossible to
 * unwrap them because their wrappers will have captured our wrapper.
 *
 * So it is important that entry points are unwrapped in the reverse
 * order that they were wrapped.
 *
 * @param {!Function} fn A function to unwrap.
 * @return {!Function} The unwrapped function, or `fn` if it was not
 *     a wrapped function created by this monitor.
 */
goog.debug.entryPointRegistry.EntryPointMonitor.prototype.unwrap;

/**
 * Alias for goog.debug.entryPointRegistry.EntryPointMonitor, for compatibility
 * purposes.
 * @const
 */
goog.debug.EntryPointMonitor = goog.debug.entryPointRegistry.EntryPointMonitor;


/**
 * An array of entry point callbacks.
 * @type {!Array<function(!Function)>}
 * @private
 */
goog.debug.entryPointRegistry.refList_ = [];


/**
 * Monitors that should wrap all the entry points.
 * @type {!Array<!goog.debug.EntryPointMonitor>}
 * @private
 */
goog.debug.entryPointRegistry.monitors_ = [];


/**
 * Whether goog.debug.entryPointRegistry.monitorAll has ever been called.
 * Checking this allows the compiler to optimize out the registrations.
 * @type {boolean}
 * @private
 */
goog.debug.entryPointRegistry.monitorsMayExist_ = false;


/**
 * Register an entry point with this module.
 *
 * The entry point will be instrumented when a monitor is passed to
 * goog.debug.entryPointRegistry.monitorAll. If this has already occurred, the
 * entry point is instrumented immediately.
 *
 * @param {function(!Function)} callback A callback function which is called
 *     with a transforming function to instrument the entry point. The callback
 *     is responsible for wrapping the relevant entry point with the
 *     transforming function.
 */
goog.debug.entryPointRegistry.register = function(callback) {
  'use strict';
  // Don't use push(), so that this can be compiled out.
  goog.debug.entryPointRegistry
      .refList_[goog.debug.entryPointRegistry.refList_.length] = callback;
  // If no one calls monitorAll, this can be compiled out.
  if (goog.debug.entryPointRegistry.monitorsMayExist_) {
    var monitors = goog.debug.entryPointRegistry.monitors_;
    for (var i = 0; i < monitors.length; i++) {
      callback(goog.bind(monitors[i].wrap, monitors[i]));
    }
  }
};


/**
 * Configures a monitor to wrap all entry points.
 *
 * Entry points that have already been registered are immediately wrapped by
 * the monitor. When an entry point is registered in the future, it will also
 * be wrapped by the monitor when it is registered.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor An entry point monitor.
 */
goog.debug.entryPointRegistry.monitorAll = function(monitor) {
  'use strict';
  goog.debug.entryPointRegistry.monitorsMayExist_ = true;
  var transformer = goog.bind(monitor.wrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  goog.debug.entryPointRegistry.monitors_.push(monitor);
};


/**
 * Try to unmonitor all the entry points that have already been registered. If
 * an entry point is registered in the future, it will not be wrapped by the
 * monitor when it is registered. Note that this may fail if the entry points
 * have additional wrapping.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor The last monitor to wrap
 *     the entry points.
 * @throws {Error} If the monitor is not the most recently configured monitor.
 */
goog.debug.entryPointRegistry.unmonitorAllIfPossible = function(monitor) {
  'use strict';
  var monitors = goog.debug.entryPointRegistry.monitors_;
  goog.asserts.assert(
      monitor == monitors[monitors.length - 1],
      'Only the most recent monitor can be unwrapped.');
  var transformer = goog.bind(monitor.unwrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  monitors.length--;
};

//third_party/javascript/closure/array/array.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for manipulating arrays.
 */


goog.module('goog.array');
goog.module.declareLegacyNamespace();

const asserts = goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.NATIVE_ARRAY_PROTOTYPES =
    goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., `Array#filter`) and remove the
 * unused pure JS implementation.
 */
const ASSUME_NATIVE_FUNCTIONS = goog.define(
    'goog.array.ASSUME_NATIVE_FUNCTIONS', goog.FEATURESET_YEAR > 2012);
exports.ASSUME_NATIVE_FUNCTIONS = ASSUME_NATIVE_FUNCTIONS;


/**
 * Returns the last element in an array without removing it.
 * Same as {@link goog.array.last}.
 * @param {IArrayLike<T>|string} array The array.
 * @return {T} Last item in array.
 * @template T
 */
function peek(array) {
  return array[array.length - 1];
}
exports.peek = peek;


/**
 * Returns the last element in an array without removing it.
 * Same as {@link goog.array.peek}.
 * @param {IArrayLike<T>|string} array The array.
 * @return {T} Last item in array.
 * @template T
 */
exports.last = peek;

// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {IArrayLike<T>|string} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
const indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ?
    function(arr, obj, opt_fromIndex) {
      asserts.assert(arr.length != null);

      return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      const fromIndex = opt_fromIndex == null ?
          0 :
          (opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) :
                               opt_fromIndex);

      if (typeof arr === 'string') {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (typeof obj !== 'string' || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (let i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj) return i;
      }
      return -1;
    };
exports.indexOf = indexOf;


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!IArrayLike<T>|string} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
const lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ?
    function(arr, obj, opt_fromIndex) {
      asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      const fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      let fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (typeof arr === 'string') {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (typeof obj !== 'string' || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (let i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj) return i;
      }
      return -1;
    };
exports.lastIndexOf = lastIndexOf;


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {IArrayLike<T>|string} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
const forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      Array.prototype.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
        }
      }
    };
exports.forEach = forEach;


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
function forEachRight(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
    }
  }
}
exports.forEachRight = forEachRight;


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
const filter = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const res = [];
      let resLength = 0;
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          const val = arr2[i];  // in case f mutates arr2
          if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };
exports.filter = filter;


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {IArrayLike<VALUE>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
 *     for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return something. The result will be
 *     inserted into a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array<RESULT>} a new array with the results from f.
 * @template THIS, VALUE, RESULT
 */
const map = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const res = new Array(l);
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);
        }
      }
      return res;
    };
exports.map = map;


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 * Note that this implementation differs from the native Array.prototype.reduce
 * in that the initial value is assumed to be defined (the MDN docs linked above
 * recommend not omitting this parameter, although it is technically optional).
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
const reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ?
    function(arr, f, val, opt_obj) {
      asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return Array.prototype.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      let rval = val;
      forEach(arr, function(val, index) {
        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
      });
      return rval;
    };
exports.reduce = reduce;


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
const reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ?
    function(arr, f, val, opt_obj) {
      asserts.assert(arr.length != null);
      asserts.assert(f != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return Array.prototype.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      let rval = val;
      forEachRight(arr, function(val, index) {
        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);
      });
      return rval;
    };
exports.reduceRight = reduceRight;


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
const some = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };
exports.some = some;


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
const every = goog.NATIVE_ARRAY_PROTOTYPES &&
        (ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ?
    function(arr, f, opt_obj) {
      asserts.assert(arr.length != null);

      return Array.prototype.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      const l = arr.length;  // must be fixed during loop... see docs
      const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
      for (let i = 0; i < l; i++) {
        if (i in arr2 && !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };
exports.every = every;


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!IArrayLike<T>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
function count(arr, f, opt_obj) {
  let count = 0;
  forEach(arr, function(element, index, arr) {
    if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
}
exports.count = count;


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
function find(arr, f, opt_obj) {
  const i = findIndex(arr, f, opt_obj);
  return i < 0 ? null : typeof arr === 'string' ? arr.charAt(i) : arr[i];
}
exports.find = find;


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
function findIndex(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = 0; i < l; i++) {
    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
exports.findIndex = findIndex;


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {T|null} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
function findRight(arr, f, opt_obj) {
  const i = findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : typeof arr === 'string' ? arr.charAt(i) : arr[i];
}
exports.findRight = findRight;


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {IArrayLike<T>|string} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
function findIndexRight(arr, f, opt_obj) {
  const l = arr.length;  // must be fixed during loop... see docs
  const arr2 = (typeof arr === 'string') ? arr.split('') : arr;
  for (let i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
}
exports.findIndexRight = findIndexRight;


/**
 * Whether the array contains the given object.
 * @param {IArrayLike<?>|string} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
function contains(arr, obj) {
  return indexOf(arr, obj) >= 0;
}
exports.contains = contains;


/**
 * Whether the array is empty.
 * @param {IArrayLike<?>|string} arr The array to test.
 * @return {boolean} true if empty.
 */
function isEmpty(arr) {
  return arr.length == 0;
}
exports.isEmpty = isEmpty;


/**
 * Clears the array.
 * @param {IArrayLike<?>} arr Array or array like object to clear.
 */
function clear(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!Array.isArray(arr)) {
    for (let i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
}
exports.clear = clear;


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
function insert(arr, obj) {
  if (!contains(arr, obj)) {
    arr.push(obj);
  }
}
exports.insert = insert;


/**
 * Inserts an object at the given index of the array.
 * @param {IArrayLike<?>} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
function insertAt(arr, obj, opt_i) {
  splice(arr, opt_i, 0, obj);
}
exports.insertAt = insertAt;


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {IArrayLike<?>} arr The array to modify.
 * @param {IArrayLike<?>} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
function insertArrayAt(arr, elementsToAdd, opt_i) {
  goog.partial(splice, arr, opt_i, 0).apply(null, elementsToAdd);
}
exports.insertArrayAt = insertArrayAt;


/**
 * Inserts an object into an array before a specified object.
 * @param {Array<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
function insertBefore(arr, obj, opt_obj2) {
  let i;
  if (arguments.length == 2 || (i = indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    insertAt(arr, obj, i);
  }
}
exports.insertBefore = insertBefore;


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {IArrayLike<T>} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
function remove(arr, obj) {
  const i = indexOf(arr, obj);
  let rv;
  if ((rv = i >= 0)) {
    removeAt(arr, i);
  }
  return rv;
}
exports.remove = remove;


/**
 * Removes the last occurrence of a particular value from an array.
 * @param {!IArrayLike<T>} arr Array from which to remove value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
function removeLast(arr, obj) {
  const i = lastIndexOf(arr, obj);
  if (i >= 0) {
    removeAt(arr, i);
    return true;
  }
  return false;
}
exports.removeLast = removeLast;


/**
 * Removes from an array the element at index i
 * @param {IArrayLike<?>} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
function removeAt(arr, i) {
  asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return Array.prototype.splice.call(arr, i, 1).length == 1;
}
exports.removeAt = removeAt;


/**
 * Removes the first value that satisfies the given condition.
 * @param {IArrayLike<T>} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
function removeIf(arr, f, opt_obj) {
  const i = findIndex(arr, f, opt_obj);
  if (i >= 0) {
    removeAt(arr, i);
    return true;
  }
  return false;
}
exports.removeIf = removeIf;


/**
 * Removes all values that satisfy the given condition.
 * @param {IArrayLike<T>} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The number of items removed
 * @template T,S
 */
function removeAllIf(arr, f, opt_obj) {
  let removedCount = 0;
  forEachRight(arr, function(val, index) {
    if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {
      if (removeAt(arr, index)) {
        removedCount++;
      }
    }
  });
  return removedCount;
}
exports.removeAllIf = removeAllIf;


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * concat(0, [1, 2]) -> [0, 1, 2]
 * concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array<?>} The new resultant array.
 */
function concat(var_args) {
  return Array.prototype.concat.apply([], arguments);
}
exports.concat = concat;


/**
 * Returns a new array that contains the contents of all the arrays passed.
 * @param {...!Array<T>} var_args
 * @return {!Array<T>}
 * @template T
 */
function join(var_args) {
  return Array.prototype.concat.apply([], arguments);
}
exports.join = join;


/**
 * Converts an object to an array.
 * @param {IArrayLike<T>|string} object  The object to convert to an
 *     array.
 * @return {!Array<T>} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 * @template T
 */
function toArray(object) {
  const length = object.length;

  // If length is not a number the following is false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    const rv = new Array(length);
    for (let i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
}
exports.toArray = toArray;


/**
 * Does a shallow copy of an array.
 * @param {IArrayLike<T>|string} arr  Array or array-like object to
 *     clone.
 * @return {!Array<T>} Clone of the input array.
 * @template T
 */
const clone = toArray;
exports.clone = clone;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * extend(a, [0, 1]);
 * a; // [0, 1]
 * extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array<VALUE>} arr1  The array to modify.
 * @param {...(IArrayLike<VALUE>|VALUE)} var_args The elements or arrays of
 *     elements to add to arr1.
 * @template VALUE
 */
function extend(arr1, var_args) {
  for (let i = 1; i < arguments.length; i++) {
    const arr2 = arguments[i];
    if (goog.isArrayLike(arr2)) {
      const len1 = arr1.length || 0;
      const len2 = arr2.length || 0;
      arr1.length = len1 + len2;
      for (let j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
}
exports.extend = extend;


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {IArrayLike<T>} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array<T>} the removed elements.
 * @template T
 */
function splice(arr, index, howMany, var_args) {
  asserts.assert(arr.length != null);

  return Array.prototype.splice.apply(arr, slice(arguments, 1));
}
exports.splice = splice;


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {IArrayLike<T>|string} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
function slice(arr, start, opt_end) {
  asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return Array.prototype.slice.call(arr, start);
  } else {
    return Array.prototype.slice.call(arr, start, opt_end);
  }
}
exports.slice = slice;


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {IArrayLike<T>} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
function removeDuplicates(arr, opt_rv, opt_hashFn) {
  const returnArray = opt_rv || arr;
  const defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(item) ? 'o' + goog.getUid(item) :
                                 (typeof item).charAt(0) + item;
  };
  const hashFn = opt_hashFn || defaultHashFn;

  let cursorInsert = 0;
  let cursorRead = 0;
  const seen = {};

  while (cursorRead < arr.length) {
    const current = arr[cursorRead++];
    const key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
}
exports.removeDuplicates = removeDuplicates;


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, the
 * left-most instance will be found.
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<VALUE>} arr The array to be searched.
 * @param {TARGET} target The sought value.
 * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, the target value and an element from your array, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template TARGET, VALUE
 */
function binarySearch(arr, target, opt_compareFn) {
  return binarySearch_(
      arr, opt_compareFn || defaultCompare, false /* isEvaluator */, target);
}
exports.binarySearch = binarySearch;


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * map(map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<VALUE>} arr The array to be searched.
 * @param {function(this:THIS, VALUE, number, ?): number} evaluator
 *     Evaluator function that receives 3 arguments (the element, the index and
 *     the array). Should return a negative number, zero, or a positive number
 *     depending on whether the desired index is before, at, or after the
 *     element passed to it.
 * @param {THIS=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 * @template THIS, VALUE
 */
function binarySelect(arr, evaluator, opt_obj) {
  return binarySearch_(
      arr, evaluator, true /* isEvaluator */, undefined /* opt_target */,
      opt_obj);
}
exports.binarySelect = binarySelect;


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {IArrayLike<?>} arr The array to be searched.
 * @param {function(?, ?, ?): number | function(?, ?): number} compareFn
 *     Either an evaluator or a comparison function, as defined by binarySearch
 *     and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {?=} opt_target If the function is a comparison function, then
 *     this is the target to binary search for.
 * @param {Object=} opt_selfObj If the function is an evaluator, this is an
 *     optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @private
 */
function binarySearch_(arr, compareFn, isEvaluator, opt_target, opt_selfObj) {
  let left = 0;            // inclusive
  let right = arr.length;  // exclusive
  let found;
  while (left < right) {
    const middle = left + ((right - left) >>> 1);
    let compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      // NOTE(dimvar): To avoid this cast, we'd have to use function overloading
      // for the type of binarySearch_, which the type system can't express yet.
      compareResult = /** @type {function(?, ?): number} */ (compareFn)(
          opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // Avoiding bitwise not operator, as that causes a loss in precision for array
  // indexes outside the bounds of a 32-bit signed integer.  Array indexes have
  // a maximum value of 2^32-2 https://tc39.es/ecma262/#array-index
  return found ? left : -left - 1;
}


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogeneous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as `Array.prototype.sort`
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
function sort(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  arr.sort(opt_compareFn || defaultCompare);
}
exports.sort = sort;


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as `Array.prototype.sort`, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
function stableSort(arr, opt_compareFn) {
  const compArr = new Array(arr.length);
  for (let i = 0; i < arr.length; i++) {
    compArr[i] = {index: i, value: arr[i]};
  }
  const valueCompareFn = opt_compareFn || defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  }
  sort(compArr, stableCompareFn);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = compArr[i].value;
  }
}
exports.stableSort = stableSort;


/**
 * Sort the specified array into ascending order based on item keys
 * returned by the specified key function.
 * If no opt_compareFn is specified, the keys are compared in ascending order
 * using <code>defaultCompare</code>.
 *
 * Runtime: O(S(f(n)), where S is runtime of <code>sort</code>
 * and f(n) is runtime of the key function.
 *
 * @param {Array<T>} arr The array to be sorted.
 * @param {function(T): K} keyFn Function taking array element and returning
 *     a key used for sorting this element.
 * @param {?function(K, K): number=} opt_compareFn Optional comparison function
 *     by which the keys are to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T,K
 */
function sortByKey(arr, keyFn, opt_compareFn) {
  const keyCompareFn = opt_compareFn || defaultCompare;
  sort(arr, function(a, b) {
    return keyCompareFn(keyFn(a), keyFn(b));
  });
}
exports.sortByKey = sortByKey;


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
function sortObjectsByKey(arr, key, opt_compareFn) {
  sortByKey(arr, function(obj) {
    return obj[key];
  }, opt_compareFn);
}
exports.sortObjectsByKey = sortObjectsByKey;


/**
 * Tells if the array is sorted.
 * @param {!IArrayLike<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
function isSorted(arr, opt_compareFn, opt_strict) {
  const compare = opt_compareFn || defaultCompare;
  for (let i = 1; i < arr.length; i++) {
    const compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
}
exports.isSorted = isSorted;


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {IArrayLike<A>} arr1 The first array to compare.
 * @param {IArrayLike<B>} arr2 The second array to compare.
 * @param {?function(A,B):boolean=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 * @template A
 * @template B
 */
function equals(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  const l = arr1.length;
  const equalsFn = opt_equalsFn || defaultCompareEquality;
  for (let i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
exports.equals = equals;


/**
 * 3-way array compare function.
 * @param {!IArrayLike<VALUE>} arr1 The first array to
 *     compare.
 * @param {!IArrayLike<VALUE>} arr2 The second array to
 *     compare.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is to be ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template VALUE
 */
function compare3(arr1, arr2, opt_compareFn) {
  const compare = opt_compareFn || defaultCompare;
  const l = Math.min(arr1.length, arr2.length);
  for (let i = 0; i < l; i++) {
    const result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return defaultCompare(arr1.length, arr2.length);
}
exports.compare3 = compare3;


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second,
 *     respectively.
 * @template VALUE
 */
function defaultCompare(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
exports.defaultCompare = defaultCompare;


/**
 * Compares its two arguments for inverse order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second,
 *     respectively.
 * @template VALUE
 */
function inverseDefaultCompare(a, b) {
  return -defaultCompare(a, b);
}
exports.inverseDefaultCompare = inverseDefaultCompare;


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
function defaultCompareEquality(a, b) {
  return a === b;
}
exports.defaultCompareEquality = defaultCompareEquality;


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {IArrayLike<VALUE>} array The array to modify.
 * @param {VALUE} value The object to insert.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template VALUE
 */
function binaryInsert(array, value, opt_compareFn) {
  const index = binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
}
exports.binaryInsert = binaryInsert;


/**
 * Removes a value from a sorted array.
 * @param {!IArrayLike<VALUE>} array The array to modify.
 * @param {VALUE} value The object to remove.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was removed.
 * @template VALUE
 */
function binaryRemove(array, value, opt_compareFn) {
  const index = binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? removeAt(array, index) : false;
}
exports.binaryRemove = binaryRemove;


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {IArrayLike<T>} array The array.
 * @param {function(this:S, T, number, !IArrayLike<T>):?} sorter Function to
 *     call for every element.  This takes 3 arguments (the element, the index
 *     and the array) and must return a valid object key (a string, number,
 *     etc), or undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object<!Array<T>>} An object, with keys being all of the unique
 *     return values of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
function bucket(array, sorter, opt_obj) {
  const buckets = {};

  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    const key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);
    if (key !== undefined) {
      // Push the value to the right bucket, creating it if necessary.
      const bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
}
exports.bucket = bucket;


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {!IArrayLike<V>} array The array.
 * @param {function(V, number, !IArrayLike<V>):(K|undefined)} sorter Function to
 *     call for every element.  This takes 3 arguments (the element, the index,
 *     and the array) and must return a value to use as a key, or undefined, if
 *     that object should not be placed in a bucket.
 * @return {!Map<K, !Array<V>>} A map, with keys being all of the unique
 *     return values of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template K,V
 */
function bucketToMap(array, sorter) {
  const /** !Map<K, !Array<V>> */ buckets = new Map();

  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    const key = sorter(value, i, array);
    if (key !== undefined) {
      // Push the value to the right bucket, creating it if necessary.
      let bucket = buckets.get(key);
      if (!bucket) {
        bucket = [];
        buckets.set(key, bucket);
      }
      bucket.push(value);
    }
  }

  return buckets;
}
exports.bucketToMap = bucketToMap;


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {IArrayLike<T>} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object<T>} The new object.
 * @template T,S
 */
function toObject(arr, keyFunc, opt_obj) {
  const ret = {};
  forEach(arr, function(element, index) {
    ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =
        element;
  });
  return ret;
}
exports.toObject = toObject;


/**
 * Creates a new ES6 Map built from the provided array and the key-generation
 * function.
 * @param {!IArrayLike<V>} arr Array or array like object over which to iterate
 *     whose elements will be the values in the new object.
 * @param {?function(V, number, ?) : K} keyFunc The function to call for every
 *     element. This function takes 3 arguments (the element, the index, and the
 *     array) and should return a value that will be used as the key for the
 *     element in the new object. If the function returns the same key for more
 *     than one element, the value for that key is implementation-defined.
 * @return {!Map<K, V>} The new map.
 * @template K,V
 */
function toMap(arr, keyFunc) {
  const /** !Map<K, V> */ map = new Map();

  for (let i = 0; i < arr.length; i++) {
    const element = arr[i];
    map.set(keyFunc(element, i, arr), element);
  }

  return map;
}
exports.toMap = toMap;


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
function range(startOrEnd, opt_end, opt_step) {
  const array = [];
  let start = 0;
  let end = startOrEnd;
  const step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (let i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (let i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
}
exports.range = range;


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {VALUE} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array<VALUE>} An array with the repeated value.
 * @template VALUE
 */
function repeat(value, n) {
  const array = [];
  for (let i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
}
exports.repeat = repeat;


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array<?>} An array containing the flattened values.
 */
function flatten(var_args) {
  const CHUNK_SIZE = 8192;

  const result = [];
  for (let i = 0; i < arguments.length; i++) {
    const element = arguments[i];
    if (Array.isArray(element)) {
      for (let c = 0; c < element.length; c += CHUNK_SIZE) {
        const chunk = slice(element, c, c + CHUNK_SIZE);
        const recurseResult = flatten.apply(null, chunk);
        for (let r = 0; r < recurseResult.length; r++) {
          result.push(recurseResult[r]);
        }
      }
    } else {
      result.push(element);
    }
  }
  return result;
}
exports.flatten = flatten;


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array<T>} The array.
 * @template T
 */
function rotate(array, n) {
  asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      Array.prototype.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      Array.prototype.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
}
exports.rotate = rotate;


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!IArrayLike<?>} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     `arr.length - 1`.
 * @param {number} toIndex Target index between 0 and `arr.length - 1`.
 */
function moveItem(arr, fromIndex, toIndex) {
  asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  const removedItems = Array.prototype.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
}
exports.moveItem = moveItem;


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!IArrayLike<?>} var_args Arrays to be combined.
 * @return {!Array<!Array<?>>} A new array of arrays created from
 *     provided arrays.
 */
function zip(var_args) {
  if (!arguments.length) {
    return [];
  }
  const result = [];
  let minLen = arguments[0].length;
  for (let i = 1; i < arguments.length; i++) {
    if (arguments[i].length < minLen) {
      minLen = arguments[i].length;
    }
  }
  for (let i = 0; i < minLen; i++) {
    const value = [];
    for (let j = 0; j < arguments.length; j++) {
      value.push(arguments[j][i]);
    }
    result.push(value);
  }
  return result;
}
exports.zip = zip;


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array<?>} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
function shuffle(arr, opt_randFn) {
  const randFn = opt_randFn || Math.random;

  for (let i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    const j = Math.floor(randFn() * (i + 1));

    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
}
exports.shuffle = shuffle;


/**
 * Returns a new array of elements from arr, based on the indexes of elements
 * provided by index_arr. For example, the result of index copying
 * ['a', 'b', 'c'] with index_arr [1,0,0,2] is ['b', 'a', 'a', 'c'].
 *
 * @param {!IArrayLike<T>} arr The array to get a indexed copy from.
 * @param {!IArrayLike<number>} index_arr An array of indexes to get from arr.
 * @return {!Array<T>} A new array of elements from arr in index_arr order.
 * @template T
 */
function copyByIndex(arr, index_arr) {
  const result = [];
  forEach(index_arr, function(index) {
    result.push(arr[index]);
  });
  return result;
}
exports.copyByIndex = copyByIndex;


/**
 * Maps each element of the input array into zero or more elements of the output
 * array.
 *
 * @param {!IArrayLike<VALUE>|string} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): !Array<RESULT>} f The function
 *     to call for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return an array. The result will be
 *     used to extend a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array<RESULT>} a new array with the concatenation of all arrays
 *     returned from f.
 * @template THIS, VALUE, RESULT
 */
function concatMap(arr, f, opt_obj) {
  return concat.apply([], map(arr, f, opt_obj));
}
exports.concatMap = concatMap;

;return exports;});

//third_party/javascript/closure/debug/errorcontext.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides methods dealing with context on error objects.
 */

goog.provide('goog.debug.errorcontext');


/**
 * Adds key-value context to the error.
 * @param {!Error} err The error to add context to.
 * @param {string} contextKey Key for the context to be added.
 * @param {string} contextValue Value for the context to be added.
 */
goog.debug.errorcontext.addErrorContext = function(
    err, contextKey, contextValue) {
  'use strict';
  if (!err[goog.debug.errorcontext.CONTEXT_KEY_]) {
    err[goog.debug.errorcontext.CONTEXT_KEY_] = {};
  }
  err[goog.debug.errorcontext.CONTEXT_KEY_][contextKey] = contextValue;
};


/**
 * @param {!Error} err The error to get context from.
 * @return {!Object<string, string>} The context of the provided error.
 */
goog.debug.errorcontext.getErrorContext = function(err) {
  'use strict';
  return err[goog.debug.errorcontext.CONTEXT_KEY_] || {};
};


// TODO(aaronsn): convert this to a Symbol once goog.debug.ErrorReporter is
// able to use ES6.
/** @private @const {string} */
goog.debug.errorcontext.CONTEXT_KEY_ = '__closure__error__context__984382';

//third_party/javascript/closure/debug/debug.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug');

goog.require('goog.array');
goog.require('goog.debug.errorcontext');


/** @define {boolean} Whether logging should be enabled. */
goog.debug.LOGGING_ENABLED =
    goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);


/** @define {boolean} Whether to force "sloppy" stack building. */
goog.debug.FORCE_SLOPPY_STACKS =
    goog.define('goog.debug.FORCE_SLOPPY_STACKS', false);


/**
 * @define {boolean} TODO(b/159435805): Remove this hack once bug is resolved.
 */
goog.debug.CHECK_FOR_THROWN_EVENT =
    goog.define('goog.debug.CHECK_FOR_THROWN_EVENT', false);



/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 * @suppress {strictMissingProperties} onerror is not defined as a property
 *    on Object.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  'use strict';
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just "Script error.". For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to "" for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    'use strict';
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      lineNumber: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of `obj`.
 */
goog.debug.expose = function(obj, opt_showFn) {
  'use strict';
  if (typeof obj == 'undefined') {
    return 'undefined';
  }
  if (obj == null) {
    return 'NULL';
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn && typeof obj[x] === 'function') {
      continue;
    }
    var s = x + ' = ';

    try {
      s += obj[x];
    } catch (e) {
      s += '*** ' + e + ' ***';
    }
    str.push(s);
  }
  return str.join('\n');
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects. NOTE: The output will include
 * Uids on all objects that were exposed. Any added Uids will be removed before
 * returning.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of `obj`.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  'use strict';
  var str = [];

  // Track any objects where deepExpose added a Uid, so they can be cleaned up
  // before return. We do this globally, rather than only on ancestors so that
  // if the same object appears in the output, you can see it.
  var uidsToCleanup = [];
  var ancestorUids = {};

  var helper = function(obj, space) {
    'use strict';
    var nestspace = space + '  ';

    var indentMultiline = function(str) {
      'use strict';
      return str.replace(/\n/g, '\n' + space);
    };


    try {
      if (obj === undefined) {
        str.push('undefined');
      } else if (obj === null) {
        str.push('NULL');
      } else if (typeof obj === 'string') {
        str.push('"' + indentMultiline(obj) + '"');
      } else if (typeof obj === 'function') {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        // Add a Uid if needed. The struct calls implicitly adds them.
        if (!goog.hasUid(obj)) {
          uidsToCleanup.push(obj);
        }
        var uid = goog.getUid(obj);
        if (ancestorUids[uid]) {
          str.push('*** reference loop detected (id=' + uid + ') ***');
        } else {
          ancestorUids[uid] = true;
          str.push('{');
          for (var x in obj) {
            if (!opt_showFn && typeof obj[x] === 'function') {
              continue;
            }
            str.push('\n');
            str.push(nestspace);
            str.push(x + ' = ');
            helper(obj[x], nestspace);
          }
          str.push('\n' + space + '}');
          delete ancestorUids[uid];
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push('*** ' + e + ' ***');
    }
  };

  helper(obj, '');

  // Cleanup any Uids that were added by the deepExpose.
  for (var i = 0; i < uidsToCleanup.length; i++) {
    goog.removeUid(uidsToCleanup[i]);
  }

  return str.join('');
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array<?>} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  'use strict';
  var str = [];
  for (var i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return '[ ' + str.join(', ') + ' ]';
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {*} err Raw error object.
 * @return {{
 *    message: (?|undefined),
 *    name: (?|undefined),
 *    lineNumber: (?|undefined),
 *    fileName: (?|undefined),
 *    stack: (?|undefined)
 * }} Representation of err as an Object. It will never return err.
 * @suppress {strictMissingProperties} properties not defined on err
 */
goog.debug.normalizeErrorObject = function(err) {
  'use strict';
  var href = goog.getObjectByName('window.location.href');
  if (err == null) {
    err = 'Unknown Error of type "null/undefined"';
  }
  if (typeof err === 'string') {
    return {
      'message': err,
      'name': 'Unknown error',
      'lineNumber': 'Not available',
      'fileName': href,
      'stack': 'Not available'
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || 'Not available';
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing 'lineNumber':
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = 'Not available';
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global['$googDebugFname'] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing 'filename'.
    fileName = 'Not available';
    threwError = true;
  }

  var stack = goog.debug.serializeErrorStack_(err);

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    var message = err.message;
    if (message == null) {
      if (err.constructor && err.constructor instanceof Function) {
        var ctorName = err.constructor.name ?
            err.constructor.name :
            goog.debug.getFunctionName(err.constructor);
        message = 'Unknown Error of type "' + ctorName + '"';
        // TODO(b/159435805): Remove this hack once bug is resolved.
        if (goog.debug.CHECK_FOR_THROWN_EVENT && ctorName == 'Event') {
          try {
            message = message + ' with Event.type "' + (err.type || '') + '"';
          } catch (e) {
            // Just give up on getting more information out of the error object.
          }
        }
      } else {
        message = 'Unknown Error of unknown type';
      }

      // Avoid TypeError since toString could be missing from the instance
      // (e.g. if created Object.create(null)).
      if (typeof err.toString === 'function' &&
          Object.prototype.toString !== err.toString) {
        message += ': ' + err.toString();
      }
    }
    return {
      'message': message,
      'name': err.name || 'UnknownError',
      'lineNumber': lineNumber,
      'fileName': fileName,
      'stack': stack || 'Not available'
    };
  }
  // Standards error object
  // Typed !Object. Should be a subtype of the return type, but it's not.
  err.stack = stack;

  // Return non-standard error to allow for consistent result (eg. enumerable).
  return {
    'message': err.message,
    'name': err.name,
    'lineNumber': err.lineNumber,
    'fileName': err.fileName,
    'stack': err.stack
  };
};


/**
 * Serialize stack by including the cause chain of the exception if it exists.
 *
 * MOE:begin_intracomment_strip
 * When an OO language is transpiled to JavaScript, it might have the concept of
 * exception chaining, which we emulate here. See go/exception-cause-reporting
 * for more information.
 * MOE:end_intracomment_strip
 *
 * @param {*} e an exception that may have a cause
 * @param {!Object=} seen set of cause that have already been serialized
 * @return {string}
 * @private
 * @suppress {missingProperties} properties not defined on cause and e
 */
goog.debug.serializeErrorStack_ = function(e, seen) {
  'use strict';
  if (!seen) {
    seen = {};
  }
  seen[goog.debug.serializeErrorAsKey_(e)] = true;

  var stack = e['stack'] || '';

  // Add cause if exists.
  var cause = e.cause;
  if (cause && !seen[goog.debug.serializeErrorAsKey_(cause)]) {
    stack += '\nCaused by: ';
    // Some browsers like Chrome add the error message as the first frame of the
    // stack, In this case we don't need to add it. Note: we don't use
    // String.startsWith method because it might have to be polyfilled.
    if (!cause.stack || cause.stack.indexOf(cause.toString()) != 0) {
      stack += (typeof cause === 'string') ? cause : cause.message + '\n';
    }
    stack += goog.debug.serializeErrorStack_(cause, seen);
  }

  return stack;
};

/**
 * Serialize an error to a string key.
 * @param {*} e an exception
 * @return {string}
 * @private
 */
goog.debug.serializeErrorAsKey_ = function(e) {
  'use strict';
  var keyPrefix = '';

  if (typeof e.toString === 'function') {
    keyPrefix = '' + e;
  }

  return keyPrefix + e['stack'];
};


/**
 * Converts an object to an Error using the object's toString if it's not
 * already an Error, adds a stacktrace if there isn't one, and optionally adds
 * an extra message.
 * @param {*} err The original thrown error, object, or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
 *     it is converted to an Error which is enhanced and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  'use strict';
  var error;
  if (!(err instanceof Error)) {
    error = Error(err);
    if (Error.captureStackTrace) {
      // Trim this function off the call stack, if we can.
      Error.captureStackTrace(error, goog.debug.enhanceError);
    }
  } else {
    error = err;
  }

  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
  }
  if (opt_message) {
    // find the first unoccupied 'messageX' property
    var x = 0;
    while (error['message' + x]) {
      ++x;
    }
    error['message' + x] = String(opt_message);
  }
  return error;
};


/**
 * Converts an object to an Error using the object's toString if it's not
 * already an Error, adds a stacktrace if there isn't one, and optionally adds
 * context to the Error, which is reported by the closure error reporter.
 * @param {*} err The original thrown error, object, or string.
 * @param {!Object<string, string>=} opt_context Key-value context to add to the
 *     Error.
 * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,
 *     it is converted to an Error which is enhanced and returned.
 */
goog.debug.enhanceErrorWithContext = function(err, opt_context) {
  'use strict';
  var error = goog.debug.enhanceError(err);
  if (opt_context) {
    for (var key in opt_context) {
      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);
    }
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn't worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 * @suppress {es5Strict}
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  'use strict';
  if (!goog.debug.FORCE_SLOPPY_STACKS) {
    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
    if (stack) {
      return stack;
    }
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties.  Fall-through for legacy browser support.
  }

  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn && (!opt_depth || depth < opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push('()\n');

    try {
      fn = fn.caller;
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
      break;
    }
    depth++;
    if (depth >= goog.debug.MAX_STACK_DEPTH) {
      sb.push('[...long stack...]');
      break;
    }
  }
  if (opt_depth && depth >= opt_depth) {
    sb.push('[...reached max depth limit...]');
  } else {
    sb.push('[end]');
  }

  return sb.join('');
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * @param {Function} fn The function to start getting the trace from.
 * @return {?string}
 * @private
 */
goog.debug.getNativeStackTrace_ = function(fn) {
  'use strict';
  var tempErr = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(tempErr, fn);
    return String(tempErr.stack);
  } else {
    // IE10, only adds stack traces when an exception is thrown.
    try {
      throw tempErr;
    } catch (e) {
      tempErr = e;
    }
    var stack = tempErr.stack;
    if (stack) {
      return String(stack);
    }
  }
  return null;
};


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that's currently on the call stack.
 * @param {?Function=} fn If provided, when collecting the stack trace all
 *     frames above the topmost call to this function, including that call,
 *     will be left out of the stack trace.
 * @return {string} Stack trace.
 * @suppress {es5Strict}
 */
goog.debug.getStacktrace = function(fn) {
  'use strict';
  var stack;
  if (!goog.debug.FORCE_SLOPPY_STACKS) {
    // Try to get the stack trace from the environment if it is available.
    var contextFn = fn || goog.debug.getStacktrace;
    stack = goog.debug.getNativeStackTrace_(contextFn);
  }
  if (!stack) {
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties. This function will throw in strict mode.
    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);
  }
  return stack;
};


/**
 * Private helper for getStacktrace().
 * @param {?Function} fn If provided, when collecting the stack trace all
 *     frames above the topmost call to this function, including that call,
 *     will be left out of the stack trace.
 * @param {Array<!Function>} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @suppress {es5Strict}
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  'use strict';
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push('[...circular reference...]');

    // Traverse the call stack until function not found or max depth is reached
  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + '(');
    var args = fn.arguments;
    // Args may be null for some special functions such as host objects or eval.
    for (var i = 0; args && i < args.length; i++) {
      if (i > 0) {
        sb.push(', ');
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case 'object':
          argDesc = arg ? 'object' : 'null';
          break;

        case 'string':
          argDesc = arg;
          break;

        case 'number':
          argDesc = String(arg);
          break;

        case 'boolean':
          argDesc = arg ? 'true' : 'false';
          break;

        case 'function':
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : '[fn]';
          break;

        case 'undefined':
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length > 40) {
        argDesc = argDesc.substr(0, 40) + '...';
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(')\n');

    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
    }

  } else if (fn) {
    sb.push('[...long stack...]');
  } else {
    sb.push('[end]');
  }
  return sb.join('');
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function's name.
 */
goog.debug.getFunctionName = function(fn) {
  'use strict';
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function\s+([^\(]+)/m.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  'use strict';
  return string.replace(/ /g, '[_]')
      .replace(/\f/g, '[f]')
      .replace(/\n/g, '[n]\n')
      .replace(/\r/g, '[r]')
      .replace(/\t/g, '[t]');
};


/**
 * Returns the type of a value. If a constructor is passed, and a suitable
 * string cannot be found, 'unknown type name' will be returned.
 *
 * <p>Forked rather than moved from {@link goog.asserts.getType_}
 * to avoid adding a dependency to goog.asserts.
 * @param {*} value A constructor, object, or primitive.
 * @return {string} The best display name for the value, or 'unknown type name'.
 */
goog.debug.runtimeType = function(value) {
  'use strict';
  if (value instanceof Function) {
    return value.displayName || value.name || 'unknown type name';
  } else if (value instanceof Object) {
    return /** @type {string} */ (value.constructor.displayName) ||
        value.constructor.name || Object.prototype.toString.call(value);
  } else {
    return value === null ? 'null' : typeof value;
  }
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Private internal function to support goog.debug.freeze.
 * @param {T} arg
 * @return {T}
 * @template T
 * @private
 */
goog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {
  'use strict';
  return arg;
};


/**
 * Freezes the given object, but only in debug mode (and in browsers that
 * support it).  Note that this is a shallow freeze, so for deeply nested
 * objects it must be called at every level to ensure deep immutability.
 * @param {T} arg
 * @return {T}
 * @template T
 */
goog.debug.freeze = function(arg) {
  'use strict';
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // freezeInternal_ from the compiler so that the entire call can be
  // removed if the result is not used.
  return {
    valueOf: function() {
      'use strict';
      return goog.debug.freezeInternal_(arg);
    }
  }.valueOf();
};

//third_party/javascript/closure/disposable/dispose.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The dispose method is used to clean up references and
 * resources.
 */

goog.module('goog.dispose');
goog.module.declareLegacyNamespace();

/**
 * Calls `dispose` on the argument if it supports it. If obj is not an
 *     object with a dispose() method, this is a no-op.
 * @param {*} obj The object to dispose of.
 */
function dispose(obj) {
  if (obj && typeof obj.dispose == 'function') {
    obj.dispose();
  }
}
exports = dispose;

;return exports;});

//third_party/javascript/closure/disposable/disposeall.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The disposeAll method is used to clean up references and
 * resources.
 */

goog.module('goog.disposeAll');
goog.module.declareLegacyNamespace();

const dispose = goog.require('goog.dispose');

/**
 * Calls `dispose` on each member of the list that supports it. (If the
 * member is an ArrayLike, then `goog.disposeAll()` will be called
 * recursively on each of its members.) If the member is not an object with a
 * `dispose()` method, then it is ignored.
 * @param {...*} var_args The list.
 */
function disposeAll(var_args) {
  for (let i = 0, len = arguments.length; i < len; ++i) {
    const disposable = arguments[i];
    if (goog.isArrayLike(disposable)) {
      disposeAll.apply(null, disposable);
    } else {
      dispose(disposable);
    }
  }
}
exports = disposeAll;

;return exports;});

//third_party/javascript/closure/disposable/idisposable.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 */


goog.provide('goog.disposable.IDisposable');



/**
 * Interface for a disposable object.  If a instance requires cleanup, it should
 * implement this interface (it may subclass goog.Disposable).
 *
 * Examples of cleanup that can be done in `dispose` method:
 * 1. Remove event listeners.
 * 2. Cancel timers (setTimeout, setInterval, goog.Timer).
 * 3. Call `dispose` on other disposable objects hold by current object.
 * 4. Close connections (e.g. WebSockets).
 *
 * Note that it's not required to delete properties (e.g. DOM nodes) or set them
 * to null as garbage collector will collect them assuming that references to
 * current object will be lost after it is disposed.
 *
 * See also http://go/mdn/JavaScript/Memory_Management.
 *
 * @record
 */
goog.disposable.IDisposable = function() {};


/**
 * Disposes of the object and its resources.
 * @return {void} Nothing.
 */
goog.disposable.IDisposable.prototype.dispose = goog.abstractMethod;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.disposable.IDisposable.prototype.isDisposed = goog.abstractMethod;

//third_party/javascript/closure/disposable/disposable.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Implements the disposable interface.
 */

goog.provide('goog.Disposable');

goog.require('goog.disposable.IDisposable');
goog.require('goog.dispose');
/**
 * TODO(b/175587766): Remove this require.
 * @suppress {extraRequire}
 */
goog.require('goog.disposeAll');

/**
 * Class that provides the basic implementation for disposable objects. If your
 * class holds references or resources that can't be collected by standard GC,
 * it should extend this class or implement the disposable interface (defined
 * in goog.disposable.IDisposable). See description of
 * goog.disposable.IDisposable for examples of cleanup.
 * @constructor
 * @implements {goog.disposable.IDisposable}
 */
goog.Disposable = function() {
  'use strict';
  /**
   * If monitoring the goog.Disposable instances is enabled, stores the creation
   * stack trace of the Disposable instance.
   * @type {string|undefined}
   */
  this.creationStack;

  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {
      this.creationStack = new Error().stack;
    }
    goog.Disposable.instances_[goog.getUid(this)] = this;
  }
  // Support sealing
  this.disposed_ = this.disposed_;
  this.onDisposeCallbacks_ = this.onDisposeCallbacks_;
};


/**
 * @enum {number} Different monitoring modes for Disposable.
 */
goog.Disposable.MonitoringMode = {
  /**
   * No monitoring.
   */
  OFF: 0,
  /**
   * Creating and disposing the goog.Disposable instances is monitored. All
   * disposable objects need to call the `goog.Disposable` base
   * constructor. The PERMANENT mode must be switched on before creating any
   * goog.Disposable instances.
   */
  PERMANENT: 1,
  /**
   * INTERACTIVE mode can be switched on and off on the fly without producing
   * errors. It also doesn't warn if the disposable objects don't call the
   * `goog.Disposable` base constructor.
   */
  INTERACTIVE: 2
};


/**
 * @define {number} The monitoring mode of the goog.Disposable
 *     instances. Default is OFF. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.Disposable.MONITORING_MODE =
    goog.define('goog.Disposable.MONITORING_MODE', 0);


/**
 * @define {boolean} Whether to attach creation stack to each created disposable
 *     instance; This is only relevant for when MonitoringMode != OFF.
 */
goog.Disposable.INCLUDE_STACK_ON_CREATION =
    goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);


/**
 * Maps the unique ID of every undisposed `goog.Disposable` object to
 * the object itself.
 * @type {!Object<number, !goog.Disposable>}
 * @private
 */
goog.Disposable.instances_ = {};


/**
 * @return {!Array<!goog.Disposable>} All `goog.Disposable` objects that
 *     haven't been disposed of.
 */
goog.Disposable.getUndisposedObjects = function() {
  'use strict';
  var ret = [];
  for (var id in goog.Disposable.instances_) {
    if (goog.Disposable.instances_.hasOwnProperty(id)) {
      ret.push(goog.Disposable.instances_[Number(id)]);
    }
  }
  return ret;
};


/**
 * Clears the registry of undisposed objects but doesn't dispose of them.
 */
goog.Disposable.clearUndisposedObjects = function() {
  'use strict';
  goog.Disposable.instances_ = {};
};


/**
 * Whether the object has been disposed of.
 * @type {boolean}
 * @private
 */
goog.Disposable.prototype.disposed_ = false;


/**
 * Callbacks to invoke when this object is disposed.
 * @type {Array<!Function>}
 * @private
 */
goog.Disposable.prototype.onDisposeCallbacks_;


/**
 * @return {boolean} Whether the object has been disposed of.
 * @override
 */
goog.Disposable.prototype.isDisposed = function() {
  'use strict';
  return this.disposed_;
};


/**
 * @return {boolean} Whether the object has been disposed of.
 * @deprecated Use {@link #isDisposed} instead.
 */
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;


/**
 * Disposes of the object. If the object hasn't already been disposed of, calls
 * {@link #disposeInternal}. Classes that extend `goog.Disposable` should
 * override {@link #disposeInternal} in order to cleanup references, resources
 * and other disposable objects. Reentrant.
 *
 * @return {void} Nothing.
 * @override
 */
goog.Disposable.prototype.dispose = function() {
  'use strict';
  if (!this.disposed_) {
    // Set disposed_ to true first, in case during the chain of disposal this
    // gets disposed recursively.
    this.disposed_ = true;
    this.disposeInternal();
    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
      var uid = goog.getUid(this);
      if (goog.Disposable.MONITORING_MODE ==
              goog.Disposable.MonitoringMode.PERMANENT &&
          !goog.Disposable.instances_.hasOwnProperty(uid)) {
        throw new Error(
            this + ' did not call the goog.Disposable base ' +
            'constructor or was disposed of after a clearUndisposedObjects ' +
            'call');
      }
      if (goog.Disposable.MONITORING_MODE !=
              goog.Disposable.MonitoringMode.OFF &&
          this.onDisposeCallbacks_ && this.onDisposeCallbacks_.length > 0) {
        throw new Error(
            this + ' did not empty its onDisposeCallbacks queue. This ' +
            'probably means it overrode dispose() or disposeInternal() ' +
            'without calling the superclass\' method.');
      }
      delete goog.Disposable.instances_[uid];
    }
  }
};


/**
 * Associates a disposable object with this object so that they will be disposed
 * together.
 * @param {goog.disposable.IDisposable} disposable that will be disposed when
 *     this object is disposed.
 */
goog.Disposable.prototype.registerDisposable = function(disposable) {
  'use strict';
  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));
};


/**
 * Invokes a callback function when this object is disposed. Callbacks are
 * invoked in the order in which they were added. If a callback is added to
 * an already disposed Disposable, it will be called immediately.
 * @param {function(this:T):?} callback The callback function.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @template T
 */
goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {
  'use strict';
  if (this.disposed_) {
    opt_scope !== undefined ? callback.call(opt_scope) : callback();
    return;
  }
  if (!this.onDisposeCallbacks_) {
    this.onDisposeCallbacks_ = [];
  }

  this.onDisposeCallbacks_.push(
      opt_scope !== undefined ? goog.bind(callback, opt_scope) : callback);
};


/**
 * Performs appropriate cleanup. See description of goog.disposable.IDisposable
 * for examples. Classes that extend `goog.Disposable` should override this
 * method. Not reentrant. To avoid calling it twice, it must only be called from
 * the subclass' `disposeInternal` method. Everywhere else the public `dispose`
 * method must be used. For example:
 *
 * <pre>
 * mypackage.MyClass = function() {
 * mypackage.MyClass.base(this, 'constructor');
 *     // Constructor logic specific to MyClass.
 *     ...
 *   };
 *   goog.inherits(mypackage.MyClass, goog.Disposable);
 *
 *   mypackage.MyClass.prototype.disposeInternal = function() {
 *     // Dispose logic specific to MyClass.
 *     ...
 *     // Call superclass's disposeInternal at the end of the subclass's, like
 *     // in C++, to avoid hard-to-catch issues.
 *     mypackage.MyClass.base(this, 'disposeInternal');
 *   };
 * </pre>
 *
 * @protected
 */
goog.Disposable.prototype.disposeInternal = function() {
  'use strict';
  if (this.onDisposeCallbacks_) {
    while (this.onDisposeCallbacks_.length) {
      this.onDisposeCallbacks_.shift()();
    }
  }
};


/**
 * Returns True if we can verify the object is disposed.
 * Calls `isDisposed` on the argument if it supports it.  If obj
 * is not an object with an isDisposed() method, return false.
 * @param {*} obj The object to investigate.
 * @return {boolean} True if we can verify the object is disposed.
 */
goog.Disposable.isDisposed = function(obj) {
  'use strict';
  if (obj && typeof obj.isDisposed == 'function') {
    return obj.isDisposed();
  }
  return false;
};

//third_party/javascript/closure/events/eventid.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.events.EventId');



/**
 * A templated class that is used when registering for events. Typical usage:
 *
 *    /** @type {goog.events.EventId<MyEventObj>} *\
 *    var myEventId = new goog.events.EventId(
 *        goog.events.getUniqueId(('someEvent'));
 *
 *    // No need to cast or declare here since the compiler knows the
 *    // correct type of 'evt' (MyEventObj).
 *    something.listen(myEventId, function(evt) {});
 *
 * @param {string} eventId
 * @template T
 * @constructor
 * @struct
 * @final
 */
goog.events.EventId = function(eventId) {
  'use strict';
  /** @const */ this.id = eventId;
};


/**
 * @override
 * @return {string}
 */
goog.events.EventId.prototype.toString = function() {
  'use strict';
  return this.id;
};

//third_party/javascript/closure/events/event.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A base class for event objects.
 */


goog.provide('goog.events.Event');

/**
 * goog.events.Event no longer depends on goog.Disposable. Keep requiring
 * goog.Disposable here to not break projects which assume this dependency.
 * @suppress {extraRequire}
 */
goog.require('goog.Disposable');
goog.require('goog.events.EventId');


/**
 * A base class for event objects, so that they can support preventDefault and
 * stopPropagation.
 *
 * @param {string|!goog.events.EventId} type Event Type.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the `EventTarget` interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 */
goog.events.Event = function(type, opt_target) {
  'use strict';
  /**
   * Event type.
   * @type {string}
   */
  this.type = type instanceof goog.events.EventId ? String(type) : type;

  /**
   * TODO(tbreisacher): The type should probably be
   * EventTarget|goog.events.EventTarget.
   *
   * Target of the event.
   * @type {Object|undefined}
   */
  this.target = opt_target;

  /**
   * Object that had the listener attached.
   * @type {Object|undefined}
   */
  this.currentTarget = this.target;

  /**
   * Whether to cancel the event in internal capture/bubble processing for IE.
   * @type {boolean}
   * @private
   */
  this.propagationStopped_ = false;

  /**
   * Whether the default action has been prevented.
   * This is a property to match the W3C specification at
   * {@link http://www.w3.org/TR/DOM-Level-3-Events/
   * #events-event-type-defaultPrevented}.
   * Must be treated as read-only outside the class.
   * @type {boolean}
   */
  this.defaultPrevented = false;
};

/**
 * @return {boolean} true iff internal propagation has been stopped.
 */
goog.events.Event.prototype.hasPropagationStopped = function() {
  'use strict';
  return this.propagationStopped_;
};

/**
 * Stops event propagation.
 * @return {void}
 */
goog.events.Event.prototype.stopPropagation = function() {
  'use strict';
  this.propagationStopped_ = true;
};


/**
 * Prevents the default action, for example a link redirecting to a url.
 * @return {void}
 */
goog.events.Event.prototype.preventDefault = function() {
  'use strict';
  this.defaultPrevented = true;
};


/**
 * Stops the propagation of the event. It is equivalent to
 * `e.stopPropagation()`, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 * @return {void}
 */
goog.events.Event.stopPropagation = function(e) {
  'use strict';
  e.stopPropagation();
};


/**
 * Prevents the default action. It is equivalent to
 * `e.preventDefault()`, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 * @return {void}
 */
goog.events.Event.preventDefault = function(e) {
  'use strict';
  e.preventDefault();
};

//third_party/javascript/closure/events/browserfeature.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Browser capability checks for the events package.
 */

goog.module('goog.events.BrowserFeature');
goog.module.declareLegacyNamespace();


/**
 * Tricks Closure Compiler into believing that a function is pure.  The compiler
 * assumes that any `valueOf` function is pure, without analyzing its contents.
 *
 * @param {function(): T} fn
 * @return {T}
 * @template T
 */
const purify = (fn) => {
  return ({valueOf: fn}).valueOf();
};


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
exports = {
  /**
   * Whether the button attribute of the event is W3C compliant.  False in
   * Internet Explorer prior to version 9; document-version dependent.
   */
  HAS_W3C_BUTTON: true,

  /**
   * Whether the browser supports full W3C event model.
   */
  HAS_W3C_EVENT_SUPPORT: true,

  /**
   * To prevent default in IE7-8 for certain keydown events we need set the
   * keyCode to -1.
   */
  SET_KEY_CODE_TO_PREVENT_DEFAULT: false,

  /**
   * Whether the `navigator.onLine` property is supported.
   */
  HAS_NAVIGATOR_ONLINE_PROPERTY: true,

  /**
   * Whether HTML5 network online/offline events are supported.
   */
  HAS_HTML5_NETWORK_EVENT_SUPPORT: true,

  /**
   * Whether HTML5 network events fire on document.body, or otherwise the
   * window.
   */
  HTML5_NETWORK_EVENTS_FIRE_ON_BODY: false,

  /**
   * Whether touch is enabled in the browser.
   */
  TOUCH_ENABLED:
      ('ontouchstart' in goog.global ||
       !!(goog.global['document'] && document.documentElement &&
          'ontouchstart' in document.documentElement) ||
       // IE10 uses non-standard touch events, so it has a different check.
       !!(goog.global['navigator'] &&
          (goog.global['navigator']['maxTouchPoints'] ||
           goog.global['navigator']['msMaxTouchPoints']))),

  /**
   * Whether addEventListener supports W3C standard pointer events.
   * http://www.w3.org/TR/pointerevents/
   */
  POINTER_EVENTS: ('PointerEvent' in goog.global),

  /**
   * Whether addEventListener supports MSPointer events (only used in IE10).
   * http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
   * http://msdn.microsoft.com/library/hh673557(v=vs.85).aspx
   */
  MSPOINTER_EVENTS:
      ('MSPointerEvent' in goog.global &&
       !!(goog.global['navigator'] &&
          goog.global['navigator']['msPointerEnabled'])),

  /**
   * Whether addEventListener supports {passive: true}.
   * https://developers.google.com/web/updates/2016/06/passive-event-listeners
   */
  PASSIVE_EVENTS: purify(function() {
    // If we're in a web worker or other custom environment, we can't tell.
    if (!goog.global.addEventListener || !Object.defineProperty) {  // IE 8
      return false;
    }

    var passive = false;
    var options = Object.defineProperty({}, 'passive', {
      get: function() {
        passive = true;
      }
    });
    try {
      goog.global.addEventListener('test', goog.nullFunction, options);
      goog.global.removeEventListener('test', goog.nullFunction, options);
    } catch (e) {
    }

    return passive;
  })
};

;return exports;});

//third_party/javascript/closure/string/internal.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview String functions called from Closure packages that couldn't
 * depend on each other. Outside Closure, use goog.string function which
 * delegate to these.
 */


goog.provide('goog.string.internal');


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of `str`.
 * @return {boolean} True if `str` begins with `prefix`.
 * @see goog.string.startsWith
 */
goog.string.internal.startsWith = function(str, prefix) {
  'use strict';
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix`.
 * @see goog.string.endsWith
 */
goog.string.internal.endsWith = function(str, suffix) {
  'use strict';
  const l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of `str`.
 * @return {boolean} True if `str` begins with `prefix` (ignoring
 *     case).
 * @see goog.string.caseInsensitiveStartsWith
 */
goog.string.internal.caseInsensitiveStartsWith = function(str, prefix) {
  'use strict';
  return goog.string.internal.caseInsensitiveCompare(
             prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix` (ignoring
 *     case).
 * @see goog.string.caseInsensitiveEndsWith
 */
goog.string.internal.caseInsensitiveEndsWith = function(str, suffix) {
  'use strict';
  return (
      goog.string.internal.caseInsensitiveCompare(
          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if `str1` and `str2` are the same string,
 *     ignoring case.
 * @see goog.string.caseInsensitiveEquals
 */
goog.string.internal.caseInsensitiveEquals = function(str1, str2) {
  'use strict';
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} Whether `str` is empty or whitespace only.
 * @see goog.string.isEmptyOrWhitespace
 */
goog.string.internal.isEmptyOrWhitespace = function(str) {
  'use strict';
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of `str`.
 */
goog.string.internal.trim =
    (goog.TRUSTED_SITE && String.prototype.trim) ? function(str) {
      'use strict';
      return str.trim();
    } : function(str) {
      'use strict';
      // Since IE doesn't include non-breaking-space (0xa0) in their \s
      // character class (as required by section 7.2 of the ECMAScript spec),
      // we explicitly include it in the regexp to enforce consistent
      // cross-browser behavior.
      // NOTE: We don't use String#replace because it might have side effects
      // causing this function to not compile to 0 bytes.
      return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(str)[1];
    };


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare `str1` to.
 * @return {number} The comparator result, as described above.
 * @see goog.string.caseInsensitiveCompare
 */
goog.string.internal.caseInsensitiveCompare = function(str1, str2) {
  'use strict';
  const test1 = String(str1).toLowerCase();
  const test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of `str` with converted newlines.
 * @see goog.string.newLineToBr
 */
goog.string.internal.newLineToBr = function(str, opt_xml) {
  'use strict';
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars
 * @return {string} An escaped copy of `str`.
 * @see goog.string.htmlEscape
 */
goog.string.internal.htmlEscape = function(
    str, opt_isLikelyToContainHtmlChars) {
  'use strict';
  if (opt_isLikelyToContainHtmlChars) {
    str = str.replace(goog.string.internal.AMP_RE_, '&amp;')
              .replace(goog.string.internal.LT_RE_, '&lt;')
              .replace(goog.string.internal.GT_RE_, '&gt;')
              .replace(goog.string.internal.QUOT_RE_, '&quot;')
              .replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;')
              .replace(goog.string.internal.NULL_RE_, '&#0;');
    return str;

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.internal.ALL_RE_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.internal.AMP_RE_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.internal.LT_RE_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.internal.GT_RE_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.internal.QUOT_RE_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.internal.SINGLE_QUOTE_RE_, '&#39;');
    }
    if (str.indexOf('\x00') != -1) {
      str = str.replace(goog.string.internal.NULL_RE_, '&#0;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.AMP_RE_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.LT_RE_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.GT_RE_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.QUOT_RE_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.SINGLE_QUOTE_RE_ = /'/g;


/**
 * Regular expression that matches null character, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.NULL_RE_ = /\x00/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @const {!RegExp}
 * @private
 */
goog.string.internal.ALL_RE_ = /[\x00&<>"']/;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of `str`.
 * @see goog.string.whitespaceEscape
 */
goog.string.internal.whitespaceEscape = function(str, opt_xml) {
  'use strict';
  // This doesn't use goog.string.preserveSpaces for backwards compatibility.
  return goog.string.internal.newLineToBr(
      str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Determines whether a string contains a substring.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 * @see goog.string.contains
 */
goog.string.internal.contains = function(str, subString) {
  'use strict';
  return str.indexOf(subString) != -1;
};


/**
 * Determines whether a string contains a substring, ignoring case.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 * @see goog.string.caseInsensitiveContains
 */
goog.string.internal.caseInsensitiveContains = function(str, subString) {
  'use strict';
  return goog.string.internal.contains(
      str.toLowerCase(), subString.toLowerCase());
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if `version1` is higher.
 *                   0 if arguments are equal.
 *                  -1 if `version2` is higher.
 * @see goog.string.compareVersions
 */
goog.string.internal.compareVersions = function(version1, version2) {
  'use strict';
  let order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  const v1Subs = goog.string.internal.trim(String(version1)).split('.');
  const v2Subs = goog.string.internal.trim(String(version2)).split('.');
  const subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (let subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    let v1Sub = v1Subs[subIdx] || '';
    let v2Sub = v2Subs[subIdx] || '';

    do {
      // Split the subversions into pairs of numbers and qualifiers (like 'b').
      // Two different RegExp objects are use to make it clear the code
      // is side-effect free
      const v1Comp = /(\d*)(\D*)(.*)/.exec(v1Sub) || ['', '', '', ''];
      const v2Comp = /(\d*)(\D*)(.*)/.exec(v2Sub) || ['', '', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      const v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      const v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.internal.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.internal.compareElements_(
              v1Comp[2].length == 0, v2Comp[2].length == 0) ||
          goog.string.internal.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.

      v1Sub = v1Comp[3];
      v2Sub = v2Comp[3];
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if `left` is higher.
 *                   0 if arguments are equal.
 *                  -1 if `right` is higher.
 * @private
 */
goog.string.internal.compareElements_ = function(left, right) {
  'use strict';
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};

//third_party/javascript/closure/labs/useragent/util.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities used by goog.labs.userAgent tools. These functions
 * should not be used outside of goog.labs.userAgent.*.
 *
 */

goog.provide('goog.labs.userAgent.util');

goog.require('goog.string.internal');


/**
 * Gets the native userAgent string from navigator if it exists.
 * If navigator or navigator.userAgent string is missing, returns an empty
 * string.
 * @return {string}
 * @private
 */
goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
  'use strict';
  var navigator = goog.labs.userAgent.util.getNavigator_();
  if (navigator) {
    var userAgent = navigator.userAgent;
    if (userAgent) {
      return userAgent;
    }
  }
  return '';
};


/**
 * Getter for the native navigator.
 * This is a separate function so it can be stubbed out in testing.
 * @return {!Navigator}
 * @private
 */
goog.labs.userAgent.util.getNavigator_ = function() {
  'use strict';
  return goog.global.navigator;
};


/**
 * A possible override for applications which wish to not check
 * navigator.userAgent but use a specified value for detection instead.
 * @private {string}
 */
goog.labs.userAgent.util.userAgent_ =
    goog.labs.userAgent.util.getNativeUserAgentString_();


/**
 * Applications may override browser detection on the built in
 * navigator.userAgent object by setting this string. Set to null to use the
 * browser object instead.
 * @param {?string=} opt_userAgent The User-Agent override.
 * @return {void}
 */
goog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {
  'use strict';
  goog.labs.userAgent.util.userAgent_ =
      opt_userAgent || goog.labs.userAgent.util.getNativeUserAgentString_();
};


/**
 * @return {string} The user agent string.
 */
goog.labs.userAgent.util.getUserAgent = function() {
  'use strict';
  return goog.labs.userAgent.util.userAgent_;
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string.
 */
goog.labs.userAgent.util.matchUserAgent = function(str) {
  'use strict';
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.internal.contains(userAgent, str);
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string, ignoring
 *     case.
 */
goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {
  'use strict';
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.internal.caseInsensitiveContains(userAgent, str);
};


/**
 * Parses the user agent into tuples for each section.
 * @param {string} userAgent
 * @return {!Array<!Array<string>>} Tuples of key, version, and the contents
 *     of the parenthetical.
 */
goog.labs.userAgent.util.extractVersionTuples = function(userAgent) {
  'use strict';
  // Matches each section of a user agent string.
  // Example UA:
  // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)
  // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405
  // This has three version tuples: Mozilla, AppleWebKit, and Mobile.

  var versionRegExp = new RegExp(
      // Key. Note that a key may have a space.
      // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')
      '(\\w[\\w ]+)' +

          '/' +                // slash
          '([^\\s]+)' +        // version (i.e. '5.0b')
          '\\s*' +             // whitespace
          '(?:\\((.*?)\\))?',  // parenthetical info. parentheses not matched.
      'g');

  var data = [];
  var match;

  // Iterate and collect the version tuples.  Each iteration will be the
  // next regex match.
  while (match = versionRegExp.exec(userAgent)) {
    data.push([
      match[1],  // key
      match[2],  // value
      // || undefined as this is not undefined in IE7 and IE8
      match[3] || undefined  // info
    ]);
  }

  return data;
};

//third_party/javascript/closure/object/object.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */
goog.module('goog.object');
goog.module.declareLegacyNamespace();

/**
 * Calls a function for each element in an object/map/hash.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):?} f The function to call for every
 *     element. This function takes 3 arguments (the value, the key and the
 *     object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {void}
 * @template T,K,V
 */
function forEach(obj, f, opt_obj) {
  for (const key in obj) {
    f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
  }
}

/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):boolean} f The function to call for
 *     every element. This function takes 3 arguments (the value, the key and
 *     the object) and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the element is not
 *     included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
function filter(obj, f, opt_obj) {
  const res = {};
  for (const key in obj) {
    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
}

/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 * @param {?Object<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,?Object<K,V>):R} f The function to call for every
 *     element. This function takes 3 arguments (the value, the key and the
 *     object) and should return something. The result will be inserted into a
 *     new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
function map(obj, f, opt_obj) {
  const res = {};
  for (const key in obj) {
    res[key] = f.call(/** @type {?} */ (opt_obj), obj[key], key, obj);
  }
  return res;
}

/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 * @param {?Object<K,V>} obj The object to check.
 * @param {function(this:T,V,?,?Object<K,V>):boolean} f The function to call for
 *     every element. This function takes 3 arguments (the value, the key and
 *     the object) and should return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
function some(obj, f, opt_obj) {
  for (const key in obj) {
    if (f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      return true;
    }
  }
  return false;
}

/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 * @param {?Object<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,?Object<K,V>):boolean} f The function to call
 *     for every element. This function takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
function every(obj, f, opt_obj) {
  for (const key in obj) {
    if (!f.call(/** @type {?} */ (opt_obj), obj[key], key, obj)) {
      return false;
    }
  }
  return true;
}

/**
 * Returns the number of key-value pairs in the object map.
 * @param {?Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
function getCount(obj) {
  let rv = 0;
  for (const key in obj) {
    rv++;
  }
  return rv;
}

/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 * @param {?Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
function getAnyKey(obj) {
  for (const key in obj) {
    return key;
  }
}

/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 * @param {?Object<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
function getAnyValue(obj) {
  for (const key in obj) {
    return obj[key];
  }
}

/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for containsValue(obj, val).
 * @param {?Object<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
function contains(obj, val) {
  return containsValue(obj, val);
}

/**
 * Returns the values of the object/map/hash.
 * @param {?Object<K,V>} obj The object from which to get the values.
 * @return {!Array<V>} The values in the object/map/hash.
 * @template K,V
 */
function getValues(obj) {
  const res = [];
  let i = 0;
  for (const key in obj) {
    res[i++] = obj[key];
  }
  return res;
}

/**
 * Returns the keys of the object/map/hash.
 * @param {?Object} obj The object from which to get the keys.
 * @return {!Array<string>} Array of property keys.
 */
function getKeys(obj) {
  const res = [];
  let i = 0;
  for (const key in obj) {
    res[i++] = key;
  }
  return res;
}

/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 * @param {?Object} obj An object to get the value from. Can be array-like.
 * @param {...(string|number|!IArrayLike<number|string>)} var_args A number of
 *     keys (as strings, or numbers, for array-like objects). Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value. If, at any point, the value for a key in the
 *     current object is null or undefined, returns undefined.
 */
function getValueByKeys(obj, var_args) {
  const isArrayLike = goog.isArrayLike(var_args);
  const keys = isArrayLike ?
      /** @type {!IArrayLike<number|string>} */ (var_args) :
      arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (let i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    if (obj == null) return undefined;
    obj = obj[keys[i]];
  }

  return obj;
}

/**
 * Whether the object/map/hash contains the given key.
 * @param {?Object} obj The object in which to look for key.
 * @param {?} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
function containsKey(obj, key) {
  return obj !== null && key in obj;
}

/**
 * Whether the object/map/hash contains the given value. This is O(n).
 * @param {?Object<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
function containsValue(obj, val) {
  for (const key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
}

/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {?Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,?Object<K,V>):boolean} f The function to
 *     call for every element. Takes 3 arguments (the value, the key and the
 *     object) and should return a boolean.
 * @param {T=} thisObj An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
function findKey(obj, f, thisObj = undefined) {
  for (const key in obj) {
    if (f.call(/** @type {?} */ (thisObj), obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
}

/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {?Object<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,?Object<K,V>):boolean} f The function to
 *     call for every element. Takes 3 arguments (the value, the key and the
 *     object) and should return a boolean.
 * @param {T=} thisObj An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
function findValue(obj, f, thisObj = undefined) {
  const key = findKey(obj, f, thisObj);
  return key && obj[key];
}

/**
 * Whether the object/map/hash is empty.
 * @param {?Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
function isEmpty(obj) {
  for (const key in obj) {
    return false;
  }
  return true;
}

/**
 * Removes all key value pairs from the object/map/hash.
 * @param {?Object} obj The object to clear.
 * @return {void}
 */
function clear(obj) {
  for (const i in obj) {
    delete obj[i];
  }
}

/**
 * Removes a key-value pair based on the key.
 * @param {?Object} obj The object from which to remove the key.
 * @param {?} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
function remove(obj, key) {
  let rv;
  if (rv = key in /** @type {!Object} */ (obj)) {
    delete obj[key];
  }
  return rv;
}

/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @return {void}
 * @template K,V
 */
function add(obj, key, val) {
  if (obj !== null && key in obj) {
    throw new Error(`The object already contains the key "${key}"`);
  }
  set(obj, key, val);
}

/**
 * Returns the value for the given key.
 * @param {?Object<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} val The value to return if no item is found for the given key
 *     (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
function get(obj, key, val = undefined) {
  if (obj !== null && key in obj) {
    return obj[key];
  }
  return val;
}

/**
 * Adds a key-value pair to the object/map/hash.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 * @return {void}
 */
function set(obj, key, value) {
  obj[key] = value;
}

/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
function setIfUndefined(obj, key, value) {
  return key in /** @type {!Object} */ (obj) ? obj[key] : (obj[key] = value);
}

/**
 * Sets a key and value to an object if the key is not set. The value will be
 * the return value of the given function. If the key already exists, the
 * object will not be changed and the function will not be called (the function
 * will be lazily evaluated -- only called if necessary).
 * This function is particularly useful when used with an `Object` which is
 * acting as a cache.
 * @param {?Object<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {function():V} f The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
function setWithReturnValueIfNotSet(obj, key, f) {
  if (key in obj) {
    return obj[key];
  }

  const val = f();
  obj[key] = val;
  return val;
}

/**
 * Compares two objects for equality using === on the values.
 * @param {!Object<K,V>} a
 * @param {!Object<K,V>} b
 * @return {boolean}
 * @template K,V
 */
function equals(a, b) {
  for (const k in a) {
    if (!(k in b) || a[k] !== b[k]) {
      return false;
    }
  }
  for (const k in b) {
    if (!(k in a)) {
      return false;
    }
  }
  return true;
}

/**
 * Returns a shallow clone of the object.
 * @param {?Object<K,V>} obj Object to clone.
 * @return {!Object<K,V>} Clone of the input object.
 * @template K,V
 */
function clone(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key];
  }
  return res;
}

/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 * WARNINGS:
 * <code>unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 * <code>unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 * @param {T} obj The value to clone.
 * @return {T} A clone of the input value.
 * @template T
 */
function unsafeClone(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  if (typeof obj.clone === 'function') return obj.clone();
  if (typeof Map !== 'undefined' && obj instanceof Map) {
    return new Map(obj);
  } else if (typeof Set !== 'undefined' && obj instanceof Set) {
    return new Set(obj);
  }
  const clone = Array.isArray(obj) ? [] :
      typeof ArrayBuffer === 'function' &&
          typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj) &&
          !(obj instanceof DataView) ?
                                     new obj.constructor(obj.length) :
                                     {};
  for (const key in obj) {
    clone[key] = unsafeClone(obj[key]);
  }
  return clone;
}

/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 * @param {?Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
function transpose(obj) {
  const transposed = {};
  for (const key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
}

/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 */
const PROTOTYPE_FIELDS = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf',
];

/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 * Example:
 * var o = {};
 * extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * extend(o, {b: 2, c: 3});
 * o; // {a: 0, b: 2, c: 3}
 * @param {?Object} target The object to modify. Existing properties will be
 *     overwritten if they are also present in one of the objects in `var_args`.
 * @param {...(?Object|undefined)} var_args The objects from which values
 *     will be copied.
 * @return {void}
 * @deprecated Prefer Object.assign
 */
function extend(target, var_args) {
  let key;
  let source;
  for (let i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (let j = 0; j < PROTOTYPE_FIELDS.length; j++) {
      key = PROTOTYPE_FIELDS[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
}

/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments, otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {!Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
function create(var_args) {
  const argLength = arguments.length;
  if (argLength == 1 && Array.isArray(arguments[0])) {
    return create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw new Error('Uneven number of arguments');
  }

  const rv = {};
  for (let i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
}

/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments, otherwise the arguments are used as
 *     the property names.
 * @return {!Object} The new object.
 */
function createSet(var_args) {
  const argLength = arguments.length;
  if (argLength == 1 && Array.isArray(arguments[0])) {
    return createSet.apply(null, arguments[0]);
  }

  const rv = {};
  for (let i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
}

/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 * @param {!Object<K,V>} obj An object.
 * @return {!Object<K,V>} An immutable view of that object, or the original
 *     object if this browser does not support immutables.
 * @template K,V
 */
function createImmutableView(obj) {
  let result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
}

/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
function isImmutableView(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
}

/**
 * Get all properties names on a given Object regardless of enumerability.
 * <p> If the browser does not support `Object.getOwnPropertyNames` nor
 * `Object.getPrototypeOf` then this is equivalent to using
 * `getKeys`
 * @param {?Object} obj The object to get the properties of.
 * @param {boolean=} includeObjectPrototype Whether properties defined on
 *     `Object.prototype` should be included in the result.
 * @param {boolean=} includeFunctionPrototype Whether properties defined on
 *     `Function.prototype` should be included in the result.
 * @return {!Array<string>}
 * @public
 */
function getAllPropertyNames(
    obj, includeObjectPrototype = undefined,
    includeFunctionPrototype = undefined) {
  if (!obj) {
    return [];
  }

  // Naively use a for..in loop to get the property names if the browser doesn't
  // support any other APIs for getting it.
  if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
    return getKeys(obj);
  }

  const visitedSet = {};

  // Traverse the prototype chain and add all properties to the visited set.
  let proto = obj;
  while (proto && (proto !== Object.prototype || !!includeObjectPrototype) &&
         (proto !== Function.prototype || !!includeFunctionPrototype)) {
    const names = Object.getOwnPropertyNames(proto);
    for (let i = 0; i < names.length; i++) {
      visitedSet[names[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return getKeys(visitedSet);
}

/**
 * Given a ES5 or ES6 class reference, return its super class / super
 * constructor.
 * This should be used in rare cases where you need to walk up the inheritance
 * tree (this is generally a bad idea). But this work with ES5 and ES6 classes,
 * unlike relying on the superClass_ property.
 * Note: To start walking up the hierarchy from an instance call this with its
 * `constructor` property; e.g. `getSuperClass(instance.constructor)`.
 * @param {function(new: ?)} constructor
 * @return {?Object}
 */
function getSuperClass(constructor) {
  const proto = Object.getPrototypeOf(constructor.prototype);
  return proto && proto.constructor;
}

exports = {
  add,
  clear,
  clone,
  contains,
  containsKey,
  containsValue,
  create,
  createImmutableView,
  createSet,
  equals,
  every,
  extend,
  filter,
  findKey,
  findValue,
  forEach,
  get,
  getAllPropertyNames,
  getAnyKey,
  getAnyValue,
  getCount,
  getKeys,
  getSuperClass,
  getValueByKeys,
  getValues,
  isEmpty,
  isImmutableView,
  map,
  remove,
  set,
  setIfUndefined,
  setWithReturnValueIfNotSet,
  some,
  transpose,
  unsafeClone,
};

;return exports;});

//third_party/javascript/closure/labs/useragent/browser.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Closure user agent detection (Browser).
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on rendering engine, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,
 * goog.labs.userAgent.device respectively.)
 */

goog.provide('goog.labs.userAgent.browser');

goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.object');
goog.require('goog.string.internal');


// TODO(nnaze): Refactor to remove excessive exclusion logic in matching
// functions.


/**
 * @return {boolean} Whether the user's browser is Opera.  Note: Chromium
 *     based Opera (Opera 15+) is detected as Chrome to avoid unnecessary
 *     special casing.
 * @private
 */
goog.labs.userAgent.browser.matchOpera_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Opera');
};


/**
 * @return {boolean} Whether the user's browser is IE.
 * @private
 */
goog.labs.userAgent.browser.matchIE_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the user's browser is Edge. This refers to EdgeHTML
 * based Edge.
 * @private
 */
goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Edge');
};


/**
 * @return {boolean} Whether the user's browser is Chromium based Edge.
 * @private
 */
goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Edg/');
};


/**
 * @return {boolean} Whether the user's browser is Chromium based Opera.
 * @private
 */
goog.labs.userAgent.browser.matchOperaChromium_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('OPR');
};


/**
 * @return {boolean} Whether the user's browser is Firefox.
 * @private
 */
goog.labs.userAgent.browser.matchFirefox_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Firefox') ||
      goog.labs.userAgent.util.matchUserAgent('FxiOS');
};


/**
 * @return {boolean} Whether the user's browser is Safari.
 * @private
 */
goog.labs.userAgent.browser.matchSafari_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Safari') &&
      !(goog.labs.userAgent.browser.matchChrome_() ||
        goog.labs.userAgent.browser.matchCoast_() ||
        goog.labs.userAgent.browser.matchOpera_() ||
        goog.labs.userAgent.browser.matchEdgeHtml_() ||
        goog.labs.userAgent.browser.matchEdgeChromium_() ||
        goog.labs.userAgent.browser.matchOperaChromium_() ||
        goog.labs.userAgent.browser.matchFirefox_() ||
        goog.labs.userAgent.browser.isSilk() ||
        goog.labs.userAgent.util.matchUserAgent('Android'));
};


/**
 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
 *     iOS browser).
 * @private
 */
goog.labs.userAgent.browser.matchCoast_ = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Coast');
};


/**
 * @return {boolean} Whether the user's browser is iOS Webview.
 * @private
 */
goog.labs.userAgent.browser.matchIosWebview_ = function() {
  'use strict';
  // iOS Webview does not show up as Chrome or Safari. Also check for Opera's
  // WebKit-based iOS browser, Coast.
  return (goog.labs.userAgent.util.matchUserAgent('iPad') ||
          goog.labs.userAgent.util.matchUserAgent('iPhone')) &&
      !goog.labs.userAgent.browser.matchSafari_() &&
      !goog.labs.userAgent.browser.matchChrome_() &&
      !goog.labs.userAgent.browser.matchCoast_() &&
      !goog.labs.userAgent.browser.matchFirefox_() &&
      goog.labs.userAgent.util.matchUserAgent('AppleWebKit');
};


/**
 * @return {boolean} Whether the user's browser is any Chromium browser. This
 * returns true for Chrome, Opera 15+, and Edge Chromium.
 * @private
 */
goog.labs.userAgent.browser.matchChrome_ = function() {
  'use strict';
  return (goog.labs.userAgent.util.matchUserAgent('Chrome') ||
          goog.labs.userAgent.util.matchUserAgent('CriOS')) &&
      !goog.labs.userAgent.browser.matchEdgeHtml_();
};


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 * @private
 */
goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
  'use strict';
  // Android can appear in the user agent string for Chrome on Android.
  // This is not the Android standalone browser if it does.
  return goog.labs.userAgent.util.matchUserAgent('Android') &&
      !(goog.labs.userAgent.browser.isChrome() ||
        goog.labs.userAgent.browser.isFirefox() ||
        goog.labs.userAgent.browser.isOpera() ||
        goog.labs.userAgent.browser.isSilk());
};


/**
 * @return {boolean} Whether the user's browser is Opera.
 */
goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;


/**
 * @return {boolean} Whether the user's browser is IE.
 */
goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;


/**
 * @return {boolean} Whether the user's browser is EdgeHTML based Edge.
 */
goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_;


/**
 * @return {boolean} Whether the user's browser is Chromium based Edge.
 */
goog.labs.userAgent.browser.isEdgeChromium =
    goog.labs.userAgent.browser.matchEdgeChromium_;

/**
 * @return {boolean} Whether the user's browser is Chromium based Opera.
 */
goog.labs.userAgent.browser.isOperaChromium =
    goog.labs.userAgent.browser.matchOperaChromium_;

/**
 * @return {boolean} Whether the user's browser is Firefox.
 */
goog.labs.userAgent.browser.isFirefox =
    goog.labs.userAgent.browser.matchFirefox_;


/**
 * @return {boolean} Whether the user's browser is Safari.
 */
goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;


/**
 * @return {boolean} Whether the user's browser is Coast (Opera's Webkit-based
 *     iOS browser).
 */
goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;


/**
 * @return {boolean} Whether the user's browser is iOS Webview.
 */
goog.labs.userAgent.browser.isIosWebview =
    goog.labs.userAgent.browser.matchIosWebview_;


/**
 * @return {boolean} Whether the user's browser is any Chromium based browser (
 * Chrome, Blink-based Opera (15+) and Edge Chromium).
 */
goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 */
goog.labs.userAgent.browser.isAndroidBrowser =
    goog.labs.userAgent.browser.matchAndroidBrowser_;


/**
 * For more information, see:
 * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html
 * @return {boolean} Whether the user's browser is Silk.
 */
goog.labs.userAgent.browser.isSilk = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Silk');
};


/**
 * @return {string} The browser version or empty string if version cannot be
 *     determined. Note that for Internet Explorer, this returns the version of
 *     the browser, not the version of the rendering engine. (IE 8 in
 *     compatibility mode will return 8.0 rather than 7.0. To determine the
 *     rendering engine version, look at document.documentMode instead. See
 *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more
 *     details.)
 */
goog.labs.userAgent.browser.getVersion = function() {
  'use strict';
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  // Special case IE since IE's version is inside the parenthesis and
  // without the '/'.
  if (goog.labs.userAgent.browser.isIE()) {
    return goog.labs.userAgent.browser.getIEVersion_(userAgentString);
  }

  var versionTuples =
      goog.labs.userAgent.util.extractVersionTuples(userAgentString);

  // Construct a map for easy lookup.
  var versionMap = {};
  versionTuples.forEach(function(tuple) {
    'use strict';
    // Note that the tuple is of length three, but we only care about the
    // first two.
    var key = tuple[0];
    var value = tuple[1];
    versionMap[key] = value;
  });

  var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);

  // Gives the value with the first key it finds, otherwise empty string.
  function lookUpValueWithKeys(keys) {
    var key = goog.array.find(keys, versionMapHasKey);
    return versionMap[key] || '';
  }

  // Check Opera before Chrome since Opera 15+ has "Chrome" in the string.
  // See
  // http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond
  if (goog.labs.userAgent.browser.isOpera()) {
    // Opera 10 has Version/10.0 but Opera/9.8, so look for "Version" first.
    // Opera uses 'OPR' for more recent UAs.
    return lookUpValueWithKeys(['Version', 'Opera']);
  }

  // Check Edge before Chrome since it has Chrome in the string.
  if (goog.labs.userAgent.browser.isEdge()) {
    return lookUpValueWithKeys(['Edge']);
  }

  // Check Chromium Edge before Chrome since it has Chrome in the string.
  if (goog.labs.userAgent.browser.isEdgeChromium()) {
    return lookUpValueWithKeys(['Edg']);
  }

  if (goog.labs.userAgent.browser.isChrome()) {
    return lookUpValueWithKeys(['Chrome', 'CriOS', 'HeadlessChrome']);
  }

  // Usually products browser versions are in the third tuple after "Mozilla"
  // and the engine.
  var tuple = versionTuples[2];
  return tuple && tuple[1] || '';
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the browser version is higher or the same as the
 *     given version.
 */
goog.labs.userAgent.browser.isVersionOrHigher = function(version) {
  'use strict';
  return goog.string.internal.compareVersions(
             goog.labs.userAgent.browser.getVersion(), version) >= 0;
};


/**
 * Determines IE version. More information:
 * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString
 * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
 * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
 * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
 *
 * @param {string} userAgent the User-Agent.
 * @return {string}
 * @private
 */
goog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {
  'use strict';
  // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade
  // bug. Example UA:
  // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)
  // like Gecko.
  // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.
  var rv = /rv: *([\d\.]*)/.exec(userAgent);
  if (rv && rv[1]) {
    return rv[1];
  }

  var version = '';
  var msie = /MSIE +([\d\.]+)/.exec(userAgent);
  if (msie && msie[1]) {
    // IE in compatibility mode usually identifies itself as MSIE 7.0; in this
    // case, use the Trident version to determine the version of IE. For more
    // details, see the links above.
    var tridentVersion = /Trident\/(\d.\d)/.exec(userAgent);
    if (msie[1] == '7.0') {
      if (tridentVersion && tridentVersion[1]) {
        switch (tridentVersion[1]) {
          case '4.0':
            version = '8.0';
            break;
          case '5.0':
            version = '9.0';
            break;
          case '6.0':
            version = '10.0';
            break;
          case '7.0':
            version = '11.0';
            break;
        }
      } else {
        version = '7.0';
      }
    } else {
      version = msie[1];
    }
  }
  return version;
};

//third_party/javascript/closure/dom/asserts.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.dom.asserts');

goog.require('goog.asserts');

/**
 * @fileoverview Custom assertions to ensure that an element has the appropriate
 * type.
 *
 * Using a goog.dom.safe wrapper on an object on the incorrect type (via an
 * incorrect static type cast) can result in security bugs: For instance,
 * g.d.s.setAnchorHref ensures that the URL assigned to the .href attribute
 * satisfies the SafeUrl contract, i.e., is safe to dereference as a hyperlink.
 * However, the value assigned to a HTMLLinkElement's .href property requires
 * the stronger TrustedResourceUrl contract, since it can refer to a stylesheet.
 * Thus, using g.d.s.setAnchorHref on an (incorrectly statically typed) object
 * of type HTMLLinkElement can result in a security vulnerability.
 * Assertions of the correct run-time type help prevent such incorrect use.
 *
 * In some cases, code using the DOM API is tested using mock objects (e.g., a
 * plain object such as {'href': url} instead of an actual Location object).
 * To allow such mocking, the assertions permit objects of types that are not
 * relevant DOM API objects at all (for instance, not Element or Location).
 *
 * Note that instanceof checks don't work straightforwardly in older versions of
 * IE, or across frames (see,
 * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object,
 * http://stackoverflow.com/questions/26248599/instanceof-htmlelement-in-iframe-is-not-element-or-object).
 *
 * Hence, these assertions may pass vacuously in such scenarios. The resulting
 * risk of security bugs is limited by the following factors:
 *  - A bug can only arise in scenarios involving incorrect static typing (the
 *    wrapper methods are statically typed to demand objects of the appropriate,
 *    precise type).
 *  - Typically, code is tested and exercised in multiple browsers.
 */

/**
 * Asserts that a given object is a Location.
 *
 * To permit this assertion to pass in the context of tests where DOM APIs might
 * be mocked, also accepts any other type except for subtypes of {!Element}.
 * This is to ensure that, for instance, HTMLLinkElement is not being used in
 * place of a Location, since this could result in security bugs due to stronger
 * contracts required for assignments to the href property of the latter.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!Location}
 */
goog.dom.asserts.assertIsLocation = function(o) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    var win = goog.dom.asserts.getWindow_(o);
    if (win) {
      if (!o || (!(o instanceof win.Location) && o instanceof win.Element)) {
        goog.asserts.fail(
            'Argument is not a Location (or a non-Element mock); got: %s',
            goog.dom.asserts.debugStringForType_(o));
      }
    }
  }
  return /** @type {!Location} */ (o);
};


/**
 * Asserts that a given object is either the given subtype of Element
 * or a non-Element, non-Location Mock.
 *
 * To permit this assertion to pass in the context of tests where DOM
 * APIs might be mocked, also accepts any other type except for
 * subtypes of {!Element}.  This is to ensure that, for instance,
 * HTMLScriptElement is not being used in place of a HTMLImageElement,
 * since this could result in security bugs due to stronger contracts
 * required for assignments to the src property of the latter.
 *
 * The DOM type is looked up in the window the object belongs to.  In
 * some contexts, this might not be possible (e.g. when running tests
 * outside a browser, cross-domain lookup). In this case, the
 * assertions are skipped.
 *
 * @param {?Object} o The object whose type to assert.
 * @param {string} typename The name of the DOM type.
 * @return {!Element} The object.
 * @private
 */
// TODO(bangert): Make an analog of goog.dom.TagName to correctly handle casts?
goog.dom.asserts.assertIsElementType_ = function(o, typename) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    var win = goog.dom.asserts.getWindow_(o);
    if (win && typeof win[typename] != 'undefined') {
      if (!o ||
          (!(o instanceof win[typename]) &&
           (o instanceof win.Location || o instanceof win.Element))) {
        goog.asserts.fail(
            'Argument is not a %s (or a non-Element, non-Location mock); ' +
                'got: %s',
            typename, goog.dom.asserts.debugStringForType_(o));
      }
    }
  }
  return /** @type {!Element} */ (o);
};

/**
 * Asserts that a given object is a HTMLAnchorElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not of type Location nor a subtype
 * of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLAnchorElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlAnchorElement instead.
 */
goog.dom.asserts.assertIsHTMLAnchorElement = function(o) {
  'use strict';
  return /** @type {!HTMLAnchorElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLAnchorElement'));
};

/**
 * Asserts that a given object is a HTMLButtonElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLButtonElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlButtonElement instead.
 */
goog.dom.asserts.assertIsHTMLButtonElement = function(o) {
  'use strict';
  return /** @type {!HTMLButtonElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLButtonElement'));
};

/**
 * Asserts that a given object is a HTMLLinkElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLLinkElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlLinkElement instead.
 */
goog.dom.asserts.assertIsHTMLLinkElement = function(o) {
  'use strict';
  return /** @type {!HTMLLinkElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLLinkElement'));
};

/**
 * Asserts that a given object is a HTMLImageElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLImageElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlImageElement instead.
 */
goog.dom.asserts.assertIsHTMLImageElement = function(o) {
  'use strict';
  return /** @type {!HTMLImageElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLImageElement'));
};

/**
 * Asserts that a given object is a HTMLAudioElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLAudioElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlAudioElement instead.
 */
goog.dom.asserts.assertIsHTMLAudioElement = function(o) {
  'use strict';
  return /** @type {!HTMLAudioElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLAudioElement'));
};

/**
 * Asserts that a given object is a HTMLVideoElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLVideoElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlVideoElement instead.
 */
goog.dom.asserts.assertIsHTMLVideoElement = function(o) {
  'use strict';
  return /** @type {!HTMLVideoElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLVideoElement'));
};

/**
 * Asserts that a given object is a HTMLInputElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLInputElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlInputElement instead.
 */
goog.dom.asserts.assertIsHTMLInputElement = function(o) {
  'use strict';
  return /** @type {!HTMLInputElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLInputElement'));
};

/**
 * Asserts that a given object is a HTMLTextAreaElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLTextAreaElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlTextAreaElement instead.
 */
goog.dom.asserts.assertIsHTMLTextAreaElement = function(o) {
  'use strict';
  return /** @type {!HTMLTextAreaElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLTextAreaElement'));
};

/**
 * Asserts that a given object is a HTMLCanvasElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLCanvasElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlCanvasElement instead.
 */
goog.dom.asserts.assertIsHTMLCanvasElement = function(o) {
  'use strict';
  return /** @type {!HTMLCanvasElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLCanvasElement'));
};

/**
 * Asserts that a given object is a HTMLEmbedElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLEmbedElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlEmbedElement instead.
 */
goog.dom.asserts.assertIsHTMLEmbedElement = function(o) {
  'use strict';
  return /** @type {!HTMLEmbedElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLEmbedElement'));
};

/**
 * Asserts that a given object is a HTMLFormElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLFormElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlFormElement instead.
 */
goog.dom.asserts.assertIsHTMLFormElement = function(o) {
  'use strict';
  return /** @type {!HTMLFormElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLFormElement'));
};

/**
 * Asserts that a given object is a HTMLFrameElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLFrameElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlFrameElement instead.
 */
goog.dom.asserts.assertIsHTMLFrameElement = function(o) {
  'use strict';
  return /** @type {!HTMLFrameElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLFrameElement'));
};

/**
 * Asserts that a given object is a HTMLIFrameElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLIFrameElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlIFrameElement instead.
 */
goog.dom.asserts.assertIsHTMLIFrameElement = function(o) {
  'use strict';
  return /** @type {!HTMLIFrameElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLIFrameElement'));
};

/**
 * Asserts that a given object is a HTMLObjectElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLObjectElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlObjectElement instead.
 */
goog.dom.asserts.assertIsHTMLObjectElement = function(o) {
  'use strict';
  return /** @type {!HTMLObjectElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLObjectElement'));
};

/**
 * Asserts that a given object is a HTMLScriptElement.
 *
 * To permit this assertion to pass in the context of tests where elements might
 * be mocked, also accepts objects that are not a subtype of Element.
 *
 * @param {?Object} o The object whose type to assert.
 * @return {!HTMLScriptElement}
 * @deprecated Use goog.asserts.dom.assertIsHtmlScriptElement instead.
 */
goog.dom.asserts.assertIsHTMLScriptElement = function(o) {
  'use strict';
  return /** @type {!HTMLScriptElement} */ (
      goog.dom.asserts.assertIsElementType_(o, 'HTMLScriptElement'));
};

/**
 * Returns a string representation of a value's type.
 *
 * @param {*} value An object, or primitive.
 * @return {string} The best display name for the value.
 * @private
 */
goog.dom.asserts.debugStringForType_ = function(value) {
  'use strict';
  if (goog.isObject(value)) {
    try {
      return /** @type {string|undefined} */ (value.constructor.displayName) ||
          value.constructor.name || Object.prototype.toString.call(value);
    } catch (e) {
      return '<object could not be stringified>';
    }
  } else {
    return value === undefined ? 'undefined' :
                                 value === null ? 'null' : typeof value;
  }
};

/**
 * Gets window of element.
 * @param {?Object} o
 * @return {?Window}
 * @private
 * @suppress {strictMissingProperties} ownerDocument not defined on Object
 */
goog.dom.asserts.getWindow_ = function(o) {
  'use strict';
  try {
    var doc = o && o.ownerDocument;
    // This can throw “Blocked a frame with origin "chrome-extension://..." from
    // accessing a cross-origin frame” in Chrome extension.
    // MOE:begin_strip See
    // http://yaqs/6574360854528000#a6424563401097216.
    // MOE:end_strip
    var win =
        doc && /** @type {?Window} */ (doc.defaultView || doc.parentWindow);
    win = win || /** @type {!Window} */ (goog.global);
    // This can throw “Permission denied to access property "Element" on
    // cross-origin object”.
    if (win.Element && win.Location) {
      return win;
    }
  } catch (ex) {
  }
  return null;
};

//third_party/javascript/closure/functions/functions.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for creating functions. Loosely inspired by these
 * java classes from the Guava library:
 * com.google.common.base.Functions
 * https://google.github.io/guava/releases/snapshot-jre/api/docs/index.html?com/google/common/base/Functions.html
 *
 * com.google.common.base.Predicates
 * https://google.github.io/guava/releases/snapshot-jre/api/docs/index.html?com/google/common/base/Predicates.html
 *
 * More about these can be found at
 * https://github.com/google/guava/wiki/FunctionalExplained
 */


goog.provide('goog.functions');


/**
 * Creates a function that always returns the same value.
 * @param {T} retValue The value to return.
 * @return {function():T} The new function.
 * @template T
 */
goog.functions.constant = function(retValue) {
  'use strict';
  return function() {
    'use strict';
    return retValue;
  };
};


/**
 * Always returns false.
 * @type {function(...): boolean}
 */
goog.functions.FALSE = function() {
  'use strict';
  return false;
};


/**
 * Always returns true.
 * @type {function(...): boolean}
 */
goog.functions.TRUE = function() {
  'use strict';
  return true;
};


/**
 * Always returns `null`.
 * @type {function(...): null}
 */
goog.functions.NULL = function() {
  'use strict';
  return null;
};


/**
 * Always returns `undefined`.
 * @type {function(...): undefined}
 */
goog.functions.UNDEFINED = function() {
  return undefined;
};

/**
 * Always returns `undefined` (loosely-typed version).
 * @type {!Function}
 */
goog.functions.EMPTY = /** @type {?} */ (goog.functions.UNDEFINED);


/**
 * A simple function that returns the first argument of whatever is passed
 * into it.
 * @param {T=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {T} The first argument passed in, or undefined if nothing was passed.
 * @template T
 */
goog.functions.identity = function(opt_returnValue, var_args) {
  'use strict';
  return opt_returnValue;
};


/**
 * Creates a function that always throws an error with the given message.
 * @param {string} message The error message.
 * @return {!Function} The error-throwing function.
 */
goog.functions.error = function(message) {
  'use strict';
  return function() {
    'use strict';
    throw new Error(message);
  };
};


/**
 * Creates a function that throws the given object.
 * @param {*} err An object to be thrown.
 * @return {!Function} The error-throwing function.
 */
goog.functions.fail = function(err) {
  'use strict';
  return function() {
    'use strict';
    throw err;
  };
};


/**
 * Given a function, create a function that keeps opt_numArgs arguments and
 * silently discards all additional arguments.
 * @param {Function} f The original function.
 * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
 * @return {!Function} A version of f that only keeps the first opt_numArgs
 *     arguments.
 */
goog.functions.lock = function(f, opt_numArgs) {
  'use strict';
  opt_numArgs = opt_numArgs || 0;
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    return f.apply(self, Array.prototype.slice.call(arguments, 0, opt_numArgs));
  };
};


/**
 * Creates a function that returns its nth argument.
 * @param {number} n The position of the return argument.
 * @return {!Function} A new function.
 */
goog.functions.nth = function(n) {
  'use strict';
  return function() {
    'use strict';
    return arguments[n];
  };
};


/**
 * Like goog.partial(), except that arguments are added after arguments to the
 * returned function.
 *
 * Usage:
 * function f(arg1, arg2, arg3, arg4) { ... }
 * var g = goog.functions.partialRight(f, arg3, arg4);
 * g(arg1, arg2);
 *
 * @param {!Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn
 *     at the end.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */
goog.functions.partialRight = function(fn, var_args) {
  'use strict';
  const rightArgs = Array.prototype.slice.call(arguments, 1);
  return function() {
    'use strict';
    // Even in strict mode, IE10/11 and Edge (non-Chromium) use global context
    // when free-calling functions. To catch cases where people were using this
    // erroneously, we explicitly change the context to undefined to match
    // strict mode specifications.
    let self = /** @type {*} */ (this);
    if (self === goog.global) {
      self = undefined;
    }
    const newArgs = Array.prototype.slice.call(arguments);
    newArgs.push.apply(newArgs, rightArgs);
    return fn.apply(self, newArgs);
  };
};


/**
 * Given a function, create a new function that swallows its return value
 * and replaces it with a new one.
 * @param {Function} f A function.
 * @param {T} retValue A new return value.
 * @return {function(...?):T} A new function.
 * @template T
 */
goog.functions.withReturnValue = function(f, retValue) {
  'use strict';
  return goog.functions.sequence(f, goog.functions.constant(retValue));
};


/**
 * Creates a function that returns whether its argument equals the given value.
 *
 * Example:
 * var key = goog.object.findKey(obj, goog.functions.equalTo('needle'));
 *
 * @param {*} value The value to compare to.
 * @param {boolean=} opt_useLooseComparison Whether to use a loose (==)
 *     comparison rather than a strict (===) one. Defaults to false.
 * @return {function(*):boolean} The new function.
 */
goog.functions.equalTo = function(value, opt_useLooseComparison) {
  'use strict';
  return function(other) {
    'use strict';
    return opt_useLooseComparison ? (value == other) : (value === other);
  };
};


/**
 * Creates the composition of the functions passed in.
 * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
 * @param {function(...?):T} fn The final function.
 * @param {...Function} var_args A list of functions.
 * @return {function(...?):T} The composition of all inputs.
 * @template T
 */
goog.functions.compose = function(fn, var_args) {
  'use strict';
  const functions = arguments;
  const length = functions.length;
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    let result;
    if (length) {
      result = functions[length - 1].apply(self, arguments);
    }

    for (let i = length - 2; i >= 0; i--) {
      result = functions[i].call(self, result);
    }
    return result;
  };
};


/**
 * Creates a function that calls the functions passed in in sequence, and
 * returns the value of the last function. For example,
 * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
 * @param {...Function} var_args A list of functions.
 * @return {!Function} A function that calls all inputs in sequence.
 */
goog.functions.sequence = function(var_args) {
  'use strict';
  const functions = arguments;
  const length = functions.length;
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    let result;
    for (let i = 0; i < length; i++) {
      result = functions[i].apply(self, arguments);
    }
    return result;
  };
};


/**
 * Creates a function that returns true if each of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns false.
 * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...?):boolean} A function that ANDs its component
 *      functions.
 */
goog.functions.and = function(var_args) {
  'use strict';
  const functions = arguments;
  const length = functions.length;
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    for (let i = 0; i < length; i++) {
      if (!functions[i].apply(self, arguments)) {
        return false;
      }
    }
    return true;
  };
};


/**
 * Creates a function that returns true if any of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns true.
 * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...?):boolean} A function that ORs its component
 *    functions.
 */
goog.functions.or = function(var_args) {
  'use strict';
  const functions = arguments;
  const length = functions.length;
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    for (let i = 0; i < length; i++) {
      if (functions[i].apply(self, arguments)) {
        return true;
      }
    }
    return false;
  };
};


/**
 * Creates a function that returns the Boolean opposite of a provided function.
 * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
 * @param {!Function} f The original function.
 * @return {function(...?):boolean} A function that delegates to f and returns
 * opposite.
 */
goog.functions.not = function(f) {
  'use strict';
  return function() {
    'use strict';
    const self = /** @type {*} */ (this);
    return !f.apply(self, arguments);
  };
};


/**
 * Generic factory function to construct an object given the constructor
 * and the arguments. Intended to be bound to create object factories.
 *
 * Example:
 *
 * var factory = goog.partial(goog.functions.create, Class);
 *
 * @param {function(new:T, ...)} constructor The constructor for the Object.
 * @param {...*} var_args The arguments to be passed to the constructor.
 * @return {T} A new instance of the class given in `constructor`.
 * @template T
 * @deprecated This function does not work with ES6 class constructors. Use
 *     arrow functions + spread args instead.
 */
goog.functions.create = function(constructor, var_args) {
  'use strict';
  /**
   * @constructor
   * @final
   */
  const temp = function() {};
  temp.prototype = constructor.prototype;

  // obj will have constructor's prototype in its chain and
  // 'obj instanceof constructor' will be true.
  const obj = new temp();

  // obj is initialized by constructor.
  // arguments is only array-like so lacks shift(), but can be used with
  // the Array prototype function.
  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
  return obj;
};


/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.functions.CACHE_RETURN_VALUE =
    goog.define('goog.functions.CACHE_RETURN_VALUE', true);


/**
 * Gives a wrapper function that caches the return value of a parameterless
 * function when first called.
 *
 * When called for the first time, the given function is called and its
 * return value is cached (thus this is only appropriate for idempotent
 * functions).  Subsequent calls will return the cached return value. This
 * allows the evaluation of expensive functions to be delayed until first used.
 *
 * To cache the return values of functions with parameters, see goog.memoize.
 *
 * @param {function():T} fn A function to lazily evaluate.
 * @return {function():T} A wrapped version the function.
 * @template T
 */
goog.functions.cacheReturnValue = function(fn) {
  'use strict';
  let called = false;
  let value;

  return function() {
    'use strict';
    if (!goog.functions.CACHE_RETURN_VALUE) {
      return fn();
    }

    if (!called) {
      value = fn();
      called = true;
    }

    return value;
  };
};


/**
 * Wraps a function to allow it to be called, at most, once. All
 * additional calls are no-ops.
 *
 * This is particularly useful for initialization functions
 * that should be called, at most, once.
 *
 * @param {function():*} f Function to call.
 * @return {function():undefined} Wrapped function.
 */
goog.functions.once = function(f) {
  'use strict';
  // Keep a reference to the function that we null out when we're done with
  // it -- that way, the function can be GC'd when we're done with it.
  let inner = f;
  return function() {
    'use strict';
    if (inner) {
      const tmp = inner;
      inner = null;
      tmp();
    }
  };
};


/**
 * Wraps a function to allow it to be called, at most, once per interval
 * (specified in milliseconds). If the wrapper function is called N times within
 * that interval, only the Nth call will go through.
 *
 * This is particularly useful for batching up repeated actions where the
 * last action should win. This can be used, for example, for refreshing an
 * autocomplete pop-up every so often rather than updating with every keystroke,
 * since the final text typed by the user is the one that should produce the
 * final autocomplete results. For more stateful debouncing with support for
 * pausing, resuming, and canceling debounced actions, use
 * `goog.async.Debouncer`.
 *
 * @param {function(this:SCOPE, ...?)} f Function to call.
 * @param {number} interval Interval over which to debounce. The function will
 *     only be called after the full interval has elapsed since the last call.
 * @param {SCOPE=} opt_scope Object in whose scope to call the function.
 * @return {function(...?): undefined} Wrapped function.
 * @template SCOPE
 */
goog.functions.debounce = function(f, interval, opt_scope) {
  'use strict';
  let timeout = 0;
  return /** @type {function(...?)} */ (function(var_args) {
    'use strict';
    goog.global.clearTimeout(timeout);
    const args = arguments;
    timeout = goog.global.setTimeout(function() {
      'use strict';
      f.apply(opt_scope, args);
    }, interval);
  });
};


/**
 * Wraps a function to allow it to be called, at most, once per interval
 * (specified in milliseconds). If the wrapper function is called N times in
 * that interval, both the 1st and the Nth calls will go through.
 *
 * This is particularly useful for limiting repeated user requests where the
 * the last action should win, but you also don't want to wait until the end of
 * the interval before sending a request out, as it leads to a perception of
 * slowness for the user.
 *
 * @param {function(this:SCOPE, ...?)} f Function to call.
 * @param {number} interval Interval over which to throttle. The function can
 *     only be called once per interval.
 * @param {SCOPE=} opt_scope Object in whose scope to call the function.
 * @return {function(...?): undefined} Wrapped function.
 * @template SCOPE
 */
goog.functions.throttle = function(f, interval, opt_scope) {
  'use strict';
  let timeout = 0;
  let shouldFire = false;
  let storedArgs = [];

  const handleTimeout = function() {
    'use strict';
    timeout = 0;
    if (shouldFire) {
      shouldFire = false;
      fire();
    }
  };

  const fire = function() {
    'use strict';
    timeout = goog.global.setTimeout(handleTimeout, interval);
    let args = storedArgs;
    storedArgs = [];  // Avoid a space leak by clearing stored arguments.
    f.apply(opt_scope, args);
  };

  return /** @type {function(...?)} */ (function(var_args) {
    'use strict';
    storedArgs = arguments;
    if (!timeout) {
      fire();
    } else {
      shouldFire = true;
    }
  });
};


/**
 * Wraps a function to allow it to be called, at most, once per interval
 * (specified in milliseconds). If the wrapper function is called N times within
 * that interval, only the 1st call will go through.
 *
 * This is particularly useful for limiting repeated user requests where the
 * first request is guaranteed to have all the data required to perform the
 * final action, so there's no need to wait until the end of the interval before
 * sending the request out.
 *
 * @param {function(this:SCOPE, ...?)} f Function to call.
 * @param {number} interval Interval over which to rate-limit. The function will
 *     only be called once per interval, and ignored for the remainer of the
 *     interval.
 * @param {SCOPE=} opt_scope Object in whose scope to call the function.
 * @return {function(...?): undefined} Wrapped function.
 * @template SCOPE
 */
goog.functions.rateLimit = function(f, interval, opt_scope) {
  'use strict';
  let timeout = 0;

  const handleTimeout = function() {
    'use strict';
    timeout = 0;
  };

  return /** @type {function(...?)} */ (function(var_args) {
    'use strict';
    if (!timeout) {
      timeout = goog.global.setTimeout(handleTimeout, interval);
      f.apply(opt_scope, arguments);
    }
  });
};

/**
 * Returns true if the specified value is a function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.functions.isFunction = (val) => {
  return typeof val === 'function';
};

//third_party/javascript/closure/dom/htmlelement.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.dom.HtmlElement');



/**
 * This subclass of HTMLElement is used when only a HTMLElement is possible and
 * not any of its subclasses. Normally, a type can refer to an instance of
 * itself or an instance of any subtype. More concretely, if HTMLElement is used
 * then the compiler must assume that it might still be e.g. HTMLScriptElement.
 * With this, the type check knows that it couldn't be any special element.
 *
 * @constructor
 * @extends {HTMLElement}
 */
goog.dom.HtmlElement = function() {};

//third_party/javascript/closure/dom/tagname.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines the goog.dom.TagName class. Its constants enumerate
 * all HTML tag names specified in either the W3C HTML 4.01 index of elements
 * or the HTML5.1 specification.
 *
 * References:
 * https://www.w3.org/TR/html401/index/elements.html
 * https://www.w3.org/TR/html51/dom.html#elements
 */
goog.provide('goog.dom.TagName');

goog.require('goog.dom.HtmlElement');

/**
 * A tag name for an HTML element.
 *
 * This type is a lie. All instances are actually strings. Do not implement it.
 *
 * It exists because we need an object type to host the template type parameter,
 * and that's not possible with literal or enum types. It is a record type so
 * that runtime type checks don't try to validate the lie.
 *
 * @template T
 * @record
 */
goog.dom.TagName = class {
  /**
   * Cast a string into the tagname for the associated constructor.
   *
   * @template T
   * @param {string} name
   * @param {function(new:T, ...?)} type
   * @return {!goog.dom.TagName<T>}
   */
  static cast(name, type) {
    return /** @type {?} */ (name);
  }

  /** @suppress {unusedPrivateMembers} */
  constructor() {
    /** @private {null} */
    this.googDomTagName_doNotImplementThisTypeOrElse_;

    /** @private {T} */
    this.ensureTypeScriptRemembersTypeT_;
  }

  /**
   * Appease the compiler that instances are stringafiable for the
   * purpose of being a dictionary key.
   *
   * Never implemented; always backed by `String::toString`.
   *
   * @override
   * @return {string}
   */
  toString() {}
};



/** @const {!goog.dom.TagName<!HTMLAnchorElement>} */
goog.dom.TagName.A = /** @type {?} */ ('A');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ABBR = /** @type {?} */ ('ABBR');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ACRONYM = /** @type {?} */ ('ACRONYM');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ADDRESS = /** @type {?} */ ('ADDRESS');

/** @const {!goog.dom.TagName<!HTMLAppletElement>} */
goog.dom.TagName.APPLET = /** @type {?} */ ('APPLET');

/** @const {!goog.dom.TagName<!HTMLAreaElement>} */
goog.dom.TagName.AREA = /** @type {?} */ ('AREA');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ARTICLE = /** @type {?} */ ('ARTICLE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.ASIDE = /** @type {?} */ ('ASIDE');

/** @const {!goog.dom.TagName<!HTMLAudioElement>} */
goog.dom.TagName.AUDIO = /** @type {?} */ ('AUDIO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.B = /** @type {?} */ ('B');

/** @const {!goog.dom.TagName<!HTMLBaseElement>} */
goog.dom.TagName.BASE = /** @type {?} */ ('BASE');

/** @const {!goog.dom.TagName<!HTMLBaseFontElement>} */
goog.dom.TagName.BASEFONT = /** @type {?} */ ('BASEFONT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BDI = /** @type {?} */ ('BDI');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BDO = /** @type {?} */ ('BDO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.BIG = /** @type {?} */ ('BIG');

/** @const {!goog.dom.TagName<!HTMLQuoteElement>} */
goog.dom.TagName.BLOCKQUOTE = /** @type {?} */ ('BLOCKQUOTE');

/** @const {!goog.dom.TagName<!HTMLBodyElement>} */
goog.dom.TagName.BODY = /** @type {?} */ ('BODY');

/** @const {!goog.dom.TagName<!HTMLBRElement>} */
goog.dom.TagName.BR = /** @type {?} */ ('BR');

/** @const {!goog.dom.TagName<!HTMLButtonElement>} */
goog.dom.TagName.BUTTON = /** @type {?} */ ('BUTTON');

/** @const {!goog.dom.TagName<!HTMLCanvasElement>} */
goog.dom.TagName.CANVAS = /** @type {?} */ ('CANVAS');

/** @const {!goog.dom.TagName<!HTMLTableCaptionElement>} */
goog.dom.TagName.CAPTION = /** @type {?} */ ('CAPTION');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CENTER = /** @type {?} */ ('CENTER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CITE = /** @type {?} */ ('CITE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.CODE = /** @type {?} */ ('CODE');

/** @const {!goog.dom.TagName<!HTMLTableColElement>} */
goog.dom.TagName.COL = /** @type {?} */ ('COL');

/** @const {!goog.dom.TagName<!HTMLTableColElement>} */
goog.dom.TagName.COLGROUP = /** @type {?} */ ('COLGROUP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.COMMAND = /** @type {?} */ ('COMMAND');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DATA = /** @type {?} */ ('DATA');

/** @const {!goog.dom.TagName<!HTMLDataListElement>} */
goog.dom.TagName.DATALIST = /** @type {?} */ ('DATALIST');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DD = /** @type {?} */ ('DD');

/** @const {!goog.dom.TagName<!HTMLModElement>} */
goog.dom.TagName.DEL = /** @type {?} */ ('DEL');

/** @const {!goog.dom.TagName<!HTMLDetailsElement>} */
goog.dom.TagName.DETAILS = /** @type {?} */ ('DETAILS');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DFN = /** @type {?} */ ('DFN');

/** @const {!goog.dom.TagName<!HTMLDialogElement>} */
goog.dom.TagName.DIALOG = /** @type {?} */ ('DIALOG');

/** @const {!goog.dom.TagName<!HTMLDirectoryElement>} */
goog.dom.TagName.DIR = /** @type {?} */ ('DIR');

/** @const {!goog.dom.TagName<!HTMLDivElement>} */
goog.dom.TagName.DIV = /** @type {?} */ ('DIV');

/** @const {!goog.dom.TagName<!HTMLDListElement>} */
goog.dom.TagName.DL = /** @type {?} */ ('DL');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.DT = /** @type {?} */ ('DT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.EM = /** @type {?} */ ('EM');

/** @const {!goog.dom.TagName<!HTMLEmbedElement>} */
goog.dom.TagName.EMBED = /** @type {?} */ ('EMBED');

/** @const {!goog.dom.TagName<!HTMLFieldSetElement>} */
goog.dom.TagName.FIELDSET = /** @type {?} */ ('FIELDSET');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FIGCAPTION = /** @type {?} */ ('FIGCAPTION');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FIGURE = /** @type {?} */ ('FIGURE');

/** @const {!goog.dom.TagName<!HTMLFontElement>} */
goog.dom.TagName.FONT = /** @type {?} */ ('FONT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.FOOTER = /** @type {?} */ ('FOOTER');

/** @const {!goog.dom.TagName<!HTMLFormElement>} */
goog.dom.TagName.FORM = /** @type {?} */ ('FORM');

/** @const {!goog.dom.TagName<!HTMLFrameElement>} */
goog.dom.TagName.FRAME = /** @type {?} */ ('FRAME');

/** @const {!goog.dom.TagName<!HTMLFrameSetElement>} */
goog.dom.TagName.FRAMESET = /** @type {?} */ ('FRAMESET');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H1 = /** @type {?} */ ('H1');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H2 = /** @type {?} */ ('H2');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H3 = /** @type {?} */ ('H3');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H4 = /** @type {?} */ ('H4');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H5 = /** @type {?} */ ('H5');

/** @const {!goog.dom.TagName<!HTMLHeadingElement>} */
goog.dom.TagName.H6 = /** @type {?} */ ('H6');

/** @const {!goog.dom.TagName<!HTMLHeadElement>} */
goog.dom.TagName.HEAD = /** @type {?} */ ('HEAD');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.HEADER = /** @type {?} */ ('HEADER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.HGROUP = /** @type {?} */ ('HGROUP');

/** @const {!goog.dom.TagName<!HTMLHRElement>} */
goog.dom.TagName.HR = /** @type {?} */ ('HR');

/** @const {!goog.dom.TagName<!HTMLHtmlElement>} */
goog.dom.TagName.HTML = /** @type {?} */ ('HTML');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.I = /** @type {?} */ ('I');

/** @const {!goog.dom.TagName<!HTMLIFrameElement>} */
goog.dom.TagName.IFRAME = /** @type {?} */ ('IFRAME');

/** @const {!goog.dom.TagName<!HTMLImageElement>} */
goog.dom.TagName.IMG = /** @type {?} */ ('IMG');

/** @const {!goog.dom.TagName<!HTMLInputElement>} */
goog.dom.TagName.INPUT = /** @type {?} */ ('INPUT');

/** @const {!goog.dom.TagName<!HTMLModElement>} */
goog.dom.TagName.INS = /** @type {?} */ ('INS');

/** @const {!goog.dom.TagName<!HTMLIsIndexElement>} */
goog.dom.TagName.ISINDEX = /** @type {?} */ ('ISINDEX');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.KBD = /** @type {?} */ ('KBD');

// HTMLKeygenElement is deprecated.
/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.KEYGEN = /** @type {?} */ ('KEYGEN');

/** @const {!goog.dom.TagName<!HTMLLabelElement>} */
goog.dom.TagName.LABEL = /** @type {?} */ ('LABEL');

/** @const {!goog.dom.TagName<!HTMLLegendElement>} */
goog.dom.TagName.LEGEND = /** @type {?} */ ('LEGEND');

/** @const {!goog.dom.TagName<!HTMLLIElement>} */
goog.dom.TagName.LI = /** @type {?} */ ('LI');

/** @const {!goog.dom.TagName<!HTMLLinkElement>} */
goog.dom.TagName.LINK = /** @type {?} */ ('LINK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MAIN = /** @type {?} */ ('MAIN');

/** @const {!goog.dom.TagName<!HTMLMapElement>} */
goog.dom.TagName.MAP = /** @type {?} */ ('MAP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MARK = /** @type {?} */ ('MARK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.MATH = /** @type {?} */ ('MATH');

/** @const {!goog.dom.TagName<!HTMLMenuElement>} */
goog.dom.TagName.MENU = /** @type {?} */ ('MENU');

/** @const {!goog.dom.TagName<!HTMLMenuItemElement>} */
goog.dom.TagName.MENUITEM = /** @type {?} */ ('MENUITEM');

/** @const {!goog.dom.TagName<!HTMLMetaElement>} */
goog.dom.TagName.META = /** @type {?} */ ('META');

/** @const {!goog.dom.TagName<!HTMLMeterElement>} */
goog.dom.TagName.METER = /** @type {?} */ ('METER');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NAV = /** @type {?} */ ('NAV');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NOFRAMES = /** @type {?} */ ('NOFRAMES');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.NOSCRIPT = /** @type {?} */ ('NOSCRIPT');

/** @const {!goog.dom.TagName<!HTMLObjectElement>} */
goog.dom.TagName.OBJECT = /** @type {?} */ ('OBJECT');

/** @const {!goog.dom.TagName<!HTMLOListElement>} */
goog.dom.TagName.OL = /** @type {?} */ ('OL');

/** @const {!goog.dom.TagName<!HTMLOptGroupElement>} */
goog.dom.TagName.OPTGROUP = /** @type {?} */ ('OPTGROUP');

/** @const {!goog.dom.TagName<!HTMLOptionElement>} */
goog.dom.TagName.OPTION = /** @type {?} */ ('OPTION');

/** @const {!goog.dom.TagName<!HTMLOutputElement>} */
goog.dom.TagName.OUTPUT = /** @type {?} */ ('OUTPUT');

/** @const {!goog.dom.TagName<!HTMLParagraphElement>} */
goog.dom.TagName.P = /** @type {?} */ ('P');

/** @const {!goog.dom.TagName<!HTMLParamElement>} */
goog.dom.TagName.PARAM = /** @type {?} */ ('PARAM');

/** @const {!goog.dom.TagName<!HTMLPictureElement>} */
goog.dom.TagName.PICTURE = /** @type {?} */ ('PICTURE');

/** @const {!goog.dom.TagName<!HTMLPreElement>} */
goog.dom.TagName.PRE = /** @type {?} */ ('PRE');

/** @const {!goog.dom.TagName<!HTMLProgressElement>} */
goog.dom.TagName.PROGRESS = /** @type {?} */ ('PROGRESS');

/** @const {!goog.dom.TagName<!HTMLQuoteElement>} */
goog.dom.TagName.Q = /** @type {?} */ ('Q');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RP = /** @type {?} */ ('RP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RT = /** @type {?} */ ('RT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RTC = /** @type {?} */ ('RTC');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.RUBY = /** @type {?} */ ('RUBY');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.S = /** @type {?} */ ('S');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SAMP = /** @type {?} */ ('SAMP');

/** @const {!goog.dom.TagName<!HTMLScriptElement>} */
goog.dom.TagName.SCRIPT = /** @type {?} */ ('SCRIPT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SECTION = /** @type {?} */ ('SECTION');

/** @const {!goog.dom.TagName<!HTMLSelectElement>} */
goog.dom.TagName.SELECT = /** @type {?} */ ('SELECT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SMALL = /** @type {?} */ ('SMALL');

/** @const {!goog.dom.TagName<!HTMLSourceElement>} */
goog.dom.TagName.SOURCE = /** @type {?} */ ('SOURCE');

/** @const {!goog.dom.TagName<!HTMLSpanElement>} */
goog.dom.TagName.SPAN = /** @type {?} */ ('SPAN');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.STRIKE = /** @type {?} */ ('STRIKE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.STRONG = /** @type {?} */ ('STRONG');

/** @const {!goog.dom.TagName<!HTMLStyleElement>} */
goog.dom.TagName.STYLE = /** @type {?} */ ('STYLE');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUB = /** @type {?} */ ('SUB');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUMMARY = /** @type {?} */ ('SUMMARY');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SUP = /** @type {?} */ ('SUP');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.SVG = /** @type {?} */ ('SVG');

/** @const {!goog.dom.TagName<!HTMLTableElement>} */
goog.dom.TagName.TABLE = /** @type {?} */ ('TABLE');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.TBODY = /** @type {?} */ ('TBODY');

/** @const {!goog.dom.TagName<!HTMLTableCellElement>} */
goog.dom.TagName.TD = /** @type {?} */ ('TD');

/** @const {!goog.dom.TagName<!HTMLTemplateElement>} */
goog.dom.TagName.TEMPLATE = /** @type {?} */ ('TEMPLATE');

/** @const {!goog.dom.TagName<!HTMLTextAreaElement>} */
goog.dom.TagName.TEXTAREA = /** @type {?} */ ('TEXTAREA');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.TFOOT = /** @type {?} */ ('TFOOT');

/** @const {!goog.dom.TagName<!HTMLTableCellElement>} */
goog.dom.TagName.TH = /** @type {?} */ ('TH');

/** @const {!goog.dom.TagName<!HTMLTableSectionElement>} */
goog.dom.TagName.THEAD = /** @type {?} */ ('THEAD');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.TIME = /** @type {?} */ ('TIME');

/** @const {!goog.dom.TagName<!HTMLTitleElement>} */
goog.dom.TagName.TITLE = /** @type {?} */ ('TITLE');

/** @const {!goog.dom.TagName<!HTMLTableRowElement>} */
goog.dom.TagName.TR = /** @type {?} */ ('TR');

/** @const {!goog.dom.TagName<!HTMLTrackElement>} */
goog.dom.TagName.TRACK = /** @type {?} */ ('TRACK');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.TT = /** @type {?} */ ('TT');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.U = /** @type {?} */ ('U');

/** @const {!goog.dom.TagName<!HTMLUListElement>} */
goog.dom.TagName.UL = /** @type {?} */ ('UL');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.VAR = /** @type {?} */ ('VAR');

/** @const {!goog.dom.TagName<!HTMLVideoElement>} */
goog.dom.TagName.VIDEO = /** @type {?} */ ('VIDEO');

/** @const {!goog.dom.TagName<!goog.dom.HtmlElement>} */
goog.dom.TagName.WBR = /** @type {?} */ ('WBR');

//third_party/javascript/closure/dom/tags.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for HTML element tag names.
 */
goog.provide('goog.dom.tags');

goog.require('goog.object');


/**
 * The void elements specified by
 * http://www.w3.org/TR/html-markup/syntax.html#void-elements.
 * @const @private {!Object<string, boolean>}
 */
goog.dom.tags.VOID_TAGS_ = goog.object.createSet(
    'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input',
    'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr');


/**
 * Checks whether the tag is void (with no contents allowed and no legal end
 * tag), for example 'br'.
 * @param {string} tagName The tag name in lower case.
 * @return {boolean}
 */
goog.dom.tags.isVoidTag = function(tagName) {
  'use strict';
  return goog.dom.tags.VOID_TAGS_[tagName] === true;
};

//third_party/javascript/closure/html/trustedtypes.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Policy to convert strings to Trusted Types. See
 * https://github.com/WICG/trusted-types for details.
 */

goog.provide('goog.html.trustedtypes');


/**
 * Cached result of goog.createTrustedTypesPolicy.
 * @type {?TrustedTypePolicy|undefined}
 * @private
 */
goog.html.trustedtypes.cachedPolicy_;


/**
 * Creates a (singleton) Trusted Type Policy for Safe HTML Types.
 * @return {?TrustedTypePolicy}
 * @package
 */
goog.html.trustedtypes.getPolicyPrivateDoNotAccessOrElse = function() {
  'use strict';
  if (!goog.TRUSTED_TYPES_POLICY_NAME) {
    // Binary not configured for Trusted Types.
    return null;
  }

  if (goog.html.trustedtypes.cachedPolicy_ === undefined) {
    goog.html.trustedtypes.cachedPolicy_ =
        goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + '#html');
  }

  return goog.html.trustedtypes.cachedPolicy_;
};

//third_party/javascript/closure/string/typedstring.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.string.TypedString');



/**
 * Wrapper for strings that conform to a data type or language.
 *
 * Implementations of this interface are wrappers for strings, and typically
 * associate a type contract with the wrapped string.  Concrete implementations
 * of this interface may choose to implement additional run-time type checking,
 * see for example `goog.html.SafeHtml`. If available, client code that
 * needs to ensure type membership of an object should use the type's function
 * to assert type membership, such as `goog.html.SafeHtml.unwrap`.
 * @interface
 */
goog.string.TypedString = function() {};


/**
 * Interface marker of the TypedString interface.
 *
 * This property can be used to determine at runtime whether or not an object
 * implements this interface.  All implementations of this interface set this
 * property to `true`.
 * @type {boolean}
 */
goog.string.TypedString.prototype.implementsGoogStringTypedString;


/**
 * Retrieves this wrapped string's value.
 * @return {string} The wrapped string's value.
 */
goog.string.TypedString.prototype.getTypedStringValue;

//third_party/javascript/closure/string/const.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.string.Const');

goog.require('goog.asserts');
goog.require('goog.string.TypedString');



/**
 * Wrapper for compile-time-constant strings.
 *
 * Const is a wrapper for strings that can only be created from program
 * constants (i.e., string literals).  This property relies on a custom Closure
 * compiler check that `goog.string.Const.from` is only invoked on
 * compile-time-constant expressions.
 *
 * Const is useful in APIs whose correct and secure use requires that certain
 * arguments are not attacker controlled: Compile-time constants are inherently
 * under the control of the application and not under control of external
 * attackers, and hence are safe to use in such contexts.
 *
 * Instances of this type must be created via its factory method
 * `goog.string.Const.from` and not by invoking its constructor.  The
 * constructor intentionally takes no parameters and the type is immutable;
 * hence only a default instance corresponding to the empty string can be
 * obtained via constructor invocation.  Use goog.string.Const.EMPTY
 * instead of using this constructor to get an empty Const string.
 *
 * @see goog.string.Const#from
 * @constructor
 * @final
 * @struct
 * @implements {goog.string.TypedString}
 * @param {Object=} opt_token package-internal implementation detail.
 * @param {string=} opt_content package-internal implementation detail.
 */
goog.string.Const = function(opt_token, opt_content) {
  'use strict';
  /**
   * The wrapped value of this Const object.  The field has a purposely ugly
   * name to make (non-compiled) code that attempts to directly access this
   * field stand out.
   * @private {string}
   */
  this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ =
      ((opt_token ===
        goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_) &&
       opt_content) ||
      '';

  /**
   * A type marker used to implement additional run-time type checking.
   * @see goog.string.Const#unwrap
   * @const {!Object}
   * @private
   */
  this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ =
      goog.string.Const.TYPE_MARKER_;
};


/**
 * @override
 * @const
 */
goog.string.Const.prototype.implementsGoogStringTypedString = true;


/**
 * Returns this Const's value as a string.
 *
 * IMPORTANT: In code where it is security-relevant that an object's type is
 * indeed `goog.string.Const`, use `goog.string.Const.unwrap`
 * instead of this method.
 *
 * @see goog.string.Const#unwrap
 * @override
 * @return {string}
 */
goog.string.Const.prototype.getTypedStringValue = function() {
  'use strict';
  return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
};


if (goog.DEBUG) {
  /**
   * Returns a debug-string representation of this value.
   *
   * To obtain the actual string value wrapped inside an object of this type,
   * use `goog.string.Const.unwrap`.
   *
   * @see goog.string.Const#unwrap
   * @override
   * @return {string}
   */
  goog.string.Const.prototype.toString = function() {
    'use strict';
    return 'Const{' +
        this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ +
        '}';
  };
}


/**
 * Performs a runtime check that the provided object is indeed an instance
 * of `goog.string.Const`, and returns its value.
 * @param {!goog.string.Const} stringConst The object to extract from.
 * @return {string} The Const object's contained string, unless the run-time
 *     type check fails. In that case, `unwrap` returns an innocuous
 *     string, or, if assertions are enabled, throws
 *     `goog.asserts.AssertionError`.
 */
goog.string.Const.unwrap = function(stringConst) {
  'use strict';
  // Perform additional run-time type-checking to ensure that stringConst is
  // indeed an instance of the expected type.  This provides some additional
  // protection against security bugs due to application code that disables type
  // checks.
  if (stringConst instanceof goog.string.Const &&
      stringConst.constructor === goog.string.Const &&
      stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ ===
          goog.string.Const.TYPE_MARKER_) {
    return stringConst
        .stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  } else {
    goog.asserts.fail(
        'expected object of type Const, got \'' + stringConst + '\'');
    return 'type_error:Const';
  }
};


/**
 * Creates a Const object from a compile-time constant string.
 *
 * It is illegal to invoke this function on an expression whose
 * compile-time-constant value cannot be determined by the Closure compiler.
 *
 * Correct invocations include,
 * <pre>
 *   var s = goog.string.Const.from('hello');
 *   var t = goog.string.Const.from('hello' + 'world');
 * </pre>
 *
 * In contrast, the following are illegal:
 * <pre>
 *   var s = goog.string.Const.from(getHello());
 *   var t = goog.string.Const.from('hello' + world);
 * </pre>
 *
 * @param {string} s A constant string from which to create a Const.
 * @return {!goog.string.Const} A Const object initialized to stringConst.
 */
goog.string.Const.from = function(s) {
  'use strict';
  return new goog.string.Const(
      goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, s);
};

/**
 * Type marker for the Const type, used to implement additional run-time
 * type checking.
 * @const {!Object}
 * @private
 */
goog.string.Const.TYPE_MARKER_ = {};

/**
 * @type {!Object}
 * @private
 * @const
 */
goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {};

/**
 * A Const instance wrapping the empty string.
 * @const {!goog.string.Const}
 */
goog.string.Const.EMPTY = goog.string.Const.from('');

//third_party/javascript/closure/html/safescript.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeScript type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeScript');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const TypedString = goog.require('goog.string.TypedString');
const trustedtypes = goog.require('goog.html.trustedtypes');
const {fail} = goog.require('goog.asserts');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @const {!Object}
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string-like object which represents JavaScript code and that carries the
 * security type contract that its value, as a string, will not cause execution
 * of unconstrained attacker controlled code (XSS) when evaluated as JavaScript
 * in a browser.
 *
 * Instances of this type must be created via the factory method
 * `SafeScript.fromConstant` and not by invoking its constructor. The
 * constructor intentionally takes an extra parameter that cannot be constructed
 * outside of this file and the type is immutable; hence only a default instance
 * corresponding to the empty string can be obtained via constructor invocation.
 *
 * A SafeScript's string representation can safely be interpolated as the
 * content of a script element within HTML. The SafeScript string should not be
 * escaped before interpolation.
 *
 * Note that the SafeScript might contain text that is attacker-controlled but
 * that text should have been interpolated with appropriate escaping,
 * sanitization and/or validation into the right location in the script, such
 * that it is highly constrained in its effect (for example, it had to match a
 * set of whitelisted words).
 *
 * A SafeScript can be constructed via security-reviewed unchecked
 * conversions. In this case producers of SafeScript must ensure themselves that
 * the SafeScript does not contain unsafe script. Note in particular that
 * `&lt;` is dangerous, even when inside JavaScript strings, and so should
 * always be forbidden or JavaScript escaped in user controlled input. For
 * example, if `&lt;/script&gt;&lt;script&gt;evil&lt;/script&gt;"` were
 * interpolated inside a JavaScript string, it would break out of the context
 * of the original script element and `evil` would execute. Also note
 * that within an HTML script (raw text) element, HTML character references,
 * such as "&lt;" are not allowed. See
 * http://www.w3.org/TR/html5/scripting-1.html#restrictions-for-contents-of-script-elements.
 * Creating SafeScript objects HAS SIDE-EFFECTS due to calling Trusted Types Web
 * API.
 *
 * @see SafeScript#fromConstant
 * @final
 * @implements {TypedString}
 */
class SafeScript {
  /**
   * @param {!TrustedScript|string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    /**
     * The contained value of this SafeScript.  The field has a purposely ugly
     * name to make (non-compiled) code that attempts to directly access this
     * field stand out.
     * @private {!TrustedScript|string}
     */
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ =
        (token === CONSTRUCTOR_TOKEN_PRIVATE) ? value : '';

    /**
     * @override
     * @const
     */
    this.implementsGoogStringTypedString = true;
  }

  /**
   * Creates a SafeScript object from a compile-time constant string.
   *
   * @param {!Const} script A compile-time-constant string from which to create
   *     a SafeScript.
   * @return {!SafeScript} A SafeScript object initialized to `script`.
   */
  static fromConstant(script) {
    const scriptString = Const.unwrap(script);
    if (scriptString.length === 0) {
      return SafeScript.EMPTY;
    }
    return SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(
        scriptString);
  }

  /**
   * Creates a SafeScript JSON representation from anything that could be passed
   * to JSON.stringify.
   * @param {*} val
   * @return {!SafeScript}
   */
  static fromJson(val) {
    return SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(
        SafeScript.stringify_(val));
  }

  /**
   * Returns this SafeScript's value as a string.
   *
   * IMPORTANT: In code where it is security relevant that an object's type is
   * indeed `SafeScript`, use `SafeScript.unwrap` instead of
   * this method. If in doubt, assume that it's security relevant. In
   * particular, note that goog.html functions which return a goog.html type do
   * not guarantee the returned instance is of the right type. For example:
   *
   * <pre>
   * var fakeSafeHtml = new String('fake');
   * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
   * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
   * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
   * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
   * // instanceof goog.html.SafeHtml.
   * </pre>
   *
   * @see SafeScript#unwrap
   * @override
   */
  getTypedStringValue() {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
  }

  /**
   * Performs a runtime check that the provided object is indeed a
   * SafeScript object, and returns its value.
   *
   * @param {!SafeScript} safeScript The object to extract from.
   * @return {string} The safeScript object's contained string, unless
   *     the run-time type check fails. In that case, `unwrap` returns an
   *     innocuous string, or, if assertions are enabled, throws
   *     `asserts.AssertionError`.
   */
  static unwrap(safeScript) {
    return SafeScript.unwrapTrustedScript(safeScript).toString();
  }

  /**
   * Unwraps value as TrustedScript if supported or as a string if not.
   * @param {!SafeScript} safeScript
   * @return {!TrustedScript|string}
   * @see SafeScript.unwrap
   */
  static unwrapTrustedScript(safeScript) {
    // Perform additional Run-time type-checking to ensure that
    // safeScript is indeed an instance of the expected type.  This
    // provides some additional protection against security bugs due to
    // application code that disables type checks.
    // Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeScript instanceof SafeScript &&
        safeScript.constructor === SafeScript) {
      return safeScript.privateDoNotAccessOrElseSafeScriptWrappedValue_;
    } else {
      fail(
          'expected object of type SafeScript, got \'' + safeScript +
          '\' of type ' + goog.typeOf(safeScript));
      return 'type_error:SafeScript';
    }
  }

  /**
   * Converts the given value to an embeddable JSON string and returns it. The
   * resulting string can be embedded in HTML because the '<' character is
   * encoded.
   *
   * @param {*} val
   * @return {string}
   * @private
   */
  static stringify_(val) {
    const json = JSON.stringify(val);
    return json.replace(/</g, '\\x3c');
  }

  /**
   * Package-internal utility method to create SafeScript instances.
   *
   * @param {string} script The string to initialize the SafeScript object with.
   * @return {!SafeScript} The initialized SafeScript object.
   * @package
   */
  static createSafeScriptSecurityPrivateDoNotAccessOrElse(script) {
    const policy = trustedtypes.getPolicyPrivateDoNotAccessOrElse();
    const trustedScript = policy ? policy.createScript(script) : script;
    return new SafeScript(trustedScript, CONSTRUCTOR_TOKEN_PRIVATE);
  }
}

/**
 * Returns a string-representation of this value.
 *
 * To obtain the actual string value wrapped in a SafeScript, use
 * `SafeScript.unwrap`.
 *
 * @return {string}
 * @see SafeScript#unwrap
 * @override
 */
SafeScript.prototype.toString = function() {
  return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
};


/**
 * A SafeScript instance corresponding to the empty string.
 * @const {!SafeScript}
 */
SafeScript.EMPTY = /** @type {!SafeScript} */ ({
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // SafeScript creation (due to calling trustedTypes.createPolicy) from the
  // compiler so that the entire call can be removed if the result is not used.
  // MOE:begin_strip
  // TODO(b/155299094): Refactor after adding compiler support.
  // MOE:end_strip
  valueOf: function() {
    return SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse('');
  },
}.valueOf());


exports = SafeScript;

;return exports;});

//third_party/javascript/closure/fs/url.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Wrapper for URL and its createObjectUrl and revokeObjectUrl
 * methods that are part of the HTML5 File API.
 */

goog.provide('goog.fs.url');


/**
 * Creates a blob URL for a blob object.
 * Throws an error if the browser does not support Object Urls.
 *
 * @param {!File|!Blob|!MediaSource|!MediaStream} obj The object for which
 *   to create the URL.
 * @return {string} The URL for the object.
 */
goog.fs.url.createObjectUrl = function(obj) {
  'use strict';
  return goog.fs.url.getUrlObject_().createObjectURL(obj);
};


/**
 * Revokes a URL created by {@link goog.fs.url.createObjectUrl}.
 * Throws an error if the browser does not support Object Urls.
 *
 * @param {string} url The URL to revoke.
 * @return {void}
 */
goog.fs.url.revokeObjectUrl = function(url) {
  'use strict';
  goog.fs.url.getUrlObject_().revokeObjectURL(url);
};


/**
 * @record
 * @private
 */
goog.fs.url.UrlObject_ = function() {};

/**
 * @param {!File|!Blob|!MediaSource|!MediaStream} arg
 * @return {string}
 */
goog.fs.url.UrlObject_.prototype.createObjectURL = function(arg) {};

/**
 * @param {string} s
 * @return {void}
 */
goog.fs.url.UrlObject_.prototype.revokeObjectURL = function(s) {};


/**
 * Get the object that has the createObjectURL and revokeObjectURL functions for
 * this browser.
 *
 * @return {!goog.fs.url.UrlObject_} The object for this browser.
 * @private
 */
goog.fs.url.getUrlObject_ = function() {
  'use strict';
  const urlObject = goog.fs.url.findUrlObject_();
  if (urlObject != null) {
    return urlObject;
  } else {
    throw new Error('This browser doesn\'t seem to support blob URLs');
  }
};


/**
 * Finds the object that has the createObjectURL and revokeObjectURL functions
 * for this browser.
 *
 * @return {?goog.fs.url.UrlObject_} The object for this browser or null if the
 *     browser does not support Object Urls.
 * @private
 */
goog.fs.url.findUrlObject_ = function() {
  'use strict';
  // This is what the spec says to do
  // http://dev.w3.org/2006/webapi/FileAPI/#dfn-createObjectURL
  if (goog.global.URL !== undefined &&
      goog.global.URL.createObjectURL !== undefined) {
    return /** @type {!goog.fs.url.UrlObject_} */ (goog.global.URL);
    // This is what the spec used to say to do
  } else if (goog.global.createObjectURL !== undefined) {
    return /** @type {!goog.fs.url.UrlObject_} */ (goog.global);
  } else {
    return null;
  }
};


/**
 * Checks whether this browser supports Object Urls. If not, calls to
 * createObjectUrl and revokeObjectUrl will result in an error.
 *
 * @return {boolean} True if this browser supports Object Urls.
 */
goog.fs.url.browserSupportsObjectUrls = function() {
  'use strict';
  return goog.fs.url.findUrlObject_() != null;
};

//third_party/javascript/closure/fs/blob.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Wrappers for the HTML5 File API. These wrappers closely mirror
 * the underlying APIs, but use Closure-style events and Deferred return values.
 * Their existence also makes it possible to mock the FileSystem API for testing
 * in browsers that don't support it natively.
 *
 * When adding public functions to anything under this namespace, be sure to add
 * its mock counterpart to goog.testing.fs.
 */

goog.provide('goog.fs.blob');



/**
 * Concatenates one or more values together and converts them to a Blob.
 *
 * @param {...(string|!Blob|!ArrayBuffer)} var_args The values that will make up
 *     the resulting blob.
 * @return {!Blob} The blob.
 */
goog.fs.blob.getBlob = function(var_args) {
  'use strict';
  const BlobBuilder = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;

  if (BlobBuilder !== undefined) {
    const bb = new BlobBuilder();
    for (let i = 0; i < arguments.length; i++) {
      bb.append(arguments[i]);
    }
    return bb.getBlob();
  } else {
    return goog.fs.blob.getBlobWithProperties(
        Array.prototype.slice.call(arguments));
  }
};


/**
 * Creates a blob with the given properties.
 * See https://developer.mozilla.org/en-US/docs/Web/API/Blob for more details.
 *
 * @param {!Array<string|!Blob|!ArrayBuffer>} parts The values that will make up
 *     the resulting blob (subset supported by both BlobBuilder.append() and
 *     Blob constructor).
 * @param {string=} opt_type The MIME type of the Blob.
 * @param {string=} opt_endings Specifies how strings containing newlines are to
 *     be written out.
 * @return {!Blob} The blob.
 */
goog.fs.blob.getBlobWithProperties = function(parts, opt_type, opt_endings) {
  'use strict';
  const BlobBuilder = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;

  if (BlobBuilder !== undefined) {
    const bb = new BlobBuilder();
    for (let i = 0; i < parts.length; i++) {
      bb.append(parts[i], opt_endings);
    }
    return bb.getBlob(opt_type);
  } else if (goog.global.Blob !== undefined) {
    const properties = {};
    if (opt_type) {
      properties['type'] = opt_type;
    }
    if (opt_endings) {
      properties['endings'] = opt_endings;
    }
    return new Blob(parts, properties);
  } else {
    throw new Error('This browser doesn\'t seem to support creating Blobs');
  }
};

//third_party/javascript/closure/i18n/bidi.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utility functions for supporting Bidi issues.
 */


/**
 * Namespace for bidi supporting functions.
 */
goog.provide('goog.i18n.bidi');
goog.provide('goog.i18n.bidi.Dir');
goog.provide('goog.i18n.bidi.DirectionalString');
goog.provide('goog.i18n.bidi.Format');


/**
 * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
 * to say that the current locale is a RTL locale.  This should only be used
 * if you want to override the default behavior for deciding whether the
 * current locale is RTL or not.
 *
 * {@see goog.i18n.bidi.IS_RTL}
 */
goog.i18n.bidi.FORCE_RTL = goog.define('goog.i18n.bidi.FORCE_RTL', false);


/**
 * Constant that defines whether or not the current locale is a RTL locale.
 * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
 * to check that {@link goog.LOCALE} is one of a few major RTL locales.
 *
 * <p>This is designed to be a maximally efficient compile-time constant. For
 * example, for the default goog.LOCALE, compiling
 * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
 * is this design consideration that limits the implementation to only
 * supporting a few major RTL locales, as opposed to the broader repertoire of
 * something like goog.i18n.bidi.isRtlLanguage.
 *
 * <p>Since this constant refers to the directionality of the locale, it is up
 * to the caller to determine if this constant should also be used for the
 * direction of the UI.
 *
 * {@see goog.LOCALE}
 *
 * @type {boolean}
 *
 * TODO(aharon): write a test that checks that this is a compile-time constant.
 */
// LINT.IfChange
goog.i18n.bidi.IS_RTL =
    goog.i18n.bidi.FORCE_RTL ||
    ((goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'he' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' ||
      goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') &&
     (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' ||
      goog.LOCALE.substring(2, 3) == '_')) ||
    (  // Specific to CKB (Central Kurdish)
        goog.LOCALE.length >= 3 &&
        goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' &&
        (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' ||
         goog.LOCALE.substring(3, 4) == '_')) ||
    (  // 2 letter language codes with RTL scripts
        goog.LOCALE.length >= 7 &&
        ((goog.LOCALE.substring(2, 3) == '-' ||
          goog.LOCALE.substring(2, 3) == '_') &&
         (goog.LOCALE.substring(3, 7).toLowerCase() == 'adlm' ||
          goog.LOCALE.substring(3, 7).toLowerCase() == 'arab' ||
          goog.LOCALE.substring(3, 7).toLowerCase() == 'hebr' ||
          goog.LOCALE.substring(3, 7).toLowerCase() == 'nkoo' ||
          goog.LOCALE.substring(3, 7).toLowerCase() == 'rohg' ||
          goog.LOCALE.substring(3, 7).toLowerCase() == 'thaa'))) ||
    (  // 3 letter languages codes with RTL scripts
        goog.LOCALE.length >= 8 &&
        ((goog.LOCALE.substring(3, 4) == '-' ||
          goog.LOCALE.substring(3, 4) == '_') &&
         (goog.LOCALE.substring(4, 8).toLowerCase() == 'adlm' ||
          goog.LOCALE.substring(4, 8).toLowerCase() == 'arab' ||
          goog.LOCALE.substring(4, 8).toLowerCase() == 'hebr' ||
          goog.LOCALE.substring(4, 8).toLowerCase() == 'nkoo' ||
          goog.LOCALE.substring(4, 8).toLowerCase() == 'rohg' ||
          goog.LOCALE.substring(4, 8).toLowerCase() == 'thaa')));
//    closure/RtlLocalesTest.java)

// TODO(b/77919903): Add additional scripts and languages that are RTL,
// e.g., mende, samaritan, etc.


/**
 * Unicode formatting characters and directionality string constants.
 * @enum {string}
 */
goog.i18n.bidi.Format = {
  /** Unicode "Left-To-Right Embedding" (LRE) character. */
  LRE: '\u202A',
  /** Unicode "Right-To-Left Embedding" (RLE) character. */
  RLE: '\u202B',
  /** Unicode "Pop Directional Formatting" (PDF) character. */
  PDF: '\u202C',
  /** Unicode "Left-To-Right Mark" (LRM) character. */
  LRM: '\u200E',
  /** Unicode "Right-To-Left Mark" (RLM) character. */
  RLM: '\u200F'
};


/**
 * Directionality enum.
 * @enum {number}
 */
goog.i18n.bidi.Dir = {
  /**
   * Left-to-right.
   */
  LTR: 1,

  /**
   * Right-to-left.
   */
  RTL: -1,

  /**
   * Neither left-to-right nor right-to-left.
   */
  NEUTRAL: 0
};


/**
 * 'right' string constant.
 * @type {string}
 */
goog.i18n.bidi.RIGHT = 'right';


/**
 * 'left' string constant.
 * @type {string}
 */
goog.i18n.bidi.LEFT = 'left';


/**
 * 'left' if locale is RTL, 'right' if not.
 * @type {string}
 */
goog.i18n.bidi.I18N_RIGHT =
    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;


/**
 * 'right' if locale is RTL, 'left' if not.
 * @type {string}
 */
goog.i18n.bidi.I18N_LEFT =
    goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;


/**
 * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
 * constant. Useful for interaction with different standards of directionality
 * representation.
 *
 * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
 *     in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
 *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
 *     order to preserve legacy behavior.
 * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
 *     given directionality. If given null, returns null (i.e. unknown).
 */
goog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {
  'use strict';
  if (typeof givenDir == 'number') {
    // This includes the non-null goog.i18n.bidi.Dir case.
    return givenDir > 0 ?
        goog.i18n.bidi.Dir.LTR :
        givenDir < 0 ? goog.i18n.bidi.Dir.RTL :
                       opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
  } else if (givenDir == null) {
    return null;
  } else {
    // Must be typeof givenDir == 'boolean'.
    return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }
};


/**
 * A practical pattern to identify strong LTR character in the BMP.
 * This pattern is not theoretically correct according to the Unicode
 * standard. It is simplified for performance and small code size.
 * It also partially supports LTR scripts beyond U+FFFF by including
 * UTF-16 high surrogate values corresponding to mostly L-class code
 * point ranges.
 * However, low surrogate values and private-use regions are not included
 * in this RegEx.
 * @type {string}
 * @private
 */
goog.i18n.bidi.ltrChars_ =
    'A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590\u0900-\u1FFF' +
    '\u200E\u2C00-\uD801\uD804-\uD839\uD83C-\uDBFF' +
    '\uF900-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';

/**
 * A practical pattern to identify strong RTL character. This pattern is not
 * theoretically correct according to the Unicode standard. It is simplified
 * for performance and small code size.
 * It also partially supports RTL scripts beyond U+FFFF by including
 * UTF-16 high surrogate values corresponding to mostly R- or AL-class
 * code point ranges.
 * However, low surrogate values and private-use regions are not included
 * in this RegEx.
 * @type {string}
 * @private
 */
goog.i18n.bidi.rtlChars_ =
    '\u0591-\u06EF\u06FA-\u08FF\u200F\uD802-\uD803\uD83A-\uD83B' +
    '\uFB1D-\uFDFF\uFE70-\uFEFC';

/**
 * Simplified regular expression for an HTML tag (opening or closing) or an HTML
 * escape. We might want to skip over such expressions when estimating the text
 * directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;


/**
 * Returns the input text with spaces instead of HTML tags or HTML escapes, if
 * opt_isStripNeeded is true. Else returns the input as is.
 * Useful for text directionality estimation.
 * Note: the function should not be used in other contexts; it is not 100%
 * correct, but rather a good-enough implementation for directionality
 * estimation purposes.
 * @param {string} str The given string.
 * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
 *     Default: false (to retain consistency with calling functions).
 * @return {string} The given string cleaned of HTML tags / escapes.
 * @private
 */
goog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {
  'use strict';
  return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;
};


/**
 * Regular expression to check for RTL characters, BMP and high surrogate.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Regular expression to check for LTR characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains RTL characters.
 */
goog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.rtlCharReg_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Test whether the given string has any RTL characters in it.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the string contains RTL characters.
 * @deprecated Use hasAnyRtl.
 */
goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;


/**
 * Test whether the given string has any LTR characters in it.
 * @param {string} str The given string that need to be tested.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether the string contains LTR characters.
 */
goog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.ltrCharReg_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Regular expression pattern to check if the first character in the string
 * is LTR.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Regular expression pattern to check if the first character in the string
 * is RTL.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Check if the first character in the string is RTL or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an RTL char.
 */
goog.i18n.bidi.isRtlChar = function(str) {
  'use strict';
  return goog.i18n.bidi.rtlRe_.test(str);
};


/**
 * Check if the first character in the string is LTR or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is an LTR char.
 */
goog.i18n.bidi.isLtrChar = function(str) {
  'use strict';
  return goog.i18n.bidi.ltrRe_.test(str);
};


/**
 * Check if the first character in the string is neutral or not.
 * @param {string} str The given string that need to be tested.
 * @return {boolean} Whether the first character in str is a neutral char.
 */
goog.i18n.bidi.isNeutralChar = function(str) {
  'use strict';
  return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
};


/**
 * Regular expressions to check if a piece of text is of LTR directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrDirCheckRe_ = new RegExp(
    '^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');


/**
 * Regular expressions to check if a piece of text is of RTL directionality
 * on first character with strong directionality.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlDirCheckRe_ = new RegExp(
    '^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');


/**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 */
goog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.rtlDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check whether the first strongly directional character (if any) is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithRtl.
 */
goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;


/**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 */
goog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.ltrDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check whether the first strongly directional character (if any) is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR directionality is detected using the first
 *     strongly-directional character method.
 * @deprecated Use startsWithLtr.
 */
goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;


/**
 * Regular expression to check if a string looks like something that must
 * always be LTR even in RTL text, e.g. a URL. When estimating the
 * directionality of text containing these, we treat these as weakly LTR,
 * like numbers.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;


/**
 * Check whether the input string either contains no strongly directional
 * characters or looks like a url.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether neutral directionality is detected.
 */
goog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {
  'use strict';
  str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
  return goog.i18n.bidi.isRequiredLtrRe_.test(str) ||
      !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
};


/**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is LTR.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp(
    '[' + goog.i18n.bidi.ltrChars_ + ']' +
    '[^' + goog.i18n.bidi.rtlChars_ + ']*$');


/**
 * Regular expressions to check if the last strongly-directional character in a
 * piece of text is RTL.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp(
    '[' + goog.i18n.bidi.rtlChars_ + ']' +
    '[^' + goog.i18n.bidi.ltrChars_ + ']*$');


/**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 */
goog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.ltrExitDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check if the exit directionality a piece of text is LTR, i.e. if the last
 * strongly-directional character in the string is LTR.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether LTR exit directionality was detected.
 * @deprecated Use endsWithLtr.
 */
goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;


/**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 */
goog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.rtlExitDirCheckRe_.test(
      goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
};


/**
 * Check if the exit directionality a piece of text is RTL, i.e. if the last
 * strongly-directional character in the string is RTL.
 * @param {string} str String being checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether RTL exit directionality was detected.
 * @deprecated Use endsWithRtl.
 */
goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;


/**
 * A regular expression for matching right-to-left language codes.
 * See {@link #isRtlLanguage} for the design.
 * Note that not all RTL scripts are included.
 * @type {!RegExp}
 * @private
 */
goog.i18n.bidi.rtlLocalesRe_ = new RegExp(
    '^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' +
        '.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))' +
        '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)',
    'i');


/**
 * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
 * - a language code explicitly specifying one of the right-to-left scripts,
 *   e.g. "az-Arab", or<p>
 * - a language code specifying one of the languages normally written in a
 *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
 *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
 * The list of right-to-left scripts appears in the 100-199 range in
 * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
 * Hebrew are by far the most widely used. We also recognize Thaana, and N'Ko,
 * which also have significant modern usage. Adlam and Rohingya
 * scripts are now included since they can be expected to be used in the
 * future. The rest (Syriac, Samaritan, Mandaic, etc.) seem to have extremely
 * limited or no modern usage and are not recognized to save on code size. The
 * languages usually written in a right-to-left script are taken as those with
 * Suppress-Script: Hebr|Arab|Thaa|Nkoo|Adlm|Rohg in
 * http://www.iana.org/assignments/language-subtag-registry,
 * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
 * Other subtags of the language code, e.g. regions like EG (Egypt), are
 * ignored.
 * @param {string} lang BCP 47 (a.k.a III) language code.
 * @return {boolean} Whether the language code is an RTL language.
 */
goog.i18n.bidi.isRtlLanguage = function(lang) {
  'use strict';
  return goog.i18n.bidi.rtlLocalesRe_.test(lang);
};


/**
 * Regular expression for bracket guard replacement in text.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.bracketGuardTextRe_ =
    /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;


/**
 * Apply bracket guard using LRM and RLM. This is to address the problem of
 * messy bracket display frequently happens in RTL layout.
 * This function works for plain text, not for HTML. In HTML, the opening
 * bracket might be in a different context than the closing bracket (such as
 * an attribute value).
 * @param {string} s The string that need to be processed.
 * @param {boolean=} opt_isRtlContext specifies default direction (usually
 *     direction of the UI).
 * @return {string} The processed string, with all bracket guarded.
 */
goog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {
  'use strict';
  const useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) :
                                                  opt_isRtlContext;
  const mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
  return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
};


/**
 * Enforce the html snippet in RTL directionality regardless of overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet starts with a tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */
goog.i18n.bidi.enforceRtlInHtml = function(html) {
  'use strict';
  if (html.charAt(0) == '<') {
    return html.replace(/<\w+/, '$& dir=rtl');
  }
  // '\n' is important for FF so that it won't incorrectly merge span groups
  return '\n<span dir=rtl>' + html + '</span>';
};


/**
 * Enforce RTL on both end of the given text piece using unicode BiDi formatting
 * characters RLE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */
goog.i18n.bidi.enforceRtlInText = function(text) {
  'use strict';
  return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
};


/**
 * Enforce the html snippet in RTL directionality regardless or overall context.
 * If the html piece was enclosed by tag, dir will be applied to existing
 * tag, otherwise a span tag will be added as wrapper. For this reason, if
 * html snippet starts with a tag, this tag must enclose the whole piece. If
 * the tag already has a dir specified, this new one will override existing
 * one in behavior (tested on FF and IE).
 * @param {string} html The string that need to be processed.
 * @return {string} The processed string, with directionality enforced to RTL.
 */
goog.i18n.bidi.enforceLtrInHtml = function(html) {
  'use strict';
  if (html.charAt(0) == '<') {
    return html.replace(/<\w+/, '$& dir=ltr');
  }
  // '\n' is important for FF so that it won't incorrectly merge span groups
  return '\n<span dir=ltr>' + html + '</span>';
};


/**
 * Enforce LTR on both end of the given text piece using unicode BiDi formatting
 * characters LRE and PDF.
 * @param {string} text The piece of text that need to be wrapped.
 * @return {string} The wrapped string after process.
 */
goog.i18n.bidi.enforceLtrInText = function(text) {
  'use strict';
  return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
};


/**
 * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.dimensionsRe_ =
    /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;


/**
 * Regular expression for left.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.leftRe_ = /left/gi;


/**
 * Regular expression for right.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.rightRe_ = /right/gi;


/**
 * Placeholder regular expression for swapping.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.tempRe_ = /%%%%/g;


/**
 * Swap location parameters and 'left'/'right' in CSS specification. The
 * processed string will be suited for RTL layout. Though this function can
 * cover most cases, there are always exceptions. It is suggested to put
 * those exceptions in separate group of CSS string.
 * @param {string} cssStr CSS spefication string.
 * @return {string} Processed CSS specification string.
 */
goog.i18n.bidi.mirrorCSS = function(cssStr) {
  'use strict';
  return cssStr
      .
      // reverse dimensions
      replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2')
      .replace(goog.i18n.bidi.leftRe_, '%%%%')
      .  // swap left and right
      replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT)
      .replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
};


/**
 * Regular expression for hebrew double quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;


/**
 * Regular expression for hebrew single quote substitution, finding quote
 * directly after hebrew characters.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;


/**
 * Replace the double and single quote directly after a Hebrew character with
 * GERESH and GERSHAYIM. In such case, most likely that's user intention.
 * @param {string} str String that need to be processed.
 * @return {string} Processed string with double/single quote replaced.
 */
goog.i18n.bidi.normalizeHebrewQuote = function(str) {
  'use strict';
  return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05f4')
      .replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05f3');
};


/**
 * Regular expression to split a string into "words" for directionality
 * estimation based on relative word counts.
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.wordSeparatorRe_ = /\s+/;


/**
 * Regular expression to check if a string contains any numerals. Used to
 * differentiate between completely neutral strings and those containing
 * numbers, which are weakly LTR.
 *
 * Native Arabic digits (\u0660 - \u0669) are not included because although they
 * do flow left-to-right inside a number, this is the case even if the  overall
 * directionality is RTL, and a mathematical expression using these digits is
 * supposed to flow right-to-left overall, including unary plus and minus
 * appearing to the right of a number, and this does depend on the overall
 * directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
 * other hand, are included, since Farsi math (including unary plus and minus)
 * does flow left-to-right.
 * TODO: Consider other systems of digits, e.g., Adlam.
 *
 * @type {RegExp}
 * @private
 */
goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;


/**
 * This constant controls threshold of RTL directionality.
 * @type {number}
 * @private
 */
goog.i18n.bidi.rtlDetectionThreshold_ = 0.40;


/**
 * Estimates the directionality of a string based on relative word counts.
 * If the number of RTL words is above a certain percentage of the total number
 * of strongly directional words, returns RTL.
 * Otherwise, if any words are strongly or weakly LTR, returns LTR.
 * Otherwise, returns UNKNOWN, which is used to mean "neutral".
 * Numbers are counted as weakly LTR.
 * @param {string} str The string to be checked.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of `str`.
 */
goog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {
  'use strict';
  let rtlCount = 0;
  let totalCount = 0;
  let hasWeaklyLtr = false;
  const tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml)
                     .split(goog.i18n.bidi.wordSeparatorRe_);
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (goog.i18n.bidi.startsWithRtl(token)) {
      rtlCount++;
      totalCount++;
    } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
      hasWeaklyLtr = true;
    } else if (goog.i18n.bidi.hasAnyLtr(token)) {
      totalCount++;
    } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
      hasWeaklyLtr = true;
    }
  }

  return totalCount == 0 ?
      (hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL) :
      (rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ?
           goog.i18n.bidi.Dir.RTL :
           goog.i18n.bidi.Dir.LTR);
};


/**
 * Check the directionality of a piece of text, return true if the piece of
 * text should be laid out in RTL direction.
 * @param {string} str The piece of text that need to be detected.
 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
 *     Default: false.
 * @return {boolean} Whether this piece of text should be laid out in RTL.
 */
goog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {
  'use strict';
  return goog.i18n.bidi.estimateDirection(str, opt_isHtml) ==
      goog.i18n.bidi.Dir.RTL;
};


/**
 * Sets text input element's directionality and text alignment based on a
 * given directionality. Does nothing if the given directionality is unknown or
 * neutral.
 * @param {Element} element Input field element to set directionality to.
 * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
 *     given in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant.
 *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @return {void}
 */
goog.i18n.bidi.setElementDirAndAlign = function(element, dir) {
  'use strict';
  if (element) {
    const htmlElement = /** @type {!HTMLElement} */ (element);
    dir = goog.i18n.bidi.toDir(dir);
    if (dir) {
      htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ?
          goog.i18n.bidi.RIGHT :
          goog.i18n.bidi.LEFT;
      htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
    }
  }
};


/**
 * Sets element dir based on estimated directionality of the given text.
 * @param {!Element} element
 * @param {string} text
 * @return {void}
 */
goog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {
  'use strict';
  const htmlElement = /** @type {!HTMLElement} */ (element);
  switch (goog.i18n.bidi.estimateDirection(text)) {
    case (goog.i18n.bidi.Dir.LTR):
      if (htmlElement.dir !== 'ltr') {
        htmlElement.dir = 'ltr';
      }
      break;
    case (goog.i18n.bidi.Dir.RTL):
      if (htmlElement.dir !== 'rtl') {
        htmlElement.dir = 'rtl';
      }
      break;
    default:
      // Default for no direction, inherit from document.
      htmlElement.removeAttribute('dir');
  }
};



/**
 * Strings that have an (optional) known direction.
 *
 * Implementations of this interface are string-like objects that carry an
 * attached direction, if known.
 * @interface
 */
goog.i18n.bidi.DirectionalString = function() {};


/**
 * Interface marker of the DirectionalString interface.
 *
 * This property can be used to determine at runtime whether or not an object
 * implements this interface.  All implementations of this interface set this
 * property to `true`.
 * @type {boolean}
 */
goog.i18n.bidi.DirectionalString.prototype
    .implementsGoogI18nBidiDirectionalString;


/**
 * Retrieves this object's known direction (if any).
 * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
 */
goog.i18n.bidi.DirectionalString.prototype.getDirection;

//third_party/javascript/closure/html/trustedresourceurl.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The TrustedResourceUrl type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.provide('goog.html.TrustedResourceUrl');

goog.require('goog.asserts');
goog.require('goog.fs.blob');
goog.require('goog.fs.url');
goog.require('goog.html.SafeScript');
goog.require('goog.html.trustedtypes');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.DirectionalString');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');



/**
 * A URL which is under application control and from which script, CSS, and
 * other resources that represent executable code, can be fetched.
 *
 * Given that the URL can only be constructed from strings under application
 * control and is used to load resources, bugs resulting in a malformed URL
 * should not have a security impact and are likely to be easily detectable
 * during testing. Given the wide number of non-RFC compliant URLs in use,
 * stricter validation could prevent some applications from being able to use
 * this type.
 *
 * Instances of this type must be created via the factory method,
 * (`fromConstant`, `fromConstants`, `format` or `formatWithParams`), and not by
 * invoking its constructor. The constructor intentionally takes an extra
 * parameter that cannot be constructed outside of this file and the type is
 * immutable; hence only a default instance corresponding to the empty string
 * can be obtained via constructor invocation.
 *
 * Creating TrustedResourceUrl objects HAS SIDE-EFFECTS due to calling
 * Trusted Types Web API.
 *
 * @see goog.html.TrustedResourceUrl#fromConstant
 * @final
 * @struct
 * @implements {goog.i18n.bidi.DirectionalString}
 * @implements {goog.string.TypedString}
 */
goog.html.TrustedResourceUrl = class {
  /**
   * @param {!TrustedScriptURL|string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    /**
     * The contained value of this TrustedResourceUrl.  The field has a
     * purposely ugly name to make (non-compiled) code that attempts to directly
     * access this field stand out.
     * @const
     * @private {!TrustedScriptURL|string}
     */
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ =
        (token === goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_) ?
        value :
        '';
  }
};


/**
 * @override
 * @const
 */
goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = true;


/**
 * Returns this TrustedResourceUrl's value as a string.
 *
 * IMPORTANT: In code where it is security relevant that an object's type is
 * indeed `TrustedResourceUrl`, use
 * `goog.html.TrustedResourceUrl.unwrap` instead of this method. If in
 * doubt, assume that it's security relevant. In particular, note that
 * goog.html functions which return a goog.html type do not guarantee that
 * the returned instance is of the right type. For example:
 *
 * <pre>
 * var fakeSafeHtml = new String('fake');
 * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
 * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
 * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
 * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml instanceof
 * // goog.html.SafeHtml.
 * </pre>
 *
 * @see goog.html.TrustedResourceUrl#unwrap
 * @override
 */
goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
  'use strict';
  return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_
      .toString();
};


/**
 * @override
 * @const
 */
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString =
    true;


/**
 * Returns this URLs directionality, which is always `LTR`.
 * @override
 * @return {!goog.i18n.bidi.Dir}
 */
goog.html.TrustedResourceUrl.prototype.getDirection = function() {
  'use strict';
  return goog.i18n.bidi.Dir.LTR;
};


/**
 * Creates a new TrustedResourceUrl with params added to URL. Both search and
 * hash params can be specified.
 *
 * @param {string|?Object<string, *>|undefined} searchParams Search parameters
 *     to add to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for
 *     exact format definition.
 * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @return {!goog.html.TrustedResourceUrl} New TrustedResourceUrl with params.
 */
goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(
    searchParams, opt_hashParams) {
  'use strict';
  var url = goog.html.TrustedResourceUrl.unwrap(this);
  var parts = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(url);
  var urlBase = parts[1];
  var urlSearch = parts[2] || '';
  var urlHash = parts[3] || '';

  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(
          urlBase +
          goog.html.TrustedResourceUrl.stringifyParams_(
              '?', urlSearch, searchParams) +
          goog.html.TrustedResourceUrl.stringifyParams_(
              '#', urlHash, opt_hashParams));
};


/**
 * Returns a string-representation of this value.
 *
 * To obtain the actual string value wrapped in a TrustedResourceUrl, use
 * `goog.html.TrustedResourceUrl.unwrap`.
 *
 * @return {string}
 * @see goog.html.TrustedResourceUrl#unwrap
 * @override
 */
goog.html.TrustedResourceUrl.prototype.toString = function() {
  'use strict';
  return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + '';
};


/**
 * Performs a runtime check that the provided object is indeed a
 * TrustedResourceUrl object, and returns its value.
 *
 * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl The object to
 *     extract from.
 * @return {string} The trustedResourceUrl object's contained string, unless
 *     the run-time type check fails. In that case, `unwrap` returns an
 *     innocuous string, or, if assertions are enabled, throws
 *     `goog.asserts.AssertionError`.
 */
goog.html.TrustedResourceUrl.unwrap = function(trustedResourceUrl) {
  'use strict';
  return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(trustedResourceUrl)
      .toString();
};


/**
 * Unwraps value as TrustedScriptURL if supported or as a string if not.
 * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl
 * @return {!TrustedScriptURL|string}
 * @see goog.html.TrustedResourceUrl.unwrap
 */
goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(
    trustedResourceUrl) {
  'use strict';
  // Perform additional Run-time type-checking to ensure that
  // trustedResourceUrl is indeed an instance of the expected type.  This
  // provides some additional protection against security bugs due to
  // application code that disables type checks.
  // Specifically, the following checks are performed:
  // 1. The object is an instance of the expected type.
  // 2. The object is not an instance of a subclass.
  if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl &&
      trustedResourceUrl.constructor === goog.html.TrustedResourceUrl) {
    return trustedResourceUrl
        .privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
  } else {
    goog.asserts.fail('expected object of type TrustedResourceUrl, got \'' +
        trustedResourceUrl + '\' of type ' + goog.typeOf(trustedResourceUrl));
    return 'type_error:TrustedResourceUrl';
  }
};


/**
 * Creates a TrustedResourceUrl from a format string and arguments.
 *
 * The arguments for interpolation into the format string map labels to values.
 * Values of type `goog.string.Const` are interpolated without modifcation.
 * Values of other types are cast to string and encoded with
 * encodeURIComponent.
 *
 * `%{<label>}` markers are used in the format string to indicate locations
 * to be interpolated with the valued mapped to the given label. `<label>`
 * must contain only alphanumeric and `_` characters.
 *
 * The format string must match goog.html.TrustedResourceUrl.BASE_URL_.
 *
 * Example usage:
 *
 *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
 *        'https://www.google.com/search?q=%{query}'), {'query': searchTerm});
 *
 *    var url = goog.html.TrustedResourceUrl.format(goog.string.Const.from(
 *        '//www.youtube.com/v/%{videoId}?hl=en&fs=1%{autoplay}'), {
 *        'videoId': videoId,
 *        'autoplay': opt_autoplay ?
 *            goog.string.Const.from('&autoplay=1') : goog.string.Const.EMPTY
 *    });
 *
 * While this function can be used to create a TrustedResourceUrl from only
 * constants, fromConstant() and fromConstants() are generally preferable for
 * that purpose.
 *
 * @param {!goog.string.Const} format The format string.
 * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
 *     of labels to values to be interpolated into the format string.
 *     goog.string.Const values are interpolated without encoding.
 * @return {!goog.html.TrustedResourceUrl}
 * @throws {!Error} On an invalid format string or if a label used in the
 *     the format string is not present in args.
 */
goog.html.TrustedResourceUrl.format = function(format, args) {
  'use strict';
  var formatStr = goog.string.Const.unwrap(format);
  if (!goog.html.TrustedResourceUrl.BASE_URL_.test(formatStr)) {
    throw new Error('Invalid TrustedResourceUrl format: ' + formatStr);
  }
  var result = formatStr.replace(
      goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(match, id) {
        'use strict';
        if (!Object.prototype.hasOwnProperty.call(args, id)) {
          throw new Error(
              'Found marker, "' + id + '", in format string, "' + formatStr +
              '", but no valid label mapping found ' +
              'in args: ' + JSON.stringify(args));
        }
        var arg = args[id];
        if (arg instanceof goog.string.Const) {
          return goog.string.Const.unwrap(arg);
        } else {
          return encodeURIComponent(String(arg));
        }
      });
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(result);
};


/**
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g;


/**
 * The URL must be absolute, scheme-relative or path-absolute. So it must
 * start with:
 * - https:// followed by allowed origin characters.
 * - // followed by allowed origin characters.
 * - Any absolute or relative path.
 *
 * Based on
 * https://url.spec.whatwg.org/commit-snapshots/56b74ce7cca8883eab62e9a12666e2fac665d03d/#url-parsing
 * an initial / which is not followed by another / or \ will end up in the "path
 * state" and from there it can only go to "fragment state" and "query state".
 *
 * We don't enforce a well-formed domain name. So '.' or '1.2' are valid.
 * That's ok because the origin comes from a compile-time constant.
 *
 * A regular expression is used instead of goog.uri for several reasons:
 * - Strictness. E.g. we don't want any userinfo component and we don't
 *   want '/./, nor \' in the first path component.
 * - Small trusted base. goog.uri is generic and might need to change,
 *   reasoning about all the ways it can parse a URL now and in the future
 *   is error-prone.
 * - Code size. We expect many calls to .format(), many of which might
 *   not be using goog.uri.
 * - Simplicity. Using goog.uri would likely not result in simpler nor shorter
 *   code.
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.BASE_URL_ = new RegExp(
    '^((https:)?//[0-9a-z.:[\\]-]+/'  // Origin.
        + '|/[^/\\\\]'                // Absolute path.
        + '|[^:/\\\\%]+/'             // Relative path.
        + '|[^:/\\\\%]*[?#]'          // Query string or fragment.
        + '|about:blank#'             // about:blank with fragment.
        + ')',
    'i');

/**
 * RegExp for splitting a URL into the base, search field, and hash field.
 *
 * @private @const {!RegExp}
 */
goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ =
    /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;


/**
 * Formats the URL same as TrustedResourceUrl.format and then adds extra URL
 * parameters.
 *
 * Example usage:
 *
 *     // Creates '//www.youtube.com/v/abc?autoplay=1' for videoId='abc' and
 *     // opt_autoplay=1. Creates '//www.youtube.com/v/abc' for videoId='abc'
 *     // and opt_autoplay=undefined.
 *     var url = goog.html.TrustedResourceUrl.formatWithParams(
 *         goog.string.Const.from('//www.youtube.com/v/%{videoId}'),
 *         {'videoId': videoId},
 *         {'autoplay': opt_autoplay});
 *
 * @param {!goog.string.Const} format The format string.
 * @param {!Object<string, (string|number|!goog.string.Const)>} args Mapping
 *     of labels to values to be interpolated into the format string.
 *     goog.string.Const values are interpolated without encoding.
 * @param {string|?Object<string, *>|undefined} searchParams Parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @param {(string|?Object<string, *>)=} opt_hashParams Hash parameters to add
 *     to URL. See goog.html.TrustedResourceUrl.stringifyParams_ for exact
 *     format definition.
 * @return {!goog.html.TrustedResourceUrl}
 * @throws {!Error} On an invalid format string or if a label used in the
 *     the format string is not present in args.
 */
goog.html.TrustedResourceUrl.formatWithParams = function(
    format, args, searchParams, opt_hashParams) {
  'use strict';
  var url = goog.html.TrustedResourceUrl.format(format, args);
  return url.cloneWithParams(searchParams, opt_hashParams);
};


/**
 * Creates a TrustedResourceUrl object from a compile-time constant string.
 *
 * Compile-time constant strings are inherently program-controlled and hence
 * trusted.
 *
 * @param {!goog.string.Const} url A compile-time-constant string from which to
 *     create a TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
 *     initialized to `url`.
 */
goog.html.TrustedResourceUrl.fromConstant = function(url) {
  'use strict';
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(
          goog.string.Const.unwrap(url));
};


/**
 * Creates a TrustedResourceUrl object from a compile-time constant strings.
 *
 * Compile-time constant strings are inherently program-controlled and hence
 * trusted.
 *
 * @param {!Array<!goog.string.Const>} parts Compile-time-constant strings from
 *     which to create a TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
 *     initialized to concatenation of `parts`.
 */
goog.html.TrustedResourceUrl.fromConstants = function(parts) {
  'use strict';
  var unwrapped = '';
  for (var i = 0; i < parts.length; i++) {
    unwrapped += goog.string.Const.unwrap(parts[i]);
  }
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(unwrapped);
};

/**
 * Creates a TrustedResourceUrl object by generating a Blob from a SafeScript
 * object and then calling createObjectURL with that blob.
 *
 * SafeScript objects are trusted to contain executable JavaScript code.
 *
 * Caller must call goog.fs.url.revokeObjectUrl() on the unwrapped url to
 * release the underlying blob.
 *
 * Throws if browser doesn't support blob construction.
 *
 * @param {!goog.html.SafeScript} safeScript A script from which to create a
 *     TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} A TrustedResourceUrl object
 *     initialized to a new blob URL.
 */
goog.html.TrustedResourceUrl.fromSafeScript = function(safeScript) {
  'use strict';
  var blob = goog.fs.blob.getBlobWithProperties(
      [goog.html.SafeScript.unwrap(safeScript)], 'text/javascript');
  var url = goog.fs.url.createObjectUrl(blob);
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
};


/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @private {!Object}
 * @const
 */
goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {};


/**
 * Package-internal utility method to create TrustedResourceUrl instances.
 *
 * @param {string} url The string to initialize the TrustedResourceUrl object
 *     with.
 * @return {!goog.html.TrustedResourceUrl} The initialized TrustedResourceUrl
 *     object.
 * @package
 */
goog.html.TrustedResourceUrl
    .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(url) {
  'use strict';
  const policy = goog.html.trustedtypes.getPolicyPrivateDoNotAccessOrElse();
  var value = policy ? policy.createScriptURL(url) : url;
  return new goog.html.TrustedResourceUrl(
      value, goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_);
};


/**
 * Stringifies the passed params to be used as either a search or hash field of
 * a URL.
 *
 * @param {string} prefix The prefix character for the given field ('?' or '#').
 * @param {string} currentString The existing field value (including the prefix
 *     character, if the field is present).
 * @param {string|?Object<string, *>|undefined} params The params to set or
 *     append to the field.
 * - If `undefined` or `null`, the field remains unchanged.
 * - If a string, then the string will be escaped and the field will be
 *   overwritten with that value.
 * - If an Object, that object is treated as a set of key-value pairs to be
 *   appended to the current field. Note that JavaScript doesn't guarantee the
 *   order of values in an object which might result in non-deterministic order
 *   of the parameters. However, browsers currently preserve the order. The
 *   rules for each entry:
 *   - If an array, it will be processed as if each entry were an additional
 *     parameter with exactly the same key, following the same logic below.
 *   - If `undefined` or `null`, it will be skipped.
 *   - Otherwise, it will be turned into a string, escaped, and appended.
 * @return {string}
 * @private
 */
goog.html.TrustedResourceUrl.stringifyParams_ = function(
    prefix, currentString, params) {
  'use strict';
  if (params == null) {
    // Do not modify the field.
    return currentString;
  }
  if (typeof params === 'string') {
    // Set field to the passed string.
    return params ? prefix + encodeURIComponent(params) : '';
  }
  // Add on parameters to field from key-value object.
  for (var key in params) {
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      var value = params[key];
      var outputValues = Array.isArray(value) ? value : [value];
      for (var i = 0; i < outputValues.length; i++) {
        var outputValue = outputValues[i];
        if (outputValue != null) {
          if (!currentString) {
            currentString = prefix;
          }
          currentString += (currentString.length > prefix.length ? '&' : '') +
              encodeURIComponent(key) + '=' +
              encodeURIComponent(String(outputValue));
        }
      }
    }
  }
  return currentString;
};

//third_party/javascript/closure/html/safeurl.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeUrl type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.provide('goog.html.SafeUrl');

goog.require('goog.asserts');
goog.require('goog.fs.url');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.DirectionalString');
goog.require('goog.string.Const');
goog.require('goog.string.TypedString');
goog.require('goog.string.internal');



/**
 * A string that is safe to use in URL context in DOM APIs and HTML documents.
 *
 * A SafeUrl is a string-like object that carries the security type contract
 * that its value as a string will not cause untrusted script execution
 * when evaluated as a hyperlink URL in a browser.
 *
 * Values of this type are guaranteed to be safe to use in URL/hyperlink
 * contexts, such as assignment to URL-valued DOM properties, in the sense that
 * the use will not result in a Cross-Site-Scripting vulnerability. Similarly,
 * SafeUrls can be interpolated into the URL context of an HTML template (e.g.,
 * inside a href attribute). However, appropriate HTML-escaping must still be
 * applied.
 *
 * Note that, as documented in `goog.html.SafeUrl.unwrap`, this type's
 * contract does not guarantee that instances are safe to interpolate into HTML
 * without appropriate escaping.
 *
 * Note also that this type's contract does not imply any guarantees regarding
 * the resource the URL refers to.  In particular, SafeUrls are <b>not</b>
 * safe to use in a context where the referred-to resource is interpreted as
 * trusted code, e.g., as the src of a script tag.
 *
 * Instances of this type must be created via the factory methods
 * (`goog.html.SafeUrl.fromConstant`, `goog.html.SafeUrl.sanitize`),
 * etc and not by invoking its constructor. The constructor intentionally takes
 * an extra parameter that cannot be constructed outside of this file and the
 * type is immutable; hence only a default instance corresponding to the empty
 * string can be obtained via constructor invocation.
 *
 * @see goog.html.SafeUrl#fromConstant
 * @see goog.html.SafeUrl#from
 * @see goog.html.SafeUrl#sanitize
 * @final
 * @struct
 * @implements {goog.i18n.bidi.DirectionalString}
 * @implements {goog.string.TypedString}
 */
goog.html.SafeUrl = class {
  /**
   * @param {string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    /**
     * The contained value of this SafeUrl.  The field has a purposely ugly
     * name to make (non-compiled) code that attempts to directly access this
     * field stand out.
     * @private {string}
     */
    this.privateDoNotAccessOrElseSafeUrlWrappedValue_ =
        (token === goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_) ? value : '';
  };
};


/**
 * The innocuous string generated by goog.html.SafeUrl.sanitize when passed
 * an unsafe URL.
 *
 * about:invalid is registered in
 * http://www.w3.org/TR/css3-values/#about-invalid.
 * http://tools.ietf.org/html/rfc6694#section-2.2.1 permits about URLs to
 * contain a fragment, which is not to be considered when determining if an
 * about URL is well-known.
 *
 * Using about:invalid seems preferable to using a fixed data URL, since
 * browsers might choose to not report CSP violations on it, as legitimate
 * CSS function calls to attr() can result in this URL being produced. It is
 * also a standard URL which matches exactly the semantics we need:
 * "The about:invalid URI references a non-existent document with a generic
 * error condition. It can be used when a URI is necessary, but the default
 * value shouldn't be resolveable as any type of document".
 *
 * @const {string}
 */
goog.html.SafeUrl.INNOCUOUS_STRING = 'about:invalid#zClosurez';


/**
 * @override
 * @const
 */
goog.html.SafeUrl.prototype.implementsGoogStringTypedString = true;


/**
 * Returns this SafeUrl's value as a string.
 *
 * IMPORTANT: In code where it is security relevant that an object's type is
 * indeed `SafeUrl`, use `goog.html.SafeUrl.unwrap` instead of this
 * method. If in doubt, assume that it's security relevant. In particular, note
 * that goog.html functions which return a goog.html type do not guarantee that
 * the returned instance is of the right type.
 *
 * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the
 * behavior of browsers when interpreting URLs. Values of SafeUrl objects MUST
 * be appropriately escaped before embedding in a HTML document. Note that the
 * required escaping is context-sensitive (e.g. a different escaping is
 * required for embedding a URL in a style property within a style
 * attribute, as opposed to embedding in a href attribute).
 *
 * @see goog.html.SafeUrl#unwrap
 * @override
 */
goog.html.SafeUrl.prototype.getTypedStringValue = function() {
  'use strict';
  return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
};


/**
 * @override
 * @const {boolean}
 */
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = true;


/**
 * Returns this URLs directionality, which is always `LTR`.
 * @override
 * @return {!goog.i18n.bidi.Dir}
 */
goog.html.SafeUrl.prototype.getDirection = function() {
  'use strict';
  return goog.i18n.bidi.Dir.LTR;
};


/**
 * Returns a string-representation of this value.
 *
 * To obtain the actual string value wrapped in a SafeUrl, use
 * `goog.html.SafeUrl.unwrap`.
 *
 * @return {string}
 * @see goog.html.SafeUrl#unwrap
 * @override
 */
goog.html.SafeUrl.prototype.toString = function() {
  'use strict';
  return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
};



/**
 * Performs a runtime check that the provided object is indeed a SafeUrl
 * object, and returns its value.
 *
 * IMPORTANT: The guarantees of the SafeUrl type contract only extend to the
 * behavior of  browsers when interpreting URLs. Values of SafeUrl objects MUST
 * be appropriately escaped before embedding in a HTML document. Note that the
 * required escaping is context-sensitive (e.g. a different escaping is
 * required for embedding a URL in a style property within a style
 * attribute, as opposed to embedding in a href attribute).
 *
 * @param {!goog.html.SafeUrl} safeUrl The object to extract from.
 * @return {string} The SafeUrl object's contained string, unless the run-time
 *     type check fails. In that case, `unwrap` returns an innocuous
 *     string, or, if assertions are enabled, throws
 *     `goog.asserts.AssertionError`.
 */
goog.html.SafeUrl.unwrap = function(safeUrl) {
  'use strict';
  // Perform additional Run-time type-checking to ensure that safeUrl is indeed
  // an instance of the expected type.  This provides some additional protection
  // against security bugs due to application code that disables type checks.
  // Specifically, the following checks are performed:
  // 1. The object is an instance of the expected type.
  // 2. The object is not an instance of a subclass.
  if (safeUrl instanceof goog.html.SafeUrl &&
      safeUrl.constructor === goog.html.SafeUrl) {
    return safeUrl.privateDoNotAccessOrElseSafeUrlWrappedValue_;
  } else {
    goog.asserts.fail('expected object of type SafeUrl, got \'' +
        safeUrl + '\' of type ' + goog.typeOf(safeUrl));
    return 'type_error:SafeUrl';
  }
};


/**
 * Creates a SafeUrl object from a compile-time constant string.
 *
 * Compile-time constant strings are inherently program-controlled and hence
 * trusted.
 *
 * @param {!goog.string.Const} url A compile-time-constant string from which to
 *         create a SafeUrl.
 * @return {!goog.html.SafeUrl} A SafeUrl object initialized to `url`.
 */
goog.html.SafeUrl.fromConstant = function(url) {
  'use strict';
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      goog.string.Const.unwrap(url));
};


/**
 * A pattern that matches Blob or data types that can have SafeUrls created
 * from URL.createObjectURL(blob) or via a data: URI.
 *
 * This has some parameter support (most notably, we haven't implemented the
 * more complex parts like %-encoded characters or non-alphanumerical ones for
 * simplicity's sake). The specs are fairly complex, and they don't
 * always match Chrome's behavior: we settled on a subset where we're confident
 * all parties involved agree.
 *
 * The spec is available at https://mimesniff.spec.whatwg.org/ (and see
 * https://tools.ietf.org/html/rfc2397 for data: urls, which override some of
 * it).
 * @const
 * @private
 */
goog.html.SAFE_MIME_TYPE_PATTERN_ = new RegExp(
    // Note: Due to content-sniffing concerns, only add MIME types for
    // media formats.
    '^(?:audio/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|' +
        'font/\\w+|' +
        'image/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|' +
        'video/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))' +
        '(?:;\\w+=(?:\\w+|"[\\w;,= ]+"))*$',  // MIME type parameters
    'i');


/**
 * @param {string} mimeType The MIME type to check if safe.
 * @return {boolean} True if the MIME type is safe and creating a Blob via
 *   `SafeUrl.fromBlob()` with that type will not fail due to the type. False
 *   otherwise.
 */
goog.html.SafeUrl.isSafeMimeType = function(mimeType) {
  'use strict';
  return goog.html.SAFE_MIME_TYPE_PATTERN_.test(mimeType);
};


/**
 * Creates a SafeUrl wrapping a blob URL for the given `blob`.
 *
 * The blob URL is created with `URL.createObjectURL`. If the MIME type
 * for `blob` is not of a known safe audio, image or video MIME type,
 * then the SafeUrl will wrap {@link #INNOCUOUS_STRING}.
 *
 * Note: Call {@link revokeObjectUrl} on the URL after it's used
 * to prevent memory leaks.
 *
 * @see http://www.w3.org/TR/FileAPI/#url
 * @param {!Blob} blob
 * @return {!goog.html.SafeUrl} The blob URL, or an innocuous string wrapped
 *   as a SafeUrl.
 */
goog.html.SafeUrl.fromBlob = function(blob) {
  'use strict';
  var url = goog.html.SafeUrl.isSafeMimeType(blob.type) ?
      goog.fs.url.createObjectUrl(blob) :
      goog.html.SafeUrl.INNOCUOUS_STRING;
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};


/**
 * Revokes an object URL created for a safe URL created {@link fromBlob()}.
 * @param {!goog.html.SafeUrl} safeUrl SafeUrl wrapping a blob object.
 * @return {void}
 */
goog.html.SafeUrl.revokeObjectUrl = function(safeUrl) {
  'use strict';
  var url = safeUrl.getTypedStringValue();
  if (url !== goog.html.SafeUrl.INNOCUOUS_STRING) {
    goog.fs.url.revokeObjectUrl(url);
  }
};


/**
 * Creates a SafeUrl wrapping a blob URL created for a MediaSource.
 * @param {!MediaSource} mediaSource
 * @return {!goog.html.SafeUrl} The blob URL.
 */
goog.html.SafeUrl.fromMediaSource = function(mediaSource) {
  'use strict';
  goog.asserts.assert(
      'MediaSource' in goog.global, 'No support for MediaSource');
  const url = mediaSource instanceof MediaSource ?
      goog.fs.url.createObjectUrl(mediaSource) :
      goog.html.SafeUrl.INNOCUOUS_STRING;
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};


/**
 * Matches a base-64 data URL, with the first match group being the MIME type.
 * @const
 * @private
 */
goog.html.DATA_URL_PATTERN_ = /^data:(.*);base64,[a-z0-9+\/]+=*$/i;


/**
 * Attempts to create a SafeUrl wrapping a `data:` URL, after validating it
 * matches a known-safe media MIME type. If it doesn't match, return `null`.
 *
 * @param {string} dataUrl A valid base64 data URL with one of the whitelisted
 *     media MIME types.
 * @return {?goog.html.SafeUrl} A matching safe URL, or `null` if it does not
 *     pass.
 */
goog.html.SafeUrl.tryFromDataUrl = function(dataUrl) {
  'use strict';
  // For defensive purposes, in case users cast around the parameter type.
  dataUrl = String(dataUrl);
  // RFC4648 suggest to ignore CRLF in base64 encoding.
  // See https://tools.ietf.org/html/rfc4648.
  // Remove the CR (%0D) and LF (%0A) from the dataUrl.
  var filteredDataUrl = dataUrl.replace(/(%0A|%0D)/g, '');
  var match = filteredDataUrl.match(goog.html.DATA_URL_PATTERN_);
  // Note: The only risk of XSS here is if the `data:` URL results in a
  // same-origin document. In which case content-sniffing might cause the
  // browser to interpret the contents as html.
  // All modern browsers consider `data:` URL documents to have unique empty
  // origins. Only Firefox for versions prior to v57 behaves differently:
  // https://blog.mozilla.org/security/2017/10/04/treating-data-urls-unique-origins-firefox-57/
  // Older versions of IE don't understand `data:` urls, so it is not an issue.
  var valid = match && goog.html.SafeUrl.isSafeMimeType(match[1]);
  if (valid) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
        filteredDataUrl);
  }
  return null;
};


/**
 * Creates a SafeUrl wrapping a `data:` URL, after validating it matches a
 * known-safe media MIME type. If it doesn't match, return
 * `goog.html.SafeUrl.INNOCUOUS_URL`.
 *
 * @param {string} dataUrl A valid base64 data URL with one of the whitelisted
 *     media MIME types.
 * @return {!goog.html.SafeUrl} A matching safe URL, or
 *     `goog.html.SafeUrl.INNOCUOUS_URL` if it does not pass.
 */
goog.html.SafeUrl.fromDataUrl = function(dataUrl) {
  'use strict';
  return goog.html.SafeUrl.tryFromDataUrl(dataUrl) ||
      goog.html.SafeUrl.INNOCUOUS_URL;
};


/**
 * Creates a SafeUrl wrapping a tel: URL.
 *
 * @param {string} telUrl A tel URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromTelUrl = function(telUrl) {
  'use strict';
  // There's a risk that a tel: URL could immediately place a call once
  // clicked, without requiring user confirmation. For that reason it is
  // handled in this separate function.
  if (!goog.string.internal.caseInsensitiveStartsWith(telUrl, 'tel:')) {
    telUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      telUrl);
};


/**
 * Matches a sip/sips URL. We only allow urls that consist of an email address.
 * The characters '?' and '#' are not allowed in the local part of the email
 * address.
 * @const
 * @private
 */
goog.html.SIP_URL_PATTERN_ = new RegExp(
    '^sip[s]?:[+a-z0-9_.!$%&\'*\\/=^`{|}~-]+@([a-z0-9-]+\\.)+[a-z0-9]{2,63}$',
    'i');


/**
 * Creates a SafeUrl wrapping a sip: URL. We only allow urls that consist of an
 * email address. The characters '?' and '#' are not allowed in the local part
 * of the email address.
 *
 * @param {string} sipUrl A sip URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromSipUrl = function(sipUrl) {
  'use strict';
  if (!goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(sipUrl))) {
    sipUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      sipUrl);
};


/**
 * Creates a SafeUrl wrapping a fb-messenger://share URL.
 *
 * @param {string} facebookMessengerUrl A facebook messenger URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromFacebookMessengerUrl = function(facebookMessengerUrl) {
  'use strict';
  if (!goog.string.internal.caseInsensitiveStartsWith(
          facebookMessengerUrl, 'fb-messenger://share')) {
    facebookMessengerUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      facebookMessengerUrl);
};

/**
 * Creates a SafeUrl wrapping a whatsapp://send URL.
 *
 * @param {string} whatsAppUrl A WhatsApp URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromWhatsAppUrl = function(whatsAppUrl) {
  'use strict';
  if (!goog.string.internal.caseInsensitiveStartsWith(
          whatsAppUrl, 'whatsapp://send')) {
    whatsAppUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      whatsAppUrl);
};

/**
 * Creates a SafeUrl wrapping a sms: URL.
 *
 * @param {string} smsUrl A sms URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromSmsUrl = function(smsUrl) {
  'use strict';
  if (!goog.string.internal.caseInsensitiveStartsWith(smsUrl, 'sms:') ||
      !goog.html.SafeUrl.isSmsUrlBodyValid_(smsUrl)) {
    smsUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      smsUrl);
};


/**
 * Validates SMS URL `body` parameter, which is optional and should appear at
 * most once and should be percent-encoded if present. Rejects many malformed
 * bodies, but may spuriously reject some URLs and does not reject all malformed
 * sms: URLs.
 *
 * @param {string} smsUrl A sms URL.
 * @return {boolean} Whether SMS URL has a valid `body` parameter if it exists.
 * @private
 */
goog.html.SafeUrl.isSmsUrlBodyValid_ = function(smsUrl) {
  'use strict';
  var hash = smsUrl.indexOf('#');
  if (hash > 0) {
    smsUrl = smsUrl.substring(0, hash);
  }
  var bodyParams = smsUrl.match(/[?&]body=/gi);
  // "body" param is optional
  if (!bodyParams) {
    return true;
  }
  // "body" MUST only appear once
  if (bodyParams.length > 1) {
    return false;
  }
  // Get the encoded `body` parameter value.
  var bodyValue = smsUrl.match(/[?&]body=([^&]*)/)[1];
  if (!bodyValue) {
    return true;
  }
  try {
    decodeURIComponent(bodyValue);
  } catch (error) {
    return false;
  }
  return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(bodyValue);
};


/**
 * Creates a SafeUrl wrapping a ssh: URL.
 *
 * @param {string} sshUrl A ssh URL.
 * @return {!goog.html.SafeUrl} A matching safe URL, or {@link INNOCUOUS_STRING}
 *     wrapped as a SafeUrl if it does not pass.
 */
goog.html.SafeUrl.fromSshUrl = function(sshUrl) {
  'use strict';
  if (!goog.string.internal.caseInsensitiveStartsWith(sshUrl, 'ssh://')) {
    sshUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      sshUrl);
};

/**
 * Sanitizes a Chrome extension URL to SafeUrl, given a compile-time-constant
 * extension identifier. Can also be restricted to chrome extensions.
 *
 * @param {string} url The url to sanitize. Should start with the extension
 *     scheme and the extension identifier.
 * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The
 *     extension id to accept, as a compile-time constant or an array of those.
 *
 * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or
 *     `INNOCUOUS_STRING` if it's not.
 */
goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(url, extensionId) {
  'use strict';
  return goog.html.SafeUrl.sanitizeExtensionUrl_(
      /^chrome-extension:\/\/([^\/]+)\//, url, extensionId);
};

/**
 * Sanitizes a Firefox extension URL to SafeUrl, given a compile-time-constant
 * extension identifier. Can also be restricted to chrome extensions.
 *
 * @param {string} url The url to sanitize. Should start with the extension
 *     scheme and the extension identifier.
 * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The
 *     extension id to accept, as a compile-time constant or an array of those.
 *
 * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or
 *     `INNOCUOUS_STRING` if it's not.
 */
goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(url, extensionId) {
  'use strict';
  return goog.html.SafeUrl.sanitizeExtensionUrl_(
      /^moz-extension:\/\/([^\/]+)\//, url, extensionId);
};

/**
 * Sanitizes a Edge extension URL to SafeUrl, given a compile-time-constant
 * extension identifier. Can also be restricted to chrome extensions.
 *
 * @param {string} url The url to sanitize. Should start with the extension
 *     scheme and the extension identifier.
 * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The
 *     extension id to accept, as a compile-time constant or an array of those.
 *
 * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or
 *     `INNOCUOUS_STRING` if it's not.
 */
goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(url, extensionId) {
  'use strict';
  return goog.html.SafeUrl.sanitizeExtensionUrl_(
      /^ms-browser-extension:\/\/([^\/]+)\//, url, extensionId);
};

/**
 * Private helper for converting extension URLs to SafeUrl, given the scheme for
 * that particular extension type. Use the sanitizeFirefoxExtensionUrl,
 * sanitizeChromeExtensionUrl or sanitizeEdgeExtensionUrl unless you're building
 * new helpers.
 *
 * @private
 * @param {!RegExp} scheme The scheme to accept as a RegExp extracting the
 *     extension identifier.
 * @param {string} url The url to sanitize. Should start with the extension
 *     scheme and the extension identifier.
 * @param {!goog.string.Const|!Array<!goog.string.Const>} extensionId The
 *     extension id to accept, as a compile-time constant or an array of those.
 *
 * @return {!goog.html.SafeUrl} Either `url` if it's deemed safe, or
 *     `INNOCUOUS_STRING` if it's not.
 */
goog.html.SafeUrl.sanitizeExtensionUrl_ = function(scheme, url, extensionId) {
  'use strict';
  var matches = scheme.exec(url);
  if (!matches) {
    url = goog.html.SafeUrl.INNOCUOUS_STRING;
  } else {
    var extractedExtensionId = matches[1];
    var acceptedExtensionIds;
    if (extensionId instanceof goog.string.Const) {
      acceptedExtensionIds = [goog.string.Const.unwrap(extensionId)];
    } else {
      acceptedExtensionIds = extensionId.map(function unwrap(x) {
        'use strict';
        return goog.string.Const.unwrap(x);
      });
    }
    if (acceptedExtensionIds.indexOf(extractedExtensionId) == -1) {
      url = goog.html.SafeUrl.INNOCUOUS_STRING;
    }
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};


/**
 * Creates a SafeUrl from TrustedResourceUrl. This is safe because
 * TrustedResourceUrl is more tightly restricted than SafeUrl.
 *
 * @param {!goog.html.TrustedResourceUrl} trustedResourceUrl
 * @return {!goog.html.SafeUrl}
 */
goog.html.SafeUrl.fromTrustedResourceUrl = function(trustedResourceUrl) {
  'use strict';
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
      goog.html.TrustedResourceUrl.unwrap(trustedResourceUrl));
};


/**
 * A pattern that recognizes a commonly useful subset of URLs that satisfy
 * the SafeUrl contract.
 *
 * This regular expression matches a subset of URLs that will not cause script
 * execution if used in URL context within a HTML document. Specifically, this
 * regular expression matches if (comment from here on and regex copied from
 * Soy's EscapingConventions):
 * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
 * (2) or no protocol.  A protocol must be followed by a colon. The below
 *     allows that by allowing colons only after one of the characters [/?#].
 *     A colon after a hash (#) must be in the fragment.
 *     Otherwise, a colon after a (?) must be in a query.
 *     Otherwise, a colon after a single solidus (/) must be in a path.
 *     Otherwise, a colon after a double solidus (//) must be in the authority
 *     (before port).
 *
 * @private
 * @const {!RegExp}
 */
goog.html.SAFE_URL_PATTERN_ =
    /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;

/**
 * Public version of goog.html.SAFE_URL_PATTERN_. Updating
 * goog.html.SAFE_URL_PATTERN_ doesn't seem to be backward compatible.
 * Namespace is also changed to goog.html.SafeUrl so it can be imported using
 * goog.require('goog.dom.SafeUrl').
 *
 * TODO(bangert): Remove SAFE_URL_PATTERN_
 * @const {!RegExp}
 */
goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_;

/**
 * Attempts to create a SafeUrl object from `url`. The input string is validated
 * to match a pattern of commonly used safe URLs. If validation fails, `null` is
 * returned.
 *
 * `url` may be a URL with the `http:`, `https:`, `mailto:`, `ftp:` or `data`
 * scheme, or a relative URL (i.e., a URL without a scheme; specifically, a
 * scheme-relative, absolute-path-relative, or path-relative URL).
 *
 * @see http://url.spec.whatwg.org/#concept-relative-url
 * @param {string|!goog.string.TypedString} url The URL to validate.
 * @return {?goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl, or null
 *     if validation fails.
 */
goog.html.SafeUrl.trySanitize = function(url) {
  'use strict';
  if (url instanceof goog.html.SafeUrl) {
    return url;
  }
  if (typeof url == 'object' && url.implementsGoogStringTypedString) {
    url = /** @type {!goog.string.TypedString} */ (url).getTypedStringValue();
  } else {
    // For defensive purposes, in case users cast around the parameter type.
    url = String(url);
  }
  if (!goog.html.SAFE_URL_PATTERN_.test(url)) {
    return goog.html.SafeUrl.tryFromDataUrl(url);
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};

/**
 * Creates a SafeUrl object from `url`. If `url` is a
 * `goog.html.SafeUrl` then it is simply returned. Otherwise the input string is
 * validated to match a pattern of commonly used safe URLs. If validation fails,
 * `goog.html.SafeUrl.INNOCUOUS_URL` is returned.
 *
 * `url` may be a URL with the `http:`, `https:`, `mailto:`, `ftp:` or `data`
 * scheme, or a relative URL (i.e., a URL without a scheme; specifically, a
 * scheme-relative, absolute-path-relative, or path-relative URL).
 *
 * @see http://url.spec.whatwg.org/#concept-relative-url
 * @param {string|!goog.string.TypedString} url The URL to validate.
 * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.
 */
goog.html.SafeUrl.sanitize = function(url) {
  'use strict';
  return goog.html.SafeUrl.trySanitize(url) || goog.html.SafeUrl.INNOCUOUS_URL;
};

/**
 * Creates a SafeUrl object from `url`. If `url` is a
 * `goog.html.SafeUrl` then it is simply returned. Otherwise the input string is
 * validated to match a pattern of commonly used safe URLs.
 *
 * `url` may be a URL with the http, https, mailto or ftp scheme,
 * or a relative URL (i.e., a URL without a scheme; specifically, a
 * scheme-relative, absolute-path-relative, or path-relative URL).
 *
 * This function asserts (using goog.asserts) that the URL matches this pattern.
 * If it does not, in addition to failing the assert, an innocuous URL will be
 * returned.
 *
 * @see http://url.spec.whatwg.org/#concept-relative-url
 * @param {string|!goog.string.TypedString} url The URL to validate.
 * @param {boolean=} opt_allowDataUrl Whether to allow valid data: URLs.
 * @return {!goog.html.SafeUrl} The validated URL, wrapped as a SafeUrl.
 */
goog.html.SafeUrl.sanitizeAssertUnchanged = function(url, opt_allowDataUrl) {
  'use strict';
  if (url instanceof goog.html.SafeUrl) {
    return url;
  } else if (typeof url == 'object' && url.implementsGoogStringTypedString) {
    url = /** @type {!goog.string.TypedString} */ (url).getTypedStringValue();
  } else {
    url = String(url);
  }
  if (opt_allowDataUrl && /^data:/i.test(url)) {
    var safeUrl = goog.html.SafeUrl.fromDataUrl(url);
    if (safeUrl.getTypedStringValue() == url) {
      return safeUrl;
    }
  }
  if (!goog.asserts.assert(
          goog.html.SAFE_URL_PATTERN_.test(url),
          '%s does not match the safe URL pattern', url)) {
    url = goog.html.SafeUrl.INNOCUOUS_STRING;
  }
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @private {!Object}
 * @const
 */
goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {};

/**
 * Package-internal utility method to create SafeUrl instances.
 *
 * @param {string} url The string to initialize the SafeUrl object with.
 * @return {!goog.html.SafeUrl} The initialized SafeUrl object.
 * @package
 */
goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(
    url) {
  'use strict';
  return new goog.html.SafeUrl(
      url, goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_);
};


/**
 * `INNOCUOUS_STRING` wrapped in a `SafeUrl`.
 * @const {!goog.html.SafeUrl}
 */
goog.html.SafeUrl.INNOCUOUS_URL =
    goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
        goog.html.SafeUrl.INNOCUOUS_STRING);


/**
 * A SafeUrl corresponding to the special about:blank url.
 * @const {!goog.html.SafeUrl}
 */
goog.html.SafeUrl.ABOUT_BLANK =
    goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(
        'about:blank');

//third_party/javascript/closure/html/safestyle.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeStyle type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeStyle');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const SafeUrl = goog.require('goog.html.SafeUrl');
const TypedString = goog.require('goog.string.TypedString');
const {AssertionError, assert, fail} = goog.require('goog.asserts');
const {contains, endsWith} = goog.require('goog.string.internal');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @type {!Object}
 * @const
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string-like object which represents a sequence of CSS declarations
 * (`propertyName1: propertyvalue1; propertyName2: propertyValue2; ...`)
 * and that carries the security type contract that its value, as a string,
 * will not cause untrusted script execution (XSS) when evaluated as CSS in a
 * browser.
 *
 * Instances of this type must be created via the factory methods
 * (`SafeStyle.create` or `SafeStyle.fromConstant`)
 * and not by invoking its constructor. The constructor intentionally takes an
 * extra parameter that cannot be constructed outside of this file and the type
 * is immutable; hence only a default instance corresponding to the empty string
 * can be obtained via constructor invocation.
 *
 * SafeStyle's string representation can safely be:
 * <ul>
 *   <li>Interpolated as the content of a *quoted* HTML style attribute.
 *       However, the SafeStyle string *must be HTML-attribute-escaped* before
 *       interpolation.
 *   <li>Interpolated as the content of a {}-wrapped block within a stylesheet.
 *       '<' characters in the SafeStyle string *must be CSS-escaped* before
 *       interpolation. The SafeStyle string is also guaranteed not to be able
 *       to introduce new properties or elide existing ones.
 *   <li>Interpolated as the content of a {}-wrapped block within an HTML
 *       &lt;style&gt; element. '<' characters in the SafeStyle string
 *       *must be CSS-escaped* before interpolation.
 *   <li>Assigned to the style property of a DOM node. The SafeStyle string
 *       should not be escaped before being assigned to the property.
 * </ul>
 *
 * A SafeStyle may never contain literal angle brackets. Otherwise, it could
 * be unsafe to place a SafeStyle into a &lt;style&gt; tag (where it can't
 * be HTML escaped). For example, if the SafeStyle containing
 * `font: 'foo &lt;style/&gt;&lt;script&gt;evil&lt;/script&gt;'` were
 * interpolated within a &lt;style&gt; tag, this would then break out of the
 * style context into HTML.
 *
 * A SafeStyle may contain literal single or double quotes, and as such the
 * entire style string must be escaped when used in a style attribute (if
 * this were not the case, the string could contain a matching quote that
 * would escape from the style attribute).
 *
 * Values of this type must be composable, i.e. for any two values
 * `style1` and `style2` of this type,
 * `SafeStyle.unwrap(style1) +
 * SafeStyle.unwrap(style2)` must itself be a value that satisfies
 * the SafeStyle type constraint. This requirement implies that for any value
 * `style` of this type, `SafeStyle.unwrap(style)` must
 * not end in a "property value" or "property name" context. For example,
 * a value of `background:url("` or `font-` would not satisfy the
 * SafeStyle contract. This is because concatenating such strings with a
 * second value that itself does not contain unsafe CSS can result in an
 * overall string that does. For example, if `javascript:evil())"` is
 * appended to `background:url("}, the resulting string may result in
 * the execution of a malicious script.
 *
 * TODO(mlourenco): Consider whether we should implement UTF-8 interchange
 * validity checks and blacklisting of newlines (including Unicode ones) and
 * other whitespace characters (\t, \f). Document here if so and also update
 * SafeStyle.fromConstant().
 *
 * The following example values comply with this type's contract:
 * <ul>
 *   <li><pre>width: 1em;</pre>
 *   <li><pre>height:1em;</pre>
 *   <li><pre>width: 1em;height: 1em;</pre>
 *   <li><pre>background:url('http://url');</pre>
 * </ul>
 * In addition, the empty string is safe for use in a CSS attribute.
 *
 * The following example values do NOT comply with this type's contract:
 * <ul>
 *   <li><pre>background: red</pre> (missing a trailing semi-colon)
 *   <li><pre>background:</pre> (missing a value and a trailing semi-colon)
 *   <li><pre>1em</pre> (missing an attribute name, which provides context for
 *       the value)
 * </ul>
 *
 * @see SafeStyle#create
 * @see SafeStyle#fromConstant
 * @see http://www.w3.org/TR/css3-syntax/
 * @final
 * @struct
 * @implements {TypedString}
 */
class SafeStyle {
  /**
   * @param {string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    /**
     * The contained value of this SafeStyle.  The field has a purposely
     * ugly name to make (non-compiled) code that attempts to directly access
     * this field stand out.
     * @private {string}
     */
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ =
        (token === CONSTRUCTOR_TOKEN_PRIVATE) ? value : '';

    /**
     * @override
     * @const {boolean}
     */
    this.implementsGoogStringTypedString = true;
  }


  /**
   * Creates a SafeStyle object from a compile-time constant string.
   *
   * `style` should be in the format
   * `name: value; [name: value; ...]` and must not have any < or >
   * characters in it. This is so that SafeStyle's contract is preserved,
   * allowing the SafeStyle to correctly be interpreted as a sequence of CSS
   * declarations and without affecting the syntactic structure of any
   * surrounding CSS and HTML.
   *
   * This method performs basic sanity checks on the format of `style`
   * but does not constrain the format of `name` and `value`, except
   * for disallowing tag characters.
   *
   * @param {!Const} style A compile-time-constant string from which
   *     to create a SafeStyle.
   * @return {!SafeStyle} A SafeStyle object initialized to
   *     `style`.
   */
  static fromConstant(style) {
    'use strict';
    const styleString = Const.unwrap(style);
    if (styleString.length === 0) {
      return SafeStyle.EMPTY;
    }
    assert(
        endsWith(styleString, ';'),
        `Last character of style string is not ';': ${styleString}`);
    assert(
        contains(styleString, ':'),
        'Style string must contain at least one \':\', to ' +
            'specify a "name: value" pair: ' + styleString);
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(
        styleString);
  };


  /**
   * Returns this SafeStyle's value as a string.
   *
   * IMPORTANT: In code where it is security relevant that an object's type is
   * indeed `SafeStyle`, use `SafeStyle.unwrap` instead of
   * this method. If in doubt, assume that it's security relevant. In
   * particular, note that goog.html functions which return a goog.html type do
   * not guarantee the returned instance is of the right type. For example:
   *
   * <pre>
   * var fakeSafeHtml = new String('fake');
   * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
   * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
   * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
   * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
   * // instanceof goog.html.SafeHtml.
   * </pre>
   *
   * @return {string}
   * @see SafeStyle#unwrap
   * @override
   */
  getTypedStringValue() {
    'use strict';
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
  }


  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a SafeStyle, use
   * `SafeStyle.unwrap`.
   *
   * @return {string}
   * @see SafeStyle#unwrap
   * @override
   */
  toString() {
    'use strict';
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_.toString();
  }


  /**
   * Performs a runtime check that the provided object is indeed a
   * SafeStyle object, and returns its value.
   *
   * @param {!SafeStyle} safeStyle The object to extract from.
   * @return {string} The safeStyle object's contained string, unless
   *     the run-time type check fails. In that case, `unwrap` returns an
   *     innocuous string, or, if assertions are enabled, throws
   *     `AssertionError`.
   */
  static unwrap(safeStyle) {
    'use strict';
    // Perform additional Run-time type-checking to ensure that
    // safeStyle is indeed an instance of the expected type.  This
    // provides some additional protection against security bugs due to
    // application code that disables type checks.
    // Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeStyle instanceof SafeStyle && safeStyle.constructor === SafeStyle) {
      return safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_;
    } else {
      fail(
          `expected object of type SafeStyle, got '${safeStyle}` +
          '\' of type ' + goog.typeOf(safeStyle));
      return 'type_error:SafeStyle';
    }
  }


  /**
   * Package-internal utility method to create SafeStyle instances.
   *
   * @param {string} style The string to initialize the SafeStyle object with.
   * @return {!SafeStyle} The initialized SafeStyle object.
   * @package
   */
  static createSafeStyleSecurityPrivateDoNotAccessOrElse(style) {
    'use strict';
    return new SafeStyle(style, CONSTRUCTOR_TOKEN_PRIVATE);
  }

  /**
   * Creates a new SafeStyle object from the properties specified in the map.
   * @param {!SafeStyle.PropertyMap} map Mapping of property names to
   *     their values, for example {'margin': '1px'}. Names must consist of
   *     [-_a-zA-Z0-9]. Values might be strings consisting of
   *     [-,.'"%_!# a-zA-Z0-9[\]], where ", ', and [] must be properly balanced.
   *     We also allow simple functions like rgb() and url() which sanitizes its
   *     contents. Other values must be wrapped in Const. URLs might
   *     be passed as SafeUrl which will be wrapped into url(""). We
   *     also support array whose elements are joined with ' '. Null value
   * causes skipping the property.
   * @return {!SafeStyle}
   * @throws {!Error} If invalid name is provided.
   * @throws {!AssertionError} If invalid value is provided. With
   *     disabled assertions, invalid value is replaced by
   *     SafeStyle.INNOCUOUS_STRING.
   */
  static create(map) {
    'use strict';
    let style = '';
    for (let name in map) {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
      if (Object.prototype.hasOwnProperty.call(map, name)) {
        if (!/^[-_a-zA-Z0-9]+$/.test(name)) {
          throw new Error(`Name allows only [-_a-zA-Z0-9], got: ${name}`);
        }
        let value = map[name];
        if (value == null) {
          continue;
        }
        if (Array.isArray(value)) {
          value = value.map(sanitizePropertyValue).join(' ');
        } else {
          value = sanitizePropertyValue(value);
        }
        style += `${name}:${value};`;
      }
    }
    if (!style) {
      return SafeStyle.EMPTY;
    }
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
  };

  /**
   * Creates a new SafeStyle object by concatenating the values.
   * @param {...(!SafeStyle|!Array<!SafeStyle>)} var_args
   *     SafeStyles to concatenate.
   * @return {!SafeStyle}
   */
  static concat(var_args) {
    'use strict';
    let style = '';

    /**
     * @param {!SafeStyle|!Array<!SafeStyle>} argument
     */
    const addArgument = argument => {
      'use strict';
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        style += SafeStyle.unwrap(argument);
      }
    };

    Array.prototype.forEach.call(arguments, addArgument);
    if (!style) {
      return SafeStyle.EMPTY;
    }
    return SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style);
  };
}

/**
 * A SafeStyle instance corresponding to the empty string.
 * @const {!SafeStyle}
 */
SafeStyle.EMPTY = SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse('');


/**
 * The innocuous string generated by SafeStyle.create when passed
 * an unsafe value.
 * @const {string}
 */
SafeStyle.INNOCUOUS_STRING = 'zClosurez';


/**
 * A single property value.
 * @typedef {string|!Const|!SafeUrl}
 */
SafeStyle.PropertyValue;


/**
 * Mapping of property names to their values.
 * We don't support numbers even though some values might be numbers (e.g.
 * line-height or 0 for any length). The reason is that most numeric values need
 * units (e.g. '1px') and allowing numbers could cause users forgetting about
 * them.
 * @typedef {!Object<string, ?SafeStyle.PropertyValue|
 *     ?Array<!SafeStyle.PropertyValue>>}
 */
SafeStyle.PropertyMap;



/**
 * Checks and converts value to string.
 * @param {!SafeStyle.PropertyValue} value
 * @return {string}
 */
function sanitizePropertyValue(value) {
  'use strict';
  if (value instanceof SafeUrl) {
    const url = SafeUrl.unwrap(value);
    return 'url("' + url.replace(/</g, '%3c').replace(/[\\"]/g, '\\$&') + '")';
  }
  const result = value instanceof Const ?
      Const.unwrap(value) :
      sanitizePropertyValueString(String(value));
  // These characters can be used to change context and we don't want that even
  // with const values.
  if (/[{;}]/.test(result)) {
    throw new AssertionError('Value does not allow [{;}], got: %s.', [result]);
  }
  return result;
}


/**
 * Checks string value.
 * @param {string} value
 * @return {string}
 */
function sanitizePropertyValueString(value) {
  'use strict';
  // Some CSS property values permit nested functions. We allow one level of
  // nesting, and all nested functions must also be in the FUNCTIONS_RE_ list.
  const valueWithoutFunctions = value.replace(FUNCTIONS_RE, '$1')
                                    .replace(FUNCTIONS_RE, '$1')
                                    .replace(URL_RE, 'url');
  if (!VALUE_RE.test(valueWithoutFunctions)) {
    fail(
        `String value allows only ${VALUE_ALLOWED_CHARS}` +
        ' and simple functions, got: ' + value);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (COMMENT_RE.test(value)) {
    fail(`String value disallows comments, got: ${value}`);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (!hasBalancedQuotes(value)) {
    fail(`String value requires balanced quotes, got: ${value}`);
    return SafeStyle.INNOCUOUS_STRING;
  } else if (!hasBalancedSquareBrackets(value)) {
    fail(
        'String value requires balanced square brackets and one' +
        ' identifier per pair of brackets, got: ' + value);
    return SafeStyle.INNOCUOUS_STRING;
  }
  return sanitizeUrl(value);
}


/**
 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
 * that neither escape (\) nor any other character that could result in
 * breaking out of a string parsing context are allowed;
 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
 * @param {string} value Untrusted CSS property value.
 * @return {boolean} True if property value is safe with respect to quote
 *     balancedness.
 */
function hasBalancedQuotes(value) {
  'use strict';
  let outsideSingle = true;
  let outsideDouble = true;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c == '\'' && outsideDouble) {
      outsideSingle = !outsideSingle;
    } else if (c == '"' && outsideSingle) {
      outsideDouble = !outsideDouble;
    }
  }
  return outsideSingle && outsideDouble;
}


/**
 * Checks that square brackets ([ and ]) are properly balanced inside a string,
 * and that the content in the square brackets is one ident-token;
 * see https://www.w3.org/TR/css-syntax-3/#ident-token-diagram.
 * For practicality, and in line with other restrictions posed on SafeStyle
 * strings, we restrict the character set allowable in the ident-token to
 * [-_a-zA-Z0-9].
 * @param {string} value Untrusted CSS property value.
 * @return {boolean} True if property value is safe with respect to square
 *     bracket balancedness.
 */
function hasBalancedSquareBrackets(value) {
  'use strict';
  let outside = true;
  const tokenRe = /^[-_a-zA-Z0-9]$/;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c == ']') {
      if (outside) return false;  // Unbalanced ].
      outside = true;
    } else if (c == '[') {
      if (!outside) return false;  // No nesting.
      outside = false;
    } else if (!outside && !tokenRe.test(c)) {
      return false;
    }
  }
  return outside;
}


/**
 * Characters allowed in VALUE_RE.
 * @type {string}
 */
const VALUE_ALLOWED_CHARS = '[-,."\'%_!# a-zA-Z0-9\\[\\]]';


/**
 * Regular expression for safe values.
 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure
 * they're balanced.
 * Square brackets ([ and ]) are allowed, but a check must be done elsewhere
 * to ensure they're balanced. The content inside a pair of square brackets must
 * be one alphanumeric identifier.
 * ',' allows multiple values to be assigned to the same property
 * (e.g. background-attachment or font-family) and hence could allow
 * multiple values to get injected, but that should pose no risk of XSS.
 * The expression checks only for XSS safety, not for CSS validity.
 * @const {!RegExp}
 */
const VALUE_RE = new RegExp(`^${VALUE_ALLOWED_CHARS}+\$`);


/**
 * Regular expression for url(). We support URLs allowed by
 * https://www.w3.org/TR/css-syntax-3/#url-token-diagram without using escape
 * sequences. Use percent-encoding if you need to use special characters like
 * backslash.
 * @const {!RegExp}
 */
const URL_RE = new RegExp(
    '\\b(url\\([ \t\n]*)(' +
        '\'[ -&(-\\[\\]-~]*\'' +  // Printable characters except ' and \.
        '|"[ !#-\\[\\]-~]*"' +    // Printable characters except " and \.
        '|[!#-&*-\\[\\]-~]*' +    // Printable characters except [ "'()\\].
        ')([ \t\n]*\\))',
    'g');

/**
 * Names of functions allowed in FUNCTIONS_RE.
 * @const {!Array<string>}
 */
const ALLOWED_FUNCTIONS = [
  'calc',
  'cubic-bezier',
  'fit-content',
  'hsl',
  'hsla',
  'linear-gradient',
  'matrix',
  'minmax',
  'repeat',
  'rgb',
  'rgba',
  '(rotate|scale|translate)(X|Y|Z|3d)?',
  'var',
];


/**
 * Regular expression for simple functions.
 * @const {!RegExp}
 */
const FUNCTIONS_RE = new RegExp(
    '\\b(' + ALLOWED_FUNCTIONS.join('|') + ')' +
        '\\([-+*/0-9a-z.%\\[\\], ]+\\)',
    'g');


/**
 * Regular expression for comments. These are disallowed in CSS property values.
 * @const {!RegExp}
 */
const COMMENT_RE = /\/\*/;


/**
 * Sanitize URLs inside url().
 * NOTE: We could also consider using CSS.escape once that's available in the
 * browsers. However, loosely matching URL e.g. with url\(.*\) and then escaping
 * the contents would result in a slightly different language than CSS leading
 * to confusion of users. E.g. url(")") is valid in CSS but it would be invalid
 * as seen by our parser. On the other hand, url(\) is invalid in CSS but our
 * parser would be fine with it.
 * @param {string} value Untrusted CSS property value.
 * @return {string}
 */
function sanitizeUrl(value) {
  'use strict';
  return value.replace(URL_RE, (match, before, url, after) => {
    'use strict';
    let quote = '';
    url = url.replace(/^(['"])(.*)\1$/, (match, start, inside) => {
      'use strict';
      quote = start;
      return inside;
    });
    const sanitized = SafeUrl.sanitize(url).getTypedStringValue();
    return before + quote + sanitized + quote + after;
  });
}


exports = SafeStyle;

;return exports;});

//third_party/javascript/closure/html/safestylesheet.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The SafeStyleSheet type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeStyleSheet');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const SafeStyle = goog.require('goog.html.SafeStyle');
const TypedString = goog.require('goog.string.TypedString');
const googObject = goog.require('goog.object');
const {assert, fail} = goog.require('goog.asserts');
const {contains} = goog.require('goog.string.internal');

/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @const {!Object}
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string-like object which represents a CSS style sheet and that carries the
 * security type contract that its value, as a string, will not cause untrusted
 * script execution (XSS) when evaluated as CSS in a browser.
 *
 * Instances of this type must be created via the factory method
 * `SafeStyleSheet.fromConstant` and not by invoking its constructor. The
 * constructor intentionally takes an extra parameter that cannot be constructed
 * outside of this file and the type is immutable; hence only a default instance
 * corresponding to the empty string can be obtained via constructor invocation.
 *
 * A SafeStyleSheet's string representation can safely be interpolated as the
 * content of a style element within HTML. The SafeStyleSheet string should
 * not be escaped before interpolation.
 *
 * Values of this type must be composable, i.e. for any two values
 * `styleSheet1` and `styleSheet2` of this type,
 * `SafeStyleSheet.unwrap(styleSheet1) + SafeStyleSheet.unwrap(styleSheet2)`
 * must itself be a value that satisfies the SafeStyleSheet type constraint.
 * This requirement implies that for any value `styleSheet` of this type,
 * `SafeStyleSheet.unwrap(styleSheet1)` must end in
 * "beginning of rule" context.
 *
 * A SafeStyleSheet can be constructed via security-reviewed unchecked
 * conversions. In this case producers of SafeStyleSheet must ensure themselves
 * that the SafeStyleSheet does not contain unsafe script. Note in particular
 * that `&lt;` is dangerous, even when inside CSS strings, and so should
 * always be forbidden or CSS-escaped in user controlled input. For example, if
 * `&lt;/style&gt;&lt;script&gt;evil&lt;/script&gt;"` were interpolated
 * inside a CSS string, it would break out of the context of the original
 * style element and `evil` would execute. Also note that within an HTML
 * style (raw text) element, HTML character references, such as
 * `&amp;lt;`, are not allowed. See
 * http://www.w3.org/TR/html5/scripting-1.html#restrictions-for-contents-of-script-elements
 * (similar considerations apply to the style element).
 *
 * @see SafeStyleSheet#fromConstant
 * @final
 * @implements {TypedString}
 */
class SafeStyleSheet {
  /**
   * @param {string} value
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, token) {
    /**
     * The contained value of this SafeStyleSheet.  The field has a purposely
     * ugly name to make (non-compiled) code that attempts to directly access
     * this field stand out.
     * @private {string}
     */
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ =
        (token === CONSTRUCTOR_TOKEN_PRIVATE) ? value : '';

    /**
     * @override
     * @const
     */
    this.implementsGoogStringTypedString = true;
  }

  /**
   * Creates a style sheet consisting of one selector and one style definition.
   * Use {@link SafeStyleSheet.concat} to create longer style sheets.
   * This function doesn't support @import, @media and similar constructs.
   * @param {string} selector CSS selector, e.g. '#id' or 'tag .class, #id'. We
   *     support CSS3 selectors: https://w3.org/TR/css3-selectors/#selectors.
   * @param {!SafeStyle.PropertyMap|!SafeStyle} style Style
   *     definition associated with the selector.
   * @return {!SafeStyleSheet}
   * @throws {!Error} If invalid selector is provided.
   */
  static createRule(selector, style) {
    if (contains(selector, '<')) {
      throw new Error(`Selector does not allow '<', got: ${selector}`);
    }

    // Remove strings.
    const selectorToCheck =
        selector.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, '');

    // Check characters allowed in CSS3 selectors.
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(selectorToCheck)) {
      throw new Error(
          'Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and ' +
          'strings, got: ' + selector);
    }

    // Check balanced () and [].
    if (!SafeStyleSheet.hasBalancedBrackets_(selectorToCheck)) {
      throw new Error(
          '() and [] in selector must be balanced, got: ' + selector);
    }

    if (!(style instanceof SafeStyle)) {
      style = SafeStyle.create(style);
    }
    const styleSheet =
        `${selector}{` + SafeStyle.unwrap(style).replace(/</g, '\\3C ') + '}';
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        styleSheet);
  }

  /**
   * Checks if a string has balanced () and [] brackets.
   * @param {string} s String to check.
   * @return {boolean}
   * @private
   */
  static hasBalancedBrackets_(s) {
    const brackets = {'(': ')', '[': ']'};
    const expectedBrackets = [];
    for (let i = 0; i < s.length; i++) {
      const ch = s[i];
      if (brackets[ch]) {
        expectedBrackets.push(brackets[ch]);
      } else if (googObject.contains(brackets, ch)) {
        if (expectedBrackets.pop() != ch) {
          return false;
        }
      }
    }
    return expectedBrackets.length == 0;
  }

  /**
   * Creates a new SafeStyleSheet object by concatenating values.
   * @param {...(!SafeStyleSheet|!Array<!SafeStyleSheet>)}
   *     var_args Values to concatenate.
   * @return {!SafeStyleSheet}
   */
  static concat(var_args) {
    let result = '';

    /**
     * @param {!SafeStyleSheet|!Array<!SafeStyleSheet>}
     *     argument
     */
    const addArgument = argument => {
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        result += SafeStyleSheet.unwrap(argument);
      }
    };

    Array.prototype.forEach.call(arguments, addArgument);
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        result);
  }

  /**
   * Creates a SafeStyleSheet object from a compile-time constant string.
   *
   * `styleSheet` must not have any &lt; characters in it, so that
   * the syntactic structure of the surrounding HTML is not affected.
   *
   * @param {!Const} styleSheet A compile-time-constant string from
   *     which to create a SafeStyleSheet.
   * @return {!SafeStyleSheet} A SafeStyleSheet object initialized to
   *     `styleSheet`.
   */
  static fromConstant(styleSheet) {
    const styleSheetString = Const.unwrap(styleSheet);
    if (styleSheetString.length === 0) {
      return SafeStyleSheet.EMPTY;
    }
    // > is a valid character in CSS selectors and there's no strict need to
    // block it if we already block <.
    assert(
        !contains(styleSheetString, '<'),
        `Forbidden '<' character in style sheet string: ${styleSheetString}`);
    return SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(
        styleSheetString);
  }

  /**
   * Returns this SafeStyleSheet's value as a string.
   *
   * IMPORTANT: In code where it is security relevant that an object's type is
   * indeed `SafeStyleSheet`, use `SafeStyleSheet.unwrap`
   * instead of this method. If in doubt, assume that it's security relevant. In
   * particular, note that goog.html functions which return a goog.html type do
   * not guarantee the returned instance is of the right type. For example:
   *
   * <pre>
   * var fakeSafeHtml = new String('fake');
   * fakeSafeHtml.__proto__ = goog.html.SafeHtml.prototype;
   * var newSafeHtml = goog.html.SafeHtml.htmlEscape(fakeSafeHtml);
   * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
   * // goog.html.SafeHtml.htmlEscape() as fakeSafeHtml
   * // instanceof goog.html.SafeHtml.
   * </pre>
   *
   * @see SafeStyleSheet#unwrap
   * @override
   */
  getTypedStringValue() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
  }

  /**
   * Performs a runtime check that the provided object is indeed a
   * SafeStyleSheet object, and returns its value.
   *
   * @param {!SafeStyleSheet} safeStyleSheet The object to extract from.
   * @return {string} The safeStyleSheet object's contained string, unless
   *     the run-time type check fails. In that case, `unwrap` returns an
   *     innocuous string, or, if assertions are enabled, throws
   *     `asserts.AssertionError`.
   */
  static unwrap(safeStyleSheet) {
    // Perform additional Run-time type-checking to ensure that
    // safeStyleSheet is indeed an instance of the expected type.  This
    // provides some additional protection against security bugs due to
    // application code that disables type checks.
    // Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeStyleSheet instanceof SafeStyleSheet &&
        safeStyleSheet.constructor === SafeStyleSheet) {
      return safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
    } else {
      fail(
          'expected object of type SafeStyleSheet, got \'' + safeStyleSheet +
          '\' of type ' + goog.typeOf(safeStyleSheet));
      return 'type_error:SafeStyleSheet';
    }
  }

  /**
   * Package-internal utility method to create SafeStyleSheet instances.
   *
   * @param {string} styleSheet The string to initialize the SafeStyleSheet
   *     object with.
   * @return {!SafeStyleSheet} The initialized SafeStyleSheet object.
   * @package
   */
  static createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet) {
    return new SafeStyleSheet(styleSheet, CONSTRUCTOR_TOKEN_PRIVATE);
  }
}

/**
 * Returns a string-representation of this value.
 *
 * To obtain the actual string value wrapped in a SafeStyleSheet, use
 * `SafeStyleSheet.unwrap`.
 *
 * @return {string}
 * @see SafeStyleSheet#unwrap
 * @override
 */
SafeStyleSheet.prototype.toString = function() {
  return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_.toString();
};


/**
 * A SafeStyleSheet instance corresponding to the empty string.
 * @const {!SafeStyleSheet}
 */
SafeStyleSheet.EMPTY =
    SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse('');


exports = SafeStyleSheet;

;return exports;});

//third_party/javascript/closure/html/safehtml.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview The SafeHtml type and its builders.
 *
 * TODO(xtof): Link to document stating type contract.
 */

goog.module('goog.html.SafeHtml');
goog.module.declareLegacyNamespace();

const Const = goog.require('goog.string.Const');
const Dir = goog.require('goog.i18n.bidi.Dir');
const DirectionalString = goog.require('goog.i18n.bidi.DirectionalString');
const SafeScript = goog.require('goog.html.SafeScript');
const SafeStyle = goog.require('goog.html.SafeStyle');
const SafeStyleSheet = goog.require('goog.html.SafeStyleSheet');
const SafeUrl = goog.require('goog.html.SafeUrl');
const TagName = goog.require('goog.dom.TagName');
const TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');
const TypedString = goog.require('goog.string.TypedString');
const asserts = goog.require('goog.asserts');
const browser = goog.require('goog.labs.userAgent.browser');
const googArray = goog.require('goog.array');
const googObject = goog.require('goog.object');
const internal = goog.require('goog.string.internal');
const tags = goog.require('goog.dom.tags');
const trustedtypes = goog.require('goog.html.trustedtypes');


/**
 * Token used to ensure that object is created only from this file. No code
 * outside of this file can access this token.
 * @type {!Object}
 * @const
 */
const CONSTRUCTOR_TOKEN_PRIVATE = {};

/**
 * A string that is safe to use in HTML context in DOM APIs and HTML documents.
 *
 * A SafeHtml is a string-like object that carries the security type contract
 * that its value as a string will not cause untrusted script execution when
 * evaluated as HTML in a browser.
 *
 * Values of this type are guaranteed to be safe to use in HTML contexts,
 * such as, assignment to the innerHTML DOM property, or interpolation into
 * a HTML template in HTML PC_DATA context, in the sense that the use will not
 * result in a Cross-Site-Scripting vulnerability.
 *
 * Instances of this type must be created via the factory methods
 * (`SafeHtml.create`, `SafeHtml.htmlEscape`),
 * etc and not by invoking its constructor. The constructor intentionally takes
 * an extra parameter that cannot be constructed outside of this file and the
 * type is immutable; hence only a default instance corresponding to the empty
 * string can be obtained via constructor invocation.
 *
 * Creating SafeHtml objects HAS SIDE-EFFECTS due to calling Trusted Types Web
 * API.
 *
 * Note that there is no `SafeHtml.fromConstant`. The reason is that
 * the following code would create an unsafe HTML:
 *
 * ```
 * SafeHtml.concat(
 *     SafeHtml.fromConstant(Const.from('<script>')),
 *     SafeHtml.htmlEscape(userInput),
 *     SafeHtml.fromConstant(Const.from('<\/script>')));
 * ```
 *
 * There's `goog.dom.constHtmlToNode` to create a node from constant strings
 * only.
 *
 * @see SafeHtml.create
 * @see SafeHtml.htmlEscape
 * @final
 * @struct
 * @implements {DirectionalString}
 * @implements {TypedString}
 */
class SafeHtml {
  /**
   * @param {!TrustedHTML|string} value
   * @param {?Dir} dir
   * @param {!Object} token package-internal implementation detail.
   */
  constructor(value, dir, token) {
    /**
     * The contained value of this SafeHtml.  The field has a purposely ugly
     * name to make (non-compiled) code that attempts to directly access this
     * field stand out.
     * @private {!TrustedHTML|string}
     */
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ =
        (token === CONSTRUCTOR_TOKEN_PRIVATE) ? value : '';

    /**
     * This SafeHtml's directionality, or null if unknown.
     * @private {?Dir}
     */
    this.dir_ = dir;

    /**
     * @override
     * @const
     */
    this.implementsGoogI18nBidiDirectionalString = true;

    /**
     * @override
     * @const {boolean}
     */
    this.implementsGoogStringTypedString = true;
  }

  /**
   * @return {?Dir}
   * @override
   */
  getDirection() {
    return this.dir_;
  }


  /**
   * Returns this SafeHtml's value as string.
   *
   * IMPORTANT: In code where it is security relevant that an object's type is
   * indeed `SafeHtml`, use `SafeHtml.unwrap` instead of
   * this method. If in doubt, assume that it's security relevant. In
   * particular, note that goog.html functions which return a goog.html type do
   * not guarantee that the returned instance is of the right type. For example:
   *
   * <pre>
   * var fakeSafeHtml = new String('fake');
   * fakeSafeHtml.__proto__ = SafeHtml.prototype;
   * var newSafeHtml = SafeHtml.htmlEscape(fakeSafeHtml);
   * // newSafeHtml is just an alias for fakeSafeHtml, it's passed through by
   * // SafeHtml.htmlEscape() as fakeSafeHtml
   * // instanceof SafeHtml.
   * </pre>
   *
   * @return {string}
   * @see SafeHtml.unwrap
   * @override
   */
  getTypedStringValue() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }


  /**
   * Returns a string-representation of this value.
   *
   * To obtain the actual string value wrapped in a SafeHtml, use
   * `SafeHtml.unwrap`.
   *
   * @return {string}
   * @see SafeHtml.unwrap
   * @override
   */
  toString() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }

  /**
   * Performs a runtime check that the provided object is indeed a SafeHtml
   * object, and returns its value.
   * @param {!SafeHtml} safeHtml The object to extract from.
   * @return {string} The SafeHtml object's contained string, unless the
   *     run-time type check fails. In that case, `unwrap` returns an innocuous
   *     string, or, if assertions are enabled, throws
   *     `asserts.AssertionError`.
   */
  static unwrap(safeHtml) {
    return SafeHtml.unwrapTrustedHTML(safeHtml).toString();
  }


  /**
   * Unwraps value as TrustedHTML if supported or as a string if not.
   * @param {!SafeHtml} safeHtml
   * @return {!TrustedHTML|string}
   * @see SafeHtml.unwrap
   */
  static unwrapTrustedHTML(safeHtml) {
    // Perform additional run-time type-checking to ensure that safeHtml is
    // indeed an instance of the expected type.  This provides some additional
    // protection against security bugs due to application code that disables
    // type checks. Specifically, the following checks are performed:
    // 1. The object is an instance of the expected type.
    // 2. The object is not an instance of a subclass.
    if (safeHtml instanceof SafeHtml && safeHtml.constructor === SafeHtml) {
      return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
    } else {
      asserts.fail(
          `expected object of type SafeHtml, got '${safeHtml}' of type ` +
          goog.typeOf(safeHtml));
      return 'type_error:SafeHtml';
    }
  }

  /**
   * Returns HTML-escaped text as a SafeHtml object.
   *
   * If text is of a type that implements
   * `DirectionalString`, the directionality of the new
   * `SafeHtml` object is set to `text`'s directionality, if known.
   * Otherwise, the directionality of the resulting SafeHtml is unknown (i.e.,
   * `null`).
   *
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   */
  static htmlEscape(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    const textIsObject = typeof textOrHtml == 'object';
    let dir = null;
    if (textIsObject && textOrHtml.implementsGoogI18nBidiDirectionalString) {
      dir = /** @type {!DirectionalString} */ (textOrHtml).getDirection();
    }
    let textAsString;
    if (textIsObject && textOrHtml.implementsGoogStringTypedString) {
      textAsString =
          /** @type {!TypedString} */ (textOrHtml).getTypedStringValue();
    } else {
      textAsString = String(textOrHtml);
    }
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.htmlEscape(textAsString), dir);
  }


  /**
   * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
   * &lt;br&gt;.
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   */
  static htmlEscapePreservingNewlines(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    const html = SafeHtml.htmlEscape(textOrHtml);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.newLineToBr(SafeHtml.unwrap(html)), html.getDirection());
  }


  /**
   * Returns HTML-escaped text as a SafeHtml object, with newlines changed to
   * &lt;br&gt; and escaping whitespace to preserve spatial formatting.
   * Character entity #160 is used to make it safer for XML.
   * @param {!SafeHtml.TextOrHtml_} textOrHtml The text to escape. If
   *     the parameter is of type SafeHtml it is returned directly (no escaping
   *     is done).
   * @return {!SafeHtml} The escaped text, wrapped as a SafeHtml.
   */
  static htmlEscapePreservingNewlinesAndSpaces(textOrHtml) {
    if (textOrHtml instanceof SafeHtml) {
      return textOrHtml;
    }
    const html = SafeHtml.htmlEscape(textOrHtml);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        internal.whitespaceEscape(SafeHtml.unwrap(html)), html.getDirection());
  }

  /**
   * Converts an arbitrary string into an HTML comment by HTML-escaping the
   * contents and embedding the result between HTML comment markers.
   *
   * Escaping is needed because Internet Explorer supports conditional comments
   * and so may render HTML markup within comments.
   *
   * @param {string} text
   * @return {!SafeHtml}
   */
  static comment(text) {
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        '<!--' + internal.htmlEscape(text) + '-->', null);
  }

  /**
   * Creates a SafeHtml content consisting of a tag with optional attributes and
   * optional content.
   *
   * For convenience tag names and attribute names are accepted as regular
   * strings, instead of Const. Nevertheless, you should not pass
   * user-controlled values to these parameters. Note that these parameters are
   * syntactically validated at runtime, and invalid values will result in
   * an exception.
   *
   * Example usage:
   *
   * SafeHtml.create('br');
   * SafeHtml.create('div', {'class': 'a'});
   * SafeHtml.create('p', {}, 'a');
   * SafeHtml.create('p', {}, SafeHtml.create('br'));
   *
   * SafeHtml.create('span', {
   *   'style': {'margin': '0'}
   * });
   *
   * To guarantee SafeHtml's type contract is upheld there are restrictions on
   * attribute values and tag names.
   *
   * - For attributes which contain script code (on*), a Const is
   *   required.
   * - For attributes which contain style (style), a SafeStyle or a
   *   SafeStyle.PropertyMap is required.
   * - For attributes which are interpreted as URLs (e.g. src, href) a
   *   SafeUrl, Const or string is required. If a string
   *   is passed, it will be sanitized with SafeUrl.sanitize().
   * - For tags which can load code or set security relevant page metadata,
   *   more specific SafeHtml.create*() functions must be used. Tags
   *   which are not supported by this function are applet, base, embed, iframe,
   *   link, math, meta, object, script, style, svg, and template.
   *
   * @param {!TagName|string} tagName The name of the tag. Only tag names
   *     consisting of [a-zA-Z0-9-] are allowed. Tag names documented above are
   *     disallowed.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. This must be empty for void tags like <br>. Array elements
   * are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided.
   * @throws {!asserts.AssertionError} If content for void tag is provided.
   */
  static create(tagName, attributes = undefined, content = undefined) {
    SafeHtml.verifyTagName(String(tagName));
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        String(tagName), attributes, content);
  }


  /**
   * Verifies if the tag name is valid and if it doesn't change the context.
   * E.g. STRONG is fine but SCRIPT throws because it changes context. See
   * SafeHtml.create for an explanation of allowed tags.
   * @param {string} tagName
   * @return {void}
   * @throws {!Error} If invalid tag name is provided.
   * @package
   */
  static verifyTagName(tagName) {
    if (!VALID_NAMES_IN_TAG.test(tagName)) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ? `Invalid tag name <${tagName}>.` :
                                           '');
    }
    if (tagName.toUpperCase() in NOT_ALLOWED_TAG_NAMES) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?

              `Tag name <${tagName}> is not allowed for SafeHtml.` :
              '');
    }
  }


  /**
   * Creates a SafeHtml representing an iframe tag.
   *
   * This by default restricts the iframe as much as possible by setting the
   * sandbox attribute to the empty string. If the iframe requires less
   * restrictions, set the sandbox attribute as tight as possible, but do not
   * rely on the sandbox as a security feature because it is not supported by
   * older browsers. If a sandbox is essential to security (e.g. for third-party
   * frames), use createSandboxIframe which checks for browser support.
   *
   * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
   *
   * @param {?TrustedResourceUrl=} src The value of the src
   *     attribute. If null or undefined src will not be set.
   * @param {?SafeHtml=} srcdoc The value of the srcdoc attribute.
   *     If null or undefined srcdoc will not be set.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. Array elements are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided. If attributes
   * contains the src or srcdoc attributes.
   */
  static createIframe(
      src = undefined, srcdoc = undefined, attributes = undefined,
      content = undefined) {
    if (src) {
      // Check whether this is really TrustedResourceUrl.
      TrustedResourceUrl.unwrap(src);
    }

    const fixedAttributes = {};
    fixedAttributes['src'] = src || null;
    fixedAttributes['srcdoc'] = srcdoc && SafeHtml.unwrap(srcdoc);
    const defaultAttributes = {'sandbox': ''};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'iframe', combinedAttrs, content);
  }


  /**
   * Creates a SafeHtml representing a sandboxed iframe tag.
   *
   * The sandbox attribute is enforced in its most restrictive mode, an empty
   * string. Consequently, the security requirements for the src and srcdoc
   * attributes are relaxed compared to SafeHtml.createIframe. This function
   * will throw on browsers that do not support the sandbox attribute, as
   * determined by SafeHtml.canUseSandboxIframe.
   *
   * The SafeHtml returned by this function can trigger downloads with no
   * user interaction on Chrome (though only a few, further attempts are
   * blocked). Firefox and IE will block all downloads from the sandbox.
   *
   * @see https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe#attr-sandbox
   * @see https://lists.w3.org/Archives/Public/public-whatwg-archive/2013Feb/0112.html
   *
   * @param {string|!SafeUrl=} src The value of the src
   *     attribute. If null or undefined src will not be set.
   * @param {string=} srcdoc The value of the srcdoc attribute.
   *     If null or undefined srcdoc will not be set. Will not be sanitized.
   * @param {!Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content Content to HTML-escape and put
   * inside the tag. Array elements are concatenated.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid tag name, attribute name, or attribute value is
   *     provided. If attributes
   * contains the src, srcdoc or sandbox attributes. If browser does not support
   * the sandbox attribute on iframe.
   */
  static createSandboxIframe(
      src = undefined, srcdoc = undefined, attributes = undefined,
      content = undefined) {
    if (!SafeHtml.canUseSandboxIframe()) {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?
              'The browser does not support sandboxed iframes.' :
              '');
    }

    const fixedAttributes = {};
    if (src) {
      // Note that sanitize is a no-op on SafeUrl.
      fixedAttributes['src'] = SafeUrl.unwrap(SafeUrl.sanitize(src));
    } else {
      fixedAttributes['src'] = null;
    }
    fixedAttributes['srcdoc'] = srcdoc || null;
    fixedAttributes['sandbox'] = '';
    const combinedAttrs =
        SafeHtml.combineAttributes(fixedAttributes, {}, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'iframe', combinedAttrs, content);
  }


  /**
   * Checks if the user agent supports sandboxed iframes.
   * @return {boolean}
   */
  static canUseSandboxIframe() {
    return goog.global['HTMLIFrameElement'] &&
        ('sandbox' in goog.global['HTMLIFrameElement'].prototype);
  }


  /**
   * Creates a SafeHtml representing a script tag with the src attribute.
   * @param {!TrustedResourceUrl} src The value of the src
   * attribute.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=}
   * attributes
   *     Mapping from attribute names to their values. Only attribute names
   *     consisting of [a-zA-Z0-9-] are allowed. Value of null or undefined
   *     causes the attribute to be omitted.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid attribute name or value is provided. If
   *     attributes  contains the
   * src attribute.
   */
  static createScriptSrc(src, attributes = undefined) {
    // TODO(mlourenco): The charset attribute should probably be blocked. If
    // its value is attacker controlled, the script contains attacker controlled
    // sub-strings (even if properly escaped) and the server does not set
    // charset then XSS is likely possible.
    // https://html.spec.whatwg.org/multipage/scripting.html#dom-script-charset

    // Check whether this is really TrustedResourceUrl.
    TrustedResourceUrl.unwrap(src);

    const fixedAttributes = {'src': src};
    const defaultAttributes = {};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'script', combinedAttrs);
  }


  /**
   * Creates a SafeHtml representing a script tag. Does not allow the language,
   * src, text or type attributes to be set.
   * @param {!SafeScript|!Array<!SafeScript>}
   *     script Content to put inside the tag. Array elements are
   *     concatenated.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid attribute name or attribute value is provided.
   *     If attributes  contains the
   *     language, src, text or type attribute.
   */
  static createScript(script, attributes = undefined) {
    for (let attr in attributes) {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        const attrLower = attr.toLowerCase();
        if (attrLower == 'language' || attrLower == 'src' ||
            attrLower == 'text' || attrLower == 'type') {
          throw new Error(
              SafeHtml.ENABLE_ERROR_MESSAGES ?
                  `Cannot set "${attrLower}" attribute` :
                  '');
        }
      }
    }

    let content = '';
    script = googArray.concat(script);
    for (let i = 0; i < script.length; i++) {
      content += SafeScript.unwrap(script[i]);
    }
    // Convert to SafeHtml so that it's not HTML-escaped. This is safe because
    // as part of its contract, SafeScript should have no dangerous '<'.
    const htmlContent = SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        content, Dir.NEUTRAL);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'script', attributes, htmlContent);
  }


  /**
   * Creates a SafeHtml representing a style tag. The type attribute is set
   * to "text/css".
   * @param {!SafeStyleSheet|!Array<!SafeStyleSheet>}
   *     styleSheet Content to put inside the tag. Array elements are
   *     concatenated.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Mapping
   *     from attribute names to their values. Only attribute names consisting
   *     of [a-zA-Z0-9-] are allowed. Value of null or undefined causes the
   *     attribute to be omitted.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   * @throws {!Error} If invalid attribute name or attribute value is provided.
   *     If attributes  contains the
   *     type attribute.
   */
  static createStyle(styleSheet, attributes = undefined) {
    const fixedAttributes = {'type': 'text/css'};
    const defaultAttributes = {};
    const combinedAttrs = SafeHtml.combineAttributes(
        fixedAttributes, defaultAttributes, attributes);

    let content = '';
    styleSheet = googArray.concat(styleSheet);
    for (let i = 0; i < styleSheet.length; i++) {
      content += SafeStyleSheet.unwrap(styleSheet[i]);
    }
    // Convert to SafeHtml so that it's not HTML-escaped. This is safe because
    // as part of its contract, SafeStyleSheet should have no dangerous '<'.
    const htmlContent = SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        content, Dir.NEUTRAL);
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'style', combinedAttrs, htmlContent);
  }


  /**
   * Creates a SafeHtml representing a meta refresh tag.
   * @param {!SafeUrl|string} url Where to redirect. If a string is
   *     passed, it will be sanitized with SafeUrl.sanitize().
   * @param {number=} secs Number of seconds until the page should be
   *     reloaded. Will be set to 0 if unspecified.
   * @return {!SafeHtml} The SafeHtml content with the tag.
   */
  static createMetaRefresh(url, secs = undefined) {
    // Note that sanitize is a no-op on SafeUrl.
    let unwrappedUrl = SafeUrl.unwrap(SafeUrl.sanitize(url));

    if (browser.isIE() || browser.isEdge()) {
      // IE/EDGE can't parse the content attribute if the url contains a
      // semicolon. We can fix this by adding quotes around the url, but then we
      // can't parse quotes in the URL correctly. Also, it seems that IE/EDGE
      // did not unescape semicolons in these URLs at some point in the past. We
      // take a best-effort approach.
      //
      // If the URL has semicolons (which may happen in some cases, see
      // http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2
      // for instance), wrap it in single quotes to protect the semicolons.
      // If the URL has semicolons and single quotes, url-encode the single
      // quotes as well.
      //
      // This is imperfect. Notice that both ' and ; are reserved characters in
      // URIs, so this could do the wrong thing, but at least it will do the
      // wrong thing in only rare cases.
      if (internal.contains(unwrappedUrl, ';')) {
        unwrappedUrl = '\'' + unwrappedUrl.replace(/'/g, '%27') + '\'';
      }
    }
    const attributes = {
      'http-equiv': 'refresh',
      'content': (secs || 0) + '; url=' + unwrappedUrl,
    };

    // This function will handle the HTML escaping for attributes.
    return SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
        'meta', attributes);
  }

  /**
   * Creates a SafeHtml content with known directionality consisting of a tag
   * with optional attributes and optional content.
   * @param {!Dir} dir Directionality.
   * @param {string} tagName
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes
   * @param {!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>=} content
   * @return {!SafeHtml} The SafeHtml content with the tag.
   */
  static createWithDir(
      dir, tagName, attributes = undefined, content = undefined) {
    const html = SafeHtml.create(tagName, attributes, content);
    html.dir_ = dir;
    return html;
  }


  /**
   * Creates a new SafeHtml object by joining the parts with separator.
   * @param {!SafeHtml.TextOrHtml_} separator
   * @param {!Array<!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>>} parts Parts to join. If a part
   *     contains an array then each member of this array is also joined with
   * the separator.
   * @return {!SafeHtml}
   */
  static join(separator, parts) {
    const separatorHtml = SafeHtml.htmlEscape(separator);
    let dir = separatorHtml.getDirection();
    const content = [];

    /**
     * @param {!SafeHtml.TextOrHtml_|
     *     !Array<!SafeHtml.TextOrHtml_>} argument
     */
    const addArgument = (argument) => {
      if (Array.isArray(argument)) {
        argument.forEach(addArgument);
      } else {
        const html = SafeHtml.htmlEscape(argument);
        content.push(SafeHtml.unwrap(html));
        const htmlDir = html.getDirection();
        if (dir == Dir.NEUTRAL) {
          dir = htmlDir;
        } else if (htmlDir != Dir.NEUTRAL && dir != htmlDir) {
          dir = null;
        }
      }
    };

    parts.forEach(addArgument);
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        content.join(SafeHtml.unwrap(separatorHtml)), dir);
  }


  /**
   * Creates a new SafeHtml object by concatenating values.
   * @param {...(!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>)} var_args Values to concatenate.
   * @return {!SafeHtml}
   */
  static concat(var_args) {
    return SafeHtml.join(SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
  }


  /**
   * Creates a new SafeHtml object with known directionality by concatenating
   * the values.
   * @param {!Dir} dir Directionality.
   * @param {...(!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>)} var_args Elements of array
   *     arguments would be processed recursively.
   * @return {!SafeHtml}
   */
  static concatWithDir(dir, var_args) {
    const html = SafeHtml.concat(Array.prototype.slice.call(arguments, 1));
    html.dir_ = dir;
    return html;
  }

  /**
   * Package-internal utility method to create SafeHtml instances.
   *
   * @param {string} html The string to initialize the SafeHtml object with.
   * @param {?Dir} dir The directionality of the SafeHtml to be
   *     constructed, or null if unknown.
   * @return {!SafeHtml} The initialized SafeHtml object.
   * @package
   */
  static createSafeHtmlSecurityPrivateDoNotAccessOrElse(html, dir) {
    const policy = trustedtypes.getPolicyPrivateDoNotAccessOrElse();
    const trustedHtml = policy ? policy.createHTML(html) : html;
    return new SafeHtml(trustedHtml, dir, CONSTRUCTOR_TOKEN_PRIVATE);
  }


  /**
   * Like create() but does not restrict which tags can be constructed.
   *
   * @param {string} tagName Tag name. Set or validated by caller.
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes
   * @param {(!SafeHtml.TextOrHtml_|
   *     !Array<!SafeHtml.TextOrHtml_>)=} content
   * @return {!SafeHtml}
   * @throws {!Error} If invalid or unsafe attribute name or value is provided.
   * @throws {!asserts.AssertionError} If content for void tag is provided.
   * @package
   */
  static createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(
      tagName, attributes = undefined, content = undefined) {
    let dir = null;
    let result = `<${tagName}`;
    result += SafeHtml.stringifyAttributes(tagName, attributes);

    if (content == null) {
      content = [];
    } else if (!Array.isArray(content)) {
      content = [content];
    }

    if (tags.isVoidTag(tagName.toLowerCase())) {
      asserts.assert(
          !content.length, `Void tag <${tagName}> does not allow content.`);
      result += '>';
    } else {
      const html = SafeHtml.concat(content);
      result += '>' + SafeHtml.unwrap(html) + '</' + tagName + '>';
      dir = html.getDirection();
    }

    const dirAttribute = attributes && attributes['dir'];
    if (dirAttribute) {
      if (/^(ltr|rtl|auto)$/i.test(dirAttribute)) {
        // If the tag has the "dir" attribute specified then its direction is
        // neutral because it can be safely used in any context.
        dir = Dir.NEUTRAL;
      } else {
        dir = null;
      }
    }

    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(result, dir);
  }


  /**
   * Creates a string with attributes to insert after tagName.
   * @param {string} tagName
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes
   * @return {string} Returns an empty string if there are no attributes,
   *     returns a string starting with a space otherwise.
   * @throws {!Error} If attribute value is unsafe for the given tag and
   *     attribute.
   * @package
   */
  static stringifyAttributes(tagName, attributes = undefined) {
    let result = '';
    if (attributes) {
      for (let name in attributes) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
        if (Object.prototype.hasOwnProperty.call(attributes, name)) {
          if (!VALID_NAMES_IN_TAG.test(name)) {
            throw new Error(
                SafeHtml.ENABLE_ERROR_MESSAGES ?
                    `Invalid attribute name "${name}".` :
                    '');
          }
          const value = attributes[name];
          if (value == null) {
            continue;
          }
          result += ' ' + getAttrNameAndValue(tagName, name, value);
        }
      }
    }
    return result;
  }


  /**
   * @param {!Object<string, ?SafeHtml.AttributeValue>} fixedAttributes
   * @param {!Object<string, string>} defaultAttributes
   * @param {?Object<string, ?SafeHtml.AttributeValue>=} attributes  Optional
   *     attributes passed to create*().
   * @return {!Object<string, ?SafeHtml.AttributeValue>}
   * @throws {!Error} If attributes contains an attribute with the same name as
   *     an attribute in fixedAttributes.
   * @package
   */
  static combineAttributes(
      fixedAttributes, defaultAttributes, attributes = undefined) {
    const combinedAttributes = {};

    for (const name in fixedAttributes) {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty#Using_hasOwnProperty_as_a_property_name
      if (Object.prototype.hasOwnProperty.call(fixedAttributes, name)) {
        asserts.assert(name.toLowerCase() == name, 'Must be lower case');
        combinedAttributes[name] = fixedAttributes[name];
      }
    }
    for (const name in defaultAttributes) {
      if (Object.prototype.hasOwnProperty.call(defaultAttributes, name)) {
        asserts.assert(name.toLowerCase() == name, 'Must be lower case');
        combinedAttributes[name] = defaultAttributes[name];
      }
    }

    if (attributes) {
      for (const name in attributes) {
        if (Object.prototype.hasOwnProperty.call(attributes, name)) {
          const nameLower = name.toLowerCase();
          if (nameLower in fixedAttributes) {
            throw new Error(
                SafeHtml.ENABLE_ERROR_MESSAGES ?
                    `Cannot override "${nameLower}" attribute, got "` + name +
                        '" with value "' + attributes[name] + '"' :
                    '');
          }
          if (nameLower in defaultAttributes) {
            delete combinedAttributes[nameLower];
          }
          combinedAttributes[name] = attributes[name];
        }
      }
    }

    return combinedAttributes;
  }
}


/**
 * @define {boolean} Whether to strip out error messages or to leave them in.
 */
SafeHtml.ENABLE_ERROR_MESSAGES =
    goog.define('goog.html.SafeHtml.ENABLE_ERROR_MESSAGES', goog.DEBUG);


/**
 * Whether the `style` attribute is supported. Set to false to avoid the byte
 * weight of `SafeStyle` where unneeded. An error will be thrown if
 * the `style` attribute is used.
 * @define {boolean}
 */
SafeHtml.SUPPORT_STYLE_ATTRIBUTE =
    goog.define('goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE', true);


/**
 * Shorthand for union of types that can sensibly be converted to strings
 * or might already be SafeHtml (as SafeHtml is a TypedString).
 * @private
 * @typedef {string|number|boolean|!TypedString|
 *           !DirectionalString}
 */
SafeHtml.TextOrHtml_;


/**
 * Coerces an arbitrary object into a SafeHtml object.
 *
 * If `textOrHtml` is already of type `SafeHtml`, the same
 * object is returned. Otherwise, `textOrHtml` is coerced to string, and
 * HTML-escaped. If `textOrHtml` is of a type that implements
 * `DirectionalString`, its directionality, if known, is
 * preserved.
 *
 * @param {!SafeHtml.TextOrHtml_} textOrHtml The text or SafeHtml to
 *     coerce.
 * @return {!SafeHtml} The resulting SafeHtml object.
 * @deprecated Use SafeHtml.htmlEscape.
 */
SafeHtml.from = SafeHtml.htmlEscape;


/**
 * @const
 */
const VALID_NAMES_IN_TAG = /^[a-zA-Z0-9-]+$/;


/**
 * Set of attributes containing URL as defined at
 * http://www.w3.org/TR/html5/index.html#attributes-1.
 * @const {!Object<string,boolean>}
 */
const URL_ATTRIBUTES = googObject.createSet(
    'action', 'cite', 'data', 'formaction', 'href', 'manifest', 'poster',
    'src');


/**
 * Tags which are unsupported via create(). They might be supported via a
 * tag-specific create method. These are tags which might require a
 * TrustedResourceUrl in one of their attributes or a restricted type for
 * their content.
 * @const {!Object<string,boolean>}
 */
const NOT_ALLOWED_TAG_NAMES = googObject.createSet(
    TagName.APPLET, TagName.BASE, TagName.EMBED, TagName.IFRAME, TagName.LINK,
    TagName.MATH, TagName.META, TagName.OBJECT, TagName.SCRIPT, TagName.STYLE,
    TagName.SVG, TagName.TEMPLATE);


/**
 * @typedef {string|number|!TypedString|
 *     !SafeStyle.PropertyMap|undefined|null}
 */
SafeHtml.AttributeValue;


/**
 * @param {string} tagName The tag name.
 * @param {string} name The attribute name.
 * @param {!SafeHtml.AttributeValue} value The attribute value.
 * @return {string} A "name=value" string.
 * @throws {!Error} If attribute value is unsafe for the given tag and
 *     attribute.
 * @private
 */
function getAttrNameAndValue(tagName, name, value) {
  // If it's goog.string.Const, allow any valid attribute name.
  if (value instanceof Const) {
    value = Const.unwrap(value);
  } else if (name.toLowerCase() == 'style') {
    if (SafeHtml.SUPPORT_STYLE_ATTRIBUTE) {
      value = getStyleValue(value);
    } else {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' :
                                           '');
    }
  } else if (/^on/i.test(name)) {
    // TODO(jakubvrana): Disallow more attributes with a special meaning.
    throw new Error(
        SafeHtml.ENABLE_ERROR_MESSAGES ? `Attribute "${name}` +
                '" requires goog.string.Const value, "' + value + '" given.' :
                                         '');
    // URL attributes handled differently according to tag.
  } else if (name.toLowerCase() in URL_ATTRIBUTES) {
    if (value instanceof TrustedResourceUrl) {
      value = TrustedResourceUrl.unwrap(value);
    } else if (value instanceof SafeUrl) {
      value = SafeUrl.unwrap(value);
    } else if (typeof value === 'string') {
      value = SafeUrl.sanitize(value).getTypedStringValue();
    } else {
      throw new Error(
          SafeHtml.ENABLE_ERROR_MESSAGES ?
              `Attribute "${name}" on tag "${tagName}` +
                  '" requires goog.html.SafeUrl, goog.string.Const, or' +
                  ' string, value "' + value + '" given.' :
              '');
    }
  }

  // Accept SafeUrl, TrustedResourceUrl, etc. for attributes which only require
  // HTML-escaping.
  if (value.implementsGoogStringTypedString) {
    // Ok to call getTypedStringValue() since there's no reliance on the type
    // contract for security here.
    value =
        /** @type {!TypedString} */ (value).getTypedStringValue();
  }

  asserts.assert(
      typeof value === 'string' || typeof value === 'number',
      'String or number value expected, got ' + (typeof value) +
          ' with value: ' + value);
  return `${name}="` + internal.htmlEscape(String(value)) + '"';
}


/**
 * Gets value allowed in "style" attribute.
 * @param {!SafeHtml.AttributeValue} value It could be SafeStyle or a
 *     map which will be passed to SafeStyle.create.
 * @return {string} Unwrapped value.
 * @throws {!Error} If string value is given.
 * @private
 */
function getStyleValue(value) {
  if (!goog.isObject(value)) {
    throw new Error(
        SafeHtml.ENABLE_ERROR_MESSAGES ?
            'The "style" attribute requires goog.html.SafeStyle or map ' +
                'of style properties, ' + (typeof value) + ' given: ' + value :
            '');
  }
  if (!(value instanceof SafeStyle)) {
    // Process the property bag into a style object.
    value = SafeStyle.create(value);
  }
  return SafeStyle.unwrap(value);
}


/**
 * A SafeHtml instance corresponding to the HTML doctype: "<!DOCTYPE html>".
 * @const {!SafeHtml}
 */
SafeHtml.DOCTYPE_HTML = /** @type {!SafeHtml} */ ({
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // SafeHtml creation (due to calling trustedTypes.createPolicy) from the
  // compiler so that the entire call can be removed if the result is not used.
  // MOE:begin_strip
  // TODO(b/155299094): Refactor after adding compiler support.
  // MOE:end_strip
  valueOf: function() {
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        '<!DOCTYPE html>', Dir.NEUTRAL);
  },
}.valueOf());

/**
 * A SafeHtml instance corresponding to the empty string.
 * @const {!SafeHtml}
 */
SafeHtml.EMPTY = new SafeHtml(
    (goog.global.trustedTypes && goog.global.trustedTypes.emptyHTML) || '',
    Dir.NEUTRAL, CONSTRUCTOR_TOKEN_PRIVATE);

/**
 * A SafeHtml instance corresponding to the <br> tag.
 * @const {!SafeHtml}
 */
SafeHtml.BR = /** @type {!SafeHtml} */ ({
  // NOTE: this compiles to nothing, but hides the possible side effect of
  // SafeHtml creation (due to calling trustedTypes.createPolicy) from the
  // compiler so that the entire call can be removed if the result is not used.
  // MOE:begin_strip
  // TODO(b/155299094): Refactor after adding compiler support.
  // MOE:end_strip
  valueOf: function() {
    return SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        '<br>', Dir.NEUTRAL);
  },
}.valueOf());


exports = SafeHtml;

;return exports;});

//third_party/javascript/closure/html/uncheckedconversions.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Unchecked conversions to create values of goog.html types from
 * plain strings.  Use of these functions could potentially result in instances
 * of goog.html types that violate their type contracts, and hence result in
 * security vulnerabilties.
 *
 * Therefore, all uses of the methods herein must be carefully security
 * reviewed.  Avoid use of the methods in this file whenever possible; instead
 * prefer to create instances of goog.html types using inherently safe builders
 * or template systems.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * MOE:begin_intracomment_strip
 * MAINTAINERS: Use of these functions is detected with a Tricorder analyzer.
 * If adding functions here also add them to analyzer's list at
 * j/c/g/devtools/staticanalysis/pipeline/analyzers/shared/SafeHtmlAnalyzers.java.
 * MOE:end_intracomment_strip
 */


goog.provide('goog.html.uncheckedconversions');

goog.require('goog.asserts');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.string.Const');
goog.require('goog.string.internal');
goog.requireType('goog.i18n.bidi.Dir');


/**
 * Performs an "unchecked conversion" to SafeHtml from a plain string that is
 * known to satisfy the SafeHtml type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `html` satisfies the SafeHtml type contract in all
 * possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} html A string that is claimed to adhere to the SafeHtml
 *     contract.
 * @param {?goog.i18n.bidi.Dir=} opt_dir The optional directionality of the
 *     SafeHtml to be constructed. A null or undefined value signifies an
 *     unknown directionality.
 * @return {!goog.html.SafeHtml} The value of html, wrapped in a SafeHtml
 *     object.
 */
goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract =
    function(justification, html, opt_dir) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
      html, opt_dir || null);
};


/**
 * Performs an "unchecked conversion" to SafeScript from a plain string that is
 * known to satisfy the SafeScript type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `script` satisfies the SafeScript type contract in
 * all possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} script The string to wrap as a SafeScript.
 * @return {!goog.html.SafeScript} The value of `script`, wrapped in a
 *     SafeScript object.
 */
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract =
    function(justification, script) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(
      script);
};


/**
 * Performs an "unchecked conversion" to SafeStyle from a plain string that is
 * known to satisfy the SafeStyle type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `style` satisfies the SafeStyle type contract in all
 * possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} style The string to wrap as a SafeStyle.
 * @return {!goog.html.SafeStyle} The value of `style`, wrapped in a
 *     SafeStyle object.
 */
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract =
    function(justification, style) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(
      style);
};


/**
 * Performs an "unchecked conversion" to SafeStyleSheet from a plain string
 * that is known to satisfy the SafeStyleSheet type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `styleSheet` satisfies the SafeStyleSheet type
 * contract in all possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} styleSheet The string to wrap as a SafeStyleSheet.
 * @return {!goog.html.SafeStyleSheet} The value of `styleSheet`, wrapped
 *     in a SafeStyleSheet object.
 */
goog.html.uncheckedconversions
    .safeStyleSheetFromStringKnownToSatisfyTypeContract = function(
    justification, styleSheet) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.SafeStyleSheet
      .createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet);
};


/**
 * Performs an "unchecked conversion" to SafeUrl from a plain string that is
 * known to satisfy the SafeUrl type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `url` satisfies the SafeUrl type contract in all
 * possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} url The string to wrap as a SafeUrl.
 * @return {!goog.html.SafeUrl} The value of `url`, wrapped in a SafeUrl
 *     object.
 */
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract =
    function(justification, url) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url);
};


/**
 * Performs an "unchecked conversion" to TrustedResourceUrl from a plain string
 * that is known to satisfy the TrustedResourceUrl type contract.
 *
 * IMPORTANT: Uses of this method must be carefully security-reviewed to ensure
 * that the value of `url` satisfies the TrustedResourceUrl type contract
 * in all possible program states.
 *
 * MOE:begin_intracomment_strip
 * See http://go/safehtml-unchecked for guidelines on using these functions.
 * MOE:end_intracomment_strip
 *
 * @param {!goog.string.Const} justification A constant string explaining why
 *     this use of this method is safe. May include a security review ticket
 *     number.
 * @param {string} url The string to wrap as a TrustedResourceUrl.
 * @return {!goog.html.TrustedResourceUrl} The value of `url`, wrapped in
 *     a TrustedResourceUrl object.
 */
goog.html.uncheckedconversions
    .trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(
    justification, url) {
  'use strict';
  // unwrap() called inside an assert so that justification can be optimized
  // away in production code.
  goog.asserts.assertString(
      goog.string.Const.unwrap(justification), 'must provide justification');
  goog.asserts.assert(
      !goog.string.internal.isEmptyOrWhitespace(
          goog.string.Const.unwrap(justification)),
      'must provide non-empty justification');
  return goog.html.TrustedResourceUrl
      .createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url);
};

//third_party/javascript/closure/dom/safe.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Type-safe wrappers for unsafe DOM APIs.
 *
 * This file provides type-safe wrappers for DOM APIs that can result in
 * cross-site scripting (XSS) vulnerabilities, if the API is supplied with
 * untrusted (attacker-controlled) input.  Instead of plain strings, the type
 * safe wrappers consume values of types from the goog.html package whose
 * contract promises that values are safe to use in the corresponding context.
 *
 * Hence, a program that exclusively uses the wrappers in this file (i.e., whose
 * only reference to security-sensitive raw DOM APIs are in this file) is
 * guaranteed to be free of XSS due to incorrect use of such DOM APIs (modulo
 * correctness of code that produces values of the respective goog.html types,
 * and absent code that violates type safety).
 *
 * For example, assigning to an element's .innerHTML property a string that is
 * derived (even partially) from untrusted input typically results in an XSS
 * vulnerability. The type-safe wrapper goog.dom.safe.setInnerHtml consumes a
 * value of type goog.html.SafeHtml, whose contract states that using its values
 * in a HTML context will not result in XSS. Hence a program that is free of
 * direct assignments to any element's innerHTML property (with the exception of
 * the assignment to .innerHTML in this file) is guaranteed to be free of XSS
 * due to assignment of untrusted strings to the innerHTML property.
 */

goog.provide('goog.dom.safe');
goog.provide('goog.dom.safe.InsertAdjacentHtmlPosition');

goog.require('goog.asserts');
goog.require('goog.dom.asserts');
goog.require('goog.functions');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.html.uncheckedconversions');
goog.require('goog.string.Const');
goog.require('goog.string.internal');


/** @enum {string} */
goog.dom.safe.InsertAdjacentHtmlPosition = {
  AFTERBEGIN: 'afterbegin',
  AFTEREND: 'afterend',
  BEFOREBEGIN: 'beforebegin',
  BEFOREEND: 'beforeend'
};


/**
 * Inserts known-safe HTML into a Node, at the specified position.
 * @param {!Node} node The node on which to call insertAdjacentHTML.
 * @param {!goog.dom.safe.InsertAdjacentHtmlPosition} position Position where
 *     to insert the HTML.
 * @param {!goog.html.SafeHtml} html The known-safe HTML to insert.
 */
goog.dom.safe.insertAdjacentHtml = function(node, position, html) {
  'use strict';
  node.insertAdjacentHTML(position, goog.html.SafeHtml.unwrapTrustedHTML(html));
};


/**
 * Tags not allowed in goog.dom.safe.setInnerHtml.
 * @private @const {!Object<string, boolean>}
 */
goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = {
  'MATH': true,
  'SCRIPT': true,
  'STYLE': true,
  'SVG': true,
  'TEMPLATE': true
};


/**
 * Whether assigning to innerHTML results in a non-spec-compliant clean-up. Used
 * to define goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse.
 *
 * <p>As mentioned in https://stackoverflow.com/questions/28741528, re-rendering
 * an element in IE by setting innerHTML causes IE to recursively disconnect all
 * parent/children connections that were in the previous contents of the
 * element. Unfortunately, this can unexpectedly result in confusing cases where
 * a function is run (typically asynchronously) on element that has since
 * disconnected from the DOM but assumes the presence of its children. A simple
 * workaround is to remove all children first. Testing on IE11 via
 * https://jsperf.com/innerhtml-vs-removechild/239, removeChild seems to be
 * ~10x faster than innerHTML='' for a large number of children (perhaps due
 * to the latter's recursive behavior), implying that this workaround would
 * not hurt performance and might actually improve it.
 * @return {boolean}
 * @private
 */
goog.dom.safe.isInnerHtmlCleanupRecursive_ =
    goog.functions.cacheReturnValue(function() {
      'use strict';
      // `document` missing in some test frameworks.
      if (goog.DEBUG && typeof document === 'undefined') {
        return false;
      }
      // Create 3 nested <div>s without using innerHTML.
      // We're not chaining the appendChilds in one call,  as this breaks
      // in a DocumentFragment.
      var div = document.createElement('div');
      var childDiv = document.createElement('div');
      childDiv.appendChild(document.createElement('div'));
      div.appendChild(childDiv);
      // `firstChild` is null in Google Js Test.
      if (goog.DEBUG && !div.firstChild) {
        return false;
      }
      var innerChild = div.firstChild.firstChild;
      div.innerHTML =
          goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);
      return !innerChild.parentElement;
    });


/**
 * Assigns HTML to an element's innerHTML property. Helper to use only here and
 * in soy.js.
 * @param {?Element|?ShadowRoot} elem The element whose innerHTML is to be
 *     assigned to.
 * @param {!goog.html.SafeHtml} html
 */
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(elem, html) {
  'use strict';
  // See comment above goog.dom.safe.isInnerHtmlCleanupRecursive_.
  if (goog.dom.safe.isInnerHtmlCleanupRecursive_()) {
    while (elem.lastChild) {
      elem.removeChild(elem.lastChild);
    }
  }
  elem.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(html);
};


/**
 * Assigns known-safe HTML to an element's innerHTML property.
 * @param {!Element|!ShadowRoot} elem The element whose innerHTML is to be
 *     assigned to.
 * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
 * @throws {Error} If called with one of these tags: math, script, style, svg,
 *     template.
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeElement.setInnerHtml instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setInnerHtml = function(elem, html) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS && elem.tagName) {
    var tagName = elem.tagName.toUpperCase();
    if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[tagName]) {
      throw new Error(
          'goog.dom.safe.setInnerHtml cannot be used to set content of ' +
          elem.tagName + '.');
    }
  }

  goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(elem, html);
};


/**
 * Assigns constant HTML to an element's innerHTML property.
 * @param {!Element} element The element whose innerHTML is to be assigned to.
 * @param {!goog.string.Const} constHtml The known-safe HTML to assign.
 * @throws {!Error} If called with one of these tags: math, script, style, svg,
 *     template.
 */
goog.dom.safe.setInnerHtmlFromConstant = function(element, constHtml) {
  'use strict';
  goog.dom.safe.setInnerHtml(
      element,
      goog.html.uncheckedconversions
          .safeHtmlFromStringKnownToSatisfyTypeContract(
              goog.string.Const.from('Constant HTML to be immediatelly used.'),
              goog.string.Const.unwrap(constHtml)));
};


/**
 * Assigns known-safe HTML to an element's outerHTML property.
 * @param {!Element} elem The element whose outerHTML is to be assigned to.
 * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeElement.setOuterHtml instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setOuterHtml = function(elem, html) {
  'use strict';
  elem.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(html);
};


/**
 * Safely assigns a URL a form element's action property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * form's action property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.setFormElementAction(formEl, url);
 * which is a safe alternative to
 *   formEl.action = url;
 * The latter can result in XSS vulnerabilities if url is a
 * user-/attacker-controlled value.
 *
 * @param {!Element} form The form element whose action property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeFormEl.setAction instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setFormElementAction = function(form, url) {
  'use strict';
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  goog.dom.asserts.assertIsHTMLFormElement(form).action =
      goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Safely assigns a URL to a button element's formaction property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * button's formaction property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.setButtonFormAction(buttonEl, url);
 * which is a safe alternative to
 *   buttonEl.action = url;
 * The latter can result in XSS vulnerabilities if url is a
 * user-/attacker-controlled value.
 *
 * @param {!Element} button The button element whose action property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeButtonEl.setFormaction instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setButtonFormAction = function(button, url) {
  'use strict';
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  goog.dom.asserts.assertIsHTMLButtonElement(button).formAction =
      goog.html.SafeUrl.unwrap(safeUrl);
};
/**
 * Safely assigns a URL to an input element's formaction property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * input's formaction property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.setInputFormAction(inputEl, url);
 * which is a safe alternative to
 *   inputEl.action = url;
 * The latter can result in XSS vulnerabilities if url is a
 * user-/attacker-controlled value.
 *
 * @param {!Element} input The input element whose action property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeInputEl.setFormaction instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setInputFormAction = function(input, url) {
  'use strict';
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  goog.dom.asserts.assertIsHTMLInputElement(input).formAction =
      goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Sets the given element's style property to the contents of the provided
 * SafeStyle object.
 * @param {!Element} elem
 * @param {!goog.html.SafeStyle} style
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeElement.setCssText instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setStyle = function(elem, style) {
  'use strict';
  elem.style.cssText = goog.html.SafeStyle.unwrap(style);
};


/**
 * Writes known-safe HTML to a document.
 * @param {!Document} doc The document to be written to.
 * @param {!goog.html.SafeHtml} html The known-safe HTML to assign.
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeDocument.write instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.documentWrite = function(doc, html) {
  'use strict';
  doc.write(goog.html.SafeHtml.unwrapTrustedHTML(html));
};


/**
 * Safely assigns a URL to an anchor element's href property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * anchor's href property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.setAnchorHref(anchorEl, url);
 * which is a safe alternative to
 *   anchorEl.href = url;
 * The latter can result in XSS vulnerabilities if url is a
 * user-/attacker-controlled value.
 *
 * @param {!HTMLAnchorElement} anchor The anchor element whose href property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeAnchorEl.setHref instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setAnchorHref = function(anchor, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLAnchorElement(anchor);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  anchor.href = goog.html.SafeUrl.unwrap(safeUrl);
};


/**
 * Safely assigns a URL to an image element's src property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * image's src property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * @param {!HTMLImageElement} imageElement The image element whose src property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeImageEl.setSrc instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setImageSrc = function(imageElement, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLImageElement(imageElement);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    var allowDataUrl = /^data:image\//i.test(url);
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);
  }
  imageElement.src = goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Safely assigns a URL to a audio element's src property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * audio's src property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * @param {!HTMLAudioElement} audioElement The audio element whose src property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 */
goog.dom.safe.setAudioSrc = function(audioElement, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLAudioElement(audioElement);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    var allowDataUrl = /^data:audio\//i.test(url);
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);
  }
  audioElement.src = goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Safely assigns a URL to a video element's src property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * video's src property.  If url is of type string however, it is first
 * sanitized using goog.html.SafeUrl.sanitize.
 *
 * @param {!HTMLVideoElement} videoElement The video element whose src property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 */
goog.dom.safe.setVideoSrc = function(videoElement, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLVideoElement(videoElement);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    var allowDataUrl = /^data:video\//i.test(url);
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url, allowDataUrl);
  }
  videoElement.src = goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Safely assigns a URL to an embed element's src property.
 *
 * Example usage:
 *   goog.dom.safe.setEmbedSrc(embedEl, url);
 * which is a safe alternative to
 *   embedEl.src = url;
 * The latter can result in loading untrusted code unless it is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLEmbedElement} embed The embed element whose src property
 *     is to be assigned to.
 * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
 */
goog.dom.safe.setEmbedSrc = function(embed, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLEmbedElement(embed);
  embed.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);
};


/**
 * Safely assigns a URL to a frame element's src property.
 *
 * Example usage:
 *   goog.dom.safe.setFrameSrc(frameEl, url);
 * which is a safe alternative to
 *   frameEl.src = url;
 * The latter can result in loading untrusted code unless it is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLFrameElement} frame The frame element whose src property
 *     is to be assigned to.
 * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
 * @return {void}
 */
goog.dom.safe.setFrameSrc = function(frame, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLFrameElement(frame);
  frame.src = goog.html.TrustedResourceUrl.unwrap(url);
};


/**
 * Safely assigns a URL to an iframe element's src property.
 *
 * Example usage:
 *   goog.dom.safe.setIframeSrc(iframeEl, url);
 * which is a safe alternative to
 *   iframeEl.src = url;
 * The latter can result in loading untrusted code unless it is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLIFrameElement} iframe The iframe element whose src property
 *     is to be assigned to.
 * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeIframeEl.setSrc instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setIframeSrc = function(iframe, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
  iframe.src = goog.html.TrustedResourceUrl.unwrap(url);
};


/**
 * Safely assigns HTML to an iframe element's srcdoc property.
 *
 * Example usage:
 *   goog.dom.safe.setIframeSrcdoc(iframeEl, safeHtml);
 * which is a safe alternative to
 *   iframeEl.srcdoc = html;
 * The latter can result in loading untrusted code.
 *
 * @param {!HTMLIFrameElement} iframe The iframe element whose srcdoc property
 *     is to be assigned to.
 * @param {!goog.html.SafeHtml} html The HTML to assign.
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeIframeEl.setSrcdoc instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setIframeSrcdoc = function(iframe, html) {
  'use strict';
  goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
  iframe.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(html);
};


/**
 * Safely sets a link element's href and rel properties. Whether or not
 * the URL assigned to href has to be a goog.html.TrustedResourceUrl
 * depends on the value of the rel property. If rel contains "stylesheet"
 * then a TrustedResourceUrl is required.
 *
 * Example usage:
 *   goog.dom.safe.setLinkHrefAndRel(linkEl, url, 'stylesheet');
 * which is a safe alternative to
 *   linkEl.rel = 'stylesheet';
 *   linkEl.href = url;
 * The latter can result in loading untrusted code unless it is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLLinkElement} link The link element whose href property
 *     is to be assigned to.
 * @param {string|!goog.html.SafeUrl|!goog.html.TrustedResourceUrl} url The URL
 *     to assign to the href property. Must be a TrustedResourceUrl if the
 *     value assigned to rel contains "stylesheet". A string value is
 *     sanitized with goog.html.SafeUrl.sanitize.
 * @param {string} rel The value to assign to the rel property.
 * @return {void}
 * @throws {Error} if rel contains "stylesheet" and url is not a
 *     TrustedResourceUrl
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeLinkEl.setHrefAndRel instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setLinkHrefAndRel = function(link, url, rel) {
  'use strict';
  goog.dom.asserts.assertIsHTMLLinkElement(link);
  link.rel = rel;
  if (goog.string.internal.caseInsensitiveContains(rel, 'stylesheet')) {
    goog.asserts.assert(
        url instanceof goog.html.TrustedResourceUrl,
        'URL must be TrustedResourceUrl because "rel" contains "stylesheet"');
    link.href = goog.html.TrustedResourceUrl.unwrap(url);
    const win = link.ownerDocument && link.ownerDocument.defaultView;
    const nonce = goog.dom.safe.getStyleNonce(win);
    if (nonce) {
      link.setAttribute('nonce', nonce);
    }
  } else if (url instanceof goog.html.TrustedResourceUrl) {
    link.href = goog.html.TrustedResourceUrl.unwrap(url);
  } else if (url instanceof goog.html.SafeUrl) {
    link.href = goog.html.SafeUrl.unwrap(url);
  } else {  // string
    // SafeUrl.sanitize must return legitimate SafeUrl when passed a string.
    link.href = goog.html.SafeUrl.unwrap(
        goog.html.SafeUrl.sanitizeAssertUnchanged(url));
  }
};


/**
 * Safely assigns a URL to an object element's data property.
 *
 * Example usage:
 *   goog.dom.safe.setObjectData(objectEl, url);
 * which is a safe alternative to
 *   objectEl.data = url;
 * The latter can result in loading untrusted code unless setit is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLObjectElement} object The object element whose data property
 *     is to be assigned to.
 * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
 * @return {void}
 */
goog.dom.safe.setObjectData = function(object, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLObjectElement(object);
  object.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);
};


/**
 * Safely assigns a URL to a script element's src property.
 *
 * Example usage:
 *   goog.dom.safe.setScriptSrc(scriptEl, url);
 * which is a safe alternative to
 *   scriptEl.src = url;
 * The latter can result in loading untrusted code unless it is ensured that
 * the URL refers to a trustworthy resource.
 *
 * @param {!HTMLScriptElement} script The script element whose src property
 *     is to be assigned to.
 * @param {!goog.html.TrustedResourceUrl} url The URL to assign.
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeScriptEl.setSrc instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setScriptSrc = function(script, url) {
  'use strict';
  goog.dom.asserts.assertIsHTMLScriptElement(script);
  script.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(url);
  goog.dom.safe.setNonceForScriptElement_(script);
};


/**
 * Safely assigns a value to a script element's content.
 *
 * Example usage:
 *   goog.dom.safe.setScriptContent(scriptEl, content);
 * which is a safe alternative to
 *   scriptEl.text = content;
 * The latter can result in executing untrusted code unless it is ensured that
 * the code is loaded from a trustworthy resource.
 *
 * @param {!HTMLScriptElement} script The script element whose content is being
 *     set.
 * @param {!goog.html.SafeScript} content The content to assign.
 * @return {void}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeScriptEl.setTextContent instead.
 * @package
 * MOE:end_intracomment_strip
 */
goog.dom.safe.setScriptContent = function(script, content) {
  'use strict';
  goog.dom.asserts.assertIsHTMLScriptElement(script);
  script.textContent = goog.html.SafeScript.unwrapTrustedScript(content);
  goog.dom.safe.setNonceForScriptElement_(script);
};


/**
 * Set nonce-based CSPs to dynamically created scripts.
 * @param {!HTMLScriptElement} script The script element whose nonce value
 *     is to be calculated
 * @private
 */
goog.dom.safe.setNonceForScriptElement_ = function(script) {
  'use strict';
  var win = script.ownerDocument && script.ownerDocument.defaultView;
  const nonce = goog.dom.safe.getScriptNonce(win);
  if (nonce) {
    script.setAttribute('nonce', nonce);
  }
};


/**
 * Safely assigns a URL to a Location object's href property.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and assigned to
 * loc's href property.  If url is of type string however, it is first sanitized
 * using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.setLocationHref(document.location, redirectUrl);
 * which is a safe alternative to
 *   document.location.href = redirectUrl;
 * The latter can result in XSS vulnerabilities if redirectUrl is a
 * user-/attacker-controlled value.
 *
 * @param {!Location} loc The Location object whose href property is to be
 *     assigned to.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeLocation.setHref instead.
 * MOE:end_intracomment_strip

 */
goog.dom.safe.setLocationHref = function(loc, url) {
  'use strict';
  goog.dom.asserts.assertIsLocation(loc);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  loc.href = goog.html.SafeUrl.unwrap(safeUrl);
};

/**
 * Safely assigns the URL of a Location object.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and
 * passed to Location#assign. If url is of type string however, it is
 * first sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.assignLocation(document.location, newUrl);
 * which is a safe alternative to
 *   document.location.assign(newUrl);
 * The latter can result in XSS vulnerabilities if newUrl is a
 * user-/attacker-controlled value.
 *
 * This has the same behaviour as setLocationHref, however some test
 * mock Location.assign instead of a property assignment.
 *
 * @param {!Location} loc The Location object which is to be assigned.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeLocation.assign instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.assignLocation = function(loc, url) {
  'use strict';
  goog.dom.asserts.assertIsLocation(loc);
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  loc.assign(goog.html.SafeUrl.unwrap(safeUrl));
};


/**
 * Safely replaces the URL of a Location object.
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and
 * passed to Location#replace. If url is of type string however, it is
 * first sanitized using goog.html.SafeUrl.sanitize.
 *
 * Example usage:
 *   goog.dom.safe.replaceLocation(document.location, newUrl);
 * which is a safe alternative to
 *   document.location.replace(newUrl);
 * The latter can result in XSS vulnerabilities if newUrl is a
 * user-/attacker-controlled value.
 *
 * @param {!Location} loc The Location object which is to be replaced.
 * @param {string|!goog.html.SafeUrl} url The URL to assign.
 * @return {void}
 * @see goog.html.SafeUrl#sanitize
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeLocation.replace instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.replaceLocation = function(loc, url) {
  'use strict';
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  loc.replace(goog.html.SafeUrl.unwrap(safeUrl));
};


/**
 * Safely opens a URL in a new window (via window.open).
 *
 * If url is of type goog.html.SafeUrl, its value is unwrapped and passed in to
 * window.open.  If url is of type string however, it is first sanitized
 * using goog.html.SafeUrl.sanitize.
 *
 * Note that this function does not prevent leakages via the referer that is
 * sent by window.open. It is advised to only use this to open 1st party URLs.
 *
 * Example usage:
 *   goog.dom.safe.openInWindow(url);
 * which is a safe alternative to
 *   window.open(url);
 * The latter can result in XSS vulnerabilities if url is a
 * user-/attacker-controlled value.
 *
 * @param {string|!goog.html.SafeUrl} url The URL to open.
 * @param {Window=} opt_openerWin Window of which to call the .open() method.
 *     Defaults to the global window.
 * @param {!goog.string.Const|string=} opt_name Name of the window to open in.
 *     Can be _top, etc as allowed by window.open(). This accepts string for
 *     legacy reasons. Pass goog.string.Const if possible.
 * @param {string=} opt_specs Comma-separated list of specifications, same as
 *     in window.open().
 * @return {Window} Window the url was opened in.
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeWindow.open instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.openInWindow = function(url, opt_openerWin, opt_name, opt_specs) {
  'use strict';
  /** @type {!goog.html.SafeUrl} */
  var safeUrl;
  if (url instanceof goog.html.SafeUrl) {
    safeUrl = url;
  } else {
    safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
  }
  var win = opt_openerWin || goog.global;
  // If opt_name is undefined, simply passing that in to open() causes IE to
  // reuse the current window instead of opening a new one. Thus we pass '' in
  // instead, which according to spec opens a new window. See
  // https://html.spec.whatwg.org/multipage/browsers.html#dom-open .
  var name = opt_name instanceof goog.string.Const ?
      goog.string.Const.unwrap(opt_name) :
      opt_name || '';
  // Do not pass opt_specs to window.open unless it was provided by the caller.
  // IE11 will use it as a signal to open a new window rather than a new tab
  // (even if it is undefined).
  if (opt_specs !== undefined) {
    return win.open(goog.html.SafeUrl.unwrap(safeUrl), name, opt_specs);
  } else {
    return win.open(goog.html.SafeUrl.unwrap(safeUrl), name);
  }
};


/**
 * Parses the HTML as 'text/html'.
 * @param {!DOMParser} parser
 * @param {!goog.html.SafeHtml} html The HTML to be parsed.
 * @return {!Document}
 */
goog.dom.safe.parseFromStringHtml = function(parser, html) {
  'use strict';
  return goog.dom.safe.parseFromString(parser, html, 'text/html');
};


/**
 * Parses the string.
 * @param {!DOMParser} parser
 * @param {!goog.html.SafeHtml} content Note: We don't have a special type for
 *     XML or SVG supported by this function so we use SafeHtml.
 * @param {string} type
 * @return {!Document}
 */
goog.dom.safe.parseFromString = function(parser, content, type) {
  'use strict';
  return parser.parseFromString(
      goog.html.SafeHtml.unwrapTrustedHTML(content), type);
};


/**
 * Safely creates an HTMLImageElement from a Blob.
 *
 * Example usage:
 *     goog.dom.safe.createImageFromBlob(blob);
 * which is a safe alternative to
 *     image.src = createObjectUrl(blob)
 * The latter can result in executing malicious same-origin scripts from a bad
 * Blob.
 * @param {!Blob} blob The blob to create the image from.
 * @return {!HTMLImageElement} The image element created from the blob.
 * @throws {!Error} If called with a Blob with a MIME type other than image/.*.
 */
goog.dom.safe.createImageFromBlob = function(blob) {
  'use strict';
  // Any image/* MIME type is accepted as safe.
  if (!/^image\/.*/g.test(blob.type)) {
    throw new Error(
        'goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.');
  }
  var objectUrl = goog.global.URL.createObjectURL(blob);
  var image = new goog.global.Image();
  image.onload = function() {
    'use strict';
    goog.global.URL.revokeObjectURL(objectUrl);
  };
  goog.dom.safe.setImageSrc(
      image,
      goog.html.uncheckedconversions
          .safeUrlFromStringKnownToSatisfyTypeContract(
              goog.string.Const.from('Image blob URL.'), objectUrl));
  return image;
};

/**
 * Creates a DocumentFragment by parsing html in the context of a Range.
 * @param {!Range} range The Range object starting from the context node to
 * create a fragment in.
 * @param {!goog.html.SafeHtml} html HTML to create a fragment from.
 * @return {?DocumentFragment}
 * MOE:begin_intracomment_strip
 * @deprecated Use safedom.safeRange.createContextualFragment instead.
 * MOE:end_intracomment_strip
 */
goog.dom.safe.createContextualFragment = function(range, html) {
  'use strict';
  return range.createContextualFragment(
      goog.html.SafeHtml.unwrapTrustedHTML(html));
};

/**
 * Returns CSP script nonce, if set for any <script> tag.
 * @param {?Window=} opt_window The window context used to retrieve the nonce.
 *     Defaults to global context.
 * @return {string} CSP nonce or empty string if no nonce is present.
 */
goog.dom.safe.getScriptNonce = function(opt_window) {
  return goog.dom.safe.getNonce_('script[nonce]', opt_window);
};

/**
 * Returns CSP style nonce, if set for any <style> or <link rel="stylesheet">
 * tag.
 * @param {?Window=} opt_window The window context used to retrieve the nonce.
 *     Defaults to global context.
 * @return {string} CSP nonce or empty string if no nonce is present.
 */
goog.dom.safe.getStyleNonce = function(opt_window) {
  return goog.dom.safe.getNonce_(
      'style[nonce],link[rel="stylesheet"][nonce]', opt_window);
};

/**
 * According to the CSP3 spec a nonce must be a valid base64 string.
 * @see https://www.w3.org/TR/CSP3/#grammardef-base64-value
 * @private @const
 */
goog.dom.safe.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;

/**
 * Returns CSP nonce, if set for any tag of given type.
 * @param {string} selector Selector for locating the element with nonce.
 * @param {?Window=} win The window context used to retrieve the nonce.
 * @return {string} CSP nonce or empty string if no nonce is present.
 * @private
 */
goog.dom.safe.getNonce_ = function(selector, win) {
  const doc = (win || goog.global).document;
  if (!doc.querySelector) {
    return '';
  }
  let el = doc.querySelector(selector);
  if (el) {
    // Try to get the nonce from the IDL property first, because browsers that
    // implement additional nonce protection features (currently only Chrome) to
    // prevent nonce stealing via CSS do not expose the nonce via attributes.
    // See https://github.com/whatwg/html/issues/2369
    const nonce = el['nonce'] || el.getAttribute('nonce');
    if (nonce && goog.dom.safe.NONCE_PATTERN_.test(nonce)) {
      return nonce;
    }
  }
  return '';
};

//third_party/javascript/closure/string/string.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');

goog.require('goog.dom.safe');
goog.require('goog.html.uncheckedconversions');
goog.require('goog.string.Const');
goog.require('goog.string.internal');


/**
 * @define {boolean} Enables HTML escaping of lowercase letter "e" which helps
 * with detection of double-escaping as this letter is frequently used.
 */
goog.string.DETECT_DOUBLE_ESCAPING =
    goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);


/**
 * @define {boolean} Whether to force non-dom html unescaping.
 */
goog.string.FORCE_NON_DOM_HTML_UNESCAPING =
    goog.define('goog.string.FORCE_NON_DOM_HTML_UNESCAPING', false);


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of `str`.
 * @return {boolean} True if `str` begins with `prefix`.
 */
goog.string.startsWith = goog.string.internal.startsWith;


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix`.
 */
goog.string.endsWith = goog.string.internal.endsWith;


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of `str`.
 * @return {boolean} True if `str` begins with `prefix` (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith =
    goog.string.internal.caseInsensitiveStartsWith;


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of `str`.
 * @return {boolean} True if `str` ends with `suffix` (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith =
    goog.string.internal.caseInsensitiveEndsWith;


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if `str1` and `str2` are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals;


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of `str` in which each occurrence of
 *     {@code %s} has been replaced an argument from `var_args`.
 */
goog.string.subs = function(str, var_args) {
  'use strict';
  const splitParts = str.split('%s');
  let returnString = '';

  const subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length &&
         // Replace up to the last split part. We are inserting in the
         // positions between split parts.
         splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }

  return returnString + splitParts.join('%s');  // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of `str` with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  'use strict';
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} Whether `str` is empty or whitespace only.
 */
goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace;


/**
 * Checks if a string is empty.
 * @param {string} str The string to check.
 * @return {boolean} Whether `str` is empty.
 */
goog.string.isEmptyString = function(str) {
  'use strict';
  return str.length == 0;
};


/**
 * Checks if a string is empty or contains only whitespaces.
 *
 * @param {string} str The string to check.
 * @return {boolean} Whether `str` is empty or whitespace only.
 * @deprecated Use goog.string.isEmptyOrWhitespace instead.
 */
goog.string.isEmpty = goog.string.isEmptyOrWhitespace;


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} Whether `str` is null, undefined, empty, or
 *     whitespace only.
 * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))
 *     instead.
 */
goog.string.isEmptyOrWhitespaceSafe = function(str) {
  'use strict';
  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 *
 * @param {*} str The string to check.
 * @return {boolean} Whether `str` is null, undefined, empty, or
 *     whitespace only.
 * @deprecated Use goog.string.isEmptyOrWhitespace instead.
 */
goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  'use strict';
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if `str` consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  'use strict';
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if `str` is numeric.
 */
goog.string.isNumeric = function(str) {
  'use strict';
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if `str` is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  'use strict';
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if `ch` is a space.
 */
goog.string.isSpace = function(ch) {
  'use strict';
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if `ch` is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  'use strict';
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
      ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of `str` stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  'use strict';
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} `str` A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  'use strict';
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of `str` with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  'use strict';
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of `str` with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  'use strict';
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  'use strict';
  return str.replace(/[\t\r\n ]+/g, ' ')
      .replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of `str`.
 */
goog.string.trim = goog.string.internal.trim;


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of `str`.
 */
goog.string.trimLeft = function(str) {
  'use strict';
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of `str`.
 */
goog.string.trimRight = function(str) {
  'use strict';
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare `str1` to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare =
    goog.string.internal.caseInsensitiveCompare;


/**
 * Compares two strings interpreting their numeric substrings as numbers.
 *
 * @param {string} str1 First string.
 * @param {string} str2 Second string.
 * @param {!RegExp} tokenizerRegExp Splits a string into substrings of
 *     non-negative integers, non-numeric characters and optionally fractional
 *     numbers starting with a decimal point.
 * @return {number} Negative if str1 < str2, 0 is str1 == str2, positive if
 *     str1 > str2.
 * @private
 */
goog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {
  'use strict';
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  const tokens1 = str1.toLowerCase().match(tokenizerRegExp);
  const tokens2 = str2.toLowerCase().match(tokenizerRegExp);

  const count = Math.min(tokens1.length, tokens2.length);

  for (let i = 0; i < count; i++) {
    const a = tokens1[i];
    const b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {
      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      const num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        const num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII string
  // comparison to stabilize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * String comparison function that handles non-negative integer numbers in a
 * way humans might expect. Using this function, the string 'File 2.jpg' sorts
 * before 'File 10.jpg', and 'Version 1.9' before 'Version 1.10'. The comparison
 * is mostly case-insensitive, though strings that are identical except for case
 * are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is up to 50x slower than either the default or the
 * case-insensitive compare. It should not be used in time-critical code, but
 * should be fast enough to sort several hundred short strings (like filenames)
 * with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare `str1` to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.intAwareCompare = function(str1, str2) {
  'use strict';
  return goog.string.numberAwareCompare_(str1, str2, /\d+|\D+/g);
};


/**
 * String comparison function that handles non-negative integer and fractional
 * numbers in a way humans might expect. Using this function, the string
 * 'File 2.jpg' sorts before 'File 10.jpg', and '3.14' before '3.2'. Equivalent
 * to {@link goog.string.intAwareCompare} apart from the way how it interprets
 * dots.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare `str1` to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.floatAwareCompare = function(str1, str2) {
  'use strict';
  return goog.string.numberAwareCompare_(str1, str2, /\d+|\.\d+|\D+/g);
};


/**
 * Alias for {@link goog.string.floatAwareCompare}.
 *
 * @param {string} str1
 * @param {string} str2
 * @return {number}
 */
goog.string.numerateCompare = goog.string.floatAwareCompare;


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of `str` that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  'use strict';
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded `str`.
 */
goog.string.urlDecode = function(str) {
  'use strict';
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of `str` with converted newlines.
 */
goog.string.newLineToBr = goog.string.internal.newLineToBr;


/**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
 * lowercase letter "e".
 *
 * NOTE(pupius):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of `str`.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {
  'use strict';
  str = goog.string.internal.htmlEscape(str, opt_isLikelyToContainHtmlChars);
  if (goog.string.DETECT_DOUBLE_ESCAPING) {
    str = str.replace(goog.string.E_RE_, '&#101;');
  }
  return str;
};


/**
 * Regular expression that matches a lowercase letter "e", for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.E_RE_ = /e/g;


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of `str`.
 */
goog.string.unescapeEntities = function(str) {
  'use strict';
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one or we explicitly
    // requested non-DOM html unescaping.
    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &&
        'document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes a HTML string using the provided document.
 *
 * @param {string} str The string to unescape.
 * @param {!Document} document A document to use in escaping the string.
 * @return {string} An unescaped copy of `str`.
 */
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  'use strict';
  if (goog.string.contains(str, '&')) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @param {Document=} opt_document An optional document to use for creating
 *     elements. If this is not specified then the default window.document
 *     will be used.
 * @return {string} The unescaped `str` string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  'use strict';
  /** @type {!Object<string, string>} */
  const seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  /** @type {!Element} */
  let div;
  if (opt_document) {
    div = opt_document.createElement('div');
  } else {
    div = goog.global.document.createElement('div');
  }
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    'use strict';
    // Check for cached entity.
    let value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      const n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      goog.dom.safe.setInnerHtml(
          div,
          goog.html.uncheckedconversions
              .safeHtmlFromStringKnownToSatisfyTypeContract(
                  goog.string.Const.from('Single HTML entity.'), s + ' '));
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of `str`.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  'use strict';
  return str.replace(/&([^;]+);/g, function(s, entity) {
    'use strict';
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          const n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of `str`.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  'use strict';
  // This doesn't use goog.string.preserveSpaces for backwards compatibility.
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Preserve spaces that would be otherwise collapsed in HTML by replacing them
 * with non-breaking space Unicode characters.
 * @param {string} str The string in which to preserve whitespace.
 * @return {string} A copy of `str` with preserved whitespace.
 */
goog.string.preserveSpaces = function(str) {
  'use strict';
  return str.replace(/(^|[\n ]) /g, '$1' + goog.string.Unicode.NBSP);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of `str` without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  'use strict';
  const length = quoteChars.length;
  for (let i = 0; i < length; i++) {
    const quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated `str` string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  'use strict';
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of `str`.
 */
goog.string.truncateMiddle = function(
    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
  'use strict';
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    const endPoint = str.length - opt_trailingChars;
    const startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    let half = Math.floor(chars / 2);
    const endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private {!Object<string, string>}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B',  // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\',
  // To support the use case of embedding quoted strings inside of script
  // tags, we have to make sure HTML comments and opening/closing script tags do
  // not appear in the resulting string. The specific strings that must be
  // escaped are documented at:
  // https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements
  '<': '\\u003C'  // NOTE: JSON.parse crashes on '\\x3c'.
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private {!Object<string, string>}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string. The resulting string is safe to embed in
 * `<script>` tags as "<" is escaped.
 * @param {string} s The string to quote.
 * @return {string} A copy of `s` surrounded by double quotes.
 */
goog.string.quote = function(s) {
  'use strict';
  s = String(s);
  const sb = ['"'];
  for (let i = 0; i < s.length; i++) {
    const ch = s.charAt(i);
    const cc = ch.charCodeAt(0);
    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
        ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
  }
  sb.push('"');
  return sb.join('');
};


/**
 * Takes a string and returns the escaped string for that input string.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing `str`.
 */
goog.string.escapeString = function(str) {
  'use strict';
  const sb = [];
  for (let i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing `c`.
 */
goog.string.escapeChar = function(c) {
  'use strict';
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  let rv = c;
  const cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) {  // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Determines whether a string contains a substring.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 */
goog.string.contains = goog.string.internal.contains;


/**
 * Determines whether a string contains a substring, ignoring case.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether `str` contains `subString`.
 */
goog.string.caseInsensitiveContains =
    goog.string.internal.caseInsensitiveContains;


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  'use strict';
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of `s` with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  'use strict';
  let resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 * Removes the first occurrence of a substring from a string.
 * @param {string} str The base string from which to remove.
 * @param {string} substr The string to remove.
 * @return {string} A copy of `str` with `substr` removed or the
 *     full string if nothing is removed.
 */
goog.string.remove = function(str, substr) {
  'use strict';
  return str.replace(substr, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of `s` with `ss` removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  'use strict';
  const re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 *  Replaces all occurrences of a substring of a string with a new substring.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to replace.
 *  @param {string} replacement The replacement string.
 *  @return {string} A copy of `s` with `ss` replaced by
 *      `replacement` or the original string if nothing is replaced.
 */
goog.string.replaceAll = function(s, ss, replacement) {
  'use strict';
  const re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, replacement.replace(/\$/g, '$$$$'));
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of `s`.
 */
goog.string.regExpEscape = function(s) {
  'use strict';
  return String(s)
      .replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1')
      .replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing `length` repetitions of
 *     `string`.
 */
goog.string.repeat = (String.prototype.repeat) ? function(string, length) {
  'use strict';
  // The native method is over 100 times faster than the alternative.
  return string.repeat(length);
} : function(string, length) {
  'use strict';
  return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} `num` as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  'use strict';
  const s =
      (opt_precision !== undefined) ? num.toFixed(opt_precision) : String(num);
  let index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the `obj`.
 */
goog.string.makeSafe = function(obj) {
  'use strict';
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of `var_args`.
 */
goog.string.buildString = function(var_args) {
  'use strict';
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust JavaScript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  'use strict';
  const x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if `version1` is higher.
 *                   0 if arguments are equal.
 *                  -1 if `version2` is higher.
 */
goog.string.compareVersions = goog.string.internal.compareVersions;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for `str`, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  'use strict';
  let result = 0;
  for (let i = 0; i < str.length; ++i) {
    // Normalize to 4 byte range, 0 ... 2^32.
    result = (31 * result + str.charCodeAt(i)) >>> 0;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  'use strict';
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Infinity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than JavaScript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  'use strict';
  const num = Number(str);
  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {
    return NaN;
  }
  return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function(str) {
  'use strict';
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function(str) {
  'use strict';
  return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  'use strict';
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    'use strict';
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  'use strict';
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  'use strict';
  let delimiters = (typeof opt_delimiters === 'string') ?
      goog.string.regExpEscape(opt_delimiters) :
      '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  const regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    'use strict';
    return p1 + p2.toUpperCase();
  });
};


/**
 * Capitalizes a string, i.e. converts the first letter to uppercase
 * and all other letters to lowercase, e.g.:
 *
 * goog.string.capitalize('one')     => 'One'
 * goog.string.capitalize('ONE')     => 'One'
 * goog.string.capitalize('one two') => 'One two'
 *
 * Note that this function does not trim initial whitespace.
 *
 * @param {string} str String value to capitalize.
 * @return {string} String value with first letter in uppercase.
 */
goog.string.capitalize = function(str) {
  'use strict';
  return String(str.charAt(0)).toUpperCase() +
      String(str.substr(1)).toLowerCase();
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  'use strict';
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (typeof value === 'string') {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array<string>} The string, split.
 */
goog.string.splitLimit = function(str, separator, limit) {
  'use strict';
  const parts = str.split(separator);
  const returnVal = [];

  // Only continue doing this while we haven't hit the limit and we have
  // parts left.
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }

  // If there are remaining parts, append them to the end.
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }

  return returnVal;
};


/**
 * Finds the characters to the right of the last instance of any separator
 *
 * This function is similar to goog.string.path.baseName, except it can take a
 * list of characters to split the string on. It will return the rightmost
 * grouping of characters to the right of any separator as a left-to-right
 * oriented string.
 *
 * @see goog.string.path.baseName
 * @param {string} str The string
 * @param {string|!Array<string>} separators A list of separator characters
 * @return {string} The last part of the string with respect to the separators
 */
goog.string.lastComponent = function(str, separators) {
  'use strict';
  if (!separators) {
    return str;
  } else if (typeof separators == 'string') {
    separators = [separators];
  }

  let lastSeparatorIndex = -1;
  for (let i = 0; i < separators.length; i++) {
    if (separators[i] == '') {
      continue;
    }
    const currentSeparatorIndex = str.lastIndexOf(separators[i]);
    if (currentSeparatorIndex > lastSeparatorIndex) {
      lastSeparatorIndex = currentSeparatorIndex;
    }
  }
  if (lastSeparatorIndex == -1) {
    return str;
  }
  return str.slice(lastSeparatorIndex + 1);
};


/**
 * Computes the Levenshtein edit distance between two strings.
 * @param {string} a
 * @param {string} b
 * @return {number} The edit distance between the two strings.
 */
goog.string.editDistance = function(a, b) {
  'use strict';
  const v0 = [];
  const v1 = [];

  if (a == b) {
    return 0;
  }

  if (!a.length || !b.length) {
    return Math.max(a.length, b.length);
  }

  for (let i = 0; i < b.length + 1; i++) {
    v0[i] = i;
  }

  for (let i = 0; i < a.length; i++) {
    v1[0] = i + 1;

    for (let j = 0; j < b.length; j++) {
      const cost = Number(a[i] != b[j]);
      // Cost for the substring is the minimum of adding one character, removing
      // one character, or a swap.
      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
    }

    for (let j = 0; j < v0.length; j++) {
      v0[j] = v1[j];
    }
  }

  return v1[b.length];
};

//third_party/javascript/closure/labs/useragent/engine.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Closure user agent detection.
 * @see http://en.wikipedia.org/wiki/User_agent
 * For more information on browser brand, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent (browser, platform, and device).
 */

goog.provide('goog.labs.userAgent.engine');

goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the rendering engine is Presto.
 */
goog.labs.userAgent.engine.isPresto = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Presto');
};


/**
 * @return {boolean} Whether the rendering engine is Trident.
 */
goog.labs.userAgent.engine.isTrident = function() {
  'use strict';
  // IE only started including the Trident token in IE8.
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the rendering engine is EdgeHTML.
 */
goog.labs.userAgent.engine.isEdge = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Edge');
};


/**
 * @return {boolean} Whether the rendering engine is WebKit. This will return
 * true for Chrome, Blink-based Opera (15+), Edge Chromium and Safari.
 */
goog.labs.userAgent.engine.isWebKit = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit') &&
      !goog.labs.userAgent.engine.isEdge();
};


/**
 * @return {boolean} Whether the rendering engine is Gecko.
 */
goog.labs.userAgent.engine.isGecko = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Gecko') &&
      !goog.labs.userAgent.engine.isWebKit() &&
      !goog.labs.userAgent.engine.isTrident() &&
      !goog.labs.userAgent.engine.isEdge();
};


/**
 * @return {string} The rendering engine's version or empty string if version
 *     can't be determined.
 */
goog.labs.userAgent.engine.getVersion = function() {
  'use strict';
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  if (userAgentString) {
    var tuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);

    var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);
    if (engineTuple) {
      // In Gecko, the version string is either in the browser info or the
      // Firefox version.  See Gecko user agent string reference:
      // http://goo.gl/mULqa
      if (engineTuple[0] == 'Gecko') {
        return goog.labs.userAgent.engine.getVersionForKey_(tuples, 'Firefox');
      }

      return engineTuple[1];
    }

    // MSIE has only one version identifier, and the Trident version is
    // specified in the parenthetical. IE Edge is covered in the engine tuple
    // detection.
    var browserTuple = tuples[0];
    var info;
    if (browserTuple && (info = browserTuple[2])) {
      var match = /Trident\/([^\s;]+)/.exec(info);
      if (match) {
        return match[1];
      }
    }
  }
  return '';
};


/**
 * @param {!Array<!Array<string>>} tuples Extracted version tuples.
 * @return {!Array<string>|undefined} The engine tuple or undefined if not
 *     found.
 * @private
 */
goog.labs.userAgent.engine.getEngineTuple_ = function(tuples) {
  'use strict';
  if (!goog.labs.userAgent.engine.isEdge()) {
    return tuples[1];
  }
  for (var i = 0; i < tuples.length; i++) {
    var tuple = tuples[i];
    if (tuple[0] == 'Edge') {
      return tuple;
    }
  }
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the rendering engine version is higher or the same
 *     as the given version.
 */
goog.labs.userAgent.engine.isVersionOrHigher = function(version) {
  'use strict';
  return goog.string.compareVersions(
             goog.labs.userAgent.engine.getVersion(), version) >= 0;
};


/**
 * @param {!Array<!Array<string>>} tuples Version tuples.
 * @param {string} key The key to look for.
 * @return {string} The version string of the given key, if present.
 *     Otherwise, the empty string.
 * @private
 */
goog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {
  'use strict';
  // TODO(nnaze): Move to util if useful elsewhere.

  var pair = goog.array.find(tuples, function(pair) {
    'use strict';
    return key == pair[0];
  });

  return pair && pair[1] || '';
};

//third_party/javascript/closure/labs/useragent/platform.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Closure user agent platform detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on browser brand, rendering engine, or device see the
 * other sub-namespaces in goog.labs.userAgent (browser, engine, and device
 * respectively).
 */

goog.provide('goog.labs.userAgent.platform');

goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the platform is Android.
 */
goog.labs.userAgent.platform.isAndroid = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Android');
};


/**
 * @return {boolean} Whether the platform is iPod.
 */
goog.labs.userAgent.platform.isIpod = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('iPod');
};


/**
 * @return {boolean} Whether the platform is iPhone.
 */
goog.labs.userAgent.platform.isIphone = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('iPhone') &&
      !goog.labs.userAgent.util.matchUserAgent('iPod') &&
      !goog.labs.userAgent.util.matchUserAgent('iPad');
};


/**
 * Returns whether the platform is iPad.
 * Note that iPadOS 13+ spoofs macOS Safari by default in its user agent, and in
 * this scenario the platform will not be recognized as iPad. If you must have
 * iPad-specific behavior, use
 * {@link goog.labs.userAgent.extra.isSafariDesktopOnMobile}.
 * @return {boolean} Whether the platform is iPad.
 */
goog.labs.userAgent.platform.isIpad = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('iPad');
};


/**
 * Returns whether the platform is iOS.
 * Note that iPadOS 13+ spoofs macOS Safari by default in its user agent, and in
 * this scenario the platform will not be recognized as iOS. If you must have
 * iPad-specific behavior, use
 * {@link goog.labs.userAgent.extra.isSafariDesktopOnMobile}.
 * @return {boolean} Whether the platform is iOS.
 */
goog.labs.userAgent.platform.isIos = function() {
  'use strict';
  return goog.labs.userAgent.platform.isIphone() ||
      goog.labs.userAgent.platform.isIpad() ||
      goog.labs.userAgent.platform.isIpod();
};


/**
 * @return {boolean} Whether the platform is Mac.
 */
goog.labs.userAgent.platform.isMacintosh = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Macintosh');
};


/**
 * Note: ChromeOS is not considered to be Linux as it does not report itself
 * as Linux in the user agent string.
 * @return {boolean} Whether the platform is Linux.
 */
goog.labs.userAgent.platform.isLinux = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Linux');
};


/**
 * @return {boolean} Whether the platform is Windows.
 */
goog.labs.userAgent.platform.isWindows = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('Windows');
};


/**
 * @return {boolean} Whether the platform is ChromeOS.
 */
goog.labs.userAgent.platform.isChromeOS = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('CrOS');
};

/**
 * @return {boolean} Whether the platform is Chromecast.
 */
goog.labs.userAgent.platform.isChromecast = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgent('CrKey');
};

/**
 * @return {boolean} Whether the platform is KaiOS.
 */
goog.labs.userAgent.platform.isKaiOS = function() {
  'use strict';
  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('KaiOS');
};

/**
 * The version of the platform. We only determine the version for Windows,
 * Mac, and Chrome OS. It doesn't make much sense on Linux. For Windows, we only
 * look at the NT version. Non-NT-based versions (e.g. 95, 98, etc.) are given
 * version 0.0.
 *
 * @return {string} The platform version or empty string if version cannot be
 *     determined.
 */
goog.labs.userAgent.platform.getVersion = function() {
  'use strict';
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  var version = '', re;
  if (goog.labs.userAgent.platform.isWindows()) {
    re = /Windows (?:NT|Phone) ([0-9.]+)/;
    var match = re.exec(userAgentString);
    if (match) {
      version = match[1];
    } else {
      version = '0.0';
    }
  } else if (goog.labs.userAgent.platform.isIos()) {
    re = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/;
    var match = re.exec(userAgentString);
    // Report the version as x.y.z and not x_y_z
    version = match && match[1].replace(/_/g, '.');
  } else if (goog.labs.userAgent.platform.isMacintosh()) {
    re = /Mac OS X ([0-9_.]+)/;
    var match = re.exec(userAgentString);
    // Note: some old versions of Camino do not report an OSX version.
    // Default to 10.
    version = match ? match[1].replace(/_/g, '.') : '10';
  } else if (goog.labs.userAgent.platform.isKaiOS()) {
    re = /(?:KaiOS)\/(\S+)/i;
    var match = re.exec(userAgentString);
    version = match && match[1];
  } else if (goog.labs.userAgent.platform.isAndroid()) {
    re = /Android\s+([^\);]+)(\)|;)/;
    var match = re.exec(userAgentString);
    version = match && match[1];
  } else if (goog.labs.userAgent.platform.isChromeOS()) {
    re = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/;
    var match = re.exec(userAgentString);
    version = match && match[1];
  }
  return version || '';
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the browser version is higher or the same as the
 *     given version.
 */
goog.labs.userAgent.platform.isVersionOrHigher = function(version) {
  'use strict';
  return goog.string.compareVersions(
             goog.labs.userAgent.platform.getVersion(), version) >= 0;
};

//third_party/javascript/closure/reflect/reflect.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Useful compiler idioms.
 */

goog.provide('goog.reflect');


/**
 * Syntax for object literal casts.
 * @see http://go/jscompiler-renaming
 * @see https://goo.gl/CRs09P
 *
 * Use this if you have an object literal whose keys need to have the same names
 * as the properties of some class even after they are renamed by the compiler.
 *
 * @param {!Function} type Type to cast to.
 * @param {Object} object Object literal to cast.
 * @return {Object} The object literal.
 */
goog.reflect.object = function(type, object) {
  'use strict';
  return object;
};

/**
 * Syntax for renaming property strings.
 * @see http://go/jscompiler-renaming
 * @see https://goo.gl/CRs09P
 *
 * Use this if you have an need to access a property as a string, but want
 * to also have the property renamed by the compiler. In contrast to
 * goog.reflect.object, this method takes an instance of an object.
 *
 * Properties must be simple names (not qualified names).
 *
 * @param {string} prop Name of the property
 * @param {!Object} object Instance of the object whose type will be used
 *     for renaming
 * @return {string} The renamed property.
 */
goog.reflect.objectProperty = function(prop, object) {
  'use strict';
  return prop;
};

/**
 * To assert to the compiler that an operation is needed when it would
 * otherwise be stripped. For example:
 * <code>
 *     // Force a layout
 *     goog.reflect.sinkValue(dialog.offsetHeight);
 * </code>
 * @param {T} x
 * @return {T}
 * @template T
 */
goog.reflect.sinkValue = function(x) {
  'use strict';
  goog.reflect.sinkValue[' '](x);
  return x;
};


/**
 * The compiler should optimize this function away iff no one ever uses
 * goog.reflect.sinkValue.
 */
goog.reflect.sinkValue[' '] = goog.nullFunction;


/**
 * Check if a property can be accessed without throwing an exception.
 * @param {Object} obj The owner of the property.
 * @param {string} prop The property name.
 * @return {boolean} Whether the property is accessible. Will also return true
 *     if obj is null.
 */
goog.reflect.canAccessProperty = function(obj, prop) {
  'use strict';
  try {
    goog.reflect.sinkValue(obj[prop]);
    return true;
  } catch (e) {
  }
  return false;
};


/**
 * Retrieves a value from a cache given a key. The compiler provides special
 * consideration for this call such that it is generally considered side-effect
 * free. However, if the `opt_keyFn` or `valueFn` have side-effects
 * then the entire call is considered to have side-effects.
 *
 * Conventionally storing the value on the cache would be considered a
 * side-effect and preclude unused calls from being pruned, ie. even if
 * the value was never used, it would still always be stored in the cache.
 *
 * Providing a side-effect free `valueFn` and `opt_keyFn`
 * allows unused calls to `goog.reflect.cache` to be pruned.
 *
 * @param {!Object<K, V>} cacheObj The object that contains the cached values.
 * @param {?} key The key to lookup in the cache. If it is not string or number
 *     then a `opt_keyFn` should be provided. The key is also used as the
 *     parameter to the `valueFn`.
 * @param {function(?):V} valueFn The value provider to use to calculate the
 *     value to store in the cache. This function should be side-effect free
 *     to take advantage of the optimization.
 * @param {function(?):K=} opt_keyFn The key provider to determine the cache
 *     map key. This should be used if the given key is not a string or number.
 *     If not provided then the given key is used. This function should be
 *     side-effect free to take advantage of the optimization.
 * @return {V} The cached or calculated value.
 * @template K
 * @template V
 */
goog.reflect.cache = function(cacheObj, key, valueFn, opt_keyFn) {
  'use strict';
  const storedKey = opt_keyFn ? opt_keyFn(key) : key;

  if (Object.prototype.hasOwnProperty.call(cacheObj, storedKey)) {
    return cacheObj[storedKey];
  }

  return (cacheObj[storedKey] = valueFn(key));
};

//third_party/javascript/closure/useragent/useragent.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.engine');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.labs.userAgent.util');
goog.require('goog.reflect');
goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.userAgent.ASSUME_IE = goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is EDGE,
 * referring to EdgeHTML based Edge.
 */
goog.userAgent.ASSUME_EDGE = goog.define('goog.userAgent.ASSUME_EDGE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.userAgent.ASSUME_GECKO = goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.userAgent.ASSUME_WEBKIT =
    goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.userAgent.ASSUME_MOBILE_WEBKIT =
    goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA,
 * referring to Presto-based Opera.
 */
goog.userAgent.ASSUME_OPERA = goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     `goog.userAgent.isVersionOrHigher`
 *     function will return true for any version.
 */
goog.userAgent.ASSUME_ANY_VERSION =
    goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 *
 * @return {string} The userAgent string.
 */
goog.userAgent.getUserAgentString = function() {
  'use strict';
  return goog.labs.userAgent.util.getUserAgent();
};


/**
 * @return {?Navigator} The native navigator object.
 */
goog.userAgent.getNavigatorTyped = function() {
  'use strict';
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'] || null;
};


/**
 * TODO(nnaze): Change type to "Navigator" and update compilation targets.
 * @return {?Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  'use strict';
  return goog.userAgent.getNavigatorTyped();
};


/**
 * Whether the user agent is Presto-based Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA :
    goog.labs.userAgent.browser.isOpera();


/**
 * Whether the user agent is Internet Explorer.
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE :
    goog.labs.userAgent.browser.isIE();


/**
 * Whether the user agent is Microsoft Edge (EdgeHTML based).
 * @type {boolean}
 */
goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_EDGE :
    goog.labs.userAgent.engine.isEdge();


/**
 * Whether the user agent is MS Internet Explorer or MS Edge (EdgeHTML based).
 * @type {boolean}
 */
goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Firefox, and others.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.labs.userAgent.engine.isGecko();


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Edge Chromium, Opera Chromium, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.labs.userAgent.engine.isWebKit();


/**
 * Whether the user agent is running on a mobile device.
 *
 * This is a separate function so that the logic can be tested.
 *
 * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().
 *
 * @return {boolean} Whether the user agent is running on a mobile device.
 * @private
 */
goog.userAgent.isMobile_ = function() {
  'use strict';
  return goog.userAgent.WEBKIT &&
      goog.labs.userAgent.util.matchUserAgent('Mobile');
};


/**
 * Whether the user agent is running on a mobile device.
 *
 * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent
 *   is promoted as the gecko/webkit logic is likely inaccurate.
 *
 * @type {boolean}
 */
goog.userAgent.MOBILE =
    goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  'use strict';
  var navigator = goog.userAgent.getNavigatorTyped();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.userAgent.ASSUME_MAC = goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.userAgent.ASSUME_WINDOWS =
    goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.userAgent.ASSUME_LINUX = goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.userAgent.ASSUME_X11 = goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.userAgent.ASSUME_ANDROID =
    goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.userAgent.ASSUME_IPHONE =
    goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.userAgent.ASSUME_IPAD = goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @define {boolean} Whether the user agent is running on an iPod.
 */
goog.userAgent.ASSUME_IPOD = goog.define('goog.userAgent.ASSUME_IPOD', false);


/**
 * @define {boolean} Whether the user agent is running on KaiOS.
 */
goog.userAgent.ASSUME_KAIOS = goog.define('goog.userAgent.ASSUME_KAIOS', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID ||
    goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||
    goog.userAgent.ASSUME_IPOD;


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC :
    goog.labs.userAgent.platform.isMacintosh();


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS :
    goog.labs.userAgent.platform.isWindows();


/**
 * Whether the user agent is Linux per the legacy behavior of
 * goog.userAgent.LINUX, which considered ChromeOS to also be
 * Linux.
 * @return {boolean}
 * @private
 */
goog.userAgent.isLegacyLinux_ = function() {
  'use strict';
  return goog.labs.userAgent.platform.isLinux() ||
      goog.labs.userAgent.platform.isChromeOS();
};


/**
 * Whether the user agent is running on a Linux operating system.
 *
 * Note that goog.userAgent.LINUX considers ChromeOS to be Linux,
 * while goog.labs.userAgent.platform considers ChromeOS and
 * Linux to be different OSes.
 *
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX :
    goog.userAgent.isLegacyLinux_();


/**
 * @return {boolean} Whether the user agent is an X11 windowing system.
 * @private
 */
goog.userAgent.isX11_ = function() {
  'use strict';
  var navigator = goog.userAgent.getNavigatorTyped();
  return !!navigator &&
      goog.string.contains(navigator['appVersion'] || '', 'X11');
};


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 :
    goog.userAgent.isX11_();


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID :
    goog.labs.userAgent.platform.isAndroid();


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE :
    goog.labs.userAgent.platform.isIphone();


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD :
    goog.labs.userAgent.platform.isIpad();


/**
 * Whether the user agent is running on an iPod.
 * @type {boolean}
 */
goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPOD :
    goog.labs.userAgent.platform.isIpod();


/**
 * Whether the user agent is running on iOS.
 * @type {boolean}
 */
goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ?
    (goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD ||
     goog.userAgent.ASSUME_IPOD) :
    goog.labs.userAgent.platform.isIos();

/**
 * Whether the user agent is running on KaiOS.
 * @type {boolean}
 */
goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_KAIOS :
    goog.labs.userAgent.platform.isKaiOS();


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  'use strict';
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.
  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '';
  var arr = goog.userAgent.getVersionRegexResult_();
  if (arr) {
    version = arr ? arr[1] : '';
  }

  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode != null && docMode > parseFloat(version)) {
      return String(docMode);
    }
  }

  return version;
};


/**
 * @return {?IArrayLike<string>|undefined} The version regex matches from
 *     parsing the user
 *     agent string. These regex statements must be executed inline so they can
 *     be compiled out by the closure compiler with the rest of the useragent
 *     detection logic when ASSUME_* is specified.
 * @private
 */
goog.userAgent.getVersionRegexResult_ = function() {
  'use strict';
  var userAgent = goog.userAgent.getUserAgentString();
  if (goog.userAgent.GECKO) {
    return /rv\:([^\);]+)(\)|;)/.exec(userAgent);
  }
  if (goog.userAgent.EDGE) {
    return /Edge\/([\d\.]+)/.exec(userAgent);
  }
  if (goog.userAgent.IE) {
    return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(userAgent);
  }
  if (goog.userAgent.WEBKIT) {
    // WebKit/125.4
    return /WebKit\/(\S+)/.exec(userAgent);
  }
  if (goog.userAgent.OPERA) {
    // If none of the above browsers were detected but the browser is Opera, the
    // only string that is of interest is 'Version/<number>'.
    return /(?:Version)[ \/]?(\S+)/.exec(userAgent);
  }
  return undefined;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  'use strict';
  // NOTE(pupius): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  'use strict';
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
  'use strict';
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.reflect.cache(
          goog.userAgent.isVersionOrHigherCache_, version, function() {
            'use strict';
            return goog.string.compareVersions(
                       goog.userAgent.VERSION, version) >= 0;
          });
};


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
  'use strict';
  return Number(goog.userAgent.DOCUMENT_MODE) >= documentMode;
};


/**
 * Deprecated alias to `goog.userAgent.isDocumentModeOrHigher`.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 *
 * NOTE(2019/05/31): Support for IE < 7 is long gone, so this is now simplified.
 * It returns document.documentMode for IE and undefined for everything else.
 *
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
  'use strict';
  var doc = goog.global['document'];
  if (!doc || !goog.userAgent.IE) return undefined;
  // This must be an IE user agent.
  var documentMode = goog.userAgent.getDocumentMode_();
  if (documentMode) return documentMode;
  // The user agent version string begins with the major version.
  // Parse the major version and truncate anything following.
  var ieVersion = parseInt(goog.userAgent.VERSION, 10);
  return ieVersion || undefined;
})();

//third_party/javascript/closure/events/eventtype.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Event Types.
 */


goog.provide('goog.events.EventType');
goog.provide('goog.events.MouseAsMouseEventType');
goog.provide('goog.events.MouseEvents');
goog.provide('goog.events.PointerAsMouseEventType');
goog.provide('goog.events.PointerAsTouchEventType');
goog.provide('goog.events.PointerFallbackEventType');
goog.provide('goog.events.PointerTouchFallbackEventType');

goog.require('goog.events.BrowserFeature');
goog.require('goog.userAgent');


/**
 * Returns a prefixed event name for the current browser.
 * @param {string} eventName The name of the event.
 * @return {string} The prefixed event name.
 * @private
 */
goog.events.getVendorPrefixedName_ = function(eventName) {
  'use strict';
  return goog.userAgent.WEBKIT ? 'webkit' + eventName : eventName.toLowerCase();
};


/**
 * Constants for event names.
 * @enum {string}
 */
goog.events.EventType = {
  // Mouse events
  CLICK: 'click',
  RIGHTCLICK: 'rightclick',
  DBLCLICK: 'dblclick',
  AUXCLICK: 'auxclick',
  MOUSEDOWN: 'mousedown',
  MOUSEUP: 'mouseup',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEMOVE: 'mousemove',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',

  // Non-existent event; will never fire. This exists as a mouse counterpart to
  // POINTERCANCEL.
  MOUSECANCEL: 'mousecancel',

  // Selection events.
  // https://www.w3.org/TR/selection-api/
  SELECTIONCHANGE: 'selectionchange',
  SELECTSTART: 'selectstart',  // IE, Safari, Chrome

  // Wheel events
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
  WHEEL: 'wheel',

  // Key events
  KEYPRESS: 'keypress',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',

  // Focus
  BLUR: 'blur',
  FOCUS: 'focus',
  DEACTIVATE: 'deactivate',  // IE only
  FOCUSIN: 'focusin',
  FOCUSOUT: 'focusout',

  // Forms
  CHANGE: 'change',
  RESET: 'reset',
  SELECT: 'select',
  SUBMIT: 'submit',
  INPUT: 'input',
  PROPERTYCHANGE: 'propertychange',  // IE only

  // Drag and drop
  DRAGSTART: 'dragstart',
  DRAG: 'drag',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DRAGLEAVE: 'dragleave',
  DROP: 'drop',
  DRAGEND: 'dragend',

  // Touch events
  // Note that other touch events exist, but we should follow the W3C list here.
  // http://www.w3.org/TR/touch-events/#list-of-touchevent-types
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  TOUCHCANCEL: 'touchcancel',

  // Misc
  BEFOREUNLOAD: 'beforeunload',
  CONSOLEMESSAGE: 'consolemessage',
  CONTEXTMENU: 'contextmenu',
  DEVICECHANGE: 'devicechange',
  DEVICEMOTION: 'devicemotion',
  DEVICEORIENTATION: 'deviceorientation',
  DOMCONTENTLOADED: 'DOMContentLoaded',
  ERROR: 'error',
  HELP: 'help',
  LOAD: 'load',
  LOSECAPTURE: 'losecapture',
  ORIENTATIONCHANGE: 'orientationchange',
  READYSTATECHANGE: 'readystatechange',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  UNLOAD: 'unload',

  // Media events
  CANPLAY: 'canplay',
  CANPLAYTHROUGH: 'canplaythrough',
  DURATIONCHANGE: 'durationchange',
  EMPTIED: 'emptied',
  ENDED: 'ended',
  LOADEDDATA: 'loadeddata',
  LOADEDMETADATA: 'loadedmetadata',
  PAUSE: 'pause',
  PLAY: 'play',
  PLAYING: 'playing',
  PROGRESS: 'progress',
  RATECHANGE: 'ratechange',
  SEEKED: 'seeked',
  SEEKING: 'seeking',
  STALLED: 'stalled',
  SUSPEND: 'suspend',
  TIMEUPDATE: 'timeupdate',
  VOLUMECHANGE: 'volumechange',
  WAITING: 'waiting',

  // Media Source Extensions events
  // https://www.w3.org/TR/media-source/#mediasource-events
  SOURCEOPEN: 'sourceopen',
  SOURCEENDED: 'sourceended',
  SOURCECLOSED: 'sourceclosed',
  // https://www.w3.org/TR/media-source/#sourcebuffer-events
  ABORT: 'abort',
  UPDATE: 'update',
  UPDATESTART: 'updatestart',
  UPDATEEND: 'updateend',

  // HTML 5 History events
  // See http://www.w3.org/TR/html5/browsers.html#event-definitions-0
  HASHCHANGE: 'hashchange',
  PAGEHIDE: 'pagehide',
  PAGESHOW: 'pageshow',
  POPSTATE: 'popstate',

  // Copy and Paste
  // Support is limited. Make sure it works on your favorite browser
  // before using.
  // http://www.quirksmode.org/dom/events/cutcopypaste.html
  COPY: 'copy',
  PASTE: 'paste',
  CUT: 'cut',
  BEFORECOPY: 'beforecopy',
  BEFORECUT: 'beforecut',
  BEFOREPASTE: 'beforepaste',

  // HTML5 online/offline events.
  // http://www.w3.org/TR/offline-webapps/#related
  ONLINE: 'online',
  OFFLINE: 'offline',

  // HTML 5 worker events
  MESSAGE: 'message',
  CONNECT: 'connect',

  // Service Worker Events - ServiceWorkerGlobalScope context
  // See https://w3c.github.io/ServiceWorker/#execution-context-events
  // Note: message event defined in worker events section
  INSTALL: 'install',
  ACTIVATE: 'activate',
  FETCH: 'fetch',
  FOREIGNFETCH: 'foreignfetch',
  MESSAGEERROR: 'messageerror',

  // Service Worker Events - Document context
  // See https://w3c.github.io/ServiceWorker/#document-context-events
  STATECHANGE: 'statechange',
  UPDATEFOUND: 'updatefound',
  CONTROLLERCHANGE: 'controllerchange',

  // CSS animation events.
  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),
  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),
  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),

  // CSS transition events. Based on the browser support described at:
  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility
  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),

  // W3C Pointer Events
  // http://www.w3.org/TR/pointerevents/
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTERCANCEL: 'pointercancel',
  POINTERMOVE: 'pointermove',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',

  // IE specific events.
  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
  // Note: these events will be supplanted in IE11.
  MSGESTURECHANGE: 'MSGestureChange',
  MSGESTUREEND: 'MSGestureEnd',
  MSGESTUREHOLD: 'MSGestureHold',
  MSGESTURESTART: 'MSGestureStart',
  MSGESTURETAP: 'MSGestureTap',
  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',
  MSINERTIASTART: 'MSInertiaStart',
  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',
  MSPOINTERCANCEL: 'MSPointerCancel',
  MSPOINTERDOWN: 'MSPointerDown',
  MSPOINTERENTER: 'MSPointerEnter',
  MSPOINTERHOVER: 'MSPointerHover',
  MSPOINTERLEAVE: 'MSPointerLeave',
  MSPOINTERMOVE: 'MSPointerMove',
  MSPOINTEROUT: 'MSPointerOut',
  MSPOINTEROVER: 'MSPointerOver',
  MSPOINTERUP: 'MSPointerUp',

  // Native IMEs/input tools events.
  TEXT: 'text',
  // The textInput event is supported in IE9+, but only in lower case. All other
  // browsers use the camel-case event name.
  TEXTINPUT: goog.userAgent.IE ? 'textinput' : 'textInput',
  COMPOSITIONSTART: 'compositionstart',
  COMPOSITIONUPDATE: 'compositionupdate',
  COMPOSITIONEND: 'compositionend',

  // The beforeinput event is initially only supported in Safari. See
  // https://bugs.chromium.org/p/chromium/issues/detail?id=342670 for Chrome
  // implementation tracking.
  BEFOREINPUT: 'beforeinput',

  // Webview tag events
  // See https://developer.chrome.com/apps/tags/webview
  EXIT: 'exit',
  LOADABORT: 'loadabort',
  LOADCOMMIT: 'loadcommit',
  LOADREDIRECT: 'loadredirect',
  LOADSTART: 'loadstart',
  LOADSTOP: 'loadstop',
  RESPONSIVE: 'responsive',
  SIZECHANGED: 'sizechanged',
  UNRESPONSIVE: 'unresponsive',

  // HTML5 Page Visibility API.  See details at
  // `goog.labs.dom.PageVisibilityMonitor`.
  VISIBILITYCHANGE: 'visibilitychange',

  // LocalStorage event.
  STORAGE: 'storage',

  // DOM Level 2 mutation events (deprecated).
  DOMSUBTREEMODIFIED: 'DOMSubtreeModified',
  DOMNODEINSERTED: 'DOMNodeInserted',
  DOMNODEREMOVED: 'DOMNodeRemoved',
  DOMNODEREMOVEDFROMDOCUMENT: 'DOMNodeRemovedFromDocument',
  DOMNODEINSERTEDINTODOCUMENT: 'DOMNodeInsertedIntoDocument',
  DOMATTRMODIFIED: 'DOMAttrModified',
  DOMCHARACTERDATAMODIFIED: 'DOMCharacterDataModified',

  // Print events.
  BEFOREPRINT: 'beforeprint',
  AFTERPRINT: 'afterprint',

  // Web app manifest events.
  BEFOREINSTALLPROMPT: 'beforeinstallprompt',
  APPINSTALLED: 'appinstalled'
};


/**
 * Returns one of the given pointer fallback event names in order of preference:
 *   1. pointerEventName
 *   2. msPointerEventName
 *   3. fallbackEventName
 * @param {string} pointerEventName
 * @param {string} msPointerEventName
 * @param {string} fallbackEventName
 * @return {string} The supported pointer or fallback (mouse or touch) event
 *     name.
 * @private
 */
goog.events.getPointerFallbackEventName_ = function(
    pointerEventName, msPointerEventName, fallbackEventName) {
  'use strict';
  if (goog.events.BrowserFeature.POINTER_EVENTS) {
    return pointerEventName;
  }
  if (goog.events.BrowserFeature.MSPOINTER_EVENTS) {
    return msPointerEventName;
  }
  return fallbackEventName;
};


/**
 * Constants for pointer event names that fall back to corresponding mouse event
 * names on unsupported platforms. These are intended to be drop-in replacements
 * for corresponding values in `goog.events.EventType`.
 * @enum {string}
 */
goog.events.PointerFallbackEventType = {
  POINTERDOWN: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,
      goog.events.EventType.MOUSEDOWN),
  POINTERUP: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,
      goog.events.EventType.MOUSEUP),
  POINTERCANCEL: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERCANCEL,
      goog.events.EventType.MSPOINTERCANCEL,
      // When falling back to mouse events, there is no MOUSECANCEL equivalent
      // of POINTERCANCEL. In this case POINTERUP already falls back to MOUSEUP
      // which represents both UP and CANCEL. POINTERCANCEL does not fall back
      // to MOUSEUP to prevent listening twice on the same event.
      goog.events.EventType.MOUSECANCEL),
  POINTERMOVE: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,
      goog.events.EventType.MOUSEMOVE),
  POINTEROVER: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTEROVER, goog.events.EventType.MSPOINTEROVER,
      goog.events.EventType.MOUSEOVER),
  POINTEROUT: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTEROUT, goog.events.EventType.MSPOINTEROUT,
      goog.events.EventType.MOUSEOUT),
  POINTERENTER: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERENTER, goog.events.EventType.MSPOINTERENTER,
      goog.events.EventType.MOUSEENTER),
  POINTERLEAVE: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERLEAVE, goog.events.EventType.MSPOINTERLEAVE,
      goog.events.EventType.MOUSELEAVE)
};


/**
 * Constants for pointer event names that fall back to corresponding touch event
 * names on unsupported platforms. These are intended to be drop-in replacements
 * for corresponding values in `goog.events.EventType`.
 * @enum {string}
 */
goog.events.PointerTouchFallbackEventType = {
  POINTERDOWN: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN,
      goog.events.EventType.TOUCHSTART),
  POINTERUP: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP,
      goog.events.EventType.TOUCHEND),
  POINTERCANCEL: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERCANCEL,
      goog.events.EventType.MSPOINTERCANCEL, goog.events.EventType.TOUCHCANCEL),
  POINTERMOVE: goog.events.getPointerFallbackEventName_(
      goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE,
      goog.events.EventType.TOUCHMOVE)
};


/**
 * Mapping of mouse event names to underlying browser event names.
 * @typedef {{
 *     MOUSEDOWN: string,
 *     MOUSEUP: string,
 *     MOUSECANCEL:string,
 *     MOUSEMOVE:string,
 *     MOUSEOVER:string,
 *     MOUSEOUT:string,
 *     MOUSEENTER:string,
 *     MOUSELEAVE: string,
 * }}
 */
goog.events.MouseEvents;


/**
 * An alias for `goog.events.EventType.MOUSE*` event types that is overridden by
 * corresponding `POINTER*` event types.
 * @const {!goog.events.MouseEvents}
 */
goog.events.PointerAsMouseEventType = {
  MOUSEDOWN: goog.events.PointerFallbackEventType.POINTERDOWN,
  MOUSEUP: goog.events.PointerFallbackEventType.POINTERUP,
  MOUSECANCEL: goog.events.PointerFallbackEventType.POINTERCANCEL,
  MOUSEMOVE: goog.events.PointerFallbackEventType.POINTERMOVE,
  MOUSEOVER: goog.events.PointerFallbackEventType.POINTEROVER,
  MOUSEOUT: goog.events.PointerFallbackEventType.POINTEROUT,
  MOUSEENTER: goog.events.PointerFallbackEventType.POINTERENTER,
  MOUSELEAVE: goog.events.PointerFallbackEventType.POINTERLEAVE
};


/**
 * An alias for `goog.events.EventType.MOUSE*` event types that continue to use
 * mouse events.
 * @const {!goog.events.MouseEvents}
 */
goog.events.MouseAsMouseEventType = {
  MOUSEDOWN: goog.events.EventType.MOUSEDOWN,
  MOUSEUP: goog.events.EventType.MOUSEUP,
  MOUSECANCEL: goog.events.EventType.MOUSECANCEL,
  MOUSEMOVE: goog.events.EventType.MOUSEMOVE,
  MOUSEOVER: goog.events.EventType.MOUSEOVER,
  MOUSEOUT: goog.events.EventType.MOUSEOUT,
  MOUSEENTER: goog.events.EventType.MOUSEENTER,
  MOUSELEAVE: goog.events.EventType.MOUSELEAVE
};


/**
 * An alias for `goog.events.EventType.TOUCH*` event types that is overridden by
 * corresponding `POINTER*` event types.
 * @enum {string}
 */
goog.events.PointerAsTouchEventType = {
  TOUCHCANCEL: goog.events.PointerTouchFallbackEventType.POINTERCANCEL,
  TOUCHEND: goog.events.PointerTouchFallbackEventType.POINTERUP,
  TOUCHMOVE: goog.events.PointerTouchFallbackEventType.POINTERMOVE,
  TOUCHSTART: goog.events.PointerTouchFallbackEventType.POINTERDOWN
};

//third_party/javascript/closure/events/browserevent.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A patched, standardized event object for browser events.
 *
 * <pre>
 * The patched event object contains the following members:
 * - type           {string}    Event type, e.g. 'click'
 * - target         {Object}    The element that actually triggered the event
 * - currentTarget  {Object}    The element the listener is attached to
 * - relatedTarget  {Object}    For mouseover and mouseout, the previous object
 * - offsetX        {number}    X-coordinate relative to target
 * - offsetY        {number}    Y-coordinate relative to target
 * - clientX        {number}    X-coordinate relative to viewport
 * - clientY        {number}    Y-coordinate relative to viewport
 * - screenX        {number}    X-coordinate relative to the edge of the screen
 * - screenY        {number}    Y-coordinate relative to the edge of the screen
 * - button         {number}    Mouse button. Use isButton() to test.
 * - keyCode        {number}    Key-code
 * - ctrlKey        {boolean}   Was ctrl key depressed
 * - altKey         {boolean}   Was alt key depressed
 * - shiftKey       {boolean}   Was shift key depressed
 * - metaKey        {boolean}   Was meta key depressed
 * - pointerId      {number}    Pointer ID
 * - pointerType    {string}    Pointer type, e.g. 'mouse', 'pen', or 'touch'
 * - defaultPrevented {boolean} Whether the default action has been prevented
 * - state          {Object}    History state object
 *
 * NOTE: The keyCode member contains the raw browser keyCode. For normalized
 * key and character code use {@link goog.events.KeyHandler}.
 * </pre>
 */

goog.provide('goog.events.BrowserEvent');
goog.provide('goog.events.BrowserEvent.MouseButton');
goog.provide('goog.events.BrowserEvent.PointerType');

goog.require('goog.debug');
goog.require('goog.events.Event');
goog.require('goog.events.EventType');
goog.require('goog.reflect');
goog.require('goog.userAgent');

/**
 * @define {boolean} If true, use the layerX and layerY properties of a native
 * browser event over the offsetX and offsetY properties, which cause expensive
 * reflow. If layerX or layerY is not defined, offsetX and offsetY will be used
 * as usual.
 */
goog.events.USE_LAYER_XY_AS_OFFSET_XY =
    goog.define('goog.events.USE_LAYER_XY_AS_OFFSET_XY', false);

/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * The content of this object will not be initialized if no event object is
 * provided. If this is the case, init() needs to be invoked separately.
 * @param {Event=} opt_e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 * @constructor
 * @extends {goog.events.Event}
 */
goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {
  'use strict';
  goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');

  /**
   * Target that fired the event.
   * @override
   * @type {?Node}
   */
  this.target = null;

  /**
   * Node that had the listener attached.
   * @override
   * @type {?Node|undefined}
   */
  this.currentTarget = null;

  /**
   * For mouseover and mouseout events, the related object for the event.
   * @type {?Node}
   */
  this.relatedTarget = null;

  /**
   * X-coordinate relative to target.
   * @type {number}
   */
  this.offsetX = 0;

  /**
   * Y-coordinate relative to target.
   * @type {number}
   */
  this.offsetY = 0;

  /**
   * X-coordinate relative to the window.
   * @type {number}
   */
  this.clientX = 0;

  /**
   * Y-coordinate relative to the window.
   * @type {number}
   */
  this.clientY = 0;

  /**
   * X-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenX = 0;

  /**
   * Y-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenY = 0;

  /**
   * Which mouse button was pressed.
   * @type {number}
   */
  this.button = 0;

  /**
   * Key of key press.
   * @type {string}
   */
  this.key = '';

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.charCode = 0;

  /**
   * Whether control was pressed at time of event.
   * @type {boolean}
   */
  this.ctrlKey = false;

  /**
   * Whether alt was pressed at time of event.
   * @type {boolean}
   */
  this.altKey = false;

  /**
   * Whether shift was pressed at time of event.
   * @type {boolean}
   */
  this.shiftKey = false;

  /**
   * Whether the meta key was pressed at time of event.
   * @type {boolean}
   */
  this.metaKey = false;

  /**
   * History state object, only set for PopState events where it's a copy of the
   * state object provided to pushState or replaceState.
   * @type {?Object}
   */
  this.state = null;

  /**
   * Whether the default platform modifier key was pressed at time of event.
   * (This is control for all platforms except Mac, where it's Meta.)
   * @type {boolean}
   */
  this.platformModifierKey = false;

  /**
   * @type {number}
   */
  this.pointerId = 0;

  /**
   * @type {string}
   */
  this.pointerType = '';

  /**
   * The browser event object.
   * @private {?Event}
   */
  this.event_ = null;

  if (opt_e) {
    this.init(opt_e, opt_currentTarget);
  }
};
goog.inherits(goog.events.BrowserEvent, goog.events.Event);


/**
 * Normalized button constants for the mouse.
 * @enum {number}
 */
goog.events.BrowserEvent.MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};


/**
 * Normalized pointer type constants for pointer events.
 * @enum {string}
 */
goog.events.BrowserEvent.PointerType = {
  MOUSE: 'mouse',
  PEN: 'pen',
  TOUCH: 'touch'
};


/**
 * Static data for mapping mouse buttons.
 * @type {!Array<number>}
 * @deprecated Use `goog.events.BrowserEvent.IE_BUTTON_MAP` instead.
 */
goog.events.BrowserEvent.IEButtonMap = goog.debug.freeze([
  1,  // LEFT
  4,  // MIDDLE
  2   // RIGHT
]);


/**
 * Static data for mapping mouse buttons.
 * @const {!Array<number>}
 */
goog.events.BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;


/**
 * Static data for mapping MSPointerEvent types to PointerEvent types.
 * @const {!Object<number, goog.events.BrowserEvent.PointerType>}
 */
goog.events.BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({
  2: goog.events.BrowserEvent.PointerType.TOUCH,
  3: goog.events.BrowserEvent.PointerType.PEN,
  4: goog.events.BrowserEvent.PointerType.MOUSE
});


/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * @param {Event} e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 */
goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {
  'use strict';
  var type = this.type = e.type;

  /**
   * On touch devices use the first "changed touch" as the relevant touch.
   * @type {?Touch}
   */
  var relevantTouch =
      e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;

  // TODO(nicksantos): Change this.target to type EventTarget.
  this.target = /** @type {Node} */ (e.target) || e.srcElement;

  // TODO(nicksantos): Change this.currentTarget to type EventTarget.
  this.currentTarget = /** @type {Node} */ (opt_currentTarget);

  var relatedTarget = /** @type {Node} */ (e.relatedTarget);
  if (relatedTarget) {
    // There's a bug in FireFox where sometimes, relatedTarget will be a
    // chrome element, and accessing any property of it will get a permission
    // denied exception. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780
    if (goog.userAgent.GECKO) {
      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {
        relatedTarget = null;
      }
    }
  } else if (type == goog.events.EventType.MOUSEOVER) {
    relatedTarget = e.fromElement;
  } else if (type == goog.events.EventType.MOUSEOUT) {
    relatedTarget = e.toElement;
  }

  this.relatedTarget = relatedTarget;

  if (relevantTouch) {
    this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX :
                                                         relevantTouch.pageX;
    this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY :
                                                         relevantTouch.pageY;
    this.screenX = relevantTouch.screenX || 0;
    this.screenY = relevantTouch.screenY || 0;
  } else {
    if (goog.events.USE_LAYER_XY_AS_OFFSET_XY) {
      this.offsetX = (e.layerX !== undefined) ? e.layerX : e.offsetX;
      this.offsetY = (e.layerY !== undefined) ? e.layerY : e.offsetY;
    } else {
      // Webkit emits a lame warning whenever layerX/layerY is accessed.
      // http://code.google.com/p/chromium/issues/detail?id=101733
      this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?
          e.offsetX :
          e.layerX;
      this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?
          e.offsetY :
          e.layerY;
    }
    this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
    this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
    this.screenX = e.screenX || 0;
    this.screenY = e.screenY || 0;
  }

  this.button = e.button;

  this.keyCode = e.keyCode || 0;
  this.key = e.key || '';
  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);
  this.ctrlKey = e.ctrlKey;
  this.altKey = e.altKey;
  this.shiftKey = e.shiftKey;
  this.metaKey = e.metaKey;
  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
  this.pointerId = e.pointerId || 0;
  this.pointerType = goog.events.BrowserEvent.getPointerType_(e);
  this.state = e.state;
  this.event_ = e;
  if (e.defaultPrevented) {
    // Sync native event state to internal state via super class, where default
    // prevention is implemented and managed.
    goog.events.BrowserEvent.superClass_.preventDefault.call(this);
  }
};


/**
 * Tests to see which button was pressed during the event. This is really only
 * useful in IE and Gecko browsers. And in IE, it's only useful for
 * mousedown/mouseup events, because click only fires for the left mouse button.
 *
 * Safari 2 only reports the left button being clicked, and uses the value '1'
 * instead of 0. Opera only reports a mousedown event for the middle button, and
 * no mouse events for the right button. Opera has default behavior for left and
 * middle click that can only be overridden via a configuration setting.
 *
 * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.
 *
 * @param {goog.events.BrowserEvent.MouseButton} button The button
 *     to test for.
 * @return {boolean} True if button was pressed.
 */
goog.events.BrowserEvent.prototype.isButton = function(button) {
  'use strict';
  return this.event_.button == button;
};


/**
 * Whether this has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @return {boolean} The result.
 */
goog.events.BrowserEvent.prototype.isMouseActionButton = function() {
  'use strict';
  // Ctrl+click should never behave like a left-click on mac, regardless of
  // whether or not the browser will actually ever emit such an event.  If
  // we see it, treat it like right-click always.
  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&
      !(goog.userAgent.MAC && this.ctrlKey);
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.stopPropagation = function() {
  'use strict';
  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
  if (this.event_.stopPropagation) {
    this.event_.stopPropagation();
  } else {
    this.event_.cancelBubble = true;
  }
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.preventDefault = function() {
  'use strict';
  goog.events.BrowserEvent.superClass_.preventDefault.call(this);
  var be = this.event_;
  if (!be.preventDefault) {
    be.returnValue = false;
  } else {
    be.preventDefault();
  }
};


/**
 * @return {Event} The underlying browser event object.
 */
goog.events.BrowserEvent.prototype.getBrowserEvent = function() {
  'use strict';
  return this.event_;
};


/**
 * Extracts the pointer type from the given event.
 * @param {!Event} e
 * @return {string} The pointer type, e.g. 'mouse', 'pen', or 'touch'.
 * @private
 */
goog.events.BrowserEvent.getPointerType_ = function(e) {
  'use strict';
  if (typeof (e.pointerType) === 'string') {
    return e.pointerType;
  }
  // IE10 uses integer codes for pointer type.
  // https://msdn.microsoft.com/en-us/library/hh772359(v=vs.85).aspx
  return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || '';
};

//third_party/javascript/closure/events/listenable.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview An interface for a listenable JavaScript object.
 */

goog.provide('goog.events.Listenable');

goog.requireType('goog.events.EventId');
goog.requireType('goog.events.EventLike');
goog.requireType('goog.events.ListenableKey');


/**
 * A listenable interface. A listenable is an object with the ability
 * to dispatch/broadcast events to "event listeners" registered via
 * listen/listenOnce.
 *
 * The interface allows for an event propagation mechanism similar
 * to one offered by native browser event targets, such as
 * capture/bubble mechanism, stopping propagation, and preventing
 * default actions. Capture/bubble mechanism depends on the ancestor
 * tree constructed via `#getParentEventTarget`; this tree
 * must be directed acyclic graph. The meaning of default action(s)
 * in preventDefault is specific to a particular use case.
 *
 * Implementations that do not support capture/bubble or can not have
 * a parent listenable can simply not implement any ability to set the
 * parent listenable (and have `#getParentEventTarget` return
 * null).
 *
 * Implementation of this class can be used with or independently from
 * goog.events.
 *
 * Implementation must call `#addImplementation(implClass)`.
 *
 * @interface
 * @see goog.events
 * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html
 */
goog.events.Listenable = function() {};


/**
 * An expando property to indicate that an object implements
 * goog.events.Listenable.
 *
 * See addImplementation/isImplementedBy.
 *
 * @type {string}
 * @const
 */
goog.events.Listenable.IMPLEMENTED_BY_PROP =
    'closure_listenable_' + ((Math.random() * 1e6) | 0);


/**
 * Marks a given class (constructor) as an implementation of
 * Listenable, so that we can query that fact at runtime. The class
 * must have already implemented the interface.
 * @param {function(new:goog.events.Listenable,...)} cls The class constructor.
 *     The corresponding class must have already implemented the interface.
 */
goog.events.Listenable.addImplementation = function(cls) {
  'use strict';
  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;
};


/**
 * @param {?Object} obj The object to check.
 * @return {boolean} Whether a given instance implements Listenable. The
 *     class/superclass of the instance must call addImplementation.
 */
goog.events.Listenable.isImplementedBy = function(obj) {
  'use strict';
  return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {!goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listen = function(
    type, listener, opt_useCapture, opt_listenerScope) {};


/**
 * Adds an event listener that is removed automatically after the
 * listener fired once.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {!goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listenOnce = function(
    type, listener, opt_useCapture, opt_listenerScope) {};


/**
 * Removes an event listener which was added with listen() or listenOnce().
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.unlisten = function(
    type, listener, opt_useCapture, opt_listenerScope) {};


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {!goog.events.ListenableKey} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 */
goog.events.Listenable.prototype.unlistenByKey = function(key) {};


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {?goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 */
goog.events.Listenable.prototype.dispatchEvent = function(e) {};


/**
 * Removes all listeners from this listenable. If type is specified,
 * it will only remove listeners of the particular type. otherwise all
 * registered listeners will be removed.
 *
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove,
 *     default is to remove all types.
 * @return {number} Number of listeners removed.
 */
goog.events.Listenable.prototype.removeAllListeners = function(opt_type) {};


/**
 * Returns the parent of this event target to use for capture/bubble
 * mechanism.
 *
 * NOTE(chrishenry): The name reflects the original implementation of
 * custom event target (`goog.events.EventTarget`). We decided
 * that changing the name is not worth it.
 *
 * @return {?goog.events.Listenable} The parent EventTarget or null if
 *     there is no parent.
 */
goog.events.Listenable.prototype.getParentEventTarget = function() {};


/**
 * Fires all registered listeners in this listenable for the given
 * type and capture mode, passing them the given eventObject. This
 * does not perform actual capture/bubble. Only implementors of the
 * interface should be using this.
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The type of the
 *     listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @param {EVENTOBJ} eventObject The event object to fire.
 * @return {boolean} Whether all listeners succeeded without
 *     attempting to prevent default behavior. If any listener returns
 *     false or called goog.events.Event#preventDefault, this returns
 *     false.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.fireListeners = function(
    type, capture, eventObject) {};


/**
 * Gets all listeners in this listenable for the given type and
 * capture mode.
 *
 * @param {string|!goog.events.EventId} type The type of the listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @return {!Array<!goog.events.ListenableKey>} An array of registered
 *     listeners.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.getListeners = function(type, capture) {};


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The name of the event
 *     without the 'on' prefix.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The
 *     listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {?goog.events.ListenableKey} the found listener or null if not found.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {};


/**
 * Whether there is any active listeners matching the specified
 * signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {string|!goog.events.EventId<EVENTOBJ>=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble
 *     listeners.
 * @return {boolean} Whether there is any active listeners matching
 *     the requested type and/or capture phase.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.hasListener = function(
    opt_type, opt_capture) {};

//third_party/javascript/closure/events/listenablekey.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview An interface that describes a single registered listener.
 */
goog.provide('goog.events.ListenableKey');

goog.requireType('goog.events.Listenable');


/**
 * An interface that describes a single registered listener.
 * @interface
 */
goog.events.ListenableKey = function() {};


/**
 * Counter used to create a unique key
 * @type {number}
 * @private
 */
goog.events.ListenableKey.counter_ = 0;


/**
 * Reserves a key to be used for ListenableKey#key field.
 * @return {number} A number to be used to fill ListenableKey#key
 *     field.
 */
goog.events.ListenableKey.reserveKey = function() {
  'use strict';
  return ++goog.events.ListenableKey.counter_;
};


/**
 * The source event target.
 * @type {?Object|?goog.events.Listenable}
 */
goog.events.ListenableKey.prototype.src;


/**
 * The event type the listener is listening to.
 * @type {string}
 */
goog.events.ListenableKey.prototype.type;


/**
 * The listener function.
 * @type {function(?):?|{handleEvent:function(?):?}|null}
 */
goog.events.ListenableKey.prototype.listener;


/**
 * Whether the listener works on capture phase.
 * @type {boolean}
 */
goog.events.ListenableKey.prototype.capture;


/**
 * The 'this' object for the listener function's scope.
 * @type {?Object|undefined}
 */
goog.events.ListenableKey.prototype.handler;


/**
 * A globally unique number to identify the key.
 * @type {number}
 */
goog.events.ListenableKey.prototype.key;

//third_party/javascript/closure/events/listener.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Listener object.
 * @see ../demos/events.html
 */

goog.provide('goog.events.Listener');

goog.require('goog.events.ListenableKey');
goog.requireType('goog.events.Listenable');



/**
 * Simple class that stores information about a listener
 * @param {function(?):?} listener Callback function.
 * @param {Function} proxy Wrapper for the listener that patches the event.
 * @param {EventTarget|goog.events.Listenable} src Source object for
 *     the event.
 * @param {string} type Event type.
 * @param {boolean} capture Whether in capture or bubble phase.
 * @param {Object=} opt_handler Object in whose context to execute the callback.
 * @implements {goog.events.ListenableKey}
 * @constructor
 */
goog.events.Listener = function(
    listener, proxy, src, type, capture, opt_handler) {
  'use strict';
  if (goog.events.Listener.ENABLE_MONITORING) {
    this.creationStack = new Error().stack;
  }

  /** @override */
  this.listener = listener;

  /**
   * A wrapper over the original listener. This is used solely to
   * handle native browser events (it is used to simulate the capture
   * phase and to patch the event object).
   * @type {Function}
   */
  this.proxy = proxy;

  /**
   * Object or node that callback is listening to
   * @type {EventTarget|goog.events.Listenable}
   */
  this.src = src;

  /**
   * The event type.
   * @const {string}
   */
  this.type = type;

  /**
   * Whether the listener is being called in the capture or bubble phase
   * @const {boolean}
   */
  this.capture = !!capture;

  /**
   * Optional object whose context to execute the listener in
   * @type {Object|undefined}
   */
  this.handler = opt_handler;

  /**
   * The key of the listener.
   * @const {number}
   * @override
   */
  this.key = goog.events.ListenableKey.reserveKey();

  /**
   * Whether to remove the listener after it has been called.
   * @type {boolean}
   */
  this.callOnce = false;

  /**
   * Whether the listener has been removed.
   * @type {boolean}
   */
  this.removed = false;
};


/**
 * @define {boolean} Whether to enable the monitoring of the
 *     goog.events.Listener instances. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.events.Listener.ENABLE_MONITORING =
    goog.define('goog.events.Listener.ENABLE_MONITORING', false);


/**
 * If monitoring the goog.events.Listener instances is enabled, stores the
 * creation stack trace of the Disposable instance.
 * @type {string}
 */
goog.events.Listener.prototype.creationStack;


/**
 * Marks this listener as removed. This also remove references held by
 * this listener object (such as listener and event source).
 */
goog.events.Listener.prototype.markAsRemoved = function() {
  'use strict';
  this.removed = true;
  this.listener = null;
  this.proxy = null;
  this.src = null;
  this.handler = null;
};

//third_party/javascript/closure/events/listenermap.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A map of listeners that provides utility functions to
 * deal with listeners on an event target. Used by
 * `goog.events.EventTarget`.
 *
 * WARNING: Do not use this class from outside goog.events package.
 *
 */

goog.provide('goog.events.ListenerMap');

goog.require('goog.array');
goog.require('goog.events.Listener');
goog.require('goog.object');
goog.requireType('goog.events.EventId');
goog.requireType('goog.events.Listenable');
goog.requireType('goog.events.ListenableKey');



/**
 * Creates a new listener map.
 * @param {EventTarget|goog.events.Listenable} src The src object.
 * @constructor
 * @final
 */
goog.events.ListenerMap = function(src) {
  'use strict';
  /** @type {EventTarget|goog.events.Listenable} */
  this.src = src;

  /**
   * Maps of event type to an array of listeners.
   * @type {!Object<string, !Array<!goog.events.Listener>>}
   */
  this.listeners = {};

  /**
   * The count of types in this map that have registered listeners.
   * @private {number}
   */
  this.typeCount_ = 0;
};


/**
 * @return {number} The count of event types in this map that actually
 *     have registered listeners.
 */
goog.events.ListenerMap.prototype.getTypeCount = function() {
  'use strict';
  return this.typeCount_;
};


/**
 * @return {number} Total number of registered listeners.
 */
goog.events.ListenerMap.prototype.getListenerCount = function() {
  'use strict';
  var count = 0;
  for (var type in this.listeners) {
    count += this.listeners[type].length;
  }
  return count;
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {string|!goog.events.EventId} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {!goog.events.ListenableKey} Unique key for the listener.
 */
goog.events.ListenerMap.prototype.add = function(
    type, listener, callOnce, opt_useCapture, opt_listenerScope) {
  'use strict';
  var typeStr = type.toString();
  var listenerArray = this.listeners[typeStr];
  if (!listenerArray) {
    listenerArray = this.listeners[typeStr] = [];
    this.typeCount_++;
  }

  var listenerObj;
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    listenerObj = listenerArray[index];
    if (!callOnce) {
      // Ensure that, if there is an existing callOnce listener, it is no
      // longer a callOnce listener.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = new goog.events.Listener(
        listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);
    listenerObj.callOnce = callOnce;
    listenerArray.push(listenerObj);
  }
  return listenerObj;
};


/**
 * Removes a matching listener.
 * @param {string|!goog.events.EventId} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {boolean} Whether any listener was removed.
 */
goog.events.ListenerMap.prototype.remove = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  'use strict';
  var typeStr = type.toString();
  if (!(typeStr in this.listeners)) {
    return false;
  }

  var listenerArray = this.listeners[typeStr];
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    var listenerObj = listenerArray[index];
    listenerObj.markAsRemoved();
    goog.array.removeAt(listenerArray, index);
    if (listenerArray.length == 0) {
      delete this.listeners[typeStr];
      this.typeCount_--;
    }
    return true;
  }
  return false;
};


/**
 * Removes the given listener object.
 * @param {!goog.events.ListenableKey} listener The listener to remove.
 * @return {boolean} Whether the listener is removed.
 */
goog.events.ListenerMap.prototype.removeByKey = function(listener) {
  'use strict';
  var type = listener.type;
  if (!(type in this.listeners)) {
    return false;
  }

  var removed = goog.array.remove(this.listeners[type], listener);
  if (removed) {
    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();
    if (this.listeners[type].length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return removed;
};


/**
 * Removes all listeners from this map. If opt_type is provided, only
 * listeners that match the given type are removed.
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
 * @return {number} Number of listeners removed.
 */
goog.events.ListenerMap.prototype.removeAll = function(opt_type) {
  'use strict';
  var typeStr = opt_type && opt_type.toString();
  var count = 0;
  for (var type in this.listeners) {
    if (!typeStr || type == typeStr) {
      var listenerArray = this.listeners[type];
      for (var i = 0; i < listenerArray.length; i++) {
        ++count;
        listenerArray[i].markAsRemoved();
      }
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return count;
};


/**
 * Gets all listeners that match the given type and capture mode. The
 * returned array is a copy (but the listener objects are not).
 * @param {string|!goog.events.EventId} type The type of the listeners
 *     to retrieve.
 * @param {boolean} capture The capture mode of the listeners to retrieve.
 * @return {!Array<!goog.events.ListenableKey>} An array of matching
 *     listeners.
 */
goog.events.ListenerMap.prototype.getListeners = function(type, capture) {
  'use strict';
  var listenerArray = this.listeners[type.toString()];
  var rv = [];
  if (listenerArray) {
    for (var i = 0; i < listenerArray.length; ++i) {
      var listenerObj = listenerArray[i];
      if (listenerObj.capture == capture) {
        rv.push(listenerObj);
      }
    }
  }
  return rv;
};


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId} type The type of the listener
 *     to retrieve.
 * @param {!Function} listener The listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.ListenerMap.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  'use strict';
  var listenerArray = this.listeners[type.toString()];
  var i = -1;
  if (listenerArray) {
    i = goog.events.ListenerMap.findListenerIndex_(
        listenerArray, listener, capture, opt_listenerScope);
  }
  return i > -1 ? listenerArray[i] : null;
};


/**
 * Whether there is a matching listener. If either the type or capture
 * parameters are unspecified, the function will match on the
 * remaining criteria.
 *
 * @param {string|!goog.events.EventId=} opt_type The type of the listener.
 * @param {boolean=} opt_capture The capture mode of the listener.
 * @return {boolean} Whether there is an active listener matching
 *     the requested type and/or capture phase.
 */
goog.events.ListenerMap.prototype.hasListener = function(
    opt_type, opt_capture) {
  'use strict';
  var hasType = (opt_type !== undefined);
  var typeStr = hasType ? opt_type.toString() : '';
  var hasCapture = (opt_capture !== undefined);

  return goog.object.some(this.listeners, function(listenerArray, type) {
    'use strict';
    for (var i = 0; i < listenerArray.length; ++i) {
      if ((!hasType || listenerArray[i].type == typeStr) &&
          (!hasCapture || listenerArray[i].capture == opt_capture)) {
        return true;
      }
    }

    return false;
  });
};


/**
 * Finds the index of a matching goog.events.Listener in the given
 * listenerArray.
 * @param {!Array<!goog.events.Listener>} listenerArray Array of listener.
 * @param {!Function} listener The listener function.
 * @param {boolean=} opt_useCapture The capture flag for the listener.
 * @param {Object=} opt_listenerScope The listener scope.
 * @return {number} The index of the matching listener within the
 *     listenerArray.
 * @private
 */
goog.events.ListenerMap.findListenerIndex_ = function(
    listenerArray, listener, opt_useCapture, opt_listenerScope) {
  'use strict';
  for (var i = 0; i < listenerArray.length; ++i) {
    var listenerObj = listenerArray[i];
    if (!listenerObj.removed && listenerObj.listener == listener &&
        listenerObj.capture == !!opt_useCapture &&
        listenerObj.handler == opt_listenerScope) {
      return i;
    }
  }
  return -1;
};

//third_party/javascript/closure/events/events.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview An event manager for both native browser event
 * targets and custom JavaScript event targets
 * (`goog.events.Listenable`). This provides an abstraction
 * over browsers' event systems.
 *
 * It also provides a simulation of W3C event model's capture phase in
 * Internet Explorer (IE 8 and below). Caveat: the simulation does not
 * interact well with listeners registered directly on the elements
 * (bypassing goog.events) or even with listeners registered via
 * goog.events in a separate JS binary. In these cases, we provide
 * no ordering guarantees.
 *
 * The listeners will receive a "patched" event object. Such event object
 * contains normalized values for certain event properties that differs in
 * different browsers.
 *
 * Example usage:
 * <pre>
 * goog.events.listen(myNode, 'click', function(e) { alert('woo') });
 * goog.events.listen(myNode, 'mouseover', mouseHandler, true);
 * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);
 * goog.events.removeAll(myNode);
 * </pre>
 *
 *                                            in IE and event object patching]
 *
 * @see ../demos/events.html
 * @see ../demos/event-propagation.html
 * @see ../demos/stopevent.html
 */

// IMPLEMENTATION NOTES:
// goog.events stores an auxiliary data structure on each EventTarget
// source being listened on. This allows us to take advantage of GC,
// having the data structure GC'd when the EventTarget is GC'd. This
// GC behavior is equivalent to using W3C DOM Events directly.

goog.provide('goog.events');
goog.provide('goog.events.CaptureSimulationMode');
goog.provide('goog.events.Key');
goog.provide('goog.events.ListenableType');

goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.requireType('goog.debug.ErrorHandler');
goog.requireType('goog.events.EventId');
goog.requireType('goog.events.EventLike');
goog.requireType('goog.events.EventWrapper');
goog.requireType('goog.events.ListenableKey');
goog.requireType('goog.events.Listener');


/**
 * @typedef {number|goog.events.ListenableKey}
 */
goog.events.Key;


/**
 * @typedef {EventTarget|goog.events.Listenable}
 */
goog.events.ListenableType;


/**
 * Property name on a native event target for the listener map
 * associated with the event target.
 * @private @const {string}
 */
goog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);


/**
 * String used to prepend to IE event types.
 * @const
 * @private
 */
goog.events.onString_ = 'on';


/**
 * Map of computed "on<eventname>" strings for IE event types. Caching
 * this removes an extra object allocation in goog.events.listen which
 * improves IE6 performance.
 * @const
 * @dict
 * @private
 */
goog.events.onStringMap_ = {};


/**
 * @enum {number} Different capture simulation mode for IE8-.
 */
goog.events.CaptureSimulationMode = {
  /**
   * Does not perform capture simulation. Will asserts in IE8- when you
   * add capture listeners.
   */
  OFF_AND_FAIL: 0,

  /**
   * Does not perform capture simulation, silently ignore capture
   * listeners.
   */
  OFF_AND_SILENT: 1,

  /**
   * Performs capture simulation.
   */
  ON: 2
};


/**
 * @define {number} The capture simulation mode for IE8-. By default,
 *     this is ON.
 */
goog.events.CAPTURE_SIMULATION_MODE =
    goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);


/**
 * Estimated count of total native listeners.
 * @private {number}
 */
goog.events.listenerCountEstimate_ = 0;


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. A listener can only be added once
 * to an object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
 *     listener Callback method, or an object with a handleEvent function.
 *     WARNING: passing an Object is now softly deprecated.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T,EVENTOBJ
 */
goog.events.listen = function(src, type, listener, opt_options, opt_handler) {
  'use strict';
  if (opt_options && opt_options.once) {
    return goog.events.listenOnce(
        src, type, listener, opt_options, opt_handler);
  }
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listen(src, type[i], listener, opt_options, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    var capture =
        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
    return src.listen(
        /** @type {string|!goog.events.EventId} */ (type), listener, capture,
        opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {!EventTarget} */ (src), type, listener,
        /* callOnce */ false, opt_options, opt_handler);
  }
};


/**
 * Adds an event listener for a specific event on a native event
 * target. A listener can only be added once to an object and if it
 * is added again the key for the listener is returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {EventTarget} src The node to listen to events on.
 * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.
 * @param {!Function} listener Callback function.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener or otherwise.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template EVENTOBJ
 * @private
 */
goog.events.listen_ = function(
    src, type, listener, callOnce, opt_options, opt_handler) {
  'use strict';
  if (!type) {
    throw new Error('Invalid event type');
  }

  var capture =
      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;

  var listenerMap = goog.events.getListenerMap_(src);
  if (!listenerMap) {
    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
        new goog.events.ListenerMap(src);
  }

  var listenerObj = /** @type {goog.events.Listener} */ (
      listenerMap.add(type, listener, callOnce, capture, opt_handler));

  // If the listenerObj already has a proxy, it has been set up
  // previously. We simply return.
  if (listenerObj.proxy) {
    return listenerObj;
  }

  var proxy = goog.events.getProxy();
  listenerObj.proxy = proxy;

  proxy.src = src;
  proxy.listener = listenerObj;

  // Attach the proxy through the browser's API
  if (src.addEventListener) {
    // Don't pass an object as `capture` if the browser doesn't support that.
    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {
      opt_options = capture;
    }
    // Don't break tests that expect a boolean.
    if (opt_options === undefined) opt_options = false;
    src.addEventListener(type.toString(), proxy, opt_options);
  } else if (src.attachEvent) {
    // The else if above used to be an unconditional else. It would call
    // attachEvent come gws or high water. This would sometimes throw an
    // exception on IE11, spoiling the day of some callers. The previous
    // incarnation of this code, from 2007, indicates that it replaced an
    // earlier still version that caused excess allocations on IE6.
    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);
  } else if (src.addListener && src.removeListener) {
    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In
    // Safari, there is no global for the MediaQueryList constructor, so we just
    // check whether the object "looks like" MediaQueryList.
    goog.asserts.assert(
        type === 'change', 'MediaQueryList only has a change event');
    src.addListener(proxy);
  } else {
    throw new Error('addEventListener and attachEvent are unavailable.');
  }

  goog.events.listenerCountEstimate_++;
  return listenerObj;
};


/**
 * Helper function for returning a proxy function.
 * @return {!Function} A new or reused function object.
 */
goog.events.getProxy = function() {
  'use strict';
  var proxyCallbackFunction = goog.events.handleBrowserEvent_;
  // Use a local var f to prevent one allocation.
  var f =
      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {
        'use strict';
        return proxyCallbackFunction.call(f.src, f.listener, eventObject);
      } : function(eventObject) {
        'use strict';
        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if
        // there is inline event handler which tries to prevent default (for
        // example <a href="..." onclick="return false">...</a>) in a
        // descendant element, the prevent default will be overridden
        // by this listener if this listener were to return true. Hence, we
        // return undefined.
        if (!v) return v;
      };
  return f;
};


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. After the event has fired the event
 * listener is removed from the target.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
 *     listener Callback method.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T,EVENTOBJ
 */
goog.events.listenOnce = function(
    src, type, listener, opt_options, opt_handler) {
  'use strict';
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    var capture =
        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
    return src.listenOnce(
        /** @type {string|!goog.events.EventId} */ (type), listener, capture,
        opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {!EventTarget} */ (src), type, listener,
        /* callOnce */ true, opt_options, opt_handler);
  }
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.Listenable}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.Listenable} src The target to
 *     listen to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @template T
 */
goog.events.listenWithWrapper = function(
    src, wrapper, listener, opt_capt, opt_handler) {
  'use strict';
  wrapper.listen(src, listener, opt_capt, opt_handler);
};


/**
 * Removes an event listener which was added with listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type or array of event types to unlisten to.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {(boolean|!EventListenerOptions)=} opt_options
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {?boolean} indicating whether the listener was there to remove.
 * @template EVENTOBJ
 */
goog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {
  'use strict';
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);
    }
    return null;
  }
  var capture =
      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlisten(
        /** @type {string|!goog.events.EventId} */ (type), listener, capture,
        opt_handler);
  }

  if (!src) {
    // TODO(chrishenry): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return false;
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {!EventTarget} */ (src));
  if (listenerMap) {
    var listenerObj = listenerMap.getListener(
        /** @type {string|!goog.events.EventId} */ (type), listener, capture,
        opt_handler);
    if (listenerObj) {
      return goog.events.unlistenByKey(listenerObj);
    }
  }

  return false;
};


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.Key} key The key returned by listen() for this
 *     event listener.
 * @return {boolean} indicating whether the listener was there to remove.
 */
goog.events.unlistenByKey = function(key) {
  'use strict';
  // TODO(chrishenry): Remove this check when tests that rely on this
  // are fixed.
  if (typeof key === 'number') {
    return false;
  }

  var listener = key;
  if (!listener || listener.removed) {
    return false;
  }

  var src = listener.src;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);
  }

  var type = listener.type;
  var proxy = listener.proxy;
  if (src.removeEventListener) {
    src.removeEventListener(type, proxy, listener.capture);
  } else if (src.detachEvent) {
    src.detachEvent(goog.events.getOnString_(type), proxy);
  } else if (src.addListener && src.removeListener) {
    src.removeListener(proxy);
  }
  goog.events.listenerCountEstimate_--;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {!EventTarget} */ (src));
  // TODO(chrishenry): Try to remove this conditional and execute the
  // first branch always. This should be safe.
  if (listenerMap) {
    listenerMap.removeByKey(listener);
    if (listenerMap.getTypeCount() == 0) {
      // Null the src, just because this is simple to do (and useful
      // for IE <= 7).
      listenerMap.src = null;
      // We don't use delete here because IE does not allow delete
      // on a window object.
      src[goog.events.LISTENER_MAP_PROP_] = null;
    }
  } else {
    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();
  }

  return true;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 */
goog.events.unlistenWithWrapper = function(
    src, wrapper, listener, opt_capt, opt_handler) {
  'use strict';
  wrapper.unlisten(src, listener, opt_capt, opt_handler);
};


/**
 * Removes all listeners from an object. You can also optionally
 * remove listeners of a particular type.
 *
 * @param {Object|undefined} obj Object to remove listeners from. Must be an
 *     EventTarget or a goog.events.Listenable.
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
 *     Default is all types.
 * @return {number} Number of listeners removed.
 */
goog.events.removeAll = function(obj, opt_type) {
  'use strict';
  // TODO(chrishenry): Change the type of obj to
  // (!EventTarget|!goog.events.Listenable).

  if (!obj) {
    return 0;
  }

  if (goog.events.Listenable.isImplementedBy(obj)) {
    return /** @type {?} */ (obj).removeAllListeners(opt_type);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {!EventTarget} */ (obj));
  if (!listenerMap) {
    return 0;
  }

  var count = 0;
  var typeStr = opt_type && opt_type.toString();
  for (var type in listenerMap.listeners) {
    if (!typeStr || type == typeStr) {
      // Clone so that we don't need to worry about unlistenByKey
      // changing the content of the ListenerMap.
      var listeners = listenerMap.listeners[type].concat();
      for (var i = 0; i < listeners.length; ++i) {
        if (goog.events.unlistenByKey(listeners[i])) {
          ++count;
        }
      }
    }
  }
  return count;
};


/**
 * Gets the listeners for a given object, type and capture phase.
 *
 * @param {Object} obj Object to get listeners for.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Capture phase?.
 * @return {!Array<!goog.events.Listener>} Array of listener objects.
 */
goog.events.getListeners = function(obj, type, capture) {
  'use strict';
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return /** @type {!goog.events.Listenable} */ (obj).getListeners(
        type, capture);
  } else {
    if (!obj) {
      // TODO(chrishenry): We should tighten the API to accept
      // !EventTarget|goog.events.Listenable, and add an assertion here.
      return [];
    }

    var listenerMap = goog.events.getListenerMap_(
        /** @type {!EventTarget} */ (obj));
    return listenerMap ? listenerMap.getListeners(type, capture) : [];
  }
};


/**
 * Gets the goog.events.Listener for the event or null if no such listener is
 * in use.
 *
 * @param {EventTarget|goog.events.Listenable} src The target from
 *     which to get listeners.
 * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.
 * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to get.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *                            whether the listener is fired during the
 *                            capture or bubble phase of the event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 * @template EVENTOBJ
 */
goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
  'use strict';
  // TODO(chrishenry): Change type from ?string to string, or add assertion.
  type = /** @type {string} */ (type);
  listener = goog.events.wrapListener(listener);
  var capture = !!opt_capt;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.getListener(type, listener, capture, opt_handler);
  }

  if (!src) {
    // TODO(chrishenry): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return null;
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {!EventTarget} */ (src));
  if (listenerMap) {
    return listenerMap.getListener(type, listener, capture, opt_handler);
  }
  return null;
};


/**
 * Returns whether an event target has any active listeners matching the
 * specified signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {EventTarget|goog.events.Listenable} obj Target to get
 *     listeners for.
 * @param {string|!goog.events.EventId=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
 *     listeners.
 * @return {boolean} Whether an event target has one or more listeners matching
 *     the requested type and/or capture phase.
 */
goog.events.hasListener = function(obj, opt_type, opt_capture) {
  'use strict';
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.hasListener(opt_type, opt_capture);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {!EventTarget} */ (obj));
  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);
};


/**
 * Provides a nice string showing the normalized event objects public members
 * @param {Object} e Event Object.
 * @return {string} String of the public members of the normalized event object.
 */
goog.events.expose = function(e) {
  'use strict';
  var str = [];
  for (var key in e) {
    if (e[key] && e[key].id) {
      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');
    } else {
      str.push(key + ' = ' + e[key]);
    }
  }
  return str.join('\n');
};


/**
 * Returns a string with on prepended to the specified type. This is used for IE
 * which expects "on" to be prepended. This function caches the string in order
 * to avoid extra allocations in steady state.
 * @param {string} type Event type.
 * @return {string} The type string with 'on' prepended.
 * @private
 */
goog.events.getOnString_ = function(type) {
  'use strict';
  if (type in goog.events.onStringMap_) {
    return goog.events.onStringMap_[type];
  }
  return goog.events.onStringMap_[type] = goog.events.onString_ + type;
};


/**
 * Fires an object's listeners of a particular type and phase
 *
 * @param {Object} obj Object whose listeners to call.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 */
goog.events.fireListeners = function(obj, type, capture, eventObject) {
  'use strict';
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(
        type, capture, eventObject);
  }

  return goog.events.fireListeners_(obj, type, capture, eventObject);
};


/**
 * Fires an object's listeners of a particular type and phase.
 * @param {Object} obj Object whose listeners to call.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 * @private
 */
goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
  'use strict';
  /** @type {boolean} */
  var retval = true;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  if (listenerMap) {
    // TODO(chrishenry): Original code avoids array creation when there
    // is no listener, so we do the same. If this optimization turns
    // out to be not required, we can replace this with
    // listenerMap.getListeners(type, capture) instead, which is simpler.
    var listenerArray = listenerMap.listeners[type.toString()];
    if (listenerArray) {
      listenerArray = listenerArray.concat();
      for (var i = 0; i < listenerArray.length; i++) {
        var listener = listenerArray[i];
        // We might not have a listener if the listener was removed.
        if (listener && listener.capture == capture && !listener.removed) {
          var result = goog.events.fireListener(listener, eventObject);
          retval = retval && (result !== false);
        }
      }
    }
  }
  return retval;
};


/**
 * Fires a listener with a set of arguments
 *
 * @param {goog.events.Listener} listener The listener object to call.
 * @param {Object} eventObject The event object to pass to the listener.
 * @return {*} Result of listener.
 */
goog.events.fireListener = function(listener, eventObject) {
  'use strict';
  var listenerFn = listener.listener;
  var listenerHandler = listener.handler || listener.src;

  if (listener.callOnce) {
    goog.events.unlistenByKey(listener);
  }
  return listenerFn.call(listenerHandler, eventObject);
};


/**
 * Gets the total number of listeners currently in the system.
 * @return {number} Number of listeners.
 * @deprecated This returns estimated count, now that Closure no longer
 * stores a central listener registry. We still return an estimation
 * to keep existing listener-related tests passing. In the near future,
 * this function will be removed.
 */
goog.events.getTotalListenerCount = function() {
  'use strict';
  return goog.events.listenerCountEstimate_;
};


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.Listenable} src The event target.
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false) this will also return false.
 *     If there are no handlers, or if all handlers return true, this returns
 *     true.
 */
goog.events.dispatchEvent = function(src, e) {
  'use strict';
  goog.asserts.assert(
      goog.events.Listenable.isImplementedBy(src),
      'Can not use goog.events.dispatchEvent with ' +
          'non-goog.events.Listenable instance.');
  return src.dispatchEvent(e);
};


/**
 * Installs exception protection for the browser event entry point using the
 * given error handler.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point.
 */
goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
  'use strict';
  goog.events.handleBrowserEvent_ =
      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);
};


/**
 * Handles an event and dispatches it to the correct listeners. This
 * function is a proxy for the real listener the user specified.
 *
 * @param {goog.events.Listener} listener The listener object.
 * @param {Event=} opt_evt Optional event object that gets passed in via the
 *     native event handlers.
 * @return {*} Result of the event handler.
 * @this {EventTarget} The object or Element that fired the event.
 * @private
 */
goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
  'use strict';
  if (listener.removed) {
    return true;
  }

  // Synthesize event propagation if the browser does not support W3C
  // event model.
  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    var ieEvent = opt_evt ||
        /** @type {Event} */ (goog.getObjectByName('window.event'));
    var evt = new goog.events.BrowserEvent(ieEvent, this);
    /** @type {*} */
    var retval = true;

    if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.ON) {
      // If we have not marked this event yet, we should perform capture
      // simulation.
      if (!goog.events.isMarkedIeEvent_(ieEvent)) {
        goog.events.markIeEvent_(ieEvent);

        var ancestors = [];
        for (var parent = evt.currentTarget; parent;
             parent = parent.parentNode) {
          ancestors.push(parent);
        }

        // Fire capture listeners.
        var type = listener.type;
        for (var i = ancestors.length - 1;
             !evt.hasPropagationStopped() && i >= 0; i--) {
          evt.currentTarget = ancestors[i];
          var result =
              goog.events.fireListeners_(ancestors[i], type, true, evt);
          retval = retval && result;
        }

        // Fire bubble listeners.
        //
        // We can technically rely on IE to perform bubble event
        // propagation. However, it turns out that IE fires events in
        // opposite order of attachEvent registration, which broke
        // some code and tests that rely on the order. (While W3C DOM
        // Level 2 Events TR leaves the event ordering unspecified,
        // modern browsers and W3C DOM Level 3 Events Working Draft
        // actually specify the order as the registration order.)
        for (var i = 0; !evt.hasPropagationStopped() && i < ancestors.length;
             i++) {
          evt.currentTarget = ancestors[i];
          var result =
              goog.events.fireListeners_(ancestors[i], type, false, evt);
          retval = retval && result;
        }
      }
    } else {
      retval = goog.events.fireListener(listener, evt);
    }
    return retval;
  }

  // Otherwise, simply fire the listener.
  return goog.events.fireListener(
      listener, new goog.events.BrowserEvent(opt_evt, this));
};


/**
 * This is used to mark the IE event object so we do not do the Closure pass
 * twice for a bubbling event.
 * @param {Event} e The IE browser event.
 * @private
 */
goog.events.markIeEvent_ = function(e) {
  'use strict';
  // Only the keyCode and the returnValue can be changed. We use keyCode for
  // non keyboard events.
  // event.returnValue is a bit more tricky. It is undefined by default. A
  // boolean false prevents the default action. In a window.onbeforeunload and
  // the returnValue is non undefined it will be alerted. However, we will only
  // modify the returnValue for keyboard events. We can get a problem if non
  // closure events sets the keyCode or the returnValue

  var useReturnValue = false;

  if (e.keyCode == 0) {
    // We cannot change the keyCode in case that srcElement is input[type=file].
    // We could test that that is the case but that would allocate 3 objects.
    // If we use try/catch we will only allocate extra objects in the case of a
    // failure.

    try {
      e.keyCode = -1;
      return;
    } catch (ex) {
      useReturnValue = true;
    }
  }

  if (useReturnValue ||
      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
    e.returnValue = true;
  }
};


/**
 * This is used to check if an IE event has already been handled by the Closure
 * system so we do not do the Closure pass twice for a bubbling event.
 * @param {Event} e  The IE browser event.
 * @return {boolean} True if the event object has been marked.
 * @private
 */
goog.events.isMarkedIeEvent_ = function(e) {
  'use strict';
  return e.keyCode < 0 || e.returnValue != undefined;
};


/**
 * Counter to create unique event ids.
 * @private {number}
 */
goog.events.uniqueIdCounter_ = 0;


/**
 * Creates a unique event id.
 *
 * @param {string} identifier The identifier.
 * @return {string} A unique identifier.
 * @idGenerator {unique}
 */
goog.events.getUniqueId = function(identifier) {
  'use strict';
  return identifier + '_' + goog.events.uniqueIdCounter_++;
};


/**
 * @param {EventTarget} src The source object.
 * @return {goog.events.ListenerMap} A listener map for the given
 *     source object, or null if none exists.
 * @private
 */
goog.events.getListenerMap_ = function(src) {
  'use strict';
  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
  // IE serializes the property as well (e.g. when serializing outer
  // HTML). So we must check that the value is of the correct type.
  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
};


/**
 * Expando property for listener function wrapper for Object with
 * handleEvent.
 * @private @const {string}
 */
goog.events.LISTENER_WRAPPER_PROP_ =
    '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);


/**
 * @param {Object|Function} listener The listener function or an
 *     object that contains handleEvent method.
 * @return {!Function} Either the original function or a function that
 *     calls obj.handleEvent. If the same listener is passed to this
 *     function more than once, the same function is guaranteed to be
 *     returned.
 */
goog.events.wrapListener = function(listener) {
  'use strict';
  goog.asserts.assert(listener, 'Listener can not be null.');

  if (typeof listener === 'function') {
    return listener;
  }

  goog.asserts.assert(
      listener.handleEvent, 'An object listener must have handleEvent method.');
  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {
    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
      'use strict';
      return /** @type {?} */ (listener).handleEvent(e);
    };
  }
  return listener[goog.events.LISTENER_WRAPPER_PROP_];
};


// Register the browser event handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      'use strict';
      goog.events.handleBrowserEvent_ =
          transformer(goog.events.handleBrowserEvent_);
    });

//third_party/javascript/closure/async/freelist.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Simple freelist.
 *
 * An anterative to goog.structs.SimplePool, it imposes the requirement that the
 * objects in the list contain a "next" property that can be used to maintain
 * the pool.
 */

goog.provide('goog.async.FreeList');


/**
 * @template ITEM
 */
goog.async.FreeList = class {
  /**
   * @param {function():ITEM} create
   * @param {function(ITEM):void} reset
   * @param {number} limit
   */
  constructor(create, reset, limit) {
    /** @private @const {number} */
    this.limit_ = limit;
    /** @private @const {function()} */
    this.create_ = create;
    /** @private @const {function(ITEM):void} */
    this.reset_ = reset;

    /** @private {number} */
    this.occupants_ = 0;
    /** @private {ITEM} */
    this.head_ = null;
  }

  /**
   * @return {ITEM}
   */
  get() {
    let item;
    if (this.occupants_ > 0) {
      this.occupants_--;
      item = this.head_;
      this.head_ = item.next;
      item.next = null;
    } else {
      item = this.create_();
    }
    return item;
  }

  /**
   * @param {ITEM} item An item available for possible future reuse.
   */
  put(item) {
    this.reset_(item);
    if (this.occupants_ < this.limit_) {
      this.occupants_++;
      item.next = this.head_;
      this.head_ = item;
    }
  }

  /**
   * Visible for testing.
   * @package
   * @return {number}
   */
  occupants() {
    return this.occupants_;
  }
};

//third_party/javascript/closure/dom/browserfeature.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Browser capability checks for the dom package.
 */


goog.provide('goog.dom.BrowserFeature');

goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser doesn't
 * support OffscreenCanvas.
 */
goog.dom.BrowserFeature.ASSUME_NO_OFFSCREEN_CANVAS =
    goog.define('goog.dom.ASSUME_NO_OFFSCREEN_CANVAS', false);

/**
 * @define {boolean} Whether we know at compile time that the browser supports
 * all OffscreenCanvas contexts.
 */
// TODO(fserb): Eventually this should default to "FEATURESET_YEAR >= 202X".
goog.dom.BrowserFeature.ASSUME_OFFSCREEN_CANVAS =
    goog.define('goog.dom.ASSUME_OFFSCREEN_CANVAS', false);

/**
 * Detects if a particular OffscreenCanvas context is supported.
 * @param {string} contextName name of the context to test.
 * @return {boolean} Whether the browser supports this OffscreenCanvas context.
 * @private
 */
goog.dom.BrowserFeature.detectOffscreenCanvas_ = function(contextName) {
  'use strict';
  // This code only gets removed because we forced @nosideeffects on
  // the functions. See: b/138802376
  try {
    return Boolean(new self.OffscreenCanvas(0, 0).getContext(contextName));
  } catch (ex) {
  }
  return false;
};

/**
 * Whether the browser supports OffscreenCanvas 2D context.
 * @const {boolean}
 */
goog.dom.BrowserFeature.OFFSCREEN_CANVAS_2D =
    !goog.dom.BrowserFeature.ASSUME_NO_OFFSCREEN_CANVAS &&
    (goog.dom.BrowserFeature.ASSUME_OFFSCREEN_CANVAS ||
     goog.dom.BrowserFeature.detectOffscreenCanvas_('2d'));

/**
 * Whether attributes 'name' and 'type' can be added to an element after it's
 * created. False in Internet Explorer prior to version 9.
 * @const {boolean}
 */
goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES = true;

/**
 * Whether we can use element.children to access an element's Element
 * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
 * nodes in the collection.)
 * @const {boolean}
 */
goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE = true;

/**
 * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
 * include text nodes in script and style tags. Not document-mode-dependent.
 * @const {boolean}
 */
goog.dom.BrowserFeature.CAN_USE_INNER_TEXT = false;

/**
 * MSIE, Opera, and Safari>=4 support element.parentElement to access an
 * element's parent if it is an Element.
 * @const {boolean}
 */
goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY =
    goog.userAgent.IE || goog.userAgent.WEBKIT;

/**
 * Whether NoScope elements need a scoped element written before them in
 * innerHTML.
 * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
 * @const {boolean}
 */
goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT = goog.userAgent.IE;

//third_party/javascript/closure/math/math.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Additional mathematical functions.
 */

goog.provide('goog.math');

goog.require('goog.asserts');


/**
 * Returns a random integer greater than or equal to 0 and less than `a`.
 * @param {number} a  The upper bound for the random integer (exclusive).
 * @return {number} A random integer N such that 0 <= N < a.
 */
goog.math.randomInt = function(a) {
  'use strict';
  return Math.floor(Math.random() * a);
};


/**
 * Returns a random number greater than or equal to `a` and less than
 * `b`.
 * @param {number} a  The lower bound for the random number (inclusive).
 * @param {number} b  The upper bound for the random number (exclusive).
 * @return {number} A random number N such that a <= N < b.
 */
goog.math.uniformRandom = function(a, b) {
  'use strict';
  return a + Math.random() * (b - a);
};


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
goog.math.clamp = function(value, min, max) {
  'use strict';
  return Math.min(Math.max(value, min), max);
};


/**
 * The % operator in JavaScript returns the remainder of a / b, but differs from
 * some other languages in that the result will have the same sign as the
 * dividend. For example, -1 % 8 == -1, whereas in some other languages
 * (such as Python) the result would be 7. This function emulates the more
 * correct modulo behavior, which is useful for certain applications such as
 * calculating an offset index in a circular list.
 *
 * @param {number} a The dividend.
 * @param {number} b The divisor.
 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
 *     or b < x <= 0, depending on the sign of b).
 */
goog.math.modulo = function(a, b) {
  'use strict';
  var r = a % b;
  // If r and b differ in sign, add b to wrap the result to the correct sign.
  return (r * b < 0) ? r + b : r;
};


/**
 * Performs linear interpolation between values a and b. Returns the value
 * between a and b proportional to x (when x is between 0 and 1. When x is
 * outside this range, the return value is a linear extrapolation).
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number} x The proportion between a and b.
 * @return {number} The interpolated value between a and b.
 */
goog.math.lerp = function(a, b, x) {
  'use strict';
  return a + x * (b - a);
};


/**
 * Tests whether the two values are equal to each other, within a certain
 * tolerance to adjust for floating point errors.
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number=} opt_tolerance Optional tolerance range. Defaults
 *     to 0.000001. If specified, should be greater than 0.
 * @return {boolean} Whether `a` and `b` are nearly equal.
 */
goog.math.nearlyEquals = function(a, b, opt_tolerance) {
  'use strict';
  return Math.abs(a - b) <= (opt_tolerance || 0.000001);
};


// TODO(jrajeshwar): Rename to normalizeAngle, retaining old name as deprecated
// alias.
/**
 * Normalizes an angle to be in range [0-360). Angles outside this range will
 * be normalized to be the equivalent angle with that range.
 * @param {number} angle Angle in degrees.
 * @return {number} Standardized angle.
 */
goog.math.standardAngle = function(angle) {
  'use strict';
  return goog.math.modulo(angle, 360);
};


/**
 * Normalizes an angle to be in range [0-2*PI). Angles outside this range will
 * be normalized to be the equivalent angle with that range.
 * @param {number} angle Angle in radians.
 * @return {number} Standardized angle.
 */
goog.math.standardAngleInRadians = function(angle) {
  'use strict';
  return goog.math.modulo(angle, 2 * Math.PI);
};


/**
 * Converts degrees to radians.
 * @param {number} angleDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
goog.math.toRadians = function(angleDegrees) {
  'use strict';
  return angleDegrees * Math.PI / 180;
};


/**
 * Converts radians to degrees.
 * @param {number} angleRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
goog.math.toDegrees = function(angleRadians) {
  'use strict';
  return angleRadians * 180 / Math.PI;
};


/**
 * For a given angle and radius, finds the X portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The x-distance for the angle and radius.
 */
goog.math.angleDx = function(degrees, radius) {
  'use strict';
  return radius * Math.cos(goog.math.toRadians(degrees));
};


/**
 * For a given angle and radius, finds the Y portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The y-distance for the angle and radius.
 */
goog.math.angleDy = function(degrees, radius) {
  'use strict';
  return radius * Math.sin(goog.math.toRadians(degrees));
};


/**
 * Computes the angle between two points (x1,y1) and (x2,y2).
 * Angle zero points in the +X direction, 90 degrees points in the +Y
 * direction (down) and from there we grow clockwise towards 360 degrees.
 * @param {number} x1 x of first point.
 * @param {number} y1 y of first point.
 * @param {number} x2 x of second point.
 * @param {number} y2 y of second point.
 * @return {number} Standardized angle in degrees of the vector from
 *     x1,y1 to x2,y2.
 */
goog.math.angle = function(x1, y1, x2, y2) {
  'use strict';
  return goog.math.standardAngle(
      goog.math.toDegrees(Math.atan2(y2 - y1, x2 - x1)));
};


/**
 * Computes the difference between startAngle and endAngle (angles in degrees).
 * @param {number} startAngle  Start angle in degrees.
 * @param {number} endAngle  End angle in degrees.
 * @return {number} The number of degrees that when added to
 *     startAngle will result in endAngle. Positive numbers mean that the
 *     direction is clockwise. Negative numbers indicate a counter-clockwise
 *     direction.
 *     The shortest route (clockwise vs counter-clockwise) between the angles
 *     is used.
 *     When the difference is 180 degrees, the function returns 180 (not -180)
 *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
 *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
 */
goog.math.angleDifference = function(startAngle, endAngle) {
  'use strict';
  var d =
      goog.math.standardAngle(endAngle) - goog.math.standardAngle(startAngle);
  if (d > 180) {
    d = d - 360;
  } else if (d <= -180) {
    d = 360 + d;
  }
  return d;
};


/**
 * Returns the sign of a number as per the "sign" or "signum" function.
 * @param {number} x The number to take the sign of.
 * @return {number} -1 when negative, 1 when positive, 0 when 0. Preserves
 *     signed zeros and NaN.
 */
goog.math.sign = function(x) {
  'use strict';
  if (x > 0) {
    return 1;
  }
  if (x < 0) {
    return -1;
  }
  return x;  // Preserves signed zeros and NaN.
};


/**
 * JavaScript implementation of Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the longest possible array that is subarray of both of given arrays.
 *
 * @param {IArrayLike<S>} array1 First array of objects.
 * @param {IArrayLike<T>} array2 Second array of objects.
 * @param {Function=} opt_compareFn Function that acts as a custom comparator
 *     for the array ojects. Function should return true if objects are equal,
 *     otherwise false.
 * @param {Function=} opt_collectorFn Function used to decide what to return
 *     as a result subsequence. It accepts 2 arguments: index of common element
 *     in the first array and index in the second. The default function returns
 *     element from the first array.
 * @return {!Array<S|T>} A list of objects that are common to both arrays
 *     such that there is no common subsequence with size greater than the
 *     length of the list.
 * @template S,T
 */
goog.math.longestCommonSubsequence = function(
    array1, array2, opt_compareFn, opt_collectorFn) {
  'use strict';
  var compare = opt_compareFn || function(a, b) {
    'use strict';
    return a == b;
  };

  var collect = opt_collectorFn || function(i1, i2) {
    'use strict';
    return array1[i1];
  };

  var length1 = array1.length;
  var length2 = array2.length;

  var arr = [];
  for (var i = 0; i < length1 + 1; i++) {
    arr[i] = [];
    arr[i][0] = 0;
  }

  for (var j = 0; j < length2 + 1; j++) {
    arr[0][j] = 0;
  }

  for (i = 1; i <= length1; i++) {
    for (j = 1; j <= length2; j++) {
      if (compare(array1[i - 1], array2[j - 1])) {
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
      }
    }
  }

  // Backtracking
  var result = [];
  var i = length1, j = length2;
  while (i > 0 && j > 0) {
    if (compare(array1[i - 1], array2[j - 1])) {
      result.unshift(collect(i - 1, j - 1));
      i--;
      j--;
    } else {
      if (arr[i - 1][j] > arr[i][j - 1]) {
        i--;
      } else {
        j--;
      }
    }
  }

  return result;
};


/**
 * Returns the sum of the arguments.
 * @param {...number} var_args Numbers to add.
 * @return {number} The sum of the arguments (0 if no arguments were provided,
 *     `NaN` if any of the arguments is not a valid number).
 */
goog.math.sum = function(var_args) {
  'use strict';
  return /** @type {number} */ (
      Array.prototype.reduce.call(arguments, function(sum, value) {
        'use strict';
        return sum + value;
      }, 0));
};


/**
 * Returns the arithmetic mean of the arguments.
 * @param {...number} var_args Numbers to average.
 * @return {number} The average of the arguments (`NaN` if no arguments
 *     were provided or any of the arguments is not a valid number).
 */
goog.math.average = function(var_args) {
  'use strict';
  return goog.math.sum.apply(null, arguments) / arguments.length;
};


/**
 * Returns the unbiased sample variance of the arguments. For a definition,
 * see e.g. http://en.wikipedia.org/wiki/Variance
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The unbiased sample variance of the arguments (0 if fewer
 *     than two samples were provided, or `NaN` if any of the samples is
 *     not a valid number).
 */
goog.math.sampleVariance = function(var_args) {
  'use strict';
  var sampleSize = arguments.length;
  if (sampleSize < 2) {
    return 0;
  }

  var mean = goog.math.average.apply(null, arguments);
  var variance = goog.math.sum.apply(
                     null,
                     Array.prototype.map.call(
                         arguments,
                         function(val) {
                           'use strict';
                           return Math.pow(val - mean, 2);
                         })) /
      (sampleSize - 1);

  return variance;
};


/**
 * Returns the sample standard deviation of the arguments.  For a definition of
 * sample standard deviation, see e.g.
 * http://en.wikipedia.org/wiki/Standard_deviation
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The sample standard deviation of the arguments (0 if fewer
 *     than two samples were provided, or `NaN` if any of the samples is
 *     not a valid number).
 */
goog.math.standardDeviation = function(var_args) {
  'use strict';
  return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));
};


/**
 * Returns whether the supplied number represents an integer, i.e. that is has
 * no fractional component.  No range-checking is performed on the number.
 * @param {number} num The number to test.
 * @return {boolean} Whether `num` is an integer.
 */
goog.math.isInt = function(num) {
  'use strict';
  return isFinite(num) && num % 1 == 0;
};


/**
 * Returns whether the supplied number is finite and not NaN.
 * @param {number} num The number to test.
 * @return {boolean} Whether `num` is a finite number.
 * @deprecated Use {@link isFinite} instead.
 */
goog.math.isFiniteNumber = function(num) {
  'use strict';
  return isFinite(num);
};


/**
 * @param {number} num The number to test.
 * @return {boolean} Whether it is negative zero.
 */
goog.math.isNegativeZero = function(num) {
  'use strict';
  return num == 0 && 1 / num < 0;
};


/**
 * Returns the precise value of floor(log10(num)).
 * Simpler implementations didn't work because of floating point rounding
 * errors. For example
 * <ul>
 * <li>Math.floor(Math.log(num) / Math.LN10) is off by one for num == 1e+3.
 * <li>Math.floor(Math.log(num) * Math.LOG10E) is off by one for num == 1e+15.
 * <li>Math.floor(Math.log10(num)) is off by one for num == 1e+15 - 1.
 * </ul>
 * @param {number} num A floating point number.
 * @return {number} Its logarithm to base 10 rounded down to the nearest
 *     integer if num > 0. -Infinity if num == 0. NaN if num < 0.
 */
goog.math.log10Floor = function(num) {
  'use strict';
  if (num > 0) {
    var x = Math.round(Math.log(num) * Math.LOG10E);
    return x - (parseFloat('1e' + x) > num ? 1 : 0);
  }
  return num == 0 ? -Infinity : NaN;
};


/**
 * A tweaked variant of `Math.floor` which tolerates if the passed number
 * is infinitesimally smaller than the closest integer. It often happens with
 * the results of floating point calculations because of the finite precision
 * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
 * Math.LN10) == 2}, not 3 as one would expect.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The largest integer less than or equal to `num`.
 */
goog.math.safeFloor = function(num, opt_epsilon) {
  'use strict';
  goog.asserts.assert(opt_epsilon === undefined || opt_epsilon > 0);
  return Math.floor(num + (opt_epsilon || 2e-15));
};


/**
 * A tweaked variant of `Math.ceil`. See `goog.math.safeFloor` for
 * details.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The smallest integer greater than or equal to `num`.
 */
goog.math.safeCeil = function(num, opt_epsilon) {
  'use strict';
  goog.asserts.assert(opt_epsilon === undefined || opt_epsilon > 0);
  return Math.ceil(num - (opt_epsilon || 2e-15));
};

//third_party/javascript/closure/math/coordinate.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */


goog.provide('goog.math.Coordinate');

goog.require('goog.math');



/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @struct
 * @constructor
 */
goog.math.Coordinate = function(opt_x, opt_y) {
  'use strict';
  /**
   * X-value
   * @type {number}
   */
  this.x = (opt_x !== undefined) ? opt_x : 0;

  /**
   * Y-value
   * @type {number}
   */
  this.y = (opt_y !== undefined) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function() {
  'use strict';
  return new goog.math.Coordinate(this.x, this.y);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the coordinate.
   * @return {string} In the form (50, 73).
   * @override
   */
  goog.math.Coordinate.prototype.toString = function() {
    'use strict';
    return '(' + this.x + ', ' + this.y + ')';
  };
}


/**
 * Returns whether the specified value is equal to this coordinate.
 * @param {*} other Some other value.
 * @return {boolean} Whether the specified value is equal to this coordinate.
 */
goog.math.Coordinate.prototype.equals = function(other) {
  'use strict';
  return other instanceof goog.math.Coordinate &&
      goog.math.Coordinate.equals(this, other);
};


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function(a, b) {
  'use strict';
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.x == b.x && a.y == b.y;
};


/**
 * Returns the distance between two coordinates.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The distance between `a` and `b`.
 */
goog.math.Coordinate.distance = function(a, b) {
  'use strict';
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
};


/**
 * Returns the magnitude of a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The distance between the origin and `a`.
 */
goog.math.Coordinate.magnitude = function(a) {
  'use strict';
  return Math.sqrt(a.x * a.x + a.y * a.y);
};


/**
 * Returns the angle from the origin to a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The angle, in degrees, clockwise from the positive X
 *     axis to `a`.
 */
goog.math.Coordinate.azimuth = function(a) {
  'use strict';
  return goog.math.angle(0, 0, a.x, a.y);
};


/**
 * Returns the squared distance between two coordinates. Squared distances can
 * be used for comparisons when the actual value is not required.
 *
 * Performance note: eliminating the square root is an optimization often used
 * in lower-level languages, but the speed difference is not nearly as
 * pronounced in JavaScript (only a few percent.)
 *
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The squared distance between `a` and `b`.
 */
goog.math.Coordinate.squaredDistance = function(a, b) {
  'use strict';
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx * dx + dy * dy;
};


/**
 * Returns the difference between two coordinates as a new
 * goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the difference
 *     between `a` and `b`.
 */
goog.math.Coordinate.difference = function(a, b) {
  'use strict';
  return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
};


/**
 * Returns the sum of two coordinates as a new goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
 *     coordinates.
 */
goog.math.Coordinate.sum = function(a, b) {
  'use strict';
  return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
};


/**
 * Rounds the x and y fields to the next larger integer values.
 * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
 */
goog.math.Coordinate.prototype.ceil = function() {
  'use strict';
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the next smaller integer values.
 * @return {!goog.math.Coordinate} This coordinate with floored fields.
 */
goog.math.Coordinate.prototype.floor = function() {
  'use strict';
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the nearest integer values.
 * @return {!goog.math.Coordinate} This coordinate with rounded fields.
 */
goog.math.Coordinate.prototype.round = function() {
  'use strict';
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  return this;
};


/**
 * Translates this box by the given offsets. If a `goog.math.Coordinate`
 * is given, then the x and y values are translated by the coordinate's x and y.
 * Otherwise, x and y are translated by `tx` and `opt_ty`
 * respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate x by or the
 *     the coordinate to translate this coordinate by.
 * @param {number=} opt_ty The value to translate y by.
 * @return {!goog.math.Coordinate} This coordinate after translating.
 */
goog.math.Coordinate.prototype.translate = function(tx, opt_ty) {
  'use strict';
  if (tx instanceof goog.math.Coordinate) {
    this.x += tx.x;
    this.y += tx.y;
  } else {
    this.x += Number(tx);
    if (typeof opt_ty === 'number') {
      this.y += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y values are
 * scaled by `sx` and `opt_sy` respectively.  If `opt_sy`
 * is not given, then `sx` is used for both x and y.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Coordinate} This coordinate after scaling.
 */
goog.math.Coordinate.prototype.scale = function(sx, opt_sy) {
  'use strict';
  var sy = (typeof opt_sy === 'number') ? opt_sy : sx;
  this.x *= sx;
  this.y *= sy;
  return this;
};


/**
 * Rotates this coordinate clockwise about the origin (or, optionally, the given
 * center) by the given angle, in radians.
 * @param {number} radians The angle by which to rotate this coordinate
 *     clockwise about the given center, in radians.
 * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
 *     to (0, 0) if not given.
 */
goog.math.Coordinate.prototype.rotateRadians = function(radians, opt_center) {
  'use strict';
  var center = opt_center || new goog.math.Coordinate(0, 0);

  var x = this.x;
  var y = this.y;
  var cos = Math.cos(radians);
  var sin = Math.sin(radians);

  this.x = (x - center.x) * cos - (y - center.y) * sin + center.x;
  this.y = (x - center.x) * sin + (y - center.y) * cos + center.y;
};


/**
 * Rotates this coordinate clockwise about the origin (or, optionally, the given
 * center) by the given angle, in degrees.
 * @param {number} degrees The angle by which to rotate this coordinate
 *     clockwise about the given center, in degrees.
 * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
 *     to (0, 0) if not given.
 */
goog.math.Coordinate.prototype.rotateDegrees = function(degrees, opt_center) {
  'use strict';
  this.rotateRadians(goog.math.toRadians(degrees), opt_center);
};

//third_party/javascript/closure/math/size.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @struct
 * @constructor
 */
goog.math.Size = function(width, height) {
  'use strict';
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  'use strict';
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  'use strict';
  return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size.
   * @return {string} In the form (50 x 73).
   * @override
   */
  goog.math.Size.prototype.toString = function() {
    'use strict';
    return '(' + this.width + ' x ' + this.height + ')';
  };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function() {
  'use strict';
  return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function() {
  'use strict';
  return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  'use strict';
  return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function() {
  'use strict';
  return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function() {
  'use strict';
  return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  'use strict';
  return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function() {
  'use strict';
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function(target) {
  'use strict';
  return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function() {
  'use strict';
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function() {
  'use strict';
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by `sx` and `opt_sy` respectively.  If `opt_sy` is not
 * given, then `sx` is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function(sx, opt_sy) {
  'use strict';
  const sy = (typeof opt_sy === 'number') ? opt_sy : sx;
  this.width *= sx;
  this.height *= sy;
  return this;
};


/**
 * Uniformly scales the size to perfectly cover the dimensions of a given size.
 * If the size is already larger than the target, it will be scaled down to the
 * minimum size at which it still covers the entire target. The original aspect
 * ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToCover = function(target) {
  'use strict';
  const s = this.aspectRatio() <= target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function(target) {
  'use strict';
  const s = this.aspectRatio() > target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};

//third_party/javascript/closure/dom/dom.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 * @suppress {strictMissingProperties}
 */


// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.safe');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.uncheckedconversions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.string.Const');
goog.require('goog.string.Unicode');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.dom.ASSUME_QUIRKS_MODE = goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.dom.ASSUME_STANDARDS_MODE =
    goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function(opt_element) {
  'use strict';
  return opt_element ?
      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
      (goog.dom.defaultDomHelper_ ||
       (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {!goog.dom.DomHelper|undefined}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function() {
  'use strict';
  return document;
};


/**
 * Gets an element from the current document by element id.
 *
 * If an Element is passed in, it is returned.
 *
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function(element) {
  'use strict';
  return goog.dom.getElementHelper_(document, element);
};


/**
 * Gets an element by id from the given document (if present).
 * If an element is given, it is returned.
 * @param {!Document} doc
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The resulting element.
 * @private
 */
goog.dom.getElementHelper_ = function(doc, element) {
  'use strict';
  return typeof element === 'string' ? doc.getElementById(element) : element;
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.getRequiredElement = function(id) {
  'use strict';
  return goog.dom.getRequiredElementHelper_(document, id);
};


/**
 * Helper function for getRequiredElementHelper functions, both static and
 * on DomHelper.  Asserts the element with the given id exists.
 * @param {!Document} doc
 * @param {string} id
 * @return {!Element} The element with the given ID, if it exists.
 * @private
 */
goog.dom.getRequiredElementHelper_ = function(doc, id) {
  'use strict';
  // To prevent users passing in Elements as is permitted in getElement().
  goog.asserts.assertString(id);
  var element = goog.dom.getElementHelper_(doc, id);
  element =
      goog.asserts.assertElement(element, 'No element found with id: ' + id);
  return element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Gets elements by tag name.
 * @param {!goog.dom.TagName<T>} tagName
 * @param {(!Document|!Element)=} opt_parent Parent element or document where to
 *     look for elements. Defaults to document.
 * @return {!NodeList<R>} List of elements. The members of the list are
 *     {!Element} if tagName is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.getElementsByTagName = function(tagName, opt_parent) {
  'use strict';
  var parent = opt_parent || document;
  return parent.getElementsByTagName(String(tagName));
};


/**
 * Looks up elements by both tag and class name, using browser native functions
 * (`querySelectorAll`, `getElementsByTagName` or
 * `getElementsByClassName`) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  `querySelectorAll` offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions.
 *
 * Note that tag names are case sensitive in the SVG namespace, and this
 * function converts opt_tag to uppercase for comparisons. For queries in the
 * SVG namespace you should use querySelector or querySelectorAll instead.
 * https://bugzilla.mozilla.org/show_bug.cgi?id=963870
 * https://bugs.webkit.org/show_bug.cgi?id=83438
 *
 * @see {https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll}
 *
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {!IArrayLike<R>} Array-like list of elements (only a length property
 *     and numerical indices are guaranteed to exist). The members of the array
 *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  'use strict';
  return goog.dom.getElementsByTagNameAndClass_(
      document, opt_tag, opt_class, opt_el);
};


/**
 * Gets the first element matching the tag and the class.
 *
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {?R} Reference to a DOM node. The return type is {?Element} if
 *     tagName is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  'use strict';
  return goog.dom.getElementByTagNameAndClass_(
      document, opt_tag, opt_class, opt_el);
};


/**
 * Returns a static, array-like list of the elements with the provided
 * className.
 *
 * @param {string} className the name of the class to look for.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {!IArrayLike<!Element>} The items found with the class name provided.
 */
goog.dom.getElementsByClass = function(className, opt_el) {
  'use strict';
  var parent = opt_el || document;
  if (goog.dom.canUseQuerySelector_(parent)) {
    return parent.querySelectorAll('.' + className);
  }
  return goog.dom.getElementsByTagNameAndClass_(
      document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 *
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function(className, opt_el) {
  'use strict';
  var parent = opt_el || document;
  var retVal = null;
  if (parent.getElementsByClassName) {
    retVal = parent.getElementsByClassName(className)[0];
  } else {
    retVal =
        goog.dom.getElementByTagNameAndClass_(document, '*', className, opt_el);
  }
  return retVal || null;
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 *
 * @param {string} className the name of the class to look for.
 * @param {!Element|!Document=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.getRequiredElementByClass = function(className, opt_root) {
  'use strict';
  var retValue = goog.dom.getElementByClass(className, opt_root);
  return goog.asserts.assert(
      retValue, 'No element found with className: ' + className);
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API.
 * @param {!(Element|Document)} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function(parent) {
  'use strict';
  return !!(parent.querySelectorAll && parent.querySelector);
};


/**
 * Helper for `getElementsByTagNameAndClass`.
 * @param {!Document} doc The document to get the elements in.
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {!IArrayLike<R>} Array-like list of elements (only a length property
 *     and numerical indices are guaranteed to exist). The members of the array
 *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function(
    doc, opt_tag, opt_class, opt_el) {
  'use strict';
  var parent = opt_el || doc;
  var tagName =
      (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';

  if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {
    var query = tagName + (opt_class ? '.' + opt_class : '');
    return parent.querySelectorAll(query);
  }

  // Use the native getElementsByClassName if available, under the assumption
  // that even when the tag name is specified, there will be fewer elements to
  // filter through when going by class than by tag name
  if (opt_class && parent.getElementsByClassName) {
    var els = parent.getElementsByClassName(opt_class);

    if (tagName) {
      var arrayLike = {};
      var len = 0;

      // Filter for specific tags if requested.
      for (var i = 0, el; el = els[i]; i++) {
        if (tagName == el.nodeName) {
          arrayLike[len++] = el;
        }
      }
      arrayLike.length = len;

      return /** @type {!IArrayLike<!Element>} */ (arrayLike);
    } else {
      return els;
    }
  }

  var els = parent.getElementsByTagName(tagName || '*');

  if (opt_class) {
    var arrayLike = {};
    var len = 0;
    for (var i = 0, el; el = els[i]; i++) {
      var className = el.className;
      // Check if className has a split function since SVG className does not.
      if (typeof className.split == 'function' &&
          goog.array.contains(className.split(/\s+/), opt_class)) {
        arrayLike[len++] = el;
      }
    }
    arrayLike.length = len;
    return /** @type {!IArrayLike<!Element>} */ (arrayLike);
  } else {
    return els;
  }
};


/**
 * Helper for goog.dom.getElementByTagNameAndClass.
 *
 * @param {!Document} doc The document to get the elements in.
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {?R} Reference to a DOM node. The return type is {?Element} if
 *     tagName is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @private
 */
goog.dom.getElementByTagNameAndClass_ = function(
    doc, opt_tag, opt_class, opt_el) {
  'use strict';
  var parent = opt_el || doc;
  var tag = (opt_tag && opt_tag != '*') ? String(opt_tag).toUpperCase() : '';
  if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) {
    return parent.querySelector(tag + (opt_class ? '.' + opt_class : ''));
  }
  var elements =
      goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);
  return elements[0] || null;
};



/**
 * Alias for `getElementsByTagNameAndClass`.
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return {!IArrayLike<R>} Array-like list of elements (only a length property
 *     and numerical indices are guaranteed to exist). The members of the array
 *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties, and sometimes attributes, on an element. Note that
 * properties are simply object properties on the element instance, while
 * attributes are visible in the DOM. Many properties map to attributes with the
 * same names, some with different names, and there are also unmappable cases.
 *
 * This method sets properties by default (which means that custom attributes
 * are not supported). These are the exeptions (some of which is legacy):
 * - "style": Even though this is an attribute name, it is translated to a
 *   property, "style.cssText". Note that this property sanitizes and formats
 *   its value, unlike the attribute.
 * - "class": This is an attribute name, it is translated to the "className"
 *   property.
 * - "for": This is an attribute name, it is translated to the "htmlFor"
 *   property.
 * - Entries in {@see goog.dom.DIRECT_ATTRIBUTE_MAP_} are set as attributes,
 *   this is probably due to browser quirks.
 * - "aria-*", "data-*": Always set as attributes, they have no property
 *   counterparts.
 *
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 *     Property values can be strings or goog.string.TypedString values (such as
 *     goog.html.SafeUrl).
 */
goog.dom.setProperties = function(element, properties) {
  'use strict';
  goog.object.forEach(properties, function(val, key) {
    'use strict';
    if (val && typeof val == 'object' && val.implementsGoogStringTypedString) {
      val = val.getTypedStringValue();
    }
    if (key == 'style') {
      element.style.cssText = val;
    } else if (key == 'class') {
      element.className = val;
    } else if (key == 'for') {
      element.htmlFor = val;
    } else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) {
      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
    } else if (
        goog.string.startsWith(key, 'aria-') ||
        goog.string.startsWith(key, 'data-')) {
      element.setAttribute(key, val);
    } else {
      element[key] = val;
    }
  });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @private {!Object<string, string>}
 * @const
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
  'cellpadding': 'cellPadding',
  'cellspacing': 'cellSpacing',
  'colspan': 'colSpan',
  'frameborder': 'frameBorder',
  'height': 'height',
  'maxlength': 'maxLength',
  'nonce': 'nonce',
  'role': 'role',
  'rowspan': 'rowSpan',
  'type': 'type',
  'usemap': 'useMap',
  'valign': 'vAlign',
  'width': 'width'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function(opt_window) {
  'use strict';
  // TODO(arv): This should not take an argument
  return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for `getViewportSize`.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function(win) {
  'use strict';
  var doc = win.document;
  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
  return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the current document.
 */
goog.dom.getDocumentHeight = function() {
  'use strict';
  return goog.dom.getDocumentHeight_(window);
};

/**
 * Calculates the height of the document of the given window.
 *
 * @param {!Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeightForWindow = function(win) {
  'use strict';
  return goog.dom.getDocumentHeight_(win);
};

/**
 * Calculates the height of the document of the given window.
 *
 * Function code copied from the opensocial gadget api:
 *   gadgets.window.adjustHeight(opt_height)
 *
 * @private
 * @param {!Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeight_ = function(win) {
  'use strict';
  // NOTE(eae): This method will return the window size rather than the document
  // size in webkit quirks mode.
  var doc = win.document;
  var height = 0;

  if (doc) {
    // Calculating inner content height is hard and different between
    // browsers rendering in Strict vs. Quirks mode.  We use a combination of
    // three properties within document.body and document.documentElement:
    // - scrollHeight
    // - offsetHeight
    // - clientHeight
    // These values differ significantly between browsers and rendering modes.
    // But there are patterns.  It just takes a lot of time and persistence
    // to figure out.

    var body = doc.body;
    var docEl = /** @type {!HTMLElement} */ (doc.documentElement);
    if (!(docEl && body)) {
      return 0;
    }

    // Get the height of the viewport
    var vh = goog.dom.getViewportSize_(win).height;
    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
      // In Strict mode:
      // The inner content height is contained in either:
      //    document.documentElement.scrollHeight
      //    document.documentElement.offsetHeight
      // Based on studying the values output by different browsers,
      // use the value that's NOT equal to the viewport height found above.
      height =
          docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;
    } else {
      // In Quirks mode:
      // documentElement.clientHeight is equal to documentElement.offsetHeight
      // except in IE.  In most browsers, document.documentElement can be used
      // to calculate the inner content height.
      // However, in other browsers (e.g. IE), document.body must be used
      // instead.  How do we know which one to use?
      // If document.documentElement.clientHeight does NOT equal
      // document.documentElement.offsetHeight, then use document.body.
      var sh = docEl.scrollHeight;
      var oh = docEl.offsetHeight;
      if (docEl.clientHeight != oh) {
        sh = body.scrollHeight;
        oh = body.offsetHeight;
      }

      // Detect whether the inner content height is bigger or smaller
      // than the bounding box (viewport).  If bigger, take the larger
      // value.  If smaller, take the smaller value.
      if (sh > vh) {
        // Content is larger
        height = sh > oh ? sh : oh;
      } else {
        // Content is smaller
        height = sh < oh ? sh : oh;
      }
    }
  }

  return height;
};


/**
 * Gets the page scroll distance as a coordinate object.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
 */
goog.dom.getPageScroll = function(opt_window) {
  'use strict';
  var win = opt_window || goog.global || window;
  return goog.dom.getDomHelper(win.document).getDocumentScroll();
};


/**
 * Gets the document scroll distance as a coordinate object.
 *
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 */
goog.dom.getDocumentScroll = function() {
  'use strict';
  return goog.dom.getDocumentScroll_(document);
};


/**
 * Helper for `getDocumentScroll`.
 *
 * @param {!Document} doc The document to get the scroll for.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @private
 */
goog.dom.getDocumentScroll_ = function(doc) {
  'use strict';
  var el = goog.dom.getDocumentScrollElement_(doc);
  var win = goog.dom.getWindow_(doc);
  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
      win.pageYOffset != el.scrollTop) {
    // The keyboard on IE10 touch devices shifts the page using the pageYOffset
    // without modifying scrollTop. For this case, we want the body scroll
    // offsets.
    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
  }
  return new goog.math.Coordinate(
      win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop);
};


/**
 * Gets the document scroll element.
 * @return {!Element} Scrolling element.
 */
goog.dom.getDocumentScrollElement = function() {
  'use strict';
  return goog.dom.getDocumentScrollElement_(document);
};


/**
 * Helper for `getDocumentScrollElement`.
 * @param {!Document} doc The document to get the scroll element for.
 * @return {!Element} Scrolling element.
 * @private
 */
goog.dom.getDocumentScrollElement_ = function(doc) {
  'use strict';
  // Old WebKit needs body.scrollLeft in both quirks mode and strict mode. We
  // also default to the documentElement if the document does not have a body
  // (e.g. a SVG document).
  // Uses http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement to
  // avoid trying to guess about browser behavior from the UA string.
  if (doc.scrollingElement) {
    return doc.scrollingElement;
  }
  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {
    return doc.documentElement;
  }
  return doc.body || doc.documentElement;
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.getWindow = function(opt_doc) {
  'use strict';
  // TODO(arv): This should not take an argument.
  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for `getWindow`.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function(doc) {
  'use strict';
  return /** @type {!Window} */ (doc.parentWindow || doc.defaultView);
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),
 * createDom(goog.dom.TagName.P));</code> would return a div with two child
 * paragraphs
 *
 * This function uses {@link goog.dom.setProperties} to set attributes: the
 * `opt_attributes` parameter follows the same rules.
 *
 * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
 * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further
 *     DOM nodes or strings for text nodes. If one of the var_args is an array
 *     or NodeList, its elements will be added as childNodes instead.
 * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
 *     is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
  'use strict';
  return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for `createDom`.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     `goog.dom.createDom` for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function(doc, args) {
  'use strict';
  var tagName = String(args[0]);
  var attributes = args[1];

  var element = goog.dom.createElement_(doc, tagName);

  if (attributes) {
    if (typeof attributes === 'string') {
      element.className = attributes;
    } else if (Array.isArray(attributes)) {
      element.className = attributes.join(' ');
    } else {
      goog.dom.setProperties(element, attributes);
    }
  }

  if (args.length > 2) {
    goog.dom.append_(doc, element, args, 2);
  }

  return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See `goog.dom.append`.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function(doc, parent, args, startIndex) {
  'use strict';
  function childHandler(child) {
    // TODO(pupius): More coercion, ala MochiKit?
    if (child) {
      parent.appendChild(
          typeof child === 'string' ? doc.createTextNode(child) : child);
    }
  }

  for (var i = startIndex; i < args.length; i++) {
    var arg = args[i];
    // TODO(attila): Fix isArrayLike to return false for a text node.
    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
      // If the argument is a node list, not a real array, use a clone,
      // because forEach can't be used to mutate a NodeList.
      goog.array.forEach(
          goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg,
          childHandler);
    } else {
      childHandler(arg);
    }
  }
};


/**
 * Alias for `createDom`.
 * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
 * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList|null|undefined)} var_args Further
 *     DOM nodes or strings for text nodes. If one of the var_args is an array,
 *     its children will be added as childNodes instead.
 * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
 *     is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string|!goog.dom.TagName<T>} name Tag to create.
 * @return {R} The new element. The return type is {!Element} if name is
 *     a string or a more specific type if it is a member of goog.dom.TagName
 *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.createElement = function(name) {
  'use strict';
  return goog.dom.createElement_(document, name);
};


/**
 * Creates a new element.
 * @param {!Document} doc The document to create the element in.
 * @param {string|!goog.dom.TagName<T>} name Tag to create.
 * @return {R} The new element. The return type is {!Element} if name is
 *     a string or a more specific type if it is a member of goog.dom.TagName
 *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @private
 */
goog.dom.createElement_ = function(doc, name) {
  'use strict';
  name = String(name);
  if (doc.contentType === 'application/xhtml+xml') name = name.toLowerCase();
  return doc.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function(content) {
  'use strict';
  return document.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with
 *     `goog.string.Unicode.NBSP` characters.
 * @return {!Element} The created table.
 */
goog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {
  'use strict';
  // TODO(mlourenco): Return HTMLTableElement, also in prototype function.
  // Callers need to be updated to e.g. not assign numbers to table.cellSpacing.
  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Create a table.
 * @param {!Document} doc Document object to use to create the table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean} fillWithNbsp If true, fills table entries with
 *     `goog.string.Unicode.NBSP` characters.
 * @return {!HTMLTableElement} The created table.
 * @private
 */
goog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {
  'use strict';
  var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);
  var tbody =
      table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));
  for (var i = 0; i < rows; i++) {
    var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);
    for (var j = 0; j < columns; j++) {
      var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);
      // IE <= 9 will create a text node if we set text content to the empty
      // string, so we avoid doing it unless necessary. This ensures that the
      // same DOM tree is returned on all browsers.
      if (fillWithNbsp) {
        goog.dom.setTextContent(td, goog.string.Unicode.NBSP);
      }
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
  return table;
};



/**
 * Creates a new Node from constant strings of HTML markup.
 * @param {...!goog.string.Const} var_args The HTML strings to concatenate then
 *     convert into a node.
 * @return {!Node}
 */
goog.dom.constHtmlToNode = function(var_args) {
  'use strict';
  var stringArray =
      Array.prototype.map.call(arguments, goog.string.Const.unwrap);
  var safeHtml =
      goog.html.uncheckedconversions
          .safeHtmlFromStringKnownToSatisfyTypeContract(
              goog.string.Const.from(
                  'Constant HTML string, that gets turned into a ' +
                  'Node later, so it will be automatically balanced.'),
              stringArray.join(''));
  return goog.dom.safeHtmlToNode(safeHtml);
};


/**
 * Converts HTML markup into a node. This is a safe version of
 * `goog.dom.htmlToDocumentFragment` which is now deleted.
 * @param {!goog.html.SafeHtml} html The HTML markup to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.safeHtmlToNode = function(html) {
  'use strict';
  return goog.dom.safeHtmlToNode_(document, html);
};


/**
 * Helper for `safeHtmlToNode`.
 * @param {!Document} doc The document.
 * @param {!goog.html.SafeHtml} html The HTML markup to convert.
 * @return {!Node} The resulting node.
 * @private
 */
goog.dom.safeHtmlToNode_ = function(doc, html) {
  'use strict';
  var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
    goog.dom.safe.setInnerHtml(
        tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));
    tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));
  } else {
    goog.dom.safe.setInnerHtml(tempDiv, html);
  }
  return goog.dom.childrenToNode_(doc, tempDiv);
};


/**
 * Helper for `safeHtmlToNode_`.
 * @param {!Document} doc The document.
 * @param {!Node} tempDiv The input node.
 * @return {!Node} The resulting node.
 * @private
 */
goog.dom.childrenToNode_ = function(doc, tempDiv) {
  'use strict';
  if (tempDiv.childNodes.length == 1) {
    return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));
  } else {
    var fragment = doc.createDocumentFragment();
    while (tempDiv.firstChild) {
      fragment.appendChild(tempDiv.firstChild);
    }
    return fragment;
  }
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.isCss1CompatMode = function() {
  'use strict';
  return goog.dom.isCss1CompatMode_(document);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @param {!Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function(doc) {
  'use strict';
  if (goog.dom.COMPAT_MODE_KNOWN_) {
    return goog.dom.ASSUME_STANDARDS_MODE;
  }

  return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = goog.dom.createElement(goog.dom.TagName.BR);
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *   console.log(a.childNodes.length);  // 2
 *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * For more information, see:
 * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
 *
 * TODO(pupius): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren = function(node) {
  'use strict';
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    return false;
  }
  switch (/** @type {!Element} */ (node).tagName) {
    case String(goog.dom.TagName.APPLET):
    case String(goog.dom.TagName.AREA):
    case String(goog.dom.TagName.BASE):
    case String(goog.dom.TagName.BR):
    case String(goog.dom.TagName.COL):
    case String(goog.dom.TagName.COMMAND):
    case String(goog.dom.TagName.EMBED):
    case String(goog.dom.TagName.FRAME):
    case String(goog.dom.TagName.HR):
    case String(goog.dom.TagName.IMG):
    case String(goog.dom.TagName.INPUT):
    case String(goog.dom.TagName.IFRAME):
    case String(goog.dom.TagName.ISINDEX):
    case String(goog.dom.TagName.KEYGEN):
    case String(goog.dom.TagName.LINK):
    case String(goog.dom.TagName.NOFRAMES):
    case String(goog.dom.TagName.NOSCRIPT):
    case String(goog.dom.TagName.META):
    case String(goog.dom.TagName.OBJECT):
    case String(goog.dom.TagName.PARAM):
    case String(goog.dom.TagName.SCRIPT):
    case String(goog.dom.TagName.SOURCE):
    case String(goog.dom.TagName.STYLE):
    case String(goog.dom.TagName.TRACK):
    case String(goog.dom.TagName.WBR):
      return false;
  }
  return true;
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function(parent, child) {
  'use strict';
  goog.asserts.assert(
      parent != null && child != null,
      'goog.dom.appendChild expects non-null arguments');
  parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function(parent, var_args) {
  'use strict';
  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 * @return {void}
 */
goog.dom.removeChildren = function(node) {
  'use strict';
  // Note: Iterations over live collections can be slow, this is the fastest
  // we could find. The double parenthesis are used to prevent JsCompiler and
  // strict warnings.
  var child;
  while ((child = node.firstChild)) {
    node.removeChild(child);
  }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function(newNode, refNode) {
  'use strict';
  goog.asserts.assert(
      newNode != null && refNode != null,
      'goog.dom.insertSiblingBefore expects non-null arguments');
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode);
  }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 * @return {void}
 */
goog.dom.insertSiblingAfter = function(newNode, refNode) {
  'use strict';
  goog.asserts.assert(
      newNode != null && refNode != null,
      'goog.dom.insertSiblingAfter expects non-null arguments');
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  }
};


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 * @return {void}
 */
goog.dom.insertChildAt = function(parent, child, index) {
  'use strict';
  // Note that if the second argument is null, insertBefore
  // will append the child at the end of the list of children.
  goog.asserts.assert(
      parent != null, 'goog.dom.insertChildAt expects a non-null parent');
  parent.insertBefore(
      /** @type {!Node} */ (child), parent.childNodes[index] || null);
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function(node) {
  'use strict';
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function(newNode, oldNode) {
  'use strict';
  goog.asserts.assert(
      newNode != null && oldNode != null,
      'goog.dom.replaceNode expects non-null arguments');
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};


/**
 * Replaces child nodes of `target` with child nodes of `source`. This is
 * roughly equivalent to `target.innerHTML = source.innerHTML` which is not
 * compatible with Trusted Types.
 * @param {?Node} target Node to clean and replace its children.
 * @param {?Node} source Node to get the children from. The nodes will be cloned
 *     so they will stay in source.
 */
goog.dom.copyContents = function(target, source) {
  'use strict';
  goog.asserts.assert(
      target != null && source != null,
      'goog.dom.copyContents expects non-null arguments');
  var childNodes = source.cloneNode(/* deep= */ true).childNodes;
  goog.dom.removeChildren(target);
  while (childNodes.length) {
    target.appendChild(childNodes[0]);
  }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the document
 *     to begin with.
 */
goog.dom.flattenElement = function(element) {
  'use strict';
  var child, parent = element.parentNode;
  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
    // Use IE DOM method (supported by Opera too) if available
    if (element.removeNode) {
      return /** @type {Element} */ (element.removeNode(false));
    } else {
      // Move all children of the original node up one level.
      while ((child = element.firstChild)) {
        parent.insertBefore(child, element);
      }

      // Detach the original element.
      return /** @type {Element} */ (goog.dom.removeNode(element));
    }
  }
};


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list
 *     of just the element children of the given element.
 */
goog.dom.getChildren = function(element) {
  'use strict';
  // We check if the children attribute is supported for child elements
  // since IE8 misuses the attribute by also including comments.
  if (element.children != undefined) {
    return element.children;
  }
  // Fall back to manually filtering the element's child nodes.
  return Array.prototype.filter.call(element.childNodes, function(node) {
    return node.nodeType == goog.dom.NodeType.ELEMENT;
  });
};


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of `node` that is an element.
 */
goog.dom.getFirstElementChild = function(node) {
  'use strict';
  if (node.firstElementChild !== undefined) {
    return /** @type {!Element} */ (node).firstElementChild;
  }
  return goog.dom.getNextElementNode_(node.firstChild, true);
};


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of `node` that is an element.
 */
goog.dom.getLastElementChild = function(node) {
  'use strict';
  if (node.lastElementChild !== undefined) {
    return /** @type {!Element} */ (node).lastElementChild;
  }
  return goog.dom.getNextElementNode_(node.lastChild, false);
};


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of `node` that is an element.
 */
goog.dom.getNextElementSibling = function(node) {
  'use strict';
  if (node.nextElementSibling !== undefined) {
    return /** @type {!Element} */ (node).nextElementSibling;
  }
  return goog.dom.getNextElementNode_(node.nextSibling, true);
};


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of `node` that is
 *     an element.
 */
goog.dom.getPreviousElementSibling = function(node) {
  'use strict';
  if (node.previousElementSibling !== undefined) {
    return /** @type {!Element} */ (node).previousElementSibling;
  }
  return goog.dom.getNextElementNode_(node.previousSibling, false);
};


/**
 * Returns the first node that is an element in the specified direction,
 * starting with `node`.
 * @param {Node} node The node to get the next element from.
 * @param {boolean} forward Whether to look forwards or backwards.
 * @return {Element} The first element.
 * @private
 */
goog.dom.getNextElementNode_ = function(node, forward) {
  'use strict';
  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
    node = forward ? node.nextSibling : node.previousSibling;
  }

  return /** @type {Element} */ (node);
};


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.getNextNode = function(node) {
  'use strict';
  if (!node) {
    return null;
  }

  if (node.firstChild) {
    return node.firstChild;
  }

  while (node && !node.nextSibling) {
    node = node.parentNode;
  }

  return node ? node.nextSibling : null;
};


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.getPreviousNode = function(node) {
  'use strict';
  if (!node) {
    return null;
  }

  if (!node.previousSibling) {
    return node.parentNode;
  }

  node = node.previousSibling;
  while (node && node.lastChild) {
    node = node.lastChild;
  }

  return node;
};


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function(obj) {
  'use strict';
  return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.isElement = function(obj) {
  'use strict';
  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
};


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.isWindow = function(obj) {
  'use strict';
  return goog.isObject(obj) && obj['window'] == obj;
};


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.getParentElement = function(element) {
  'use strict';
  var parent;
  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
    var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher('9') &&
        !goog.userAgent.isVersionOrHigher('10');
    // SVG elements in IE9 can't use the parentElement property.
    // goog.global['SVGElement'] is not defined in IE9 quirks mode.
    if (!(isIe9 && goog.global['SVGElement'] &&
          element instanceof goog.global['SVGElement'])) {
      parent = element.parentElement;
      if (parent) {
        return parent;
      }
    }
  }
  parent = element.parentNode;
  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
};


/**
 * Whether a node contains another node.
 * @param {?Node|undefined} parent The node that should contain the other node.
 * @param {?Node|undefined} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendant node.
 */
goog.dom.contains = function(parent, descendant) {
  'use strict';
  if (!parent || !descendant) {
    return false;
  }
  // We use browser specific methods for this if available since it is faster
  // that way.

  // IE DOM
  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
    return parent == descendant || parent.contains(descendant);
  }

  // W3C DOM Level 3
  if (typeof parent.compareDocumentPosition != 'undefined') {
    return parent == descendant ||
        Boolean(parent.compareDocumentPosition(descendant) & 16);
  }

  // W3C DOM Level 1
  while (descendant && parent != descendant) {
    descendant = descendant.parentNode;
  }
  return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function(node1, node2) {
  'use strict';
  // Fall out quickly for equality.
  if (node1 == node2) {
    return 0;
  }

  // Use compareDocumentPosition where available
  if (node1.compareDocumentPosition) {
    // 4 is the bitmask for FOLLOWS.
    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
  }

  // Special case for document nodes on IE 7 and 8.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
      return -1;
    }
    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
      return 1;
    }
  }

  // Process in IE using sourceIndex - we check to see if the first node has
  // a source index or if its parent has one.
  if ('sourceIndex' in node1 ||
      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

    if (isElement1 && isElement2) {
      return node1.sourceIndex - node2.sourceIndex;
    } else {
      var parent1 = node1.parentNode;
      var parent2 = node2.parentNode;

      if (parent1 == parent2) {
        return goog.dom.compareSiblingOrder_(node1, node2);
      }

      if (!isElement1 && goog.dom.contains(parent1, node2)) {
        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
      }


      if (!isElement2 && goog.dom.contains(parent2, node1)) {
        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
      }

      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
          (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
    }
  }

  // For Safari, we compare ranges.
  var doc = goog.dom.getOwnerDocument(node1);

  var range1, range2;
  range1 = doc.createRange();
  range1.selectNode(node1);
  range1.collapse(true);

  range2 = doc.createRange();
  range2.selectNode(node2);
  range2.collapse(true);

  return range1.compareBoundaryPoints(
      goog.global['Range'].START_TO_END, range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * `textNode`'s parent is an ancestor of `node`.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {!Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
  'use strict';
  var parent = textNode.parentNode;
  if (parent == node) {
    // If textNode is a child of node, then node comes first.
    return -1;
  }
  var sibling = node;
  while (sibling.parentNode != parent) {
    sibling = sibling.parentNode;
  }
  return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {!Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function(node1, node2) {
  'use strict';
  var s = node2;
  while ((s = s.previousSibling)) {
    if (s == node1) {
      // We just found node1 before node2.
      return -1;
    }
  }

  // Since we didn't find it, node1 must be after node2.
  return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function(var_args) {
  'use strict';
  var i, count = arguments.length;
  if (!count) {
    return null;
  } else if (count == 1) {
    return arguments[0];
  }

  var paths = [];
  var minLength = Infinity;
  for (i = 0; i < count; i++) {
    // Compute the list of ancestors.
    var ancestors = [];
    var node = arguments[i];
    while (node) {
      ancestors.unshift(node);
      node = node.parentNode;
    }

    // Save the list for comparison.
    paths.push(ancestors);
    minLength = Math.min(minLength, ancestors.length);
  }
  var output = null;
  for (i = 0; i < minLength; i++) {
    var first = paths[0][i];
    for (var j = 1; j < count; j++) {
      if (first != paths[j][i]) {
        return output;
      }
    }
    output = first;
  }
  return output;
};


/**
 * Returns whether node is in a document or detached. Throws an error if node
 * itself is a document. This specifically handles two cases beyond naive use of
 * builtins: (1) it works correctly in IE, and (2) it works for elements from
 * different documents/iframes. If neither of these considerations are relevant
 * then a simple `document.contains(node)` may be used instead.
 * @param {!Node} node
 * @return {boolean}
 */
goog.dom.isInDocument = function(node) {
  'use strict';
  return (node.ownerDocument.compareDocumentPosition(node) & 16) == 16;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function(node) {
  'use strict';
  // TODO(nnaze): Update param signature to be non-nullable.
  goog.asserts.assert(node, 'Node cannot be null or undefined.');
  return /** @type {!Document} */ (
      node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument ||
              node.document);
};


/**
 * Cross-browser function for getting the document element of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {!Document} The frame content document.
 */
goog.dom.getFrameContentDocument = function(frame) {
  'use strict';
  return frame.contentDocument ||
      /** @type {!HTMLFrameElement} */ (frame).contentWindow.document;
};


/**
 * Cross-browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame, or null if none
 *     exists.
 */
goog.dom.getFrameContentWindow = function(frame) {
  'use strict';
  try {
    return frame.contentWindow ||
        (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) :
                                 null);
  } catch (e) {
    // NOTE(jfedor): In IE8, checking the contentWindow or contentDocument
    // properties will throw a "Unspecified Error" exception if the iframe is
    // not inserted in the DOM. If we get this we can be sure that no window
    // exists, so return null.
  }
  return null;
};


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 * @return {void}
 */
goog.dom.setTextContent = function(node, text) {
  'use strict';
  goog.asserts.assert(
      node != null,
      'goog.dom.setTextContent expects a non-null value for node');

  if ('textContent' in node) {
    node.textContent = text;
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    /** @type {!Text} */ (node).data = String(text);
  } else if (
      node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
    // If the first child is a text node we just change its data and remove the
    // rest of the children.
    while (node.lastChild != node.firstChild) {
      node.removeChild(goog.asserts.assert(node.lastChild));
    }
    /** @type {!Text} */ (node.firstChild).data = String(text);
  } else {
    goog.dom.removeChildren(node);
    var doc = goog.dom.getOwnerDocument(node);
    node.appendChild(doc.createTextNode(String(text)));
  }
};


/**
 * Gets the outerHTML of a node, which is like innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function(element) {
  'use strict';
  goog.asserts.assert(
      element !== null,
      'goog.dom.getOuterHtml expects a non-null value for element');
  // IE, Opera and WebKit all have outerHTML.
  if ('outerHTML' in element) {
    return element.outerHTML;
  } else {
    var doc = goog.dom.getOwnerDocument(element);
    var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
    div.appendChild(element.cloneNode(true));
    return div.innerHTML;
  }
};


/**
 * Finds the first descendant node that matches the filter function, using depth
 * first search. This function offers the most general purpose way of finding a
 * matching element.
 *
 * Prefer using `querySelector` if the matching criteria can be expressed as a
 * CSS selector, or `goog.dom.findElement` if you would filter for `nodeType ==
 * Node.ELEMENT_NODE`.
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.findNode = function(root, p) {
  'use strict';
  var rv = [];
  var found = goog.dom.findNodes_(root, p, rv, true);
  return found ? rv[0] : undefined;
};


/**
 * Finds all the descendant nodes that match the filter function, using depth
 * first search. This function offers the most general-purpose way
 * of finding a set of matching elements.
 *
 * Prefer using `querySelectorAll` if the matching criteria can be expressed as
 * a CSS selector, or `goog.dom.findElements` if you would filter for
 * `nodeType == Node.ELEMENT_NODE`.
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {!Array<!Node>} The found nodes or an empty array if none are found.
 */
goog.dom.findNodes = function(root, p) {
  'use strict';
  var rv = [];
  goog.dom.findNodes_(root, p, rv, false);
  return rv;
};


/**
 * Finds the first or all the descendant nodes that match the filter function,
 * using a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @param {!Array<!Node>} rv The found nodes are added to this array.
 * @param {boolean} findOne If true we exit after the first found node.
 * @return {boolean} Whether the search is complete or not. True in case findOne
 *     is true and the node is found. False otherwise.
 * @private
 */
goog.dom.findNodes_ = function(root, p, rv, findOne) {
  'use strict';
  if (root != null) {
    var child = root.firstChild;
    while (child) {
      if (p(child)) {
        rv.push(child);
        if (findOne) {
          return true;
        }
      }
      if (goog.dom.findNodes_(child, p, rv, findOne)) {
        return true;
      }
      child = child.nextSibling;
    }
  }
  return false;
};


/**
 * Finds the first descendant element (excluding `root`) that matches the filter
 * function, using depth first search. Prefer using `querySelector` if the
 * matching criteria can be expressed as a CSS selector.
 *
 * @param {!Element | !Document} root
 * @param {function(!Element): boolean} pred Filter function.
 * @return {?Element} First matching element or null if there is none.
 */
goog.dom.findElement = function(root, pred) {
  'use strict';
  var stack = goog.dom.getChildrenReverse_(root);
  while (stack.length > 0) {
    var next = stack.pop();
    if (pred(next)) return next;
    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {
      stack.push(c);
    }
  }
  return null;
};


/**
 * Finds all the descendant elements (excluding `root`) that match the filter
 * function, using depth first search. Prefer using `querySelectorAll` if the
 * matching criteria can be expressed as a CSS selector.
 *
 * @param {!Element | !Document} root
 * @param {function(!Element): boolean} pred Filter function.
 * @return {!Array<!Element>}
 */
goog.dom.findElements = function(root, pred) {
  'use strict';
  var result = [], stack = goog.dom.getChildrenReverse_(root);
  while (stack.length > 0) {
    var next = stack.pop();
    if (pred(next)) result.push(next);
    for (var c = next.lastElementChild; c; c = c.previousElementSibling) {
      stack.push(c);
    }
  }
  return result;
};


/**
 * @param {!Element | !Document} node
 * @return {!Array<!Element>} node's child elements in reverse order.
 * @private
 */
goog.dom.getChildrenReverse_ = function(node) {
  'use strict';
  // document.lastElementChild doesn't exist in IE9; fall back to
  // documentElement.
  if (node.nodeType == goog.dom.NodeType.DOCUMENT) {
    return [node.documentElement];
  } else {
    var children = [];
    for (var c = node.lastElementChild; c; c = c.previousElementSibling) {
      children.push(c);
    }
    return children;
  }
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @private {!Object<string, number>}
 * @const
 */
goog.dom.TAGS_TO_IGNORE_ = {
  'SCRIPT': 1,
  'STYLE': 1,
  'HEAD': 1,
  'IFRAME': 1,
  'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @private {!Object<string, string>}
 * @const
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {
  'IMG': ' ',
  'BR': '\n'
};


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.isFocusableTabIndex = function(element) {
  'use strict';
  return goog.dom.hasSpecifiedTabIndex_(element) &&
      goog.dom.isTabIndexFocusable_(element);
};


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 * @return {void}
 */
goog.dom.setFocusableTabIndex = function(element, enable) {
  'use strict';
  if (enable) {
    element.tabIndex = 0;
  } else {
    // Set tabIndex to -1 first, then remove it. This is a workaround for
    // Safari (confirmed in version 4 on Windows). When removing the attribute
    // without setting it to -1 first, the element remains keyboard focusable
    // despite not having a tabIndex attribute anymore.
    element.tabIndex = -1;
    element.removeAttribute('tabIndex');  // Must be camelCase!
  }
};


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.isFocusable = function(element) {
  'use strict';
  var focusable;
  // Some elements can have unspecified tab index and still receive focus.
  if (goog.dom.nativelySupportsFocus_(element)) {
    // Make sure the element is not disabled ...
    focusable = !element.disabled &&
        // ... and if a tab index is specified, it allows focus.
        (!goog.dom.hasSpecifiedTabIndex_(element) ||
         goog.dom.isTabIndexFocusable_(element));
  } else {
    focusable = goog.dom.isFocusableTabIndex(element);
  }

  // IE requires elements to be visible in order to focus them.
  return focusable && goog.userAgent.IE ?
      goog.dom.hasNonZeroBoundingRect_(/** @type {!HTMLElement} */ (element)) :
      focusable;
};


/**
 * Returns true if the element has a specified tab index.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element has a specified tab index.
 * @private
 */
goog.dom.hasSpecifiedTabIndex_ = function(element) {
  'use strict';
  return element.hasAttribute('tabindex');
};


/**
 * Returns true if the element's tab index allows the element to be focused.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element's tab index allows focus.
 * @private
 */
goog.dom.isTabIndexFocusable_ = function(element) {
  'use strict';
  var index = /** @type {!HTMLElement} */ (element).tabIndex;
  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
  return typeof (index) === 'number' && index >= 0 && index < 32768;
};


/**
 * Returns true if the element is focusable even when tabIndex is not set.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element natively supports focus.
 * @private
 */
goog.dom.nativelySupportsFocus_ = function(element) {
  'use strict';
  return (
      element.tagName == goog.dom.TagName.A && element.hasAttribute('href') ||
      element.tagName == goog.dom.TagName.INPUT ||
      element.tagName == goog.dom.TagName.TEXTAREA ||
      element.tagName == goog.dom.TagName.SELECT ||
      element.tagName == goog.dom.TagName.BUTTON);
};


/**
 * Returns true if the element has a bounding rectangle that would be visible
 * (i.e. its width and height are greater than zero).
 * @param {!HTMLElement} element Element to check.
 * @return {boolean} Whether the element has a non-zero bounding rectangle.
 * @private
 */
goog.dom.hasNonZeroBoundingRect_ = function(element) {
  'use strict';
  var rect;
  if (typeof element['getBoundingClientRect'] !== 'function' ||
      // In IE, getBoundingClientRect throws on detached nodes.
      (goog.userAgent.IE && element.parentElement == null)) {
    rect = {'height': element.offsetHeight, 'width': element.offsetWidth};
  } else {
    rect = element.getBoundingClientRect();
  }
  return rect != null && rect.height > 0 && rect.width > 0;
};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function(node) {
  'use strict';
  var textContent;
  var buf = [];
  goog.dom.getTextContent_(node, buf, true);
  textContent = buf.join('');

  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
  textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
  textContent = textContent.replace(/\u200B/g, '');

  textContent = textContent.replace(/ +/g, ' ');
  if (textContent != ' ') {
    textContent = textContent.replace(/^\s*/, '');
  }

  return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike `getTextContent` this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function(node) {
  'use strict';
  var buf = [];
  goog.dom.getTextContent_(node, buf, false);

  return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array<string>} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
  'use strict';
  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
    // ignore certain tags
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    if (normalizeWhitespace) {
      buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      buf.push(node.nodeValue);
    }
  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
  } else {
    var child = node.firstChild;
    while (child) {
      goog.dom.getTextContent_(child, buf, normalizeWhitespace);
      child = child.nextSibling;
    }
  }
};


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of `node`'s text content.
 */
goog.dom.getNodeTextLength = function(node) {
  'use strict';
  return goog.dom.getTextContent(node).length;
};


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by goog.dom.getNodeTextLength.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent The node relative to which the offset will
 *     be calculated. Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.getNodeTextOffset = function(node, opt_offsetParent) {
  'use strict';
  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
  var buf = [];
  while (node && node != root) {
    var cur = node;
    while ((cur = cur.previousSibling)) {
      buf.unshift(goog.dom.getTextContent(cur));
    }
    node = node.parentNode;
  }
  // Trim left to deal with FF cases when there might be line breaks and empty
  // nodes at the front of the text
  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
};


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.getNodeAtOffset = function(parent, offset, opt_result) {
  'use strict';
  var stack = [parent], pos = 0, cur = null;
  while (stack.length > 0 && pos < offset) {
    cur = stack.pop();
    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
      // ignore certain tags
    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {
      var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
      pos += text.length;
    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
    } else {
      for (var i = cur.childNodes.length - 1; i >= 0; i--) {
        stack.push(cur.childNodes[i]);
      }
    }
  }
  if (goog.isObject(opt_result)) {
    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
    opt_result.node = cur;
  }

  return cur;
};


/**
 * Returns true if the object is a `NodeList`.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function(val) {
  'use strict';
  // TODO(attila): Now the isNodeList is part of goog.dom we can use
  // goog.userAgent to make this simpler.
  // A NodeList must have a length property of type 'number' on all platforms.
  if (val && typeof val.length == 'number') {
    // A NodeList is an object everywhere except Safari, where it's a function.
    if (goog.isObject(val)) {
      // A NodeList must have an item function (on non-IE platforms) or an item
      // property of type 'string' (on IE).
      return typeof val.item == 'function' || typeof val.item == 'string';
    } else if (typeof val === 'function') {
      // On Safari, a NodeList is a function with an item property that is also
      // a function.
      return typeof /** @type {?} */ (val.item) == 'function';
    }
  }

  // Not a NodeList.
  return false;
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {?R} The first ancestor that matches the passed criteria, or
 *     null if no match is found. The return type is {?Element} if opt_tag is
 *     not a member of goog.dom.TagName or a more specific type if it is (e.g.
 *     {?HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.getAncestorByTagNameAndClass = function(
    element, opt_tag, opt_class, opt_maxSearchSteps) {
  'use strict';
  if (!opt_tag && !opt_class) {
    return null;
  }
  var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;
  return /** @type {Element} */ (goog.dom.getAncestor(element, function(node) {
    'use strict';
    return (!tagName || node.nodeName == tagName) &&
        (!opt_class ||
         typeof node.className === 'string' &&
             goog.array.contains(node.className.split(/\s+/), opt_class));
  }, true, opt_maxSearchSteps));
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} className The class name to match.
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {
  'use strict';
  return goog.dom.getAncestorByTagNameAndClass(
      element, null, className, opt_maxSearchSteps);
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(!Node) : boolean} matcher A function that returns true if
 *     the passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.getAncestor = function(
    element, matcher, opt_includeNode, opt_maxSearchSteps) {
  'use strict';
  if (element && !opt_includeNode) {
    element = element.parentNode;
  }
  var steps = 0;
  while (element &&
         (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {
    goog.asserts.assert(element.name != 'parentNode');
    if (matcher(element)) {
      return element;
    }
    element = element.parentNode;
    steps++;
  }
  // Reached the root of the DOM without a match
  return null;
};


/**
 * Determines the active element in the given document.
 * @param {Document} doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.getActiveElement = function(doc) {
  'use strict';
  // While in an iframe, IE9 will throw "Unspecified error" when accessing
  // activeElement.
  try {
    var activeElement = doc && doc.activeElement;
    // While not in an iframe, IE9-11 sometimes gives null.
    // While in an iframe, IE11 sometimes returns an empty object.
    return activeElement && activeElement.nodeName ? activeElement : null;
  } catch (e) {
    return null;
  }
};


/**
 * Gives the current devicePixelRatio.
 *
 * By default, this is the value of window.devicePixelRatio (which should be
 * preferred if present).
 *
 * If window.devicePixelRatio is not present, the ratio is calculated with
 * window.matchMedia, if present. Otherwise, gives 1.0.
 *
 * Some browsers (including Chrome) consider the browser zoom level in the pixel
 * ratio, so the value may change across multiple calls.
 *
 * @return {number} The number of actual pixels per virtual pixel.
 */
goog.dom.getPixelRatio = function() {
  'use strict';
  var win = goog.dom.getWindow();
  if (win.devicePixelRatio !== undefined) {
    return win.devicePixelRatio;
  } else if (win.matchMedia) {
    // Should be for IE10 and FF6-17 (this basically clamps to lower)
    // Note that the order of these statements is important
    return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) ||
           goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) ||
           .75;
  }
  return 1;
};


/**
 * Calculates a mediaQuery to check if the current device supports the
 * given actual to virtual pixel ratio.
 * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
 * @return {number} pixelRatio if applicable, otherwise 0.
 * @private
 */
goog.dom.matchesPixelRatio_ = function(pixelRatio) {
  'use strict';
  var win = goog.dom.getWindow();
  /**
   * Due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to
   * 96dpi.
   * @const {number}
   */
  var dpiPerDppx = 96;
  var query =
      // FF16-17
      '(min-resolution: ' + pixelRatio + 'dppx),' +
      // FF6-15
      '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
      // IE10 (this works for the two browsers above too but I don't want to
      // trust the 1:96 fixed ratio magic)
      '(min-resolution: ' + (pixelRatio * dpiPerDppx) + 'dpi)';
  return win.matchMedia(query).matches ? pixelRatio : 0;
};


/**
 * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a
 * type information.
 * @param {!HTMLCanvasElement|!OffscreenCanvas} canvas
 * @return {!CanvasRenderingContext2D}
 */
goog.dom.getCanvasContext2D = function(canvas) {
  'use strict';
  return /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));
};



/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function(opt_document) {
  'use strict';
  /**
   * Reference to the document object to use
   * @type {!Document}
   * @private
   */
  this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function(document) {
  'use strict';
  this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function() {
  'use strict';
  return this.document_;
};


/**
 * Alias for `getElementById`. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function(element) {
  'use strict';
  return goog.dom.getElementHelper_(this.document_, element);
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.DomHelper.prototype.getRequiredElement = function(id) {
  'use strict';
  return goog.dom.getRequiredElementHelper_(this.document_, id);
};


/**
 * Alias for `getElement`.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Gets elements by tag name.
 * @param {!goog.dom.TagName<T>} tagName
 * @param {(!Document|!Element)=} opt_parent Parent element or document where to
 *     look for elements. Defaults to document of this DomHelper.
 * @return {!NodeList<R>} List of elements. The members of the list are
 *     {!Element} if tagName is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.getElementsByTagName = function(
    tagName, opt_parent) {
  'use strict';
  var parent = opt_parent || this.document_;
  return parent.getElementsByTagName(String(tagName));
};


/**
 * Looks up elements by both tag and class name, using browser native functions
 * (`querySelectorAll`, `getElementsByTagName` or
 * `getElementsByClassName`) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name or * for all
 *     tags.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {!IArrayLike<R>} Array-like list of elements (only a length property
 *     and numerical indices are guaranteed to exist). The members of the array
 *     are {!Element} if opt_tag is not a member of goog.dom.TagName or more
 *     specific types if it is (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(
    opt_tag, opt_class, opt_el) {
  'use strict';
  return goog.dom.getElementsByTagNameAndClass_(
      this.document_, opt_tag, opt_class, opt_el);
};


/**
 * Gets the first element matching the tag and the class.
 *
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return {?R} Reference to a DOM node. The return type is {?Element} if
 *     tagName is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {?HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(
    opt_tag, opt_class, opt_el) {
  'use strict';
  return goog.dom.getElementByTagNameAndClass_(
      this.document_, opt_tag, opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {!IArrayLike<!Element>} The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
  'use strict';
  var doc = opt_el || this.document_;
  return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @param {string} className the name of the class to look for.
 * @param {(Element|Document)=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
  'use strict';
  var doc = opt_el || this.document_;
  return goog.dom.getElementByClass(className, doc);
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @param {string} className the name of the class to look for.
 * @param {(!Element|!Document)=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item found with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.DomHelper.prototype.getRequiredElementByClass = function(
    className, opt_root) {
  'use strict';
  var root = opt_root || this.document_;
  return goog.dom.getRequiredElementByClass(className, root);
};


/**
 * Alias for `getElementsByTagNameAndClass`.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 *
 * @param {(string|?goog.dom.TagName<T>)=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return {!IArrayLike<R>} Array-like list of elements (only a length property
 *     and numerical indices are guaranteed to exist). The members of the array
 *     are {!Element} if opt_tag is a string or more specific types if it is
 *     a member of goog.dom.TagName (e.g. {!HTMLAnchorElement} for
 *     goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
  'use strict';
  // TODO(arv): This should not take an argument. That breaks the rule of a
  // a DomHelper representing a single frame/window/document.
  return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the document.
 */
goog.dom.DomHelper.prototype.getDocumentHeight = function() {
  'use strict';
  return goog.dom.getDocumentHeight_(this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom(goog.dom.TagName.DIV, null, createDom(goog.dom.TagName.P),
 * createDom(goog.dom.TagName.P));</code> would return a div with two child
 * paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom(goog.dom.TagName.DIV, null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
 * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
 *     is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.createDom = function(
    tagName, opt_attributes, var_args) {
  'use strict';
  return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for `createDom`.
 * @param {string|!goog.dom.TagName<T>} tagName Tag to create.
 * @param {?Object|?Array<string>|string=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(goog.dom.Appendable|undefined)} var_args Further DOM nodes or
 *     strings for text nodes.  If one of the var_args is an array, its children
 *     will be added as childNodes instead.
 * @return {R} Reference to a DOM node. The return type is {!Element} if tagName
 *     is a string or a more specific type if it is a member of
 *     goog.dom.TagName (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string|!goog.dom.TagName<T>} name Tag to create.
 * @return {R} The new element. The return type is {!Element} if name is
 *     a string or a more specific type if it is a member of goog.dom.TagName
 *     (e.g. {!HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.createElement = function(name) {
  'use strict';
  return goog.dom.createElement_(this.document_, name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function(content) {
  'use strict';
  return this.document_.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with
 *     `goog.string.Unicode.NBSP` characters.
 * @return {!HTMLElement} The created table.
 */
goog.dom.DomHelper.prototype.createTable = function(
    rows, columns, opt_fillWithNbsp) {
  'use strict';
  return goog.dom.createTable_(
      this.document_, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Converts an HTML into a node or a document fragment. A single Node is used if
 * `html` only generates a single node. If `html` generates multiple
 * nodes then these are put inside a `DocumentFragment`. This is a safe
 * version of `goog.dom.DomHelper#htmlToDocumentFragment` which is now
 * deleted.
 * @param {!goog.html.SafeHtml} html The HTML markup to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {
  'use strict';
  return goog.dom.safeHtmlToNode_(this.document_, html);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.DomHelper.prototype.isCss1CompatMode = function() {
  'use strict';
  return goog.dom.isCss1CompatMode_(this.document_);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function() {
  'use strict';
  return goog.dom.getWindow_(this.document_);
};


/**
 * Gets the document scroll element.
 * @return {!Element} Scrolling element.
 */
goog.dom.DomHelper.prototype.getDocumentScrollElement = function() {
  'use strict';
  return goog.dom.getDocumentScrollElement_(this.document_);
};


/**
 * Gets the document scroll distance as a coordinate object.
 * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
 */
goog.dom.DomHelper.prototype.getDocumentScroll = function() {
  'use strict';
  return goog.dom.getDocumentScroll_(this.document_);
};


/**
 * Determines the active element in the given document.
 * @param {Document=} opt_doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {
  'use strict';
  return goog.dom.getActiveElement(opt_doc || this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if `oldNode` has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Replaces child nodes of `target` with child nodes of `source`. This is
 * roughly equivalent to `target.innerHTML = source.innerHTML` which is not
 * compatible with Trusted Types.
 * @param {?Node} target Node to clean and replace its children.
 * @param {?Node} source Node to get the children from. The nodes will be cloned
 *     so they will stay in source.
 */
goog.dom.DomHelper.prototype.copyContents = goog.dom.copyContents;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array<!Element>|NodeList<!Element>)} An array or array-like list
 *     of just the element children of the given element.
 */
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of `node` that is an element.
 */
goog.dom.DomHelper.prototype.getFirstElementChild =
    goog.dom.getFirstElementChild;


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of `node` that is an element.
 */
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of `node` that is an element.
 */
goog.dom.DomHelper.prototype.getNextElementSibling =
    goog.dom.getNextElementSibling;


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of `node` that is
 *     an element.
 */
goog.dom.DomHelper.prototype.getPreviousElementSibling =
    goog.dom.getPreviousElementSibling;


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendant node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Cross browser function for getting the document element of an iframe.
 * @param {Element} iframe Iframe element.
 * @return {!Document} The frame content document.
 */
goog.dom.DomHelper.prototype.getFrameContentDocument =
    goog.dom.getFrameContentDocument;


/**
 * Cross browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.DomHelper.prototype.getFrameContentWindow =
    goog.dom.getFrameContentWindow;


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;


/**
 * Finds the first descendant node that matches the filter function. This does
 * a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;


/**
 * Finds all the descendant nodes that matches the filter function. This does a
 * depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Array<Node>} The found nodes or an empty array if none are found.
 */
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.DomHelper.prototype.setFocusableTabIndex =
    goog.dom.setFocusableTabIndex;


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {!Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of `node`'s text content.
 */
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by
 * `goog.dom.getNodeTextLength`.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;


/**
 * Returns true if the object is a `NodeList`.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName<T>|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {?R} The first ancestor that matches the passed criteria, or
 *     null if no match is found. The return type is {?Element} if opt_tag is
 *     not a member of goog.dom.TagName or a more specific type if it is (e.g.
 *     {?HTMLAnchorElement} for goog.dom.TagName.A).
 * @template T
 * @template R := cond(isUnknown(T), 'Element', T) =:
 */
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =
    goog.dom.getAncestorByTagNameAndClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} class The class name to match.
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;


/**
 * Gets '2d' context of a canvas. Shortcut for canvas.getContext('2d') with a
 * type information.
 * @param {!HTMLCanvasElement} canvas
 * @return {!CanvasRenderingContext2D}
 */
goog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;

//third_party/javascript/closure/async/nexttick.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides a function to schedule running a function as soon
 * as possible after the current JS execution stops and yields to the event
 * loop.
 */

goog.provide('goog.async.nextTick');

goog.require('goog.debug.entryPointRegistry');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.functions');
goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.engine');


/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) takes at least 4ms when called from
 * within another setTimeout(…, 0) for legacy reasons.
 *
 * This will not schedule the callback as a microtask (i.e. a task that can
 * preempt user input or networking callbacks). It is meant to emulate what
 * setTimeout(_, 0) would do if it were not throttled. If you desire microtask
 * behavior, use {@see goog.Promise} instead.
 *
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @param {boolean=} opt_useSetImmediate Avoid the IE workaround that
 *     ensures correctness at the cost of speed. See comments for details.
 * @template SCOPE
 */
goog.async.nextTick = function(callback, opt_context, opt_useSetImmediate) {
  'use strict';
  var cb = callback;
  if (opt_context) {
    cb = goog.bind(callback, opt_context);
  }
  cb = goog.async.nextTick.wrapCallback_(cb);
  // Note we do allow callers to also request setImmediate if they are willing
  // to accept the possible tradeoffs of incorrectness in exchange for speed.
  // The IE fallback of readystate change is much slower. See useSetImmediate_
  // for details.
  if (typeof goog.global.setImmediate === 'function' &&
      (opt_useSetImmediate || goog.async.nextTick.useSetImmediate_())) {
    goog.global.setImmediate(cb);
    return;
  }

  // Look for and cache the custom fallback version of setImmediate.
  if (!goog.async.nextTick.setImmediate_) {
    goog.async.nextTick.setImmediate_ =
        goog.async.nextTick.getSetImmediateEmulator_();
  }
  goog.async.nextTick.setImmediate_(cb);
};


/**
 * Returns whether should use setImmediate implementation currently on window.
 *
 * window.setImmediate was introduced and currently only supported by IE10+,
 * but due to a bug in the implementation it is not guaranteed that
 * setImmediate is faster than setTimeout nor that setImmediate N is before
 * setImmediate N+1. That is why we do not use the native version if
 * available. We do, however, call setImmediate if it is a non-native function
 * because that indicates that it has been replaced by goog.testing.MockClock
 * which we do want to support.
 * See
 * http://connect.microsoft.com/IE/feedback/details/801823/setimmediate-and-messagechannel-are-broken-in-ie10
 *
 * @return {boolean} Whether to use the implementation of setImmediate defined
 *     on Window.
 * @private
 * @suppress {missingProperties} For "Window.prototype.setImmediate"
 */
goog.async.nextTick.useSetImmediate_ = function() {
  'use strict';
  // Not a browser environment.
  if (!goog.global.Window || !goog.global.Window.prototype) {
    return true;
  }

  // MS Edge has window.setImmediate natively, but it's not on Window.prototype.
  // Also, there's no clean way to detect if the goog.global.setImmediate has
  // been replaced by mockClock as its replacement also shows up as "[native
  // code]" when using toString. Therefore, just always use
  // goog.global.setImmediate for Edge. It's unclear if it suffers the same
  // issues as IE10/11, but based on
  // https://dev.modern.ie/testdrive/demos/setimmediatesorting/
  // it seems they've been working to ensure it's WAI.
  if (goog.labs.userAgent.browser.isEdge() ||
      goog.global.Window.prototype.setImmediate != goog.global.setImmediate) {
    // Something redefined setImmediate in which case we decide to use it (This
    // is so that we use the mockClock setImmediate).
    return true;
  }

  return false;
};


/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
goog.async.nextTick.setImmediate_;


/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
goog.async.nextTick.getSetImmediateEmulator_ = function() {
  'use strict';
  // Create a private message channel and use it to postMessage empty messages
  // to ourselves.
  /** @type {!Function|undefined} */
  var Channel = goog.global['MessageChannel'];
  // If MessageChannel is not available and we are in a browser, implement
  // an iframe based polyfill in browsers that have postMessage and
  // document.addEventListener. The latter excludes IE8 because it has a
  // synchronous postMessage implementation.
  if (typeof Channel === 'undefined' && typeof window !== 'undefined' &&
      window.postMessage && window.addEventListener &&
      // Presto (The old pre-blink Opera engine) has problems with iframes
      // and contentWindow.
      !goog.labs.userAgent.engine.isPresto()) {
    /** @constructor */
    Channel = function() {
      'use strict';
      // Make an empty, invisible iframe.
      var iframe = goog.dom.createElement(goog.dom.TagName.IFRAME);
      iframe.style.display = 'none';
      document.documentElement.appendChild(iframe);
      var win = iframe.contentWindow;
      var doc = win.document;
      doc.open();
      doc.close();
      // Do not post anything sensitive over this channel, as the workaround for
      // pages with file: origin could allow that information to be modified or
      // intercepted.
      var message = 'callImmediate' + Math.random();
      // The same origin policy rejects attempts to postMessage from file: urls
      // unless the origin is '*'.
      var origin = win.location.protocol == 'file:' ?
          '*' :
          win.location.protocol + '//' + win.location.host;
      var onmessage = goog.bind(function(e) {
        'use strict';
        // Validate origin and message to make sure that this message was
        // intended for us. If the origin is set to '*' (see above) only the
        // message needs to match since, for example, '*' != 'file://'. Allowing
        // the wildcard is ok, as we are not concerned with security here.
        if ((origin != '*' && e.origin != origin) || e.data != message) {
          return;
        }
        this['port1'].onmessage();
      }, this);
      win.addEventListener('message', onmessage, false);
      this['port1'] = {};
      this['port2'] = {
        postMessage: function() {
          'use strict';
          win.postMessage(message, origin);
        }
      };
    };
  }
  if (typeof Channel !== 'undefined' && !goog.labs.userAgent.browser.isIE()) {
    // Exclude all of IE due to
    // http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/
    // which allows starving postMessage with a busy setTimeout loop.
    // This currently affects IE10 and IE11 which would otherwise be able
    // to use the postMessage based fallbacks.
    var channel = new Channel();
    // Use a fifo linked list to call callbacks in the right order.
    var head = {};
    var tail = head;
    channel['port1'].onmessage = function() {
      'use strict';
      if (head.next !== undefined) {
        head = head.next;
        var cb = head.cb;
        head.cb = null;
        cb();
      }
    };
    return function(cb) {
      'use strict';
      tail.next = {cb: cb};
      tail = tail.next;
      channel['port2'].postMessage(0);
    };
  }
  // Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
  // or more.
  // NOTE(step): This fallback is used for IE.
  return function(cb) {
    'use strict';
    goog.global.setTimeout(/** @type {function()} */ (cb), 0);
  };
};


/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
goog.async.nextTick.wrapCallback_ = goog.functions.identity;


// Register the callback function as an entry point, so that it can be
// monitored for exception handling, etc. This has to be done in this file
// since it requires special code to handle all browsers.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      'use strict';
      goog.async.nextTick.wrapCallback_ = transformer;
    });

//third_party/javascript/closure/async/throwexception.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides a function to throw an error without interrupting
 * the current execution context.
 */

goog.module('goog.async.throwException');
goog.module.declareLegacyNamespace();

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
function throwException(exception) {
  // Each throw needs to be in its own context.
  goog.global.setTimeout(() => {
    throw exception;
  }, 0);
}
exports = throwException;

;return exports;});

//third_party/javascript/closure/async/workqueue.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.module('goog.async.WorkQueue');
goog.module.declareLegacyNamespace();

const FreeList = goog.require('goog.async.FreeList');
const {assert} = goog.require('goog.asserts');

// TODO(johnlenz): generalize the WorkQueue if this is used by more
// than goog.async.run.


/**
 * A low GC workqueue. The key elements of this design:
 *   - avoids the need for goog.bind or equivalent by carrying scope
 *   - avoids the need for array reallocation by using a linked list
 *   - minimizes work entry objects allocation by recycling objects
 * @final
 * @struct
 */
class WorkQueue {
  constructor() {
    this.workHead_ = null;
    this.workTail_ = null;
  }

  /**
   * @param {function()} fn
   * @param {Object|null|undefined} scope
   */
  add(fn, scope) {
    const item = this.getUnusedItem_();
    item.set(fn, scope);

    if (this.workTail_) {
      this.workTail_.next = item;
      this.workTail_ = item;
    } else {
      assert(!this.workHead_);
      this.workHead_ = item;
      this.workTail_ = item;
    }
  }

  /**
   * @return {?WorkItem}
   */
  remove() {
    let item = null;

    if (this.workHead_) {
      item = this.workHead_;
      this.workHead_ = this.workHead_.next;
      if (!this.workHead_) {
        this.workTail_ = null;
      }
      item.next = null;
    }
    return item;
  }

  /**
   * @param {!WorkItem} item
   */
  returnUnused(item) {
    WorkQueue.freelist_.put(item);
  }

  /**
   * @return {!WorkItem}
   * @private
   */
  getUnusedItem_() {
    return WorkQueue.freelist_.get();
  }
}

/** @define {number} The maximum number of entries to keep for recycling. */
WorkQueue.DEFAULT_MAX_UNUSED =
    goog.define('goog.async.WorkQueue.DEFAULT_MAX_UNUSED', 100);

/** @const @private {!FreeList<!WorkItem>} */
WorkQueue.freelist_ = new FreeList(
    () => new WorkItem(), item => item.reset(), WorkQueue.DEFAULT_MAX_UNUSED);

/**
 * @final
 * @struct
 */
class WorkItem {
  constructor() {
    /** @type {?function()} */
    this.fn = null;
    /** @type {?Object|null|undefined} */
    this.scope = null;
    /** @type {?WorkItem} */
    this.next = null;
  }

  /**
   * @param {function()} fn
   * @param {Object|null|undefined} scope
   */
  set(fn, scope) {
    'use strict';
    this.fn = fn;
    this.scope = scope;
    this.next = null;
  }

  /** Reset the work item so they don't prevent GC before reuse */
  reset() {
    this.fn = null;
    this.scope = null;
    this.next = null;
  }
}

exports = WorkQueue;

;return exports;});

//third_party/javascript/closure/async/run.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.async.run');

goog.require('goog.async.WorkQueue');
goog.require('goog.async.nextTick');
goog.require('goog.async.throwException');

/**
 * @define {boolean} If true, use the global Promise to implement goog.async.run
 * assuming either the native, or polyfill version will be used. Does still
 * permit tests to use forceNextTick.
 */
goog.ASSUME_NATIVE_PROMISE = goog.define('goog.ASSUME_NATIVE_PROMISE', false);

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
goog.async.run = function(callback, opt_context) {
  'use strict';
  if (!goog.async.run.schedule_) {
    goog.async.run.initializeRunner_();
  }
  if (!goog.async.run.workQueueScheduled_) {
    // Nothing is currently scheduled, schedule it now.
    goog.async.run.schedule_();
    goog.async.run.workQueueScheduled_ = true;
  }

  goog.async.run.workQueue_.add(callback, opt_context);
};


/**
 * Initializes the function to use to process the work queue.
 * @private
 */
goog.async.run.initializeRunner_ = function() {
  'use strict';
  if (goog.ASSUME_NATIVE_PROMISE ||
      (goog.global.Promise && goog.global.Promise.resolve)) {
    // Use goog.global.Promise instead of just Promise because the relevant
    // externs may be missing, and don't alias it because this could confuse the
    // compiler into thinking the polyfill is required when it should be treated
    // as optional.
    var promise = goog.global.Promise.resolve(undefined);
    goog.async.run.schedule_ = function() {
      'use strict';
      promise.then(goog.async.run.processWorkQueue);
    };
  } else {
    goog.async.run.schedule_ = function() {
      'use strict';
      goog.async.nextTick(goog.async.run.processWorkQueue);
    };
  }
};


/**
 * Forces goog.async.run to use nextTick instead of Promise.
 *
 * This should only be done in unit tests. It's useful because MockClock
 * replaces nextTick, but not the browser Promise implementation, so it allows
 * Promise-based code to be tested with MockClock.
 *
 * However, we also want to run promises if the MockClock is no longer in
 * control so we schedule a backup "setTimeout" to the unmocked timeout if
 * provided.
 *
 * @param {function(function())=} opt_realSetTimeout
 */
goog.async.run.forceNextTick = function(opt_realSetTimeout) {
  'use strict';
  goog.async.run.schedule_ = function() {
    'use strict';
    goog.async.nextTick(goog.async.run.processWorkQueue);
    if (opt_realSetTimeout) {
      opt_realSetTimeout(goog.async.run.processWorkQueue);
    }
  };
};


/**
 * The function used to schedule work asynchronousely.
 * @private {function()}
 */
goog.async.run.schedule_;


/** @private {boolean} */
goog.async.run.workQueueScheduled_ = false;


/** @private {!goog.async.WorkQueue} */
goog.async.run.workQueue_ = new goog.async.WorkQueue();


if (goog.DEBUG) {
  /**
   * Reset the work queue. Only available for tests in debug mode.
   */
  goog.async.run.resetQueue = function() {
    'use strict';
    goog.async.run.workQueueScheduled_ = false;
    goog.async.run.workQueue_ = new goog.async.WorkQueue();
  };
}


/**
 * Run any pending goog.async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * goog.async.nextTick.
 */
goog.async.run.processWorkQueue = function() {
  'use strict';
  // NOTE: additional work queue items may be added while processing.
  var item = null;
  while (item = goog.async.run.workQueue_.remove()) {
    try {
      item.fn.call(item.scope);
    } catch (e) {
      goog.async.throwException(e);
    }
    goog.async.run.workQueue_.returnUnused(item);
  }

  // There are no more work items, allow processing to be scheduled again.
  goog.async.run.workQueueScheduled_ = false;
};

//third_party/javascript/closure/promise/resolver.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.promise.Resolver');

goog.requireType('goog.Promise');



/**
 * Resolver interface for promises. The resolver is a convenience interface that
 * bundles the promise and its associated resolve and reject functions together,
 * for cases where the resolver needs to be persisted internally.
 *
 * @interface
 * @template TYPE
 */
goog.promise.Resolver = function() {};


/**
 * The promise that created this resolver.
 * @type {!goog.Promise<TYPE>}
 */
goog.promise.Resolver.prototype.promise;


/**
 * Resolves this resolver with the specified value.
 * @type {function((TYPE|goog.Promise<TYPE>|Thenable)=)}
 */
goog.promise.Resolver.prototype.resolve;


/**
 * Rejects this resolver with the specified reason.
 * @type {function(*=): void}
 */
goog.promise.Resolver.prototype.reject;

//third_party/javascript/closure/promise/thenable.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.Thenable');

/** @suppress {extraRequire} used in complex type */
goog.requireType('goog.Promise');  // for the type reference.



/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see goog.Promise}.
 *
 * @interface
 * @extends {IThenable<TYPE>}
 * @template TYPE
 */
goog.Thenable = function() {};


/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the `onFulfilled` callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the `onRejected` callback will be invoked with
 * the rejection reason as argument. Similar to the fulfilled case, the child
 * Promise will then be resolved with the return value of the callback, or
 * rejected with the thrown value if the callback throws an exception.
 *
 * @param {?(function(this:THIS, TYPE): VALUE)=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fulfilled.
 * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will
 *     be invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 *
 * @return {RESULT} A new Promise that will receive the result
 *     of the fulfillment or rejection callback.
 * @template VALUE
 * @template THIS
 *
 * When a Promise (or thenable) is returned from the fulfilled callback,
 * the result is the payload of that promise, not the promise itself.
 *
 * @template RESULT := type('goog.Promise',
 *     cond(isUnknown(VALUE), unknown(),
 *       mapunion(VALUE, (V) =>
 *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),
 *           templateTypeOf(V, 0),
 *           cond(sub(V, 'Thenable'),
 *              unknown(),
 *              V)))))
 *  =:
 *
 */
goog.Thenable.prototype.then = function(
    opt_onFulfilled, opt_onRejected, opt_context) {};


/**
 * An expando property to indicate that an object implements
 * `goog.Thenable`.
 *
 * {@see addImplementation}.
 *
 * @const
 */
goog.Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';


/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see goog.Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:goog.Thenable,...?)} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
goog.Thenable.addImplementation = function(ctor) {
  'use strict';
  if (COMPILED) {
    ctor.prototype[goog.Thenable.IMPLEMENTED_BY_PROP] = true;
  } else {
    // Avoids dictionary access in uncompiled mode.
    ctor.prototype.$goog_Thenable = true;
  }
};


/**
 * @param {?} object
 * @return {boolean} Whether a given instance implements `goog.Thenable`.
 *     The class/superclass of the instance must call `addImplementation`.
 */
goog.Thenable.isImplementedBy = function(object) {
  'use strict';
  if (!object) {
    return false;
  }
  try {
    if (COMPILED) {
      return !!object[goog.Thenable.IMPLEMENTED_BY_PROP];
    }
    return !!object.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

//third_party/javascript/closure/promise/promise.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.Promise');

goog.require('goog.Thenable');
goog.require('goog.asserts');
goog.require('goog.async.FreeList');
goog.require('goog.async.run');
goog.require('goog.async.throwException');
goog.require('goog.debug.Error');
goog.require('goog.promise.Resolver');



/**
 * NOTE: This class was created in anticipation of the built-in Promise type
 * being standardized and implemented across browsers. Now that Promise is
 * available in modern browsers, and is automatically polyfilled by the Closure
 * Compiler, by default, most new code should use native `Promise`
 * instead of `goog.Promise`. However, `goog.Promise` has the
 * concept of cancellation which native Promises do not yet have. So code
 * needing cancellation may still want to use `goog.Promise`.
 *
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled with a fulfillment value, rejected with a
 * rejection reason, or blocked by another Promise. A Promise is said to be
 * settled if it is either fulfilled or rejected. Once settled, the Promise
 * result is immutable.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling `then` and registering
 * `onFulfilled` and `onRejected` callbacks. Once the Promise
 * is settled, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional `then` calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering `then` invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is settled, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable<TYPE>|Thenable)=),
 *             function(*=)): void} resolver
 *     Initialization function that is invoked immediately with `resolve`
 *     and `reject` functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {goog.Thenable<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
goog.Promise = function(resolver, opt_context) {
  'use strict';
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {goog.Promise.State_}
   */
  this.state_ = goog.Promise.State_.PENDING;

  /**
   * The settled result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling `then()`, the originating parent.
   * @private {?goog.Promise}
   */
  this.parent_ = null;

  /**
   * The linked list of `onFulfilled` and `onRejected` callbacks
   * added to this Promise by calls to `then()`.
   * @private {?goog.Promise.CallbackEntry_}
   */
  this.callbackEntries_ = null;

  /**
   * The tail of the linked list of `onFulfilled` and `onRejected`
   * callbacks added to this Promise by calls to `then()`.
   * @private {?goog.Promise.CallbackEntry_}
   */
  this.callbackEntriesTail_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the `UNHANDLED_REJECTION_DELAY` is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an `onRejected` callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    /**
     * When the `UNHANDLED_REJECTION_DELAY` is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * `onRejected` callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  if (goog.Promise.LONG_STACK_TRACES) {
    /**
     * A list of stack trace frames pointing to the locations where this Promise
     * was created or had callbacks added to it. Saved to add additional context
     * to stack traces when an exception is thrown.
     * @private {!Array<string>}
     */
    this.stack_ = [];
    this.addStackTrace_(new Error('created'));

    /**
     * Index of the most recently executed stack frame entry.
     * @private {number}
     */
    this.currentStep_ = 0;
  }

  // As an optimization, we can skip this if resolver is goog.nullFunction.
  // This value is passed internally when creating a promise which will be
  // resolved through a more optimized path.
  if (resolver != goog.nullFunction) {
    try {
      var self = this;
      resolver.call(
          opt_context,
          function(value) {
            'use strict';
            self.resolve_(goog.Promise.State_.FULFILLED, value);
          },
          function(reason) {
            'use strict';
            if (goog.DEBUG &&
                !(reason instanceof goog.Promise.CancellationError)) {
              try {
                // Promise was rejected. Step up one call frame to see why.
                if (reason instanceof Error) {
                  throw reason;
                } else {
                  throw new Error('Promise rejected.');
                }
              } catch (e) {
                // Only thrown so browser dev tools can catch rejections of
                // promises when the option to break on caught exceptions is
                // activated.
              }
            }
            self.resolve_(goog.Promise.State_.REJECTED, reason);
          });
    } catch (e) {
      this.resolve_(goog.Promise.State_.REJECTED, e);
    }
  }
};


/**
 * @define {boolean} Whether traces of `then` calls should be included in
 * exceptions thrown
 */
goog.Promise.LONG_STACK_TRACES =
    goog.define('goog.Promise.LONG_STACK_TRACES', false);


/**
 * @define {number} The delay in milliseconds before a rejected Promise's reason
 * is passed to the rejection handler. By default, the rejection handler
 * rethrows the rejection reason so that it appears in the developer console or
 * `window.onerror` handler.
 *
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 */
goog.Promise.UNHANDLED_REJECTION_DELAY =
    goog.define('goog.Promise.UNHANDLED_REJECTION_DELAY', 0);


/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
goog.Promise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};



/**
 * Entries in the callback chain. Each call to `then`,
 * `thenCatch`, or `thenAlways` creates an entry containing the
 * functions that may be invoked once the Promise is settled.
 *
 * @private @final @struct @constructor
 */
goog.Promise.CallbackEntry_ = function() {
  'use strict';
  /** @type {?goog.Promise} */
  this.child = null;
  /** @type {?Function} */
  this.onFulfilled = null;
  /** @type {?Function} */
  this.onRejected = null;
  /** @type {?} */
  this.context = null;
  /** @type {?goog.Promise.CallbackEntry_} */
  this.next = null;

  /**
   * A boolean value to indicate this is a "thenAlways" callback entry.
   * Unlike a normal "then/thenVoid" a "thenAlways doesn't participate
   * in "cancel" considerations but is simply an observer and requires
   * special handling.
   * @type {boolean}
   */
  this.always = false;
};


/** clear the object prior to reuse */
goog.Promise.CallbackEntry_.prototype.reset = function() {
  'use strict';
  this.child = null;
  this.onFulfilled = null;
  this.onRejected = null;
  this.context = null;
  this.always = false;
};


/**
 * @define {number} The number of currently unused objects to keep around for
 *    reuse.
 */
goog.Promise.DEFAULT_MAX_UNUSED =
    goog.define('goog.Promise.DEFAULT_MAX_UNUSED', 100);


/** @const @private {goog.async.FreeList<!goog.Promise.CallbackEntry_>} */
goog.Promise.freelist_ = new goog.async.FreeList(
    function() {
      'use strict';
      return new goog.Promise.CallbackEntry_();
    },
    function(item) {
      'use strict';
      item.reset();
    },
    goog.Promise.DEFAULT_MAX_UNUSED);


/**
 * @param {Function} onFulfilled
 * @param {Function} onRejected
 * @param {?} context
 * @return {!goog.Promise.CallbackEntry_}
 * @private
 */
goog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {
  'use strict';
  var entry = goog.Promise.freelist_.get();
  entry.onFulfilled = onFulfilled;
  entry.onRejected = onRejected;
  entry.context = context;
  return entry;
};


/**
 * @param {!goog.Promise.CallbackEntry_} entry
 * @private
 */
goog.Promise.returnEntry_ = function(entry) {
  'use strict';
  goog.Promise.freelist_.put(entry);
};


// NOTE: this is the same template expression as is used for
// goog.IThenable.prototype.then


/**
 * @param {VALUE=} opt_value
 * @return {RESULT} A new Promise that is immediately resolved
 *     with the given value. If the input value is already a goog.Promise, it
 *     will be returned immediately without creating a new instance.
 * @template VALUE
 * @template RESULT := type('goog.Promise',
 *     cond(isUnknown(VALUE), unknown(),
 *       mapunion(VALUE, (V) =>
 *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),
 *           templateTypeOf(V, 0),
 *           cond(sub(V, 'Thenable'),
 *              unknown(),
 *              V)))))
 * =:
 */
goog.Promise.resolve = function(opt_value) {
  'use strict';
  if (opt_value instanceof goog.Promise) {
    // Avoid creating a new object if we already have a promise object
    // of the correct type.
    return opt_value;
  }

  // Passing goog.nullFunction will cause the constructor to take an optimized
  // path that skips calling the resolver function.
  var promise = new goog.Promise(goog.nullFunction);
  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);
  return promise;
};


/**
 * @param {*=} opt_reason
 * @return {!goog.Promise} A new Promise that is immediately rejected with the
 *     given reason.
 */
goog.Promise.reject = function(opt_reason) {
  'use strict';
  return new goog.Promise(function(resolve, reject) {
    'use strict';
    reject(opt_reason);
  });
};


/**
 * This is identical to
 * {@code goog.Promise.resolve(value).then(onFulfilled, onRejected)}, but it
 * avoids creating an unnecessary wrapper Promise when `value` is already
 * thenable.
 *
 * @param {?(goog.Thenable<TYPE>|Thenable|TYPE)} value
 * @param {function(TYPE): ?} onFulfilled
 * @param {function(*): *} onRejected
 * @template TYPE
 * @private
 */
goog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {
  'use strict';
  var isThenable =
      goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);
  if (!isThenable) {
    goog.async.run(goog.partial(onFulfilled, value));
  }
};


/**
 * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}
 *     promises
 * @return {!goog.Promise<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to settle immediately after it
 *     settles.
 * @template TYPE
 */
goog.Promise.race = function(promises) {
  'use strict';
  return new goog.Promise(function(resolve, reject) {
    'use strict';
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      goog.Promise.resolveThen_(promise, resolve, reject);
    }
  });
};


/**
 * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}
 *     promises
 * @return {!goog.Promise<!Array<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected with the first rejection reason
 *     immediately after it is rejected.
 * @template TYPE
 */
goog.Promise.all = function(promises) {
  'use strict';
  return new goog.Promise(function(resolve, reject) {
    'use strict';
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function(index, value) {
      'use strict';
      toFulfill--;
      values[index] = value;
      if (toFulfill == 0) {
        resolve(values);
      }
    };

    var onReject = function(reason) {
      'use strict';
      reject(reason);
    };

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);
    }
  });
};


/**
 * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}
 *     promises
 * @return {!goog.Promise<!Array<{
 *     fulfilled: boolean,
 *     value: (TYPE|undefined),
 *     reason: (*|undefined)}>>} A Promise that resolves with a list of
 *         result objects once all input Promises (or Promise-like) have
 *         settled. Each result object contains a 'fulfilled' boolean indicating
 *         whether an input Promise was fulfilled or rejected. For fulfilled
 *         Promises, the resulting value is stored in the 'value' field. For
 *         rejected Promises, the rejection reason is stored in the 'reason'
 *         field.
 * @template TYPE
 */
goog.Promise.allSettled = function(promises) {
  'use strict';
  return new goog.Promise(function(resolve, reject) {
    'use strict';
    var toSettle = promises.length;
    var results = [];

    if (!toSettle) {
      resolve(results);
      return;
    }

    var onSettled = function(index, fulfilled, result) {
      'use strict';
      toSettle--;
      results[index] = fulfilled ? {fulfilled: true, value: result} :
                                   {fulfilled: false, reason: result};
      if (toSettle == 0) {
        resolve(results);
      }
    };

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      goog.Promise.resolveThen_(
          promise, goog.partial(onSettled, i, true /* fulfilled */),
          goog.partial(onSettled, i, false /* fulfilled */));
    }
  });
};


/**
 * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}
 *     promises
 * @return {!goog.Promise<TYPE>} A Promise that receives the value of the first
 *     input to be fulfilled, or is rejected with a list of every rejection
 *     reason if all inputs are rejected.
 * @template TYPE
 */
goog.Promise.firstFulfilled = function(promises) {
  'use strict';
  return new goog.Promise(function(resolve, reject) {
    'use strict';
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function(value) {
      'use strict';
      resolve(value);
    };

    var onReject = function(index, reason) {
      'use strict';
      toReject--;
      reasons[index] = reason;
      if (toReject == 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));
    }
  });
};


/**
 * @return {!goog.promise.Resolver<TYPE>} Resolver wrapping the promise and its
 *     resolve / reject functions. Resolving or rejecting the resolver
 *     resolves or rejects the promise.
 * @template TYPE
 * @see {@link goog.promise.NativeResolver} for native Promises
 */
goog.Promise.withResolver = function() {
  'use strict';
  var resolve, reject;
  var promise = new goog.Promise(function(rs, rj) {
    'use strict';
    resolve = rs;
    reject = rj;
  });
  return new goog.Promise.Resolver_(promise, resolve, reject);
};


/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the `onFulfilled` callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the `onRejected` callback will be invoked
 * with the rejection reason as argument, and the child Promise will be resolved
 * with the return value or rejected with the thrown value of the callback.
 *
 * @param {?(function(this:THIS, TYPE): VALUE)=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fulfilled.
 * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will
 *     be invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 *
 * @return {RESULT} A new Promise that will receive the result
 *     of the fulfillment or rejection callback.
 * @template VALUE
 * @template THIS
 *
 * When a Promise (or thenable) is returned from the fulfilled callback,
 * the result is the payload of that promise, not the promise itself.
 *
 * @template RESULT := type('goog.Promise',
 *     cond(isUnknown(VALUE), unknown(),
 *       mapunion(VALUE, (V) =>
 *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),
 *           templateTypeOf(V, 0),
 *           cond(sub(V, 'Thenable'),
 *              unknown(),
 *              V)))))
 *  =:
 * @override
 */
goog.Promise.prototype.then = function(
    opt_onFulfilled, opt_onRejected, opt_context) {
  'use strict';
  if (opt_onFulfilled != null) {
    goog.asserts.assertFunction(
        opt_onFulfilled, 'opt_onFulfilled should be a function.');
  }
  if (opt_onRejected != null) {
    goog.asserts.assertFunction(
        opt_onRejected,
        'opt_onRejected should be a function. Did you pass opt_context ' +
            'as the second argument instead of the third?');
  }

  if (goog.Promise.LONG_STACK_TRACES) {
    this.addStackTrace_(new Error('then'));
  }

  return this.addChildPromise_(
      typeof opt_onFulfilled === 'function' ? opt_onFulfilled : null,
      typeof opt_onRejected === 'function' ? opt_onRejected : null,
      opt_context);
};
goog.Thenable.addImplementation(goog.Promise);


/**
 * Adds callbacks that will operate on the result of the Promise without
 * returning a child Promise (unlike "then").
 *
 * If the Promise is fulfilled, the `onFulfilled` callback will be invoked
 * with the fulfillment value as argument.
 *
 * If the Promise is rejected, the `onRejected` callback will be invoked
 * with the rejection reason as argument.
 *
 * @param {?(function(this:THIS, TYPE):?)=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fulfilled.
 * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will
 *     be invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @package
 * @template THIS
 */
goog.Promise.prototype.thenVoid = function(
    opt_onFulfilled, opt_onRejected, opt_context) {
  'use strict';
  if (opt_onFulfilled != null) {
    goog.asserts.assertFunction(
        opt_onFulfilled, 'opt_onFulfilled should be a function.');
  }
  if (opt_onRejected != null) {
    goog.asserts.assertFunction(
        opt_onRejected,
        'opt_onRejected should be a function. Did you pass opt_context ' +
            'as the second argument instead of the third?');
  }

  if (goog.Promise.LONG_STACK_TRACES) {
    this.addStackTrace_(new Error('then'));
  }

  // Note: no default rejection handler is provided here as we need to
  // distinguish unhandled rejections.
  this.addCallbackEntry_(
      goog.Promise.getCallbackEntry_(
          opt_onFulfilled || goog.nullFunction, opt_onRejected || null,
          opt_context));
};


/**
 * Adds a callback that will be invoked when the Promise is settled (fulfilled
 * or rejected). The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with `thenAlways` will be
 * executed in the same order with other calls to `then`,
 * `thenAlways`, or `thenCatch`.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with `thenAlways`. A Promise that has
 * a cleanup handler added with `thenAlways` will be canceled if all of
 * its children created by `then` (or `thenCatch`) are canceled.
 * Additionally, since any rejections are not passed to the callback, it does
 * not stop the unhandled rejection handler from running.
 *
 * @param {function(this:THIS): void} onSettled A function that will be invoked
 *     when the Promise is settled (fulfilled or rejected).
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!goog.Promise<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
goog.Promise.prototype.thenAlways = function(onSettled, opt_context) {
  'use strict';
  if (goog.Promise.LONG_STACK_TRACES) {
    this.addStackTrace_(new Error('thenAlways'));
  }

  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);
  entry.always = true;
  this.addCallbackEntry_(entry);
  return this;
};


/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to `then(null, onRejected)`.
 *
 * @param {function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if this Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!goog.Promise} A new Promise that will resolve either to the
 *     value of this promise, or if this promise is rejected, the result of
 *     `onRejected`. The returned Promise will reject if `onRejected` throws.
 * @template THIS
 */
goog.Promise.prototype.thenCatch = function(onRejected, opt_context) {
  'use strict';
  if (goog.Promise.LONG_STACK_TRACES) {
    this.addStackTrace_(new Error('thenCatch'));
  }
  return this.addChildPromise_(null, onRejected, opt_context);
};


/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
goog.Promise.prototype.cancel = function(opt_message) {
  'use strict';
  if (this.state_ == goog.Promise.State_.PENDING) {
    // Instantiate Error object synchronously. This ensures Error::stack points
    // to the cancel() callsite.
    var err = new goog.Promise.CancellationError(opt_message);
    goog.async.run(function() {
      'use strict';
      this.cancelInternal_(err);
    }, this);
  }
};


/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
goog.Promise.prototype.cancelInternal_ = function(err) {
  'use strict';
  if (this.state_ == goog.Promise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
      this.parent_ = null;
    } else {
      this.resolve_(goog.Promise.State_.REJECTED, err);
    }
  }
};


/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!goog.Promise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
goog.Promise.prototype.cancelChild_ = function(childPromise, err) {
  'use strict';
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childEntry = null;
  var beforeChildEntry = null;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var entry = this.callbackEntries_; entry; entry = entry.next) {
    if (!entry.always) {
      childCount++;
      if (entry.child == childPromise) {
        childEntry = entry;
      }
      if (childEntry && childCount > 1) {
        break;
      }
    }
    if (!childEntry) {
      beforeChildEntry = entry;
    }
  }

  // Can a child entry be missing?

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childEntry) {
    if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) {
      this.cancelInternal_(err);
    } else {
      if (beforeChildEntry) {
        this.removeEntryAfter_(beforeChildEntry);
      } else {
        this.popEntry_();
      }

      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);
    }
  }
};


/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been settled.
 *
 * @param {goog.Promise.CallbackEntry_} callbackEntry Record containing
 *     `onFulfilled` and `onRejected` callbacks to execute after
 *     the Promise is settled.
 * @private
 */
goog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {
  'use strict';
  if (!this.hasEntry_() &&
      (this.state_ == goog.Promise.State_.FULFILLED ||
       this.state_ == goog.Promise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  this.queueEntry_(callbackEntry);
};


/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the `onFulfilled` or `onRejected` callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|goog.Promise<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fulfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!goog.Promise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
goog.Promise.prototype.addChildPromise_ = function(
    onFulfilled, onRejected, opt_context) {
  'use strict';
  /** @type {goog.Promise.CallbackEntry_} */
  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);

  callbackEntry.child = new goog.Promise(function(resolve, reject) {
    'use strict';
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function(value) {
      'use strict';
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function(reason) {
      'use strict';
      try {
        var result = onRejected.call(opt_context, reason);
        if (result === undefined &&
            reason instanceof goog.Promise.CancellationError) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(callbackEntry);
  return callbackEntry.child;
};


/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
goog.Promise.prototype.unblockAndFulfill_ = function(value) {
  'use strict';
  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);
  this.state_ = goog.Promise.State_.PENDING;
  this.resolve_(goog.Promise.State_.FULFILLED, value);
};


/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
goog.Promise.prototype.unblockAndReject_ = function(reason) {
  'use strict';
  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);
  this.state_ = goog.Promise.State_.PENDING;
  this.resolve_(goog.Promise.State_.REJECTED, reason);
};


/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be settled with the same state and result as the Thenable once it is itself
 * settled.
 *
 * If the given result is not a Thenable, the Promise will be settled (fulfilled
 * or rejected) with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {goog.Promise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
goog.Promise.prototype.resolve_ = function(state, x) {
  'use strict';
  if (this.state_ != goog.Promise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = goog.Promise.State_.REJECTED;
    x = new TypeError('Promise cannot resolve to itself');
  }

  this.state_ = goog.Promise.State_.BLOCKED;
  var isThenable = goog.Promise.maybeThen_(
      x, this.unblockAndFulfill_, this.unblockAndReject_, this);
  if (isThenable) {
    return;
  }

  this.result_ = x;
  this.state_ = state;
  // Since we can no longer be canceled, remove link to parent, so that the
  // child promise does not keep the parent promise alive.
  this.parent_ = null;
  this.scheduleCallbacks_();

  if (state == goog.Promise.State_.REJECTED &&
      !(x instanceof goog.Promise.CancellationError)) {
    goog.Promise.addUnhandledRejection_(this, x);
  }
};


/**
 * Invokes the "then" method of an input value if that value is a Thenable. This
 * is a no-op if the value is not thenable.
 *
 * @param {?} value A potentially thenable value.
 * @param {!Function} onFulfilled
 * @param {!Function} onRejected
 * @param {?} context
 * @return {boolean} Whether the input value was thenable.
 * @private
 */
goog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {
  'use strict';
  if (value instanceof goog.Promise) {
    value.thenVoid(onFulfilled, onRejected, context);
    return true;
  } else if (goog.Thenable.isImplementedBy(value)) {
    value = /** @type {!goog.Thenable} */ (value);
    value.then(onFulfilled, onRejected, context);
    return true;
  } else if (goog.isObject(value)) {
    const thenable = /** @type {!Thenable} */ (value);
    try {
      var then = thenable.then;
      if (typeof then === 'function') {
        goog.Promise.tryThen_(thenable, then, onFulfilled, onRejected, context);
        return true;
      }
    } catch (e) {
      onRejected.call(context, e);
      return true;
    }
  }

  return false;
};


/**
 * Attempts to call the `then` method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the `then` method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a `then` method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The `then` method of the Thenable object.
 * @param {!Function} onFulfilled
 * @param {!Function} onRejected
 * @param {*} context
 * @private
 */
goog.Promise.tryThen_ = function(
    thenable, then, onFulfilled, onRejected, context) {
  'use strict';
  var called = false;
  var resolve = function(value) {
    'use strict';
    if (!called) {
      called = true;
      onFulfilled.call(context, value);
    }
  };

  var reject = function(reason) {
    'use strict';
    if (!called) {
      called = true;
      onRejected.call(context, reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};


/**
 * Executes the pending callbacks of a settled Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If `startExecution_` is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
goog.Promise.prototype.scheduleCallbacks_ = function() {
  'use strict';
  if (!this.executing_) {
    this.executing_ = true;
    goog.async.run(this.executeCallbacks_, this);
  }
};


/**
 * @return {boolean} Whether there are any pending callbacks queued.
 * @private
 */
goog.Promise.prototype.hasEntry_ = function() {
  'use strict';
  return !!this.callbackEntries_;
};


/**
 * @param {goog.Promise.CallbackEntry_} entry
 * @private
 */
goog.Promise.prototype.queueEntry_ = function(entry) {
  'use strict';
  goog.asserts.assert(entry.onFulfilled != null);

  if (this.callbackEntriesTail_) {
    this.callbackEntriesTail_.next = entry;
    this.callbackEntriesTail_ = entry;
  } else {
    // It the work queue was empty set the head too.
    this.callbackEntries_ = entry;
    this.callbackEntriesTail_ = entry;
  }
};


/**
 * @return {goog.Promise.CallbackEntry_} entry
 * @private
 */
goog.Promise.prototype.popEntry_ = function() {
  'use strict';
  var entry = null;
  if (this.callbackEntries_) {
    entry = this.callbackEntries_;
    this.callbackEntries_ = entry.next;
    entry.next = null;
  }
  // It the work queue is empty clear the tail too.
  if (!this.callbackEntries_) {
    this.callbackEntriesTail_ = null;
  }

  if (entry != null) {
    goog.asserts.assert(entry.onFulfilled != null);
  }
  return entry;
};


/**
 * @param {goog.Promise.CallbackEntry_} previous
 * @private
 */
goog.Promise.prototype.removeEntryAfter_ = function(previous) {
  'use strict';
  goog.asserts.assert(this.callbackEntries_);
  goog.asserts.assert(previous != null);
  // If the last entry is being removed, update the tail
  if (previous.next == this.callbackEntriesTail_) {
    this.callbackEntriesTail_ = previous;
  }

  previous.next = previous.next.next;
};


/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
goog.Promise.prototype.executeCallbacks_ = function() {
  'use strict';
  var entry = null;
  while (entry = this.popEntry_()) {
    if (goog.Promise.LONG_STACK_TRACES) {
      this.currentStep_++;
    }
    this.executeCallback_(entry, this.state_, this.result_);
  }
  this.executing_ = false;
};


/**
 * Executes a pending callback for this Promise. Invokes an `onFulfilled`
 * or `onRejected` callback based on the settled state of the Promise.
 *
 * @param {!goog.Promise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {goog.Promise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The settled result of the Promise.
 * @private
 */
goog.Promise.prototype.executeCallback_ = function(
    callbackEntry, state, result) {
  'use strict';
  // Cancel an unhandled rejection if the then/thenVoid call had an onRejected.
  if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected &&
      !callbackEntry.always) {
    this.removeUnhandledRejection_();
  }

  if (callbackEntry.child) {
    // When the parent is settled, the child no longer needs to hold on to it,
    // as the parent can no longer be canceled.
    callbackEntry.child.parent_ = null;
    goog.Promise.invokeCallback_(callbackEntry, state, result);
  } else {
    // Callbacks created with thenAlways or thenVoid do not have the rejection
    // handling code normally set up in the child Promise.
    try {
      callbackEntry.always ?
          callbackEntry.onFulfilled.call(callbackEntry.context) :
          goog.Promise.invokeCallback_(callbackEntry, state, result);
    } catch (err) {
      goog.Promise.handleRejection_.call(null, err);
    }
  }
  goog.Promise.returnEntry_(callbackEntry);
};


/**
 * Executes the onFulfilled or onRejected callback for a callbackEntry.
 *
 * @param {!goog.Promise.CallbackEntry_} callbackEntry
 * @param {goog.Promise.State_} state
 * @param {*} result
 * @private
 */
goog.Promise.invokeCallback_ = function(callbackEntry, state, result) {
  'use strict';
  if (state == goog.Promise.State_.FULFILLED) {
    callbackEntry.onFulfilled.call(callbackEntry.context, result);
  } else if (callbackEntry.onRejected) {
    callbackEntry.onRejected.call(callbackEntry.context, result);
  }
};


/**
 * Records a stack trace entry for functions that call `then` or the
 * Promise constructor. May be disabled by unsetting `LONG_STACK_TRACES`.
 *
 * @param {!Error} err An Error object created by the calling function for
 *     providing a stack trace.
 * @private
 */
goog.Promise.prototype.addStackTrace_ = function(err) {
  'use strict';
  if (goog.Promise.LONG_STACK_TRACES && typeof err.stack === 'string') {
    // Extract the third line of the stack trace, which is the entry for the
    // user function that called into Promise code.
    var trace = err.stack.split('\n', 4)[3];
    var message = err.message;

    // Pad the message to align the traces.
    message += Array(11 - message.length).join(' ');
    this.stack_.push(message + trace);
  }
};


/**
 * Adds extra stack trace information to an exception for the list of
 * asynchronous `then` calls that have been run for this Promise. Stack
 * trace information is recorded in {@see #addStackTrace_}, and appended to
 * rethrown errors when `LONG_STACK_TRACES` is enabled.
 *
 * @param {?} err An unhandled exception captured during callback execution.
 * @private
 */
goog.Promise.prototype.appendLongStack_ = function(err) {
  'use strict';
  if (goog.Promise.LONG_STACK_TRACES && err && typeof err.stack === 'string' &&
      this.stack_.length) {
    var longTrace = ['Promise trace:'];

    for (var promise = this; promise; promise = promise.parent_) {
      for (var i = this.currentStep_; i >= 0; i--) {
        longTrace.push(promise.stack_[i]);
      }
      longTrace.push(
          'Value: ' +
          '[' + (promise.state_ == goog.Promise.State_.REJECTED ? 'REJECTED' :
                                                                  'FULFILLED') +
          '] ' +
          '<' + String(promise.result_) + '>');
    }
    err.stack += '\n\n' + longTrace.join('\n');
  }
};


/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
goog.Promise.prototype.removeUnhandledRejection_ = function() {
  'use strict';
  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      goog.global.clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};


/**
 * Marks this rejected Promise as unhandled. If no `onRejected` callback
 * is called for this Promise before the `UNHANDLED_REJECTION_DELAY`
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!goog.Promise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
goog.Promise.addUnhandledRejection_ = function(promise, reason) {
  'use strict';
  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {
      'use strict';
      promise.appendLongStack_(reason);
      goog.Promise.handleRejection_.call(null, reason);
    }, goog.Promise.UNHANDLED_REJECTION_DELAY);

  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {
    promise.hadUnhandledRejection_ = true;
    goog.async.run(function() {
      'use strict';
      if (promise.hadUnhandledRejection_) {
        promise.appendLongStack_(reason);
        goog.Promise.handleRejection_.call(null, reason);
      }
    });
  }
};


/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no `onRejected` callbacks registered yet.
 * @type {function(*)}
 * @private
 */
goog.Promise.handleRejection_ = goog.async.throwException;


/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * `onRejected` callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a `window.onerror` handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to `goog.async.throwException`.
 */
goog.Promise.setUnhandledRejectionHandler = function(handler) {
  'use strict';
  goog.Promise.handleRejection_ = handler;
};



/**
 * Error used as a rejection reason for canceled Promises.  This will still be
 * a rejection, but should generally be ignored by other error handlers (because
 * cancellation should not be a reportable error).
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.Promise.CancellationError = function(opt_message) {
  'use strict';
  goog.Promise.CancellationError.base(this, 'constructor', opt_message);
  this.reportErrorToServer = false;
};
goog.inherits(goog.Promise.CancellationError, goog.debug.Error);


/** @override */
goog.Promise.CancellationError.prototype.name = 'cancel';



/**
 * Internal implementation of the resolver interface.
 *
 * @param {!goog.Promise<TYPE>} promise
 * @param {function((TYPE|goog.Promise<TYPE>|Thenable)=)} resolve
 * @param {function(*=): void} reject
 * @implements {goog.promise.Resolver<TYPE>}
 * @final @struct
 * @constructor
 * @private
 * @template TYPE
 */
goog.Promise.Resolver_ = function(promise, resolve, reject) {
  'use strict';
  /** @const */
  this.promise = promise;

  /** @const */
  this.resolve = resolve;

  /** @const */
  this.reject = reject;
};

//third_party/javascript/closure/mochikit/async/deferred.js
/**
 * @license
 * Copyright 2005, 2007 Bob Ippolito. All Rights Reserved.
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: MIT
 */

// Portions of this code are from MochiKit, received by The Closure
// Library Authors under the MIT license. All other code is Copyright
// The Closure Library Authors.

/**
 * @fileoverview Classes for tracking asynchronous operations and handling the
 * results. The Deferred object here is patterned after the Deferred object in
 * the Twisted python networking framework.
 *
 * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html
 *
 * Based on the Dojo code which in turn is based on the MochiKit code.
 *
 * @author abefettig@google.com (Abe Fettig)
 * @author arv@google.com (Erik Arvidsson)
 * @author brenneman@google.com (Shawn Brenneman)
 */

goog.provide('goog.async.Deferred');
goog.provide('goog.async.Deferred.AlreadyCalledError');
goog.provide('goog.async.Deferred.CanceledError');

goog.require('goog.Promise');
goog.require('goog.Thenable');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.Error');



/**
 * A Deferred represents the result of an asynchronous operation. A Deferred
 * instance has no result when it is created, and is "fired" (given an initial
 * result) by calling `callback` or `errback`.
 *
 * Once fired, the result is passed through a sequence of callback functions
 * registered with `addCallback` or `addErrback`. The functions may
 * mutate the result before it is passed to the next function in the sequence.
 *
 * Callbacks and errbacks may be added at any time, including after the Deferred
 * has been "fired". If there are no pending actions in the execution sequence
 * of a fired Deferred, any new callback functions will be called with the last
 * computed result. Adding a callback function is the only way to access the
 * result of the Deferred.
 *
 * If a Deferred operation is canceled, an optional user-provided cancellation
 * function is invoked which may perform any special cleanup, followed by firing
 * the Deferred's errback sequence with a `CanceledError`. If the
 * Deferred has already fired, cancellation is ignored.
 *
 * Deferreds may be templated to a specific type they produce using generics
 * with syntax such as:
 *
 *    /** @type {goog.async.Deferred<string>} *\
 *    var d = new goog.async.Deferred();
 *    // Compiler can infer that foo is a string.
 *    d.addCallback(function(foo) {...});
 *    d.callback('string');  // Checked to be passed a string
 *
 * Since deferreds are often used to produce different values across a chain,
 * the type information is not propagated across chains, but rather only
 * associated with specifically cast objects.
 *
 * @param {Function=} opt_onCancelFunction A function that will be called if the
 *     Deferred is canceled. If provided, this function runs before the
 *     Deferred is fired with a `CanceledError`.
 * @param {Object=} opt_defaultScope The default object context to call
 *     callbacks and errbacks in.
 * @constructor
 * @implements {goog.Thenable<VALUE>}
 * @template VALUE
 */
goog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {
  'use strict';
  /**
   * Entries in the sequence are arrays containing a callback, an errback, and
   * an optional scope. The callback or errback in an entry may be null.
   * @type {!Array<!Array>}
   * @private
   */
  this.sequence_ = [];

  /**
   * Optional function that will be called if the Deferred is canceled.
   * @type {Function|undefined}
   * @private
   */
  this.onCancelFunction_ = opt_onCancelFunction;

  /**
   * The default scope to execute callbacks and errbacks in.
   * @type {Object}
   * @private
   */
  this.defaultScope_ = opt_defaultScope || null;

  /**
   * Whether the Deferred has been fired.
   * @type {boolean}
   * @private
   */
  this.fired_ = false;

  /**
   * Whether the last result in the execution sequence was an error.
   * @type {boolean}
   * @private
   */
  this.hadError_ = false;

  /**
   * The current Deferred result, updated as callbacks and errbacks are
   * executed.
   * @type {*}
   * @private
   */
  this.result_ = undefined;

  /**
   * Whether the Deferred is blocked waiting on another Deferred to fire. If a
   * callback or errback returns a Deferred as a result, the execution sequence
   * is blocked until that Deferred result becomes available.
   * @type {boolean}
   * @private
   */
  this.blocked_ = false;

  /**
   * Whether this Deferred is blocking execution of another Deferred. If this
   * instance was returned as a result in another Deferred's execution
   * sequence,that other Deferred becomes blocked until this instance's
   * execution sequence completes. No additional callbacks may be added to a
   * Deferred once it is blocking another instance.
   * @type {boolean}
   * @private
   */
  this.blocking_ = false;

  /**
   * Whether the Deferred has been canceled without having a custom cancel
   * function.
   * @type {boolean}
   * @private
   */
  this.silentlyCanceled_ = false;

  /**
   * If an error is thrown during Deferred execution with no errback to catch
   * it, the error is rethrown after a timeout. Reporting the error after a
   * timeout allows execution to continue in the calling context (empty when
   * no error is scheduled).
   * @type {number}
   * @private
   */
  this.unhandledErrorId_ = 0;

  /**
   * If this Deferred was created by branch(), this will be the "parent"
   * Deferred.
   * @type {?goog.async.Deferred}
   * @private
   */
  this.parent_ = null;

  /**
   * The number of Deferred objects that have been branched off this one. This
   * will be decremented whenever a branch is fired or canceled.
   * @type {number}
   * @private
   */
  this.branches_ = 0;

  if (goog.async.Deferred.LONG_STACK_TRACES) {
    /**
     * Holds the stack trace at time of deferred creation if the JS engine
     * provides the Error.captureStackTrace API.
     * @private {?string}
     */
    this.constructorStack_ = null;
    if (Error.captureStackTrace) {
      const target = {stack: ''};
      Error.captureStackTrace(target, goog.async.Deferred);
      // Check if Error.captureStackTrace worked. It fails in gjstest.
      if (typeof target.stack == 'string') {
        // Remove first line and force stringify to prevent memory leak due to
        // holding on to actual stack frames.
        this.constructorStack_ = target.stack.replace(/^[^\n]*\n/, '');
      }
    }
  }
};


/**
 * @define {boolean} Whether unhandled errors should always get rethrown to the
 * global scope. Defaults to false.
 */
goog.async.Deferred.STRICT_ERRORS =
    goog.define('goog.async.Deferred.STRICT_ERRORS', false);


/**
 * @define {boolean} Whether to attempt to make stack traces long.  Defaults to
 * false.
 */
goog.async.Deferred.LONG_STACK_TRACES =
    goog.define('goog.async.Deferred.LONG_STACK_TRACES', false);


/**
 * Cancels a Deferred that has not yet been fired, or is blocked on another
 * deferred operation. If this Deferred is waiting for a blocking Deferred to
 * fire, the blocking Deferred will also be canceled.
 *
 * If this Deferred was created by calling branch() on a parent Deferred with
 * opt_propagateCancel set to true, the parent may also be canceled. If
 * opt_deepCancel is set, cancel() will be called on the parent (as well as any
 * other ancestors if the parent is also a branch). If one or more branches were
 * created with opt_propagateCancel set to true, the parent will be canceled if
 * cancel() is called on all of those branches.
 *
 * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even
 *     if cancel() hasn't been called on some of the parent's branches. Has no
 *     effect on a branch without opt_propagateCancel set to true.
 */
goog.async.Deferred.prototype.cancel = function(opt_deepCancel) {
  'use strict';
  if (!this.hasFired()) {
    if (this.parent_) {
      // Get rid of the parent reference before potentially running the parent's
      // canceler function to ensure that this cancellation isn't
      // double-counted.
      const parent = this.parent_;
      delete this.parent_;
      if (opt_deepCancel) {
        parent.cancel(opt_deepCancel);
      } else {
        parent.branchCancel_();
      }
    }

    if (this.onCancelFunction_) {
      // Call in user-specified scope.
      this.onCancelFunction_.call(this.defaultScope_, this);
    } else {
      this.silentlyCanceled_ = true;
    }
    if (!this.hasFired()) {
      this.errback(new goog.async.Deferred.CanceledError(this));
    }
  } else if (this.result_ instanceof goog.async.Deferred) {
    this.result_.cancel();
  }
};


/**
 * Handle a single branch being canceled. Once all branches are canceled, this
 * Deferred will be canceled as well.
 *
 * @private
 */
goog.async.Deferred.prototype.branchCancel_ = function() {
  'use strict';
  this.branches_--;
  if (this.branches_ <= 0) {
    this.cancel();
  }
};


/**
 * Called after a blocking Deferred fires. Unblocks this Deferred and resumes
 * its execution sequence.
 *
 * @param {boolean} isSuccess Whether the result is a success or an error.
 * @param {*} res The result of the blocking Deferred.
 * @private
 */
goog.async.Deferred.prototype.continue_ = function(isSuccess, res) {
  'use strict';
  this.blocked_ = false;
  this.updateResult_(isSuccess, res);
};


/**
 * Updates the current result based on the success or failure of the last action
 * in the execution sequence.
 *
 * @param {boolean} isSuccess Whether the new result is a success or an error.
 * @param {*} res The result.
 * @private
 */
goog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {
  'use strict';
  this.fired_ = true;
  this.result_ = res;
  this.hadError_ = !isSuccess;
  this.fire_();
};


/**
 * Verifies that the Deferred has not yet been fired.
 *
 * @private
 * @throws {Error} If this has already been fired.
 */
goog.async.Deferred.prototype.check_ = function() {
  'use strict';
  if (this.hasFired()) {
    if (!this.silentlyCanceled_) {
      throw new goog.async.Deferred.AlreadyCalledError(this);
    }
    this.silentlyCanceled_ = false;
  }
};


/**
 * Fire the execution sequence for this Deferred by passing the starting result
 * to the first registered callback.
 * @param {VALUE=} opt_result The starting result.
 */
goog.async.Deferred.prototype.callback = function(opt_result) {
  'use strict';
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.updateResult_(true /* isSuccess */, opt_result);
};


/**
 * Fire the execution sequence for this Deferred by passing the starting error
 * result to the first registered errback.
 * @param {*=} opt_result The starting error.
 */
goog.async.Deferred.prototype.errback = function(opt_result) {
  'use strict';
  this.check_();
  this.assertNotDeferred_(opt_result);
  this.makeStackTraceLong_(opt_result);
  this.updateResult_(false /* isSuccess */, opt_result);
};


/**
 * A method that is invoked with the reason of Deferred's failure for unhandled
 * errors.
 * @type {function(*)}
 * @private
 */
goog.async.Deferred.unhandledErrorHandler_ = (e) => {
  throw e;
};


/**
 * @param {function(*)} handler A function that will be called with the reason
 *     of Deferred's failure on unhandled errors. If none is specified, errors
 *     will fail with `throw`.
 */
goog.async.Deferred.setUnhandledErrorHandler = function(handler) {
  'use strict';
  goog.async.Deferred.unhandledErrorHandler_ = handler;
};


/**
 * Attempt to make the error's stack trace be long in that it contains the
 * stack trace from the point where the deferred was created on top of the
 * current stack trace to give additional context.
 * @param {*} error
 * @private
 * @suppress {missingProperties} error.stack
 */
goog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {
  'use strict';
  if (!goog.async.Deferred.LONG_STACK_TRACES) {
    return;
  }
  if (this.constructorStack_ && goog.isObject(error) && error.stack &&
      // Stack looks like it was system generated. See
      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
      (/^[^\n]+(\n   [^\n]+)+/).test(error.stack)) {
    error.stack = error.stack + '\nDEFERRED OPERATION:\n' +
        this.constructorStack_;
  }
};


/**
 * Asserts that an object is not a Deferred.
 * @param {*} obj The object to test.
 * @throws {Error} Throws an exception if the object is a Deferred.
 * @private
 */
goog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {
  'use strict';
  goog.asserts.assert(
      !(obj instanceof goog.async.Deferred),
      'An execution sequence may not be initiated with a blocking Deferred.');
};


/**
 * Register a callback function to be called with a successful result. If no
 * value is returned by the callback function, the result value is unchanged. If
 * a new value is returned, it becomes the Deferred result and will be passed to
 * the next callback in the execution sequence.
 *
 * If the function throws an error, the error becomes the new result and will be
 * passed to the next errback in the execution chain.
 *
 * If the function returns a Deferred, the execution sequence will be blocked
 * until that Deferred fires. Its result will be passed to the next callback (or
 * errback if it is an error result) in this Deferred's execution sequence.
 *
 * @param {function(this:T,VALUE):?} cb The function to be called with a
 *     successful result.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {
  'use strict';
  return this.addCallbacks(cb, null, opt_scope);
};


/**
 * Register a callback function to be called with an error result. If no value
 * is returned by the function, the error result is unchanged. If a new error
 * value is returned or thrown, that error becomes the Deferred result and will
 * be passed to the next errback in the execution sequence.
 *
 * If the errback function handles the error by returning a non-error value,
 * that result will be passed to the next normal callback in the sequence.
 *
 * If the function returns a Deferred, the execution sequence will be blocked
 * until that Deferred fires. Its result will be passed to the next callback (or
 * errback if it is an error result) in this Deferred's execution sequence.
 *
 * @param {function(this:T,?):?} eb The function to be called on an
 *     unsuccessful result.
 * @param {T=} opt_scope An optional scope to call the errback in.
 * @return {!goog.async.Deferred<VALUE>} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {
  'use strict';
  return this.addCallbacks(null, eb, opt_scope);
};


/**
 * Registers one function as both a callback and errback.
 *
 * @param {function(this:T,?):?} f The function to be called on any result.
 * @param {T=} opt_scope An optional scope to call the function in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addBoth = function(f, opt_scope) {
  'use strict';
  return this.addCallbacks(f, f, opt_scope);
};


/**
 * Like addBoth, but propagates uncaught exceptions in the errback.
 *
 * @param {function(this:T,?):?} f The function to be called on any result.
 * @param {T=} opt_scope An optional scope to call the function in.
 * @return {!goog.async.Deferred<VALUE>} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addFinally = function(f, opt_scope) {
  'use strict';
  return this.addCallbacks(f, function(err) {
    'use strict';
    const result = f.call(/** @type {?} */ (this), err);
    if (result === undefined) {
      throw err;
    }
    return result;
  }, opt_scope);
};


/**
 * Registers a callback function and an errback function at the same position
 * in the execution sequence. Only one of these functions will execute,
 * depending on the error state during the execution sequence.
 *
 * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If
 * the callback is invoked, the errback will be skipped, and vice versa.
 *
 * @param {?(function(this:T,VALUE):?)} cb The function to be called on a
 *     successful result.
 * @param {?(function(this:T,?):?)} eb The function to be called on an
 *     unsuccessful result.
 * @param {T=} opt_scope An optional scope to call the functions in.
 * @return {!goog.async.Deferred} This Deferred.
 * @template T
 */
goog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {
  'use strict';
  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');
  this.sequence_.push([cb, eb, opt_scope]);
  if (this.hasFired()) {
    this.fire_();
  }
  return this;
};


/**
 * Implements {@see goog.Thenable} for seamless integration with
 * {@see goog.Promise}.
 * Deferred results are mutable and may represent multiple values over
 * their lifetime. Calling `then` on a Deferred returns a Promise
 * with the result of the Deferred at that point in its callback chain.
 * Note that if the Deferred result is never mutated, and only
 * `then` calls are made, the Deferred will behave like a Promise.
 *
 * @override
 */
goog.async.Deferred.prototype.then = function(
    opt_onFulfilled, opt_onRejected, opt_context) {
  'use strict';
  let reject;
  let resolve;

  const promise = new goog.Promise(function(res, rej) {
    'use strict';
    // Copying resolvers to outer scope, so that they are available when the
    // deferred callback fires (which may be synchronous).
    resolve = res;
    reject = rej;
  });
  this.addCallbacks(resolve, function(reason) {
    'use strict';
    if (reason instanceof goog.async.Deferred.CanceledError) {
      promise.cancel();
    } else {
      reject(reason);
    }
  });
  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);
};
goog.Thenable.addImplementation(goog.async.Deferred);


/**
 * Links another Deferred to the end of this Deferred's execution sequence. The
 * result of this execution sequence will be passed as the starting result for
 * the chained Deferred, invoking either its first callback or errback.
 *
 * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.
 * @return {!goog.async.Deferred} This Deferred.
 */
goog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {
  'use strict';
  this.addCallbacks(
      otherDeferred.callback, otherDeferred.errback, otherDeferred);
  return this;
};


/**
 * Makes this Deferred wait for another Deferred's execution sequence to
 * complete before continuing.
 *
 * This is equivalent to adding a callback that returns `otherDeferred`,
 * but doesn't prevent additional callbacks from being added to
 * `otherDeferred`.
 *
 * @param {!goog.async.Deferred|!goog.Thenable} otherDeferred The Deferred
 *     to wait for.
 * @return {!goog.async.Deferred} This Deferred.
 */
goog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {
  'use strict';
  if (!(otherDeferred instanceof goog.async.Deferred)) {
    // The Thenable case.
    return this.addCallback(function() {
      'use strict';
      return otherDeferred;
    });
  }
  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));
};


/**
 * Creates a branch off this Deferred's execution sequence, and returns it as a
 * new Deferred. The branched Deferred's starting result will be shared with the
 * parent at the point of the branch, even if further callbacks are added to the
 * parent.
 *
 * All branches at the same stage in the execution sequence will receive the
 * same starting value.
 *
 * @param {boolean=} opt_propagateCancel If cancel() is called on every child
 *     branch created with opt_propagateCancel, the parent will be canceled as
 *     well.
 * @return {!goog.async.Deferred<VALUE>} A Deferred that will be started with
 *     the computed result from this stage in the execution sequence.
 */
goog.async.Deferred.prototype.branch = function(opt_propagateCancel) {
  'use strict';
  const d = new goog.async.Deferred();
  this.chainDeferred(d);
  if (opt_propagateCancel) {
    d.parent_ = this;
    this.branches_++;
  }
  return d;
};


/**
 * @return {boolean} Whether the execution sequence has been started on this
 *     Deferred by invoking `callback` or `errback`.
 */
goog.async.Deferred.prototype.hasFired = function() {
  'use strict';
  return this.fired_;
};


/**
 * @param {*} res The latest result in the execution sequence.
 * @return {boolean} Whether the current result is an error that should cause
 *     the next errback to fire. May be overridden by subclasses to handle
 *     special error types.
 * @protected
 */
goog.async.Deferred.prototype.isError = function(res) {
  'use strict';
  return res instanceof Error;
};


/**
 * @return {boolean} Whether an errback exists in the remaining sequence.
 * @private
 */
goog.async.Deferred.prototype.hasErrback_ = function() {
  'use strict';
  return goog.array.some(this.sequence_, function(sequenceRow) {
    'use strict';
    // The errback is the second element in the array.
    return typeof sequenceRow[1] === 'function';
  });
};


/**
 * Return the most recent value fired.
 *
 * @return {VALUE|undefined}
 * @deprecated This method is only for facilitating migrations from other async
 *     primitives.
 */
goog.async.Deferred.prototype.getLastValueForMigration = function() {
  'use strict';
  return (this.hasFired() && !this.hadError_) ? this.result_ : undefined;
};


/**
 * Exhausts the execution sequence while a result is available. The result may
 * be modified by callbacks or errbacks, and execution will block if the
 * returned result is an incomplete Deferred.
 *
 * @private
 */
goog.async.Deferred.prototype.fire_ = function() {
  'use strict';
  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {
    // It is possible to add errbacks after the Deferred has fired. If a new
    // errback is added immediately after the Deferred encountered an unhandled
    // error, but before that error is rethrown, the error is unscheduled.
    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);
    this.unhandledErrorId_ = 0;
  }

  if (this.parent_) {
    this.parent_.branches_--;
    delete this.parent_;
  }

  let res = this.result_;
  let unhandledException = false;
  let isNewlyBlocked = false;

  while (this.sequence_.length && !this.blocked_) {
    const sequenceEntry = this.sequence_.shift();

    const callback = sequenceEntry[0];
    const errback = sequenceEntry[1];
    const scope = sequenceEntry[2];

    const f = this.hadError_ ? errback : callback;
    if (f) {

      try {
        const ret = f.call(scope || this.defaultScope_, res);

        // If no result, then use previous result.
        if (ret !== undefined) {
          // Bubble up the error as long as the return value hasn't changed.
          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));
          this.result_ = res = ret;
        }

        if (goog.Thenable.isImplementedBy(res) ||
            (typeof goog.global['Promise'] === 'function' &&
            res instanceof goog.global['Promise'])) {
          isNewlyBlocked = true;
          this.blocked_ = true;
        }

      } catch (ex) {
        res = ex;
        this.hadError_ = true;
        this.makeStackTraceLong_(res);

        if (!this.hasErrback_()) {
          // If an error is thrown with no additional errbacks in the queue,
          // prepare to rethrow the error.
          unhandledException = true;
        }
      }
    }
  }

  this.result_ = res;

  if (isNewlyBlocked) {
    const onCallback = goog.bind(this.continue_, this, true /* isSuccess */);
    const onErrback = goog.bind(this.continue_, this, false /* isSuccess */);

    if (res instanceof goog.async.Deferred) {
      res.addCallbacks(onCallback, onErrback);
      res.blocking_ = true;
    } else {
      /** @type {!IThenable} */ (res).then(onCallback, onErrback);
    }
  } else if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) &&
      !(res instanceof goog.async.Deferred.CanceledError)) {
    this.hadError_ = true;
    unhandledException = true;
  }

  if (unhandledException) {
    // Rethrow the unhandled error after a timeout. Execution will continue, but
    // the error will be seen by global handlers and the user. The throw will
    // be canceled if another errback is appended before the timeout executes.
    // The error's original stack trace is preserved where available.
    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);
  }
};


/**
 * Creates a Deferred that has an initial result.
 *
 * @param {*=} opt_result The result.
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.succeed = function(opt_result) {
  'use strict';
  const d = new goog.async.Deferred();
  d.callback(opt_result);
  return d;
};


/**
 * Creates a Deferred that fires when the given promise resolves.
 * Use only during migration to Promises.
 *
 * Note: If the promise resolves to a thenable value (which is not allowed by
 * conforming promise implementations), then the deferred may behave
 * unexpectedly as it tries to wait on it. This should not be a risk when using
 * goog.Promise, goog.async.Deferred, or native Promise objects.
 *
 * @param {!IThenable<T>} promise
 * @return {!goog.async.Deferred<T>} The new Deferred.
 * @template T
 */
goog.async.Deferred.fromPromise = function(promise) {
  'use strict';
  const d = new goog.async.Deferred();
  promise.then(
      function(value) {
        'use strict';
        d.callback(value);
      },
      function(error) {
        'use strict';
        d.errback(error);
      });
  return d;
};


/**
 * Creates a Deferred that has an initial error result.
 *
 * @param {*} res The error result.
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.fail = function(res) {
  'use strict';
  const d = new goog.async.Deferred();
  d.errback(res);
  return d;
};


/**
 * Creates a Deferred that has already been canceled.
 *
 * @return {!goog.async.Deferred} The new Deferred.
 */
goog.async.Deferred.canceled = function() {
  'use strict';
  const d = new goog.async.Deferred();
  d.cancel();
  return d;
};


/**
 * Normalizes values that may or may not be Deferreds.
 *
 * If the input value is a Deferred, the Deferred is branched (so the original
 * execution sequence is not modified) and the input callback added to the new
 * branch. The branch is returned to the caller.
 *
 * If the input value is not a Deferred, the callback will be executed
 * immediately and an already firing Deferred will be returned to the caller.
 *
 * In the following (contrived) example, if <code>isImmediate</code> is true
 * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.
 *
 * <pre>
 * var value;
 * if (isImmediate) {
 *   value = 3;
 * } else {
 *   value = new goog.async.Deferred();
 *   setTimeout(function() { value.callback(6); }, 2000);
 * }
 *
 * var d = goog.async.Deferred.when(value, alert);
 * </pre>
 *
 * @param {*} value Deferred or normal value to pass to the callback.
 * @param {function(this:T, ?):?} callback The callback to execute.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @return {!goog.async.Deferred} A new Deferred that will call the input
 *     callback with the input value.
 * @template T
 */
goog.async.Deferred.when = function(value, callback, opt_scope) {
  'use strict';
  if (value instanceof goog.async.Deferred) {
    return value.branch(true).addCallback(callback, opt_scope);
  } else {
    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);
  }
};



/**
 * An error sub class that is used when a Deferred has already been called.
 * @param {!goog.async.Deferred} deferred The Deferred.
 *
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.async.Deferred.AlreadyCalledError = function(deferred) {
  'use strict';
  goog.debug.Error.call(this);

  /**
   * The Deferred that raised this error.
   * @type {goog.async.Deferred}
   */
  this.deferred = deferred;
};
goog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);


/** @override */
goog.async.Deferred.AlreadyCalledError.prototype.message =
    'Deferred has already fired';


/** @override */
goog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';



/**
 * An error sub class that is used when a Deferred is canceled.
 *
 * @param {!goog.async.Deferred} deferred The Deferred object.
 * @constructor
 * @extends {goog.debug.Error}
 */
goog.async.Deferred.CanceledError = function(deferred) {
  'use strict';
  goog.debug.Error.call(this);

  /**
   * The Deferred that raised this error.
   * @type {goog.async.Deferred}
   */
  this.deferred = deferred;
};
goog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);


/** @override */
goog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';


/** @override */
goog.async.Deferred.CanceledError.prototype.name = 'CanceledError';



/**
 * Wrapper around errors that are scheduled to be thrown by failing deferreds
 * after a timeout.
 *
 * @param {*} error Error from a failing deferred.
 * @constructor
 * @final
 * @private
 * @struct
 */
goog.async.Deferred.Error_ = function(error) {
  'use strict';
  /** @const @private {number} */
  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);

  /** @const @private {*} */
  this.error_ = error;
};


/**
 * Actually throws the error and removes it from the list of pending
 * deferred errors.
 */
goog.async.Deferred.Error_.prototype.throwError = function() {
  'use strict';
  goog.asserts.assert(
      goog.async.Deferred.errorMap_[this.id_],
      'Cannot throw an error that is not scheduled.');
  delete goog.async.Deferred.errorMap_[this.id_];
  goog.async.Deferred.unhandledErrorHandler_(this.error_);
};


/**
 * Resets the error throw timer.
 */
goog.async.Deferred.Error_.prototype.resetTimer = function() {
  'use strict';
  goog.global.clearTimeout(this.id_);
};


/**
 * Map of unhandled errors scheduled to be rethrown in a future timestep.
 * @private {!Object<(number|string), goog.async.Deferred.Error_>}
 */
goog.async.Deferred.errorMap_ = {};


/**
 * Schedules an error to be thrown after a delay.
 * @param {*} error Error from a failing deferred.
 * @return {number} Id of the error.
 * @private
 */
goog.async.Deferred.scheduleError_ = function(error) {
  'use strict';
  const deferredError = new goog.async.Deferred.Error_(error);
  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;
  return deferredError.id_;
};


/**
 * Unschedules an error from being thrown.
 * @param {number} id Id of the deferred error to unschedule.
 * @private
 */
goog.async.Deferred.unscheduleError_ = function(id) {
  'use strict';
  const error = goog.async.Deferred.errorMap_[id];
  if (error) {
    error.resetTimer();
    delete goog.async.Deferred.errorMap_[id];
  }
};


/**
 * Asserts that there are no pending deferred errors. If there are any
 * scheduled errors, one will be thrown immediately to make this function fail.
 */
goog.async.Deferred.assertNoErrors = function() {
  'use strict';
  const map = goog.async.Deferred.errorMap_;
  for (let key in map) {
    const error = map[key];
    error.resetTimer();
    error.throwError();
  }
};

//analytics/tracking/chrome/internal/async_storage.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for async storage of simple values.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.AsyncStorage');
goog.module.declareLegacyNamespace();

const Deferred = goog.require('goog.async.Deferred');
const Listenable = goog.require('goog.events.Listenable');
const events = goog.require('goog.events');

/**
 * Interface for asynchronous persistent storage.
 *
 * @interface
 * @extends {Listenable}
 */
function AsyncStorage() {}

/**
 * @param {string} key Key to retrieve -- must be non-empty.
 * @return {!Deferred.<string>} A deferred firing
 *     with the loaded value, or undefined if the value is not set.
 */
AsyncStorage.prototype.get;

/**
 * @param {string} key
 * @param {string} value Must not be null or undefined.
 * @return {!Deferred} A deferred firing when the value is set.
 */
AsyncStorage.prototype.set;

/**
 * Event supported by AsyncStorage instances.
 * @enum {string}
 */
AsyncStorage.Event = {
  STORAGE_CHANGED: events.getUniqueId('storage-changed')
};

exports = AsyncStorage;

;return exports;});

//third_party/javascript/closure/events/eventtarget.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A disposable implementation of a custom
 * listenable/event target. See also: documentation for
 * `goog.events.Listenable`.
 *
 * @see ../demos/eventtarget.html
 * @see goog.events.Listenable
 */

goog.provide('goog.events.EventTarget');

goog.require('goog.Disposable');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.require('goog.object');
goog.requireType('goog.events.EventId');
goog.requireType('goog.events.EventLike');
goog.requireType('goog.events.ListenableKey');



/**
 * An implementation of `goog.events.Listenable` with full W3C
 * EventTarget-like support (capture/bubble mechanism, stopping event
 * propagation, preventing default actions).
 *
 * You may subclass this class to turn your class into a Listenable.
 *
 * Unless propagation is stopped, an event dispatched by an
 * EventTarget will bubble to the parent returned by
 * `getParentEventTarget`. To set the parent, call
 * `setParentEventTarget`. Subclasses that don't support
 * changing the parent can override the setter to throw an error.
 *
 * Example usage:
 * <pre>
 *   var source = new goog.events.EventTarget();
 *   function handleEvent(e) {
 *     alert('Type: ' + e.type + '; Target: ' + e.target);
 *   }
 *   source.listen('foo', handleEvent);
 *   // Or: goog.events.listen(source, 'foo', handleEvent);
 *   ...
 *   source.dispatchEvent('foo');  // will call handleEvent
 *   ...
 *   source.unlisten('foo', handleEvent);
 *   // Or: goog.events.unlisten(source, 'foo', handleEvent);
 * </pre>
 *
 * @constructor
 * @extends {goog.Disposable}
 * @implements {goog.events.Listenable}
 */
goog.events.EventTarget = function() {
  'use strict';
  goog.Disposable.call(this);

  /**
   * Maps of event type to an array of listeners.
   * @private {!goog.events.ListenerMap}
   */
  this.eventTargetListeners_ = new goog.events.ListenerMap(this);

  /**
   * The object to use for event.target. Useful when mixing in an
   * EventTarget to another object.
   * @private {!Object}
   */
  this.actualEventTarget_ = this;

  /**
   * Parent event target, used during event bubbling.
   *
   * TODO(chrishenry): Change this to goog.events.Listenable. This
   * currently breaks people who expect getParentEventTarget to return
   * goog.events.EventTarget.
   *
   * @private {?goog.events.EventTarget}
   */
  this.parentEventTarget_ = null;
};
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);


/**
 * An artificial cap on the number of ancestors you can have. This is mainly
 * for loop detection.
 * @const {number}
 * @private
 */
goog.events.EventTarget.MAX_ANCESTORS_ = 1000;


/**
 * Returns the parent of this event target to use for bubbling.
 *
 * @return {goog.events.EventTarget} The parent EventTarget or null if
 *     there is no parent.
 * @override
 */
goog.events.EventTarget.prototype.getParentEventTarget = function() {
  'use strict';
  return this.parentEventTarget_;
};


/**
 * Sets the parent of this event target to use for capture/bubble
 * mechanism.
 * @param {goog.events.EventTarget} parent Parent listenable (null if none).
 */
goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {
  'use strict';
  this.parentEventTarget_ = parent;
};


/**
 * Adds an event listener to the event target. The same handler can only be
 * added once per the type. Even if you add the same handler multiple times
 * using the same type then it will only be called once when the event is
 * dispatched.
 *
 * @param {string|!goog.events.EventId} type The type of the event to listen for
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use `#listen` instead, when possible. Otherwise, use
 *     `goog.events.listen` if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.addEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  'use strict';
  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);
};


/**
 * Removes an event listener from the event target. The handler must be the
 * same object as the one added. If the handler has not been added then
 * nothing is done.
 *
 * @param {string|!goog.events.EventId} type The type of the event to listen for
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use `#unlisten` instead, when possible. Otherwise, use
 *     `goog.events.unlisten` if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.removeEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  'use strict';
  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);
};


/**
 * @param {?goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 * @override
 */
goog.events.EventTarget.prototype.dispatchEvent = function(e) {
  'use strict';
  this.assertInitialized_();

  var ancestorsTree, ancestor = this.getParentEventTarget();
  if (ancestor) {
    ancestorsTree = [];
    var ancestorCount = 1;
    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
      ancestorsTree.push(ancestor);
      goog.asserts.assert(
          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),
          'infinite loop');
    }
  }

  return goog.events.EventTarget.dispatchEventInternal_(
      this.actualEventTarget_, e, ancestorsTree);
};


/**
 * Removes listeners from this object.  Classes that extend EventTarget may
 * need to override this method in order to remove references to DOM Elements
 * and additional listeners.
 * @override
 * @protected
 */
goog.events.EventTarget.prototype.disposeInternal = function() {
  'use strict';
  goog.events.EventTarget.superClass_.disposeInternal.call(this);

  this.removeAllListeners();
  this.parentEventTarget_ = null;
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {!goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.listen = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  'use strict';
  this.assertInitialized_();
  return this.eventTargetListeners_.add(
      String(type), listener, false /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {!goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.listenOnce = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  'use strict';
  return this.eventTargetListeners_.add(
      String(type), listener, true /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.unlisten = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  'use strict';
  return this.eventTargetListeners_.remove(
      String(type), listener, opt_useCapture, opt_listenerScope);
};


/**
 * @param {!goog.events.ListenableKey} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 * @override
 */
goog.events.EventTarget.prototype.unlistenByKey = function(key) {
  'use strict';
  return this.eventTargetListeners_.removeByKey(key);
};


/**
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove,
 *     default is to remove all types.
 * @return {number} Number of listeners removed.
 * @override
 */
goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {
  'use strict';
  // TODO(chrishenry): Previously, removeAllListeners can be called on
  // uninitialized EventTarget, so we preserve that behavior. We
  // should remove this when usages that rely on that fact are purged.
  if (!this.eventTargetListeners_) {
    return 0;
  }
  return this.eventTargetListeners_.removeAll(opt_type);
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The type of the
 *     listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @param {EVENTOBJ} eventObject The event object to fire.
 * @return {boolean} Whether all listeners succeeded without
 *     attempting to prevent default behavior. If any listener returns
 *     false or called goog.events.Event#preventDefault, this returns
 *     false.
 * @template EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.fireListeners = function(
    type, capture, eventObject) {
  'use strict';
  // TODO(chrishenry): Original code avoids array creation when there
  // is no listener, so we do the same. If this optimization turns
  // out to be not required, we can replace this with
  // getListeners(type, capture) instead, which is simpler.
  var listenerArray = this.eventTargetListeners_.listeners[String(type)];
  if (!listenerArray) {
    return true;
  }
  listenerArray = listenerArray.concat();

  var rv = true;
  for (var i = 0; i < listenerArray.length; ++i) {
    var listener = listenerArray[i];
    // We might not have a listener if the listener was removed.
    if (listener && !listener.removed && listener.capture == capture) {
      var listenerFn = listener.listener;
      var listenerHandler = listener.handler || listener.src;

      if (listener.callOnce) {
        this.unlistenByKey(listener);
      }
      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;
    }
  }

  return rv && !eventObject.defaultPrevented;
};


/**
 * @param {string|!goog.events.EventId} type The type of the listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @return {!Array<!goog.events.ListenableKey>} An array of registered
 *     listeners.
 * @template EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.getListeners = function(type, capture) {
  'use strict';
  return this.eventTargetListeners_.getListeners(String(type), capture);
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>} type The name of the event
 *     without the 'on' prefix.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The
 *     listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {?goog.events.ListenableKey} the found listener or null if not found.
 * @template SCOPE,EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  'use strict';
  return this.eventTargetListeners_.getListener(
      String(type), listener, capture, opt_listenerScope);
};


/**
 * @param {string|!goog.events.EventId<EVENTOBJ>=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble
 *     listeners.
 * @return {boolean} Whether there is any active listeners matching
 *     the requested type and/or capture phase.
 * @template EVENTOBJ
 * @override
 */
goog.events.EventTarget.prototype.hasListener = function(
    opt_type, opt_capture) {
  'use strict';
  var id = (opt_type !== undefined) ? String(opt_type) : undefined;
  return this.eventTargetListeners_.hasListener(id, opt_capture);
};


/**
 * Sets the target to be used for `event.target` when firing
 * event. Mainly used for testing. For example, see
 * `goog.testing.events.mixinListenable`.
 * @param {!Object} target The target.
 */
goog.events.EventTarget.prototype.setTargetForTesting = function(target) {
  'use strict';
  this.actualEventTarget_ = target;
};


/**
 * Asserts that the event target instance is initialized properly.
 * @private
 */
goog.events.EventTarget.prototype.assertInitialized_ = function() {
  'use strict';
  goog.asserts.assert(
      this.eventTargetListeners_,
      'Event target is not initialized. Did you call the superclass ' +
          '(goog.events.EventTarget) constructor?');
};


/**
 * Dispatches the given event on the ancestorsTree.
 *
 * @param {!Object} target The target to dispatch on.
 * @param {goog.events.Event|Object|string} e The event object.
 * @param {Array<goog.events.Listenable>=} opt_ancestorsTree The ancestors
 *     tree of the target, in reverse order from the closest ancestor
 *     to the root event target. May be null if the target has no ancestor.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 * @private
 */
goog.events.EventTarget.dispatchEventInternal_ = function(
    target, e, opt_ancestorsTree) {
  'use strict';
  /** @suppress {missingProperties} */
  var type = e.type || /** @type {string} */ (e);

  // If accepting a string or object, create a custom event object so that
  // preventDefault and stopPropagation work with the event.
  if (typeof e === 'string') {
    e = new goog.events.Event(e, target);
  } else if (!(e instanceof goog.events.Event)) {
    var oldEvent = e;
    e = new goog.events.Event(type, target);
    goog.object.extend(e, oldEvent);
  } else {
    e.target = e.target || target;
  }

  var rv = true, currentTarget;

  // Executes all capture listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (var i = opt_ancestorsTree.length - 1;
         !e.hasPropagationStopped() && i >= 0; i--) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, true, e) && rv;
    }
  }

  // Executes capture and bubble listeners on the target.
  if (!e.hasPropagationStopped()) {
    currentTarget = /** @type {?} */ (e.currentTarget = target);
    rv = currentTarget.fireListeners(type, true, e) && rv;
    if (!e.hasPropagationStopped()) {
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  // Executes all bubble listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (i = 0; !e.hasPropagationStopped() && i < opt_ancestorsTree.length;
         i++) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  return rv;
};

//analytics/tracking/chrome/internal/chrome_storage.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple wappers for chrome.storage.{sync|local} which produces
 * Deferreds instead of taking callbacks.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.ChromeStorage');
goog.module.declareLegacyNamespace();

const AsyncStorage = goog.require('analytics.internal.AsyncStorage');
const Deferred = goog.require('goog.async.Deferred');
const GoogEventTarget = goog.require('goog.events.EventTarget');
const asserts = goog.require('goog.asserts');
const googArray = goog.require('goog.array');
const googObject = goog.require('goog.object');
const googString = goog.require('goog.string');

/**
 * A thin wrapper around chrome.storage.local which produces Deferreds
 * instead of taking callbacks. The storage is shared between all the
 * code (in the same app) that requests it necessitating a namespace.
 *
 * @implements {AsyncStorage}
 */
const ChromeStorage = class extends GoogEventTarget {
  constructor() {
    super();

    /** @private {string} */
    this.namespace_ = 'google-analytics';

    /** @private {!StorageArea} */
    this.storage_ = chrome.storage.local;

    // Get notified when our underlying storage changes.
    chrome.storage.onChanged.addListener(
        goog.bind(this.onStorageChanged_, this));
  }

  /**
   * Notifies listeners when underlying storage changes.
   *
   * @see https://developer.chrome.com/extensions/storage#type-StorageArea
   *
   * @param {!Object} changes
   * @param {string} areaName "sync", "local" or "managed"
   * @private
   */
  onStorageChanged_(changes, areaName) {
    if (areaName == 'local' && this.hasChangesInNamespace_(changes)) {
      this.dispatchEvent(AsyncStorage.Event.STORAGE_CHANGED);
    }
  }

  /**
   * Returns true if any of the given changes is in our namespace.
   * Namespaces, mind you, aren't protected, so take this answer
   * with a grain of salt.
   *
   * @param {!Object} changes
   * @return {boolean}
   * @private
   */
  hasChangesInNamespace_(changes) {
    return googArray.some(
        googObject.getKeys(changes),
        /**
         * @param {string} key
         * @this {ChromeStorage}
         */
        function(key) {
          return googString.startsWith(key, this.namespace_);
        },
        this);
  }

  /** @override */
  get(key) {
    var d = new Deferred();
    var fullKey = this.namespace_ + '.' + key;
    this.storage_.get(
        fullKey,
        /** @param {Object} items */
        function(items) {
          if (chrome.runtime.lastError) {
            d.errback(chrome.runtime.lastError);
          } else {
            var value = items[fullKey];
            d.callback(value != null ? value.toString() : undefined);
          }
        });

    return d;
  }

  /** @override */
  set(key, value) {
    var d = new Deferred();

    var data = {};
    data[this.namespace_ + '.' + key] = value;
    this.storage_.set(data, function() {
      if (chrome.runtime.lastError) {
        d.errback(chrome.runtime.lastError);
      } else {
        d.callback();
      }
    });

    return d;
  }
};

exports = ChromeStorage;

;return exports;});

//analytics/tracking/chrome/google_analytics.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.module('analytics.GoogleAnalytics');
goog.module.declareLegacyNamespace();

/**
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

const Config = goog.requireType('analytics.Config');
const Deferred = goog.requireType('goog.async.Deferred');
const Tracker = goog.requireType('analytics.Tracker');

/**
 * Service object providing access to `Tracker` and
 * `Config` objects.
 *
 * <p>An instance of this can be obtained using `analytics.getService`.
 *
 * @interface
 */
function GoogleAnalytics() {}

/**
 * Creates a new `Tracker` instance.
 * @param {string} trackingId Your Google Analytics tracking id. This id must
 *     be for an "app" style analytics property.
 * See {@link https://support.google.com/analytics/answer/2614741} for details.
 *
 * @return {!Tracker}
 */
GoogleAnalytics.prototype.getTracker;

/**
 * Provides read/write access to the runtime configuration information used
 * by the Google Analytics service classes.
 *
 * @return {!Deferred.<!Config>} A deferred
 *     that fires when the object is ready to handle method calls.
 *     Deferred is necessary to allow for object initialization from
 *     asynchronous storage.
 */
GoogleAnalytics.prototype.getConfig;

exports = GoogleAnalytics;

;return exports;});

//third_party/javascript/closure/collections/iters.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for working with ES6 iterables.
 *
 * The goal is that this should be a replacement for goog.iter which uses
 * a now non-standard approach to iterables.
 *
 * @see https://goo.gl/Rok5YQ
 */

goog.module('goog.collections.iters');
goog.module.declareLegacyNamespace();

/**
 * Get the iterator for an iterable.
 * @param {!Iterable<VALUE>} iterable
 * @return {!Iterator<VALUE>}
 * @template VALUE
 */
function getIterator(iterable) {
  return iterable[goog.global.Symbol.iterator]();
}
exports.getIterator = getIterator;


/**
 * Call a function with every value of an iterable.
 *
 * Warning: this function will never halt if given an iterable that
 * is never exhausted.
 *
 * @param {!Iterable<VALUE>} iterable
 * @param {function(VALUE) : *} f
 * @template VALUE
 */
exports.forEach = function(iterable, f) {
  for (const elem of iterable) {
    f(elem);
  }
};


/**
 * An Iterable that wraps a child iterable, and maps every element of the child
 * iterator to a new value, using a mapping function. Similar to Array.map, but
 * for Iterable.
 * @template TO,FROM
 * @implements {IteratorIterable<TO>}
 */
class MapIterator {
  /**
   * @param {!Iterable<FROM>} childIter
   * @param {function(FROM, number): TO} mapFn
   */
  constructor(childIter, mapFn) {
    /** @private @const {!Iterator<FROM>} */
    this.childIterator_ = getIterator(childIter);

    /** @private @const {function(FROM, number): TO} */
    this.mapFn_ = mapFn;

    /** @private {number} */
    this.nextIndex_ = 0;
  }

  [Symbol.iterator]() {
    return this;
  }

  /** @override */
  next() {
    const childResult = this.childIterator_.next();
    // Always return a new object, even when childResult.done == true. This is
    // so that we don't accidentally preserve generator return values, which
    // are unlikely to be meaningful in the context of this MapIterator.
    return {
      value: childResult.done ?
          undefined :
          this.mapFn_.call(undefined, childResult.value, this.nextIndex_++),
      done: childResult.done,
    };
  }
}


/**
 * Maps the values of one iterable to create another iterable.
 *
 * When next() is called on the returned iterable, it will call the given
 * function `f` with the next value of the given iterable
 * `iterable` until the given iterable is exhausted.
 *
 * @param {!Iterable<VALUE>} iterable
 * @param {function(VALUE, number): RESULT} f
 * @return {!IteratorIterable<RESULT>} The created iterable that gives the
 *     mapped values.
 * @template VALUE, RESULT
 */
exports.map = function(iterable, f) {
  return new MapIterator(iterable, f);
};


/**
 * An Iterable that wraps a child Iterable and returns a subset of the child's
 * items, based on a filter function. Similar to Array.filter, but for
 * Iterable.
 * @template T
 * @implements {IteratorIterable<T>}
 */
class FilterIterator {
  /**
   * @param {!Iterable<T>} childIter
   * @param {function(T, number): boolean} filterFn
   */
  constructor(childIter, filterFn) {
    /** @private @const {!Iterator<T>} */
    this.childIter_ = getIterator(childIter);

    /** @private @const {function(T, number): boolean} */
    this.filterFn_ = filterFn;

    /** @private {number} */
    this.nextIndex_ = 0;
  }

  [Symbol.iterator]() {
    return this;
  }

  /** @override */
  next() {
    while (true) {
      const childResult = this.childIter_.next();
      if (childResult.done) {
        // Don't return childResult directly, because that would preserve
        // generator return values, and we want to ignore them.
        return {done: true, value: undefined};
      }
      const passesFilter =
          this.filterFn_.call(undefined, childResult.value, this.nextIndex_++);
      if (passesFilter) {
        return childResult;
      }
    }
  }
}


/**
 * Filter elements from one iterator to create another iterable.
 *
 * When next() is called on the returned iterator, it will call next() on the
 * given iterator and call the given function `f` with that value until `true`
 * is returned or the given iterator is exhausted.
 *
 * @param {!Iterable<VALUE>} iterable
 * @param {function(VALUE, number): boolean} f
 * @return {!IteratorIterable<VALUE>} The created iterable that gives the mapped
 *     values.
 * @template VALUE
 */
exports.filter = function(iterable, f) {
  return new FilterIterator(iterable, f);
};


/**
 * @template T
 * @implements {IteratorIterable<T>}
 */
class ConcatIterator {
  /** @param {!Array<!Iterator<T>>} iterators */
  constructor(iterators) {
    /** @private @const {!Array<!Iterator<T>>} */
    this.iterators_ = iterators;

    /** @private {number} */
    this.iterIndex_ = 0;
  }

  [Symbol.iterator]() {
    return this;
  }

  /** @override */
  next() {
    while (this.iterIndex_ < this.iterators_.length) {
      const result = this.iterators_[this.iterIndex_].next();
      if (!result.done) {
        return result;
      }
      this.iterIndex_++;
    }
    return /** @type {!IIterableResult<T>} */ ({done: true});
  }
}


/**
 * Concatenates multiple iterators to create a new iterable.
 *
 * When next() is called on the return iterator, it will call next() on the
 * current passed iterator. When the current passed iterator is exhausted, it
 * will move on to the next iterator until there are no more left.
 *
 * All generator return values will be ignored (i.e. when childIter.next()
 * returns {done: true, value: notUndefined} it will be treated as just
 * {done: true}).
 *
 * @param {...!Iterable<VALUE>} iterables
 * @return {!IteratorIterable<VALUE>}
 * @template VALUE
 */
exports.concat = function(...iterables) {
  return new ConcatIterator(iterables.map(getIterator));
};

;return exports;});

//third_party/javascript/closure/iter/iter.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Python style iteration utilities.
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterable');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.functions');
goog.require('goog.math');


/**
 * @typedef {{length:number}|{__iterator__}}
 */
goog.iter.Iterable;


/**
 * Singleton Error object that is used to terminate iterations.
 * @const {!Error}
 */
goog.iter.StopIteration = ('StopIteration' in goog.global) ?
    // For script engines that support legacy iterators.
    goog.global['StopIteration'] :
    {message: 'StopIteration', stack: ''};



/**
 * Class/interface for iterators.  An iterator needs to implement a `next`
 * method and it needs to throw a `goog.iter.StopIteration` when the
 * iteration passes beyond the end.  Iterators have no `hasNext` method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 * @template VALUE
 * @deprecated Use objects implementing JavaScript iterable protocol introduced
 *     in ES6.
 *     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter.StopIteration} when the iteration passes the end.
 * @return {VALUE} Any object or value.
 * @deprecated To ease migration to the ES6 Iteration Protocol, this method is
 *     now called `nextValueOrThrow`.
 */
goog.iter.Iterator.prototype.next = function() {
  'use strict';
  // Explicitly do not call nextValueOrThrow via `this`, as with some subclass
  // trees this can lead to incorrect results or infinite recursion.
  return goog.iter.Iterator.prototype.nextValueOrThrow.call(this);
};

/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter.StopIteration} when the iteration passes the end.
 * @return {VALUE} Any object or value
 */
goog.iter.Iterator.prototype.nextValueOrThrow = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the `Iterator` object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (false).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator<VALUE>} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  'use strict';
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable  If the
 *     object is an iterator it will be returned as is.  If the object has an
 *     `__iterator__` method that will be called to get the value
 *     iterator.  If the object is an array-like object we create an iterator
 *     for that.
 * @return {!goog.iter.Iterator<VALUE>} An iterator that knows how to iterate
 *     over the values in `iterable`.
 * @template VALUE
 */
goog.iter.toIterator = function(iterable) {
  'use strict';
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return /** @type {{__iterator__:function(this:?, boolean=)}} */ (iterable)
        .__iterator__(false);
  }
  if (goog.isArrayLike(iterable)) {
    var like = /** @type {!IArrayLike<number|string>} */ (iterable);
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.nextValueOrThrow = function() {
      'use strict';
      while (true) {
        if (i >= like.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in like)) {
          i++;
          continue;
        }
        return like[i++];
      }
    };
    /**
     * TODO(b/159383578): Please do not remove - this will be cleaned up
     * centrally.
     * @override @see {!goog.iter.Iterator}
     */
    newIter.next = newIter.nextValueOrThrow.bind(newIter);

    return newIter;
  }


  // TODO(arv): Should we fall back on goog.structs.getValues()?
  throw new Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable  The iterator
 *     to iterate over. If the iterable is an object `toIterator` will be
 *     called on it.
 * @param {function(this:THIS,VALUE,?,!goog.iter.Iterator<VALUE>)} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and the return value is
 *     irrelevant.  The reason for passing undefined as the second argument is
 *     so that the same function can be used in {@see goog.array.forEach} as
 *     well as others.  The third parameter is of type "number" for
 *     arraylike objects, undefined, otherwise.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     `f`.
 * @template THIS, VALUE
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  'use strict';
  if (goog.isArrayLike(iterable)) {
    try {
      // NOTES: this passes the index number to the second parameter
      // of the callback contrary to the documentation above.
      goog.array.forEach(
          /** @type {IArrayLike<?>} */ (iterable), f, opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);

    try {
      while (true) {
        f.call(opt_obj, iterable.nextValueOrThrow(), undefined, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every element. This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a boolean.
 *     If the return value is true the element will be included in the returned
 *     iterator.  If it is false the element is not included.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator in which only elements
 *     that passed the test are present.
 * @template THIS, VALUE
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.nextValueOrThrow = function() {
    'use strict';
    while (true) {
      var val = iterator.nextValueOrThrow();
      if (f.call(opt_obj, val, undefined, iterator)) {
        return val;
      }
    }
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  newIter.next = newIter.nextValueOrThrow.bind(newIter);

  return newIter;
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns false adds the element to a new iterator.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every element. This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a boolean.
 *     If the return value is false the element will be included in the returned
 *     iterator.  If it is true the element is not included.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator in which only elements
 *     that did not pass the test are present.
 * @template THIS, VALUE
 */
goog.iter.filterFalse = function(iterable, f, opt_obj) {
  'use strict';
  return goog.iter.filter(iterable, goog.functions.not(f), opt_obj);
};


/**
 * Creates a new iterator that returns the values in a range.  This function
 * can take 1, 2 or 3 arguments:
 * <pre>
 * range(5) same as range(0, 5, 1)
 * range(2, 5) same as range(2, 5, 1)
 * </pre>
 *
 * @param {number} startOrStop  The stop value if only one argument is provided.
 *     The start value if 2 or more arguments are provided.  If only one
 *     argument is used the start value is 0.
 * @param {number=} opt_stop  The stop value.  If left out then the first
 *     argument is used as the stop value.
 * @param {number=} opt_step  The number to increment with between each call to
 *     next.  This can be negative.
 * @return {!goog.iter.Iterator<number>} A new iterator that returns the values
 *     in the range.
 */
goog.iter.range = function(startOrStop, opt_stop, opt_step) {
  'use strict';
  var start = 0;
  var stop = startOrStop;
  var step = opt_step || 1;
  if (arguments.length > 1) {
    start = startOrStop;
    stop = +opt_stop;
  }
  if (step == 0) {
    throw new Error('Range step argument must not be zero');
  }

  var newIter = new goog.iter.Iterator;
  newIter.nextValueOrThrow = function() {
    'use strict';
    if (step > 0 && start >= stop || step < 0 && start <= stop) {
      throw goog.iter.StopIteration;
    }
    var rv = start;
    start += step;
    return rv;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  newIter.next = newIter.nextValueOrThrow.bind(newIter);

  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 * @template VALUE
 */
goog.iter.join = function(iterable, deliminator) {
  'use strict';
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterator to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):RESULT} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a new value.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {!goog.iter.Iterator<RESULT>} A new iterator that returns the
 *     results of applying the function to each element in the original
 *     iterator.
 * @template THIS, VALUE, RESULT
 */
goog.iter.map = function(iterable, f, opt_obj) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.nextValueOrThrow = function() {
    'use strict';
    var val = iterator.nextValueOrThrow();
    return f.call(opt_obj, val, undefined, iterator);
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  newIter.next = newIter.nextValueOrThrow.bind(newIter);

  return newIter;
};


/**
 * Passes every element of an iterator into a function and accumulates the
 * result.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {function(this:THIS,VALUE,VALUE):VALUE} f The function to call for
 *     every element. This function takes 2 arguments (the function's previous
 *     result or the initial value, and the value of the current element).
 *     function(previousValue, currentElement) : newValue.
 * @param {VALUE} val The initial value to pass into the function on the first
 *     call.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     f.
 * @return {VALUE} Result of evaluating f repeatedly across the values of
 *     the iterator.
 * @template THIS, VALUE
 */
goog.iter.reduce = function(iterable, f, val, opt_obj) {
  'use strict';
  var rval = val;
  goog.iter.forEach(iterable, function(val) {
    'use strict';
    rval = f.call(opt_obj, rval, val);
  });
  return rval;
};


/**
 * Goes through the values in the iterator. Calls f for each of these, and if
 * any of them returns true, this returns true (without checking the rest). If
 * all return false this will return false.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {boolean} true if any value passes the test.
 * @template THIS, VALUE
 */
goog.iter.some = function(iterable, f, opt_obj) {
  'use strict';
  iterable = goog.iter.toIterator(iterable);

  try {
    while (true) {
      if (f.call(opt_obj, iterable.nextValueOrThrow(), undefined, iterable)) {
        return true;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return false;
};


/**
 * Goes through the values in the iterator. Calls f for each of these and if any
 * of them returns false this returns false (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {boolean} true if every value passes the test.
 * @template THIS, VALUE
 */
goog.iter.every = function(iterable, f, opt_obj) {
  'use strict';
  iterable = goog.iter.toIterator(iterable);

  try {
    while (true) {
      if (!f.call(opt_obj, iterable.nextValueOrThrow(), undefined, iterable)) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return true;
};


/**
 * Takes zero or more iterables and returns one iterator that will iterate over
 * them in the order chained.
 * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator<VALUE>} Returns a new iterator that will
 *     iterate over all the given iterables' contents.
 * @template VALUE
 */
goog.iter.chain = function(var_args) {
  'use strict';
  return goog.iter.chainFromIterable(arguments);
};


/**
 * Takes a single iterable containing zero or more iterables and returns one
 * iterator that will iterate over each one in the order given.
 * @see https://goo.gl/5NRp5d
 * @param {goog.iter.Iterator<?>|goog.iter.Iterable} iterable The iterable of
 *     iterables to chain.
 * @return {!goog.iter.Iterator<VALUE>} Returns a new iterator that will
 *     iterate over all the contents of the iterables contained within
 *     `iterable`.
 * @template VALUE
 */
goog.iter.chainFromIterable = function(iterable) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var iter = new goog.iter.Iterator();
  var current = null;

  iter.nextValueOrThrow = function() {
    'use strict';
    while (true) {
      if (current == null) {
        var it = iterator.nextValueOrThrow();
        current = goog.iter.toIterator(it);
      }
      try {
        return current.nextValueOrThrow();
      } catch (ex) {
        if (ex !== goog.iter.StopIteration) {
          throw ex;
        }
        current = null;
      }
    }
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Builds a new iterator that iterates over the original, but skips elements as
 * long as a supplied function returns true.
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator that drops elements from
 *     the original iterator as long as `f` is true.
 * @template THIS, VALUE
 */
goog.iter.dropWhile = function(iterable, f, opt_obj) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var dropping = true;
  newIter.nextValueOrThrow = function() {
    'use strict';
    while (true) {
      var val = iterator.nextValueOrThrow();
      if (dropping && f.call(opt_obj, val, undefined, iterator)) {
        continue;
      } else {
        dropping = false;
      }
      return val;
    }
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  newIter.next = newIter.nextValueOrThrow.bind(newIter);

  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but only as long as a
 * supplied function returns true.
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj This is used as the 'this' object in f when called.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator that keeps elements in
 *     the original iterator as long as the function is true.
 * @template THIS, VALUE
 */
goog.iter.takeWhile = function(iterable, f, opt_obj) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var iter = new goog.iter.Iterator();
  iter.nextValueOrThrow = function() {
    'use strict';
    var val = iterator.nextValueOrThrow();
    if (f.call(opt_obj, val, undefined, iterator)) {
      return val;
    }
    throw goog.iter.StopIteration;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);

  return iter;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to convert to an array.
 * @return {!Array<VALUE>} An array of the elements the iterator iterates over.
 * @template VALUE
 */
goog.iter.toArray = function(iterable) {
  'use strict';
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray(/** @type {!IArrayLike<?>} */ (iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    'use strict';
    array.push(val);
  });
  return array;
};


/**
 * Iterates over two iterables and returns true if they contain the same
 * sequence of elements and have the same length.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable1 The first
 *     iterable object.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable2 The second
 *     iterable object.
 * @param {function(VALUE,VALUE):boolean=} opt_equalsFn Optional comparison
 *     function.
 *     Should take two arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} true if the iterables contain the same sequence of elements
 *     and have the same length.
 * @template VALUE
 */
goog.iter.equals = function(iterable1, iterable2, opt_equalsFn) {
  'use strict';
  var fillValue = {};
  var pairs = goog.iter.zipLongest(fillValue, iterable1, iterable2);
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  return goog.iter.every(pairs, function(pair) {
    'use strict';
    return equalsFn(pair[0], pair[1]);
  });
};


/**
 * Advances the iterator to the next position, returning the given default value
 * instead of throwing an exception if the iterator has no more entries.
 * @param {goog.iter.Iterator<VALUE>|goog.iter.Iterable} iterable The iterable
 *     object.
 * @param {VALUE} defaultValue The value to return if the iterator is empty.
 * @return {VALUE} The next item in the iteration, or defaultValue if the
 *     iterator was empty.
 * @template VALUE
 */
goog.iter.nextOrValue = function(iterable, defaultValue) {
  'use strict';
  try {
    return goog.iter.toIterator(iterable).nextValueOrThrow();
  } catch (e) {
    if (e != goog.iter.StopIteration) {
      throw e;
    }
    return defaultValue;
  }
};


/**
 * Cartesian product of zero or more sets.  Gives an iterator that gives every
 * combination of one element chosen from each set.  For example,
 * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
 * @see http://docs.python.org/library/itertools.html#itertools.product
 * @param {...!IArrayLike<VALUE>} var_args Zero or more sets, as
 *     arrays.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} An iterator that gives each
 *     n-tuple (as an array).
 * @template VALUE
 */
goog.iter.product = function(var_args) {
  'use strict';
  var someArrayEmpty = Array.prototype.some.call(arguments, function(arr) {
    'use strict';
    return !arr.length;
  });

  // An empty set in a cartesian product gives an empty set.
  if (someArrayEmpty || !arguments.length) {
    return new goog.iter.Iterator();
  }

  var iter = new goog.iter.Iterator();
  var arrays = arguments;

  // The first indices are [0, 0, ...]
  /** @type {?Array<number>} */
  var indicies = goog.array.repeat(0, arrays.length);

  iter.nextValueOrThrow = function() {
    'use strict';
    if (indicies) {
      var retVal = goog.array.map(indicies, function(valueIndex, arrayIndex) {
        'use strict';
        return arrays[arrayIndex][valueIndex];
      });

      // Generate the next-largest indices for the next call.
      // Increase the rightmost index. If it goes over, increase the next
      // rightmost (like carry-over addition).
      for (var i = indicies.length - 1; i >= 0; i--) {
        // Assertion prevents compiler warning below.
        goog.asserts.assert(indicies);
        if (indicies[i] < arrays[i].length - 1) {
          indicies[i]++;
          break;
        }

        // We're at the last indices (the last element of every array), so
        // the iteration is over on the next call.
        if (i == 0) {
          indicies = null;
          break;
        }
        // Reset the index in this column and loop back to increment the
        // next one.
        indicies[i] = 0;
      }
      return retVal;
    }

    throw goog.iter.StopIteration;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Create an iterator to cycle over the iterable's elements indefinitely.
 * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
 * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable object.
 * @return {!goog.iter.Iterator<VALUE>} An iterator that iterates indefinitely
 *     over the values in `iterable`.
 * @template VALUE
 */
goog.iter.cycle = function(iterable) {
  'use strict';
  var baseIterator = goog.iter.toIterator(iterable);

  // We maintain a cache to store the iterable elements as we iterate
  // over them. The cache is used to return elements once we have
  // iterated over the iterable once.
  var cache = [];
  var cacheIndex = 0;

  var iter = new goog.iter.Iterator();

  // This flag is set after the iterable is iterated over once
  var useCache = false;

  iter.nextValueOrThrow = function() {
    'use strict';
    var returnElement = null;

    // Pull elements off the original iterator if not using cache
    if (!useCache) {
      try {
        // Return the element from the iterable
        returnElement = baseIterator.nextValueOrThrow();
        cache.push(returnElement);
        return returnElement;
      } catch (e) {
        // If an exception other than StopIteration is thrown
        // or if there are no elements to iterate over (the iterable was empty)
        // throw an exception
        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
          throw e;
        }
        // set useCache to true after we know that a 'StopIteration' exception
        // was thrown and the cache is not empty (to handle the 'empty iterable'
        // use case)
        useCache = true;
      }
    }

    returnElement = cache[cacheIndex];
    cacheIndex = (cacheIndex + 1) % cache.length;

    return returnElement;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that counts indefinitely from a starting value.
 * @see http://docs.python.org/2/library/itertools.html#itertools.count
 * @param {number=} opt_start The starting value. Default is 0.
 * @param {number=} opt_step The number to increment with between each call to
 *     next. Negative and floating point numbers are allowed. Default is 1.
 * @return {!goog.iter.Iterator<number>} A new iterator that returns the values
 *     in the series.
 */
goog.iter.count = function(opt_start, opt_step) {
  'use strict';
  var counter = opt_start || 0;
  var step = (opt_step !== undefined) ? opt_step : 1;
  var iter = new goog.iter.Iterator();

  iter.nextValueOrThrow = function() {
    'use strict';
    var returnValue = counter;
    counter += step;
    return returnValue;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that returns the same object or value repeatedly.
 * @param {VALUE} value Any object or value to repeat.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator that returns the
 *     repeated value.
 * @template VALUE
 */
goog.iter.repeat = function(value) {
  'use strict';
  var iter = new goog.iter.Iterator();

  iter.nextValueOrThrow = goog.functions.constant(value);
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that returns running totals from the numbers in
 * `iterable`. For example, the array {@code [1, 2, 3, 4, 5]} yields
 * {@code 1 -> 3 -> 6 -> 10 -> 15}.
 * @see http://docs.python.org/3.2/library/itertools.html#itertools.accumulate
 * @param {!goog.iter.Iterator<number>|!goog.iter.Iterable} iterable The
 *     iterable of numbers to accumulate.
 * @return {!goog.iter.Iterator<number>} A new iterator that returns the
 *     numbers in the series.
 */
goog.iter.accumulate = function(iterable) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var total = 0;
  var iter = new goog.iter.Iterator();

  iter.nextValueOrThrow = function() {
    'use strict';
    total += iterator.nextValueOrThrow();
    return total;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in `var_args`. Once the shortest iterable is
 * exhausted, subsequent calls to `nextValueOrThrow()` will throw
 * `goog.iter.StopIteration`.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip
 * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zip = function(var_args) {
  'use strict';
  var args = arguments;
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);
    iter.nextValueOrThrow = function() {
      'use strict';
      var arr = goog.array.map(iterators, function(it) {
        'use strict';
        return it.nextValueOrThrow();
      });
      return arr;
    };
    /**
     * TODO(b/159383578): Please do not remove - this will be cleaned up
     * centrally.
     * @override @see {!goog.iter.Iterator}
     */
    iter.next = iter.nextValueOrThrow.bind(iter);
  }

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in `var_args`. Shorter iterables will be extended
 * with `fillValue`. Once the longest iterable is exhausted, subsequent
 * calls to `nextValueOrThrow()` will throw `goog.iter.StopIteration`.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip_longest
 * @param {VALUE} fillValue The object or value used to fill shorter iterables.
 * @param {...!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zipLongest = function(fillValue, var_args) {
  'use strict';
  var args = Array.prototype.slice.call(arguments, 1);
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);

    iter.nextValueOrThrow = function() {
      'use strict';
      var iteratorsHaveValues = false;  // false when all iterators are empty.
      var arr = goog.array.map(iterators, function(it) {
        'use strict';
        var returnValue;
        try {
          returnValue = it.nextValueOrThrow();
          // Iterator had a value, so we've not exhausted the iterators.
          // Set flag accordingly.
          iteratorsHaveValues = true;
        } catch (ex) {
          if (ex !== goog.iter.StopIteration) {
            throw ex;
          }
          returnValue = fillValue;
        }
        return returnValue;
      });

      if (!iteratorsHaveValues) {
        throw goog.iter.StopIteration;
      }
      return arr;
    };
    /**
     * TODO(b/159383578): Please do not remove - this will be cleaned up
     * centrally.
     * @override @see {!goog.iter.Iterator}
     */
    iter.next = iter.nextValueOrThrow.bind(iter);
  }

  return iter;
};


/**
 * Creates an iterator that filters `iterable` based on a series of
 * `selectors`. On each call to `nextValueOrThrow()`, one item is taken from
 * both the `iterable` and `selectors` iterators. If the item from
 * `selectors` evaluates to true, the item from `iterable` is given.
 * Otherwise, it is skipped. Once either `iterable` or `selectors`
 * is exhausted, subsequent calls to `nextValueOrThrow()` will throw
 * `goog.iter.StopIteration`.
 * @see http://docs.python.org/2/library/itertools.html#itertools.compress
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to filter.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} selectors An
 *     iterable of items to be evaluated in a boolean context to determine if
 *     the corresponding element in `iterable` should be included in the
 *     result.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator that returns the
 *     filtered values.
 * @template VALUE
 */
goog.iter.compress = function(iterable, selectors) {
  'use strict';
  var selectorIterator = goog.iter.toIterator(selectors);

  return goog.iter.filter(iterable, function() {
    'use strict';
    return !!selectorIterator.nextValueOrThrow();
  });
};



/**
 * Implements the `goog.iter.groupBy` iterator.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(VALUE): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the `iterable`. Default
 *     is the identity function.
 * @constructor
 * @extends {goog.iter.Iterator<!Array<?>>}
 * @template KEY, VALUE
 * @private
 */
goog.iter.GroupByIterator_ = function(iterable, opt_keyFunc) {
  'use strict';
  /**
   * The iterable to group, coerced to an iterator.
   * @type {!goog.iter.Iterator}
   */
  this.iterator = goog.iter.toIterator(iterable);

  /**
   * A function for determining the key value for each element in the iterable.
   * If no function is provided, the identity function is used and returns the
   * element unchanged.
   * @type {function(VALUE): KEY}
   */
  this.keyFunc = opt_keyFunc || goog.functions.identity;

  /**
   * The target key for determining the start of a group.
   * @type {KEY}
   */
  this.targetKey;

  /**
   * The current key visited during iteration.
   * @type {KEY}
   */
  this.currentKey;

  /**
   * The current value being added to the group.
   * @type {VALUE}
   */
  this.currentValue;
};
goog.inherits(goog.iter.GroupByIterator_, goog.iter.Iterator);


/** @override */
goog.iter.GroupByIterator_.prototype.nextValueOrThrow = function() {
  'use strict';
  while (this.currentKey == this.targetKey) {
    this.currentValue =
        this.iterator.nextValueOrThrow();  // Exits on StopIteration
    this.currentKey = this.keyFunc(this.currentValue);
  }
  this.targetKey = this.currentKey;
  return [this.currentKey, this.groupItems_(this.targetKey)];
};
/**
 * TODO(b/159383578): Please do not remove - this will be cleaned up centrally.
 * @override @see {!goog.iter.Iterator}
 */
goog.iter.GroupByIterator_.prototype.next =
    goog.iter.GroupByIterator_.prototype.nextValueOrThrow;



/**
 * Performs the grouping of objects using the given key.
 * @param {KEY} targetKey  The target key object for the group.
 * @return {!Array<VALUE>} An array of grouped objects.
 * @private
 */
goog.iter.GroupByIterator_.prototype.groupItems_ = function(targetKey) {
  'use strict';
  var arr = [];
  while (this.currentKey == targetKey) {
    arr.push(this.currentValue);
    try {
      this.currentValue = this.iterator.nextValueOrThrow();
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
      break;
    }
    this.currentKey = this.keyFunc(this.currentValue);
  }
  return arr;
};


/**
 * Creates an iterator that returns arrays containing elements from the
 * `iterable` grouped by a key value. For iterables with repeated
 * elements (i.e. sorted according to a particular key function), this function
 * has a `uniq`-like effect. For example, grouping the array:
 * {@code [A, B, B, C, C, A]} produces
 * {@code [A, [A]], [B, [B, B]], [C, [C, C]], [A, [A]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.groupby
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(VALUE): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the `iterable`. Default
 *     is the identity function.
 * @return {!goog.iter.Iterator<!Array<?>>} A new iterator that returns
 *     arrays of consecutive key and groups.
 * @template KEY, VALUE
 */
goog.iter.groupBy = function(iterable, opt_keyFunc) {
  'use strict';
  return new goog.iter.GroupByIterator_(iterable, opt_keyFunc);
};


/**
 * Gives an iterator that gives the result of calling the given function
 * <code>f</code> with the arguments taken from the next element from
 * <code>iterable</code> (the elements are expected to also be iterables).
 *
 * Similar to {@see goog.iter.map} but allows the function to accept multiple
 * arguments from the iterable.
 *
 * @param {!goog.iter.Iterator<?>|!goog.iter.Iterable} iterable The iterable of
 *     iterables to iterate over.
 * @param {function(this:THIS,...*):RESULT} f The function to call for every
 *     element.  This function takes N+2 arguments, where N represents the
 *     number of items from the next element of the iterable. The two
 *     additional arguments passed to the function are undefined and the
 *     iterator itself. The function should return a new value.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     `f`.
 * @return {!goog.iter.Iterator<RESULT>} A new iterator that returns the
 *     results of applying the function to each element in the original
 *     iterator.
 * @template THIS, RESULT
 */
goog.iter.starMap = function(iterable, f, opt_obj) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var iter = new goog.iter.Iterator();

  iter.nextValueOrThrow = function() {
    'use strict';
    var args = goog.iter.toArray(iterator.nextValueOrThrow());
    return f.apply(opt_obj, goog.array.concat(args, undefined, iterator));
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Returns an array of iterators each of which can iterate over the values in
 * `iterable` without advancing the others.
 * @see http://docs.python.org/2/library/itertools.html#itertools.tee
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to tee.
 * @param {number=} opt_num  The number of iterators to create. Default is 2.
 * @return {!Array<goog.iter.Iterator<VALUE>>} An array of iterators.
 * @template VALUE
 */
goog.iter.tee = function(iterable, opt_num) {
  'use strict';
  var iterator = goog.iter.toIterator(iterable);
  var num = (typeof opt_num === 'number') ? opt_num : 2;
  var buffers = goog.array.map(goog.array.range(num), function() {
    'use strict';
    return [];
  });

  var addNextIteratorValueToBuffers = function() {
    'use strict';
    var val = iterator.nextValueOrThrow();
    goog.array.forEach(buffers, function(buffer) {
      'use strict';
      buffer.push(val);
    });
  };

  var createIterator = function(buffer) {
    'use strict';
    // Each tee'd iterator has an associated buffer (initially empty). When a
    // tee'd iterator's buffer is empty, it calls
    // addNextIteratorValueToBuffers(), adding the next value to all tee'd
    // iterators' buffers, and then returns that value. This allows each
    // iterator to be advanced independently.
    var iter = new goog.iter.Iterator();

    iter.nextValueOrThrow = function() {
      'use strict';
      if (goog.array.isEmpty(buffer)) {
        addNextIteratorValueToBuffers();
      }
      goog.asserts.assert(!goog.array.isEmpty(buffer));
      return buffer.shift();
    };
    /**
     * TODO(b/159383578): Please do not remove - this will be cleaned up
     * centrally.
     * @override @see {!goog.iter.Iterator}
     */
    iter.next = iter.nextValueOrThrow.bind(iter);


    return iter;
  };

  return goog.array.map(buffers, createIterator);
};


/**
 * Creates an iterator that returns arrays containing a count and an element
 * obtained from the given `iterable`.
 * @see http://docs.python.org/2/library/functions.html#enumerate
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to enumerate.
 * @param {number=} opt_start  Optional starting value. Default is 0.
 * @return {!goog.iter.Iterator<!Array<?>>} A new iterator containing
 *     count/item pairs.
 * @template VALUE
 */
goog.iter.enumerate = function(iterable, opt_start) {
  'use strict';
  return goog.iter.zip(goog.iter.count(opt_start), iterable);
};


/**
 * Creates an iterator that returns the first `limitSize` elements from an
 * iterable. If this number is greater than the number of elements in the
 * iterable, all the elements are returned.
 * @see http://goo.gl/V0sihp Inspired by the limit iterator in Guava.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to limit.
 * @param {number} limitSize  The maximum number of elements to return.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator containing
 *     `limitSize` elements.
 * @template VALUE
 */
goog.iter.limit = function(iterable, limitSize) {
  'use strict';
  goog.asserts.assert(goog.math.isInt(limitSize) && limitSize >= 0);

  var iterator = goog.iter.toIterator(iterable);

  var iter = new goog.iter.Iterator();
  var remaining = limitSize;

  iter.nextValueOrThrow = function() {
    'use strict';
    if (remaining-- > 0) {
      return iterator.nextValueOrThrow();
    }
    throw goog.iter.StopIteration;
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that is advanced `count` steps ahead. Consumed
 * values are silently discarded. If `count` is greater than the number
 * of elements in `iterable`, an empty iterator is returned. Subsequent
 * calls to `nextValueOrThrow()` will throw `goog.iter.StopIteration`.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to consume.
 * @param {number} count  The number of elements to consume from the iterator.
 * @return {!goog.iter.Iterator<VALUE>} An iterator advanced zero or more steps
 *     ahead.
 * @template VALUE
 */
goog.iter.consume = function(iterable, count) {
  'use strict';
  goog.asserts.assert(goog.math.isInt(count) && count >= 0);

  var iterator = goog.iter.toIterator(iterable);

  while (count-- > 0) {
    goog.iter.nextOrValue(iterator, null);
  }

  return iterator;
};


/**
 * Creates an iterator that returns a range of elements from an iterable.
 * Similar to {@see goog.array.slice} but does not support negative indexes.
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to slice.
 * @param {number} start  The index of the first element to return.
 * @param {number=} opt_end  The index after the last element to return. If
 *     defined, must be greater than or equal to `start`.
 * @return {!goog.iter.Iterator<VALUE>} A new iterator containing a slice of
 *     the original.
 * @template VALUE
 */
goog.iter.slice = function(iterable, start, opt_end) {
  'use strict';
  goog.asserts.assert(goog.math.isInt(start) && start >= 0);

  var iterator = goog.iter.consume(iterable, start);

  if (typeof opt_end === 'number') {
    goog.asserts.assert(goog.math.isInt(opt_end) && opt_end >= start);
    iterator = goog.iter.limit(iterator, opt_end - start /* limitSize */);
  }

  return iterator;
};


/**
 * Checks an array for duplicate elements.
 * @param {?IArrayLike<VALUE>} arr The array to check for
 *     duplicates.
 * @return {boolean} True, if the array contains duplicates, false otherwise.
 * @private
 * @template VALUE
 */
// TODO(dlindquist): Consider moving this into goog.array as a public function.
goog.iter.hasDuplicates_ = function(arr) {
  'use strict';
  var deduped = [];
  goog.array.removeDuplicates(arr, deduped);
  return arr.length != deduped.length;
};


/**
 * Creates an iterator that returns permutations of elements in
 * `iterable`.
 *
 * Permutations are obtained by taking the Cartesian product of
 * `opt_length` iterables and filtering out those with repeated
 * elements. For example, the permutations of {@code [1,2,3]} are
 * {@code [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.permutations
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate permutations.
 * @param {number=} opt_length Length of each permutation. If omitted, defaults
 *     to the length of `iterable`.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing the
 *     permutations of `iterable`.
 * @template VALUE
 */
goog.iter.permutations = function(iterable, opt_length) {
  'use strict';
  var elements = goog.iter.toArray(iterable);
  var length = (typeof opt_length === 'number') ? opt_length : elements.length;

  var sets = goog.array.repeat(elements, length);
  var product = goog.iter.product.apply(undefined, sets);

  return goog.iter.filter(product, function(arr) {
    'use strict';
    return !goog.iter.hasDuplicates_(arr);
  });
};


/**
 * Creates an iterator that returns combinations of elements from
 * `iterable`.
 *
 * Combinations are obtained by taking the {@see goog.iter.permutations} of
 * `iterable` and filtering those whose elements appear in the order they
 * are encountered in `iterable`. For example, the 3-length combinations
 * of {@code [0,1,2,3]} are {@code [[0,1,2], [0,1,3], [0,2,3], [1,2,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate combinations.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing
 *     combinations from the `iterable`.
 * @template VALUE
 */
goog.iter.combinations = function(iterable, length) {
  'use strict';
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.iter.range(elements.length);
  var indexIterator = goog.iter.permutations(indexes, length);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    'use strict';
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.nextValueOrThrow = function() {
    'use strict';
    return goog.array.map(
        sortedIndexIterator.nextValueOrThrow(), getIndexFromElements);
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};


/**
 * Creates an iterator that returns combinations of elements from
 * `iterable`, with repeated elements possible.
 *
 * Combinations are obtained by taking the Cartesian product of `length`
 * iterables and filtering those whose elements appear in the order they are
 * encountered in `iterable`. For example, the 2-length combinations of
 * {@code [1,2,3]} are {@code [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]}.
 * @see https://goo.gl/C0yXe4
 * @see https://goo.gl/djOCsk
 * @param {!goog.iter.Iterator<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to combine.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator<!Array<VALUE>>} A new iterator containing
 *     combinations from the `iterable`.
 * @template VALUE
 */
goog.iter.combinationsWithReplacement = function(iterable, length) {
  'use strict';
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.array.range(elements.length);
  var sets = goog.array.repeat(indexes, length);
  var indexIterator = goog.iter.product.apply(undefined, sets);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    'use strict';
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.nextValueOrThrow = function() {
    'use strict';
    return goog.array.map(
        /** @type {!Array<number>} */
        (sortedIndexIterator.nextValueOrThrow()), getIndexFromElements);
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  iter.next = iter.nextValueOrThrow.bind(iter);


  return iter;
};

//third_party/javascript/closure/iter/es6.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Shims between goog.iter.Iterator and ES6 iterator.
 */

goog.module('goog.iter.es6');
goog.module.declareLegacyNamespace();

const GoogIterable = goog.require('goog.iter.Iterable');
const GoogIterator = goog.require('goog.iter.Iterator');
const StopIteration = goog.require('goog.iter.StopIteration');


/**
 * Common interface extending both `goog.iter.Iterable` and ES6 `Iterable`,
 * and providing `toGoog()` and `toEs6()` methods to get either kind
 * of iterator.  `ShimIterable.of()` is the primary entry point for
 * this library.  If it is given an iterable that is *not* also an
 * iterator, then it will inherit any reusability from its argument
 * (i.e. `ShimIterable.of(mySet)` will be reusable, since mySet makes
 * a fresh Iterator every time, whereas `ShimIterable.of(myIterator)`
 * will be one-shot).
 *
 * `ShimGoogIterator` and `ShimEs6Iterator` extend `ShimIterable` and
 * also implement one or the other iterator API.  Since they extend
 * `ShimIterable`, it is easy to convert back and forth between the two
 * APIs.  Any such conversion will expose a view to the same underlying
 * iterator, so elements pulled via one API will not be available from
 * the other.
 *
 * @interface
 * @extends {Iterable<VALUE>}
 * @template VALUE
 */
class ShimIterable {
  /** @return {!GoogIterator<VALUE>} */
  __iterator__() {}

  /** @return {!ShimGoogIterator<VALUE>} */
  toGoog() {}

  /** @return {!ShimEs6Iterator<VALUE>} */
  toEs6() {}

  /**
   * @param {!Iterable<VALUE>|!Iterator<VALUE>|
   *         !GoogIterator<VALUE>|!GoogIterable} iter
   * @return {!ShimIterable}
   * @template VALUE
   */
  static of(iter) {
    if (iter instanceof ShimIterableImpl || iter instanceof ShimGoogIterator ||
        iter instanceof ShimEs6Iterator) {
      return iter;
    } else if (typeof iter.next == 'function') {
      return new ShimIterableImpl(
          () => wrapGoog(/** @type {!Iterator|!GoogIterator} */ (iter)));
    } else if (typeof iter[Symbol.iterator] == 'function') {
      return new ShimIterableImpl(() => iter[Symbol.iterator]());
    } else if (typeof iter.__iterator__ == 'function') {
      return new ShimIterableImpl(
          () => wrapGoog(
              /** @type {{__iterator__:function(this:?, boolean=)}} */ (iter)
                  .__iterator__()));
    }
    throw new Error('Not an iterator or iterable.');
  }
}


/**
 * @param {!GoogIterator<VALUE>|!Iterator<VALUE>} iter
 * @return {!Iterator<VALUE>}
 * @template VALUE
 */
const wrapGoog = (iter) => {
  if (!(iter instanceof GoogIterator)) return iter;
  let done = false;
  return /** @type {?} */ ({
    next() {
      let value;
      while (!done) {
        try {
          value = iter.nextValueOrThrow();
          break;
        } catch (err) {
          if (err !== StopIteration) throw err;
          done = true;
        }
      }
      return {value, done};
    },
  });
};


/**
 * Concrete (private) implementation of a non-iterator iterable.  This is
 * separate from the iterator versions since it supports iterables that
 * are not "one-shot".
 * @implements {ShimIterable<VALUE>}
 * @template VALUE
 */
class ShimIterableImpl {
  /** @param {function(): !Iterator<VALUE>} func */
  constructor(func) {
    /** @const @private */
    this.func_ = func;
  }

  /** @override */
  __iterator__() {
    return new ShimGoogIterator(this.func_());
  }

  /** @override */
  toGoog() {
    return new ShimGoogIterator(this.func_());
  }

  /** @override */
  [Symbol.iterator]() {
    return new ShimEs6Iterator(this.func_());
  }

  /** @override */
  toEs6() {
    return new ShimEs6Iterator(this.func_());
  }
}


/**
 * Concrete `goog.iter.Iterator` subclass that also implements `ShimIterable`.
 * @extends {GoogIterator<VALUE>}
 * @implements {ShimIterable<VALUE>}
 * @template VALUE
 */
class ShimGoogIterator extends GoogIterator {
  /** @param {!Iterator<VALUE>} iter */
  constructor(iter) {
    super();
    this.iter_ = iter;
  }

  /** @override */
  nextValueOrThrow() {
    const result = this.iter_.next();
    if (result.done) throw StopIteration;
    return result.value;
  }
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  next() {
    return ShimGoogIterator.prototype.nextValueOrThrow.call(this);
  }


  /** @override */
  toGoog() {
    return this;
  }

  /** @override */
  [Symbol.iterator]() {
    return new ShimEs6Iterator(this.iter_);
  }

  /** @override */
  toEs6() {
    return new ShimEs6Iterator(this.iter_);
  }
}


/**
 * Concrete ES6 `Iterator` that also implements `ShimIterable`.
 * @implements {IteratorIterable<VALUE>}
 * @extends {ShimIterableImpl<VALUE>}
 * @template VALUE
 */
class ShimEs6Iterator extends ShimIterableImpl {
  /** @param {!Iterator<VALUE>} iter */
  constructor(iter) {
    super(() => iter);
    /** @const @private */
    this.iter_ = iter;
  }

  /** @override */
  next() {
    return this.iter_.next();
  }
}


exports = {
  ShimIterable,
  ShimEs6Iterator,
  ShimGoogIterator,
};

;return exports;});

//third_party/javascript/closure/structs/map.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Datastructure: Hash Map.
 *
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes. This
 * is best suited for complex key types. For simple keys such as numbers and
 * strings consider using the lighter-weight utilities in goog.object.
 * MOE:begin_intracomment_strip
 *
 * NOTE(flan): Internally, key types are NOT actually cast to
 * strings. Some people actually rely on this behavior even though it
 * is incorrect. For more information, see http://b/5622311.
 *
 * NOTE(flan): Erik Corry (erikcorry) from the V8 team went over this
 * class with me to help look for simplifications and
 * optimizations. In the end, he didn't come up with very much. Erik
 * explained that "for (k in o)" is not optimized in Crankshaft
 * because it needs to look up properties in the whole prototype
 * chain. It also needs to return the keys in order. Thus keeping an
 * array of keys is actually much more efficient.
 *
 * Likewise, one option to iterate safely with "for (k in o)" is to
 * prefix the keys with some character, like ':'. This can create a
 * lot of strings that didn't exist before. In Closure Labs,
 * goog.labs.structs.Map uses extra arrays to store non-safe keys and
 * values.
 *
 * Thus, there are not a lot of reasonable simplifications that can be
 * done here without impacting performance.
 *
 * TODO(chrishenry): Create some performance benchmarks for common
 * operations.
 * MOE:end_intracomment_strip
 * @deprecated goog.structs.Map is deprecated in favour of ES6 Maps.
 */


goog.provide('goog.structs.Map');

goog.require('goog.collections.iters');
goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.iter.es6');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 * @template K, V
 * @deprecated This type is misleading: use ES6 Map instead.
 */
goog.structs.Map = function(opt_map, var_args) {
  'use strict';
  /**
   * Underlying JS object used to implement the map.
   * @private {!Object}
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @private {!Array<string>}
   */
  this.keys_ = [];

  /**
   * The number of key value pairs in the map.
   * @const {number}
   */
  this.size = 0;

  /**
   * Version used to detect changes while iterating.
   * @private {number}
   */
  this.version_ = 0;

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw new Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {!Object} */ (opt_map));
  }
};


/**
 * @return {number} The number of key-value pairs in the map.
 * @deprecated Use the `size` property instead, for alignment with ES6 Map.
 */
goog.structs.Map.prototype.getCount = function() {
  'use strict';
  return this.size;
};


/**
 * Returns the values of the map.
 * @return {!Array<V>} The values in the map.
 * @deprecated Use `Array.from(map.values())` instead, for alignment with ES6
 *     Map.
 */
goog.structs.Map.prototype.getValues = function() {
  'use strict';
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array<string>} Array of string values.
 * @deprecated Use `Array.from(map.keys())` instead, for alignment with ES6 Map.
 */
goog.structs.Map.prototype.getKeys = function() {
  'use strict';
  this.cleanupKeysArray_();
  return /** @type {!Array<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 * @deprecated Use `has` instead, for alignment with ES6 Map.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  'use strict';
  return this.has(key);
};

/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.has = function(key) {
  'use strict';
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {V} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  'use strict';
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(V, V): boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 * @deprecated Use goog.collections.maps.equals(thisMap, otherMap,
 *     opt_equalityFn) instead, for alignment with ES6 Map.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  'use strict';
  if (this === otherMap) {
    return true;
  }

  if (this.size != otherMap.getCount()) {
    return false;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return false;
    }
  }

  return true;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  'use strict';
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 * @deprecated Use the size property and compare against 0, for alignment with
 *     ES6 Map.
 */
goog.structs.Map.prototype.isEmpty = function() {
  'use strict';
  return this.size == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  'use strict';
  this.map_ = {};
  this.keys_.length = 0;
  this.setSizeInternal_(0);
  this.version_ = 0;
};



/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 * @deprecated Use `delete` instead, for alignment with ES6 Map.
 */
goog.structs.Map.prototype.remove = function(key) {
  return this.delete(key);
};

/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due
 * to updating the keys array whenever the count becomes half the size of
 * the keys in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.delete = function(key) {
  'use strict';
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.setSizeInternal_(this.size - 1);
    this.version_++;

    // clean up the keys array if the threshold is hit
    if (this.keys_.length > 2 * this.size) {
      this.cleanupKeysArray_();
    }

    return true;
  }
  return false;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  'use strict';
  if (this.size != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.size != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return `undefined`.
 * @param {*} key The key to get the value for.
 * @param {DEFAULT=} opt_val The value to return if no item is found for the
 *     given key, defaults to undefined.
 * @return {V|DEFAULT} The value for the given key.
 * @template DEFAULT
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  'use strict';
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {V} value The value to add.
 */
goog.structs.Map.prototype.set = function(key, value) {
  'use strict';
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.setSizeInternal_(this.size + 1);
    // TODO(johnlenz): This class lies, it claims to return an array of string
    // keys, but instead returns the original object used.
    this.keys_.push(/** @type {?} */ (key));
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {?Object} map Object containing the data to add.
 * @deprecated Use goog.collections.maps.setAll(thisMap, map.entries()) if map
 *     is an ES6 or goog.structs Map, or
 *     goog.collections.maps.setAll(thisMap, Object.entries(map)) otherwise.
 */
goog.structs.Map.prototype.addAll = function(map) {
  'use strict';
  if (map instanceof goog.structs.Map) {
    var keys = map.getKeys();
    for (var i = 0; i < keys.length; i++) {
      this.set(keys[i], map.get(keys[i]));
    }
  } else {
    for (var key in map) {
      this.set(key, map[key]);
    }
  }
};


/**
 * Calls the given function on each entry in the map.
 * @param {function(this:T, V, K, goog.structs.Map<K,V>)} f
 * @param {T=} opt_obj The value of "this" inside f.
 * @template T
 * @deprecated Use ES6 Iteration instead.
 */
goog.structs.Map.prototype.forEach = function(f, opt_obj) {
  'use strict';
  var keys = this.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = this.get(key);
    f.call(opt_obj, value, key, this);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 * @deprecated Use `new Map(thisMap.entries())` instead, for alignment with
 *     ES6 Map.
 */
goog.structs.Map.prototype.clone = function() {
  'use strict';
  return new goog.structs.Map(this);
};


/**
 * Returns a new map in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * It acts very similarly to {goog.object.transpose(Object)}.
 *
 * @return {!goog.structs.Map} The transposed map.
 * @deprecated Use goog.collections.maps.transpose instead, for alignment with
 *     ES6 Maps.
 */
goog.structs.Map.prototype.transpose = function() {
  'use strict';
  var transposed = new goog.structs.Map();
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    var value = this.map_[key];
    transposed.set(value, key);
  }

  return transposed;
};


/**
 * @return {!Object} Object representation of the map.
 * @deprecated Use goog.collections.maps.toObject(thisMap) instead, for aligment
 *     with ES6 Maps.
 */
goog.structs.Map.prototype.toObject = function() {
  'use strict';
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the keys in the map.  Removal of keys
 * while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the keys in the map.
 * @deprecated Use `keys()` with native iteration protocols, for alignment
 *     with ES6 Map.
 */
goog.structs.Map.prototype.getKeyIterator = function() {
  'use strict';
  return this.__iterator__(true);
};

/**
 * @return {!IteratorIterable<K>} An ES6 Iterator that iterates over the maps
 *     keys.
 */
goog.structs.Map.prototype.keys = function() {
  'use strict';
  return goog.iter.es6.ShimIterable.of(this.getKeyIterator()).toEs6();
};


/**
 * Returns an iterator that iterates over the values in the map.  Removal of
 * keys while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the values in the map.
 * @deprecated Use `values()` with native iteration protocols, for alignment
 *     with ES6 Map.
 */
goog.structs.Map.prototype.getValueIterator = function() {
  'use strict';
  return this.__iterator__(false);
};

/**
 * @return {!IteratorIterable<V>} An ES6 Iterator that iterates over the maps
 *     values.
 */
goog.structs.Map.prototype.values = function() {
  'use strict';
  return goog.iter.es6.ShimIterable.of(this.getValueIterator()).toEs6();
};

/**
 * @return {!IteratorIterable<!Array<K|V>>} An iterator of entries in this map.
 *     The type is actually Array<[K,V]> but this is not representable in the
 *     Closure Type System.
 */
goog.structs.Map.prototype.entries = function() {
  const self = this;
  return goog.collections.iters.map(this.keys(), function(key) {
    return [key, self.get(key)];
  });
};

/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 * @deprecated Call either `keys` or `values` and use native iteration, for
 *     alignment with ES6 Map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  'use strict';
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.nextValueOrThrow = function() {
    'use strict';
    if (version != selfObj.version_) {
      throw new Error('The map has changed since the iterator was created');
    }
    if (i >= selfObj.keys_.length) {
      throw goog.iter.StopIteration;
    }
    var key = selfObj.keys_[i++];
    return opt_keys ? key : selfObj.map_[key];
  };
  /**
   * TODO(b/159383578): Please do not remove - this will be cleaned up
   * centrally.
   * @override @see {!goog.iter.Iterator}
   */
  newIter.next = newIter.nextValueOrThrow.bind(newIter);

  return newIter;
};


/**
 * Assigns to the size property to isolate supressions of const assignment to
 * only where they are needed.
 * @param {number} newSize The size to update to.
 * @private
 */
goog.structs.Map.prototype.setSizeInternal_ = function(newSize) {
  /** @suppress {const} */
  this.size = newSize;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {!Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  'use strict';
  return Object.prototype.hasOwnProperty.call(obj, key);
};

//analytics/tracking/chrome/base_types.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Basic types used by GA Closure API.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.provide('analytics');
goog.provide('analytics.EventHit');
goog.provide('analytics.ExceptionHit');
goog.provide('analytics.HitType');
goog.provide('analytics.HitTypes');
goog.provide('analytics.ItemHit');
goog.provide('analytics.Parameter');
goog.provide('analytics.Parameters');
goog.provide('analytics.SocialHit');
goog.provide('analytics.TimingHit');
goog.provide('analytics.TransactionHit');
goog.provide('analytics.Value');
goog.provide('analytics.ValueType');
goog.provide('analytics.ValueTypes');

goog.require('goog.structs.Map');


/**
 * A type alias for all HitType values.
 * @typedef {string}
 */
analytics.HitType;


/**
 * The type of hit.
 * @enum {analytics.HitType}
 */
analytics.HitTypes = {
  APPVIEW: 'appview',
  EVENT: 'event',
  SOCIAL: 'social',
  TRANSACTION: 'transaction',
  ITEM: 'item',
  TIMING: 'timing',
  EXCEPTION: 'exception'
};


/**
 * A type alias for all ValueType values.
 * @typedef {string}
 */
analytics.ValueType;


/**
 * The type of value.
 * @enum {analytics.ValueType}
 */
analytics.ValueTypes = {
  TEXT: 'text',
  INTEGER: 'integer',
  BOOLEAN: 'boolean',
  CURRENCY: 'currency',
  FLOAT: 'float'
};


/**
 * A value associated with a parameter.
 * @typedef {string|number|boolean}
 */
analytics.Value;


/**
 * Typedef for analytics.HitTypes.APPVIEW hit types.
 * @typedef {{
 *   description: string
 * }}
 */
analytics.AppViewHit;


/**
 * Typedef for analytics.HitTypes.EVENT hit types.
 * @typedef {{
 *   eventCategory: string,
 *   eventAction: string,
 *   eventLabel: (string|undefined),
 *   eventValue: (number|undefined)
 * }}
 */
analytics.EventHit;


/**
 * Typedef for analytics.HitTypes.SOCIAL hit types.
 * @typedef {{
 *   socialNetwork: string,
 *   socialAction: string,
 *   socialTarget: string
 * }}
 */
analytics.SocialHit;


/**
 * Typedef for analytics.HitTypes.TRANSACTION hit types.
 * @typedef {{
 *   transactionId: string,
 *   transactionAffiliation: (string|undefined),
 *   transactionRevenue: (number|undefined),
 *   transactionShipping: (number|undefined),
 *   transactionTax: (number|undefined),
 *   currencyCode: (string|undefined)
 * }}
 */
analytics.TransactionHit;


/**
 * Typedef for analytics.HitTypes.ITEM hit types.
 * @typedef {{
 *   transactionId: string,
 *   itemName: string,
 *   itemPrice: (number|undefined),
 *   itemQuantity: (number|undefined),
 *   itemCode: (string|undefined),
 *   itemCategory: (string|undefined),
 *   currencyCode: (string|undefined)
 * }}
 */
analytics.ItemHit;


/**
 * Typedef for analytics.HitTypes.EXCEPTION hit types.
 * @typedef {{
 *   exDescription: (string|undefined),
 *   exFatal: (boolean|undefined)
 * }}
 */
analytics.ExceptionHit;


/**
 * Typedef for analytics.HitTypes.TIMING hit types.
 * @typedef {{
 *   timingCategory: (string),
 *   timingVar: (string),
 *   timingValue: (number),
 *   timingLabel: (string|undefined)
 * }}
 */
analytics.TimingHit;


/**
 * A Parameter instance.
 * @typedef {{
 *   id: string,
 *   name: string,
 *   valueType: analytics.ValueType,
 *   maxLength: (number|undefined),
 *   defaultValue: (string|undefined)
 * }}
 */
analytics.Parameter;


/**
 * All supported public hit parameters excepting DIMENSION[0-199]
 * and METRIC[0-199] which must be created with a user supplied index.
 *
 * @see analytics.createDimensionParam
 * @see analytics.createMetricParam
 *
 * @enum {analytics.Parameter}
 */
analytics.Parameters = {
  /* Hit type */
  HIT_TYPE: {
    id: 'hitType',
    name: 't',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Anonymize IP */
  ANONYMIZE_IP: {
    id: 'anonymizeIp',
    name: 'aip',
    valueType: analytics.ValueTypes.BOOLEAN,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Queue Time */
  QUEUE_TIME: {
    id: 'queueTime',
    name: 'qt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Cache Buster */
  CACHE_BUSTER: {
    id: 'cacheBuster',
    name: 'z',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Session Control */
  SESSION_CONTROL: {
    id: 'sessionControl',
    name: 'sc',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Session Group */
  SESSION_GROUP: {
    id: 'sessionGroup',
    name: 'sg',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* User ID */
  USER_ID: {
    id: 'userId',
    name: 'uid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Non-Interaction Hit */
  NON_INTERACTION: {
    id: 'nonInteraction',
    name: 'ni',
    valueType: analytics.ValueTypes.BOOLEAN,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Content Description */
  DESCRIPTION: {
    id: 'description',
    name: 'cd',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 2048,
    defaultValue: undefined
  },
  /* Document Title */
  TITLE: {
    id: 'title',
    name: 'dt',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 1500,
    defaultValue: undefined
  },
  /* Application ID */
  APP_ID: {
    id: 'appId',
    name: 'aid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  },
  /* Application Installer ID */
  APP_INSTALLER_ID: {
    id: 'appInstallerId',
    name: 'aiid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  },
  /* Event Category */
  EVENT_CATEGORY: {
    id: 'eventCategory',
    name: 'ec',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  },
  /* Event Action */
  EVENT_ACTION: {
    id: 'eventAction',
    name: 'ea',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Event Label */
  EVENT_LABEL: {
    id: 'eventLabel',
    name: 'el',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Event Value */
  EVENT_VALUE: {
    id: 'eventValue',
    name: 'ev',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Social Network */
  SOCIAL_NETWORK: {
    id: 'socialNetwork',
    name: 'sn',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 50,
    defaultValue: undefined
  },
  /* Social Action */
  SOCIAL_ACTION: {
    id: 'socialAction',
    name: 'sa',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 50,
    defaultValue: undefined
  },
  /* Social Action Target */
  SOCIAL_TARGET: {
    id: 'socialTarget',
    name: 'st',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 2048,
    defaultValue: undefined
  },
  /* Transaction ID */
  TRANSACTION_ID: {
    id: 'transactionId',
    name: 'ti',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Transaction Affiliation */
  TRANSACTION_AFFILIATION: {
    id: 'transactionAffiliation',
    name: 'ta',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Transaction Revenue */
  TRANSACTION_REVENUE: {
    id: 'transactionRevenue',
    name: 'tr',
    valueType: analytics.ValueTypes.CURRENCY,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Transaction Shipping */
  TRANSACTION_SHIPPING: {
    id: 'transactionShipping',
    name: 'ts',
    valueType: analytics.ValueTypes.CURRENCY,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Transaction Tax */
  TRANSACTION_TAX: {
    id: 'transactionTax',
    name: 'tt',
    valueType: analytics.ValueTypes.CURRENCY,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Currency Code */
  CURRENCY_CODE: {
    id: 'currencyCode',
    name: 'cu',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 10,
    defaultValue: undefined
  },
  /* Item Price */
  ITEM_PRICE: {
    id: 'itemPrice',
    name: 'ip',
    valueType: analytics.ValueTypes.CURRENCY,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Item Quantity */
  ITEM_QUANTITY: {
    id: 'itemQuantity',
    name: 'iq',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Item Code */
  ITEM_CODE: {
    id: 'itemCode',
    name: 'ic',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Item Name */
  ITEM_NAME: {
    id: 'itemName',
    name: 'in',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Item Category */
  ITEM_CATEGORY: {
    id: 'itemCategory',
    name: 'iv',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Campaign Source */
  CAMPAIGN_SOURCE: {
    id: 'campaignSource',
    name: 'cs',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 100,
    defaultValue: undefined
  },
  /* Campaign Medium */
  CAMPAIGN_MEDIUM: {
    id: 'campaignMedium',
    name: 'cm',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 50,
    defaultValue: undefined
  },
  /* Campaign Name */
  CAMPAIGN_NAME: {
    id: 'campaignName',
    name: 'cn',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 100,
    defaultValue: undefined
  },
  /* Campaign Keyword */
  CAMPAIGN_KEYWORD: {
    id: 'campaignKeyword',
    name: 'ck',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Campaign Content */
  CAMPAIGN_CONTENT: {
    id: 'campaignContent',
    name: 'cc',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Campaign ID */
  CAMPAIGN_ID: {
    id: 'campaignId',
    name: 'ci',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 100,
    defaultValue: undefined
  },
  /* Google AdWords ID */
  GCLID: {
    id: 'gclid',
    name: 'gclid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Google Display Ads ID */
  DCLID: {
    id: 'dclid',
    name: 'dclid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Page Load Time */
  PAGE_LOAD_TIME: {
    id: 'pageLoadTime',
    name: 'plt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* DNS Time */
  DNS_TIME: {
    id: 'dnsTime',
    name: 'dns',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* TCP Connect Time */
  TCP_CONNECT_TIME: {
    id: 'tcpConnectTime',
    name: 'tcp',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Server Response Time */
  SERVER_RESPONSE_TIME: {
    id: 'serverResponseTime',
    name: 'srt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Page Download Time */
  PAGE_DOWNLOAD_TIME: {
    id: 'pageDownloadTime',
    name: 'pdt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Redirect Response Time */
  REDIRECT_RESPONSE_TIME: {
    id: 'redirectResponseTime',
    name: 'rrt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* User timing category */
  TIMING_CATEGORY: {
    id: 'timingCategory',
    name: 'utc',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  },
  /* User timing variable name */
  TIMING_VAR: {
    id: 'timingVar',
    name: 'utv',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* User timing time */
  TIMING_VALUE: {
    id: 'timingValue',
    name: 'utt',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* User timing label */
  TIMING_LABEL: {
    id: 'timingLabel',
    name: 'utl',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 500,
    defaultValue: undefined
  },
  /* Exception Description */
  EX_DESCRIPTION: {
    id: 'exDescription',
    name: 'exd',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  },
  /* Is Exception Fatal? */
  EX_FATAL: {
    id: 'exFatal',
    name: 'exf',
    valueType: analytics.ValueTypes.BOOLEAN,
    maxLength: undefined,
    defaultValue: '1'
  }
};


/**
 * Returns a new DIMENSION param.
 *
 * @param {number} index Each dimension has an index configured in
 *    the Google Analytics admin console. This is that value.
 *    It must be between 1 and 200.
 * @return {!analytics.Parameter}
 */
analytics.createDimensionParam = function(index) {
  if (index < 1 || index > 200) {
    throw new Error(
        'Expected dimension index range 1-200, but was : ' + index);
  }
  return {
    id: 'dimension' + index,
    name: 'cd' + index,
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 150,
    defaultValue: undefined
  };
};


/**
 * Returns a new METRIC param.
 *
 * @param {number} index Each metric has an index configured in
 *    the Google Analytics admin console. This is that value.
 *    It must be between 1 and 200.
 * @return {!analytics.Parameter}
 */
analytics.createMetricParam = function(index) {
  if (index < 1 || index > 200) {
    throw new Error(
        'Expected metric index range 1-200, but was : ' + index);
  }
  return {
    id: 'metric' + index,
    name: 'cm' + index,
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  };
};

//analytics/tracking/chrome/internal/internal_types.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Internal-only types used by GA Closure API, and helper
 * methods.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.provide('analytics.internal.Parameters');
goog.provide('analytics.internal.parameters');

goog.require('analytics');
goog.require('analytics.Parameters');
goog.require('analytics.ValueTypes');
goog.require('goog.object');


/**
 * Parameters used by the library.
 * @enum {analytics.Parameter}
 */
analytics.internal.Parameters = {
  /* Anonymize IP Addresses */
  ANONYMIZE_IP: {
    id: 'anonymizeIp',
    name: 'aip',
    valueType: analytics.ValueTypes.BOOLEAN,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Protocol Version */
  API_VERSION: {
    id: 'apiVersion',
    name: 'v',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Application Name */
  APP_NAME: {
    id: 'appName',
    name: 'an',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 100,
    defaultValue: undefined
  },
  /* Application Version */
  APP_VERSION: {
    id: 'appVersion',
    name: 'av',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 100,
    defaultValue: undefined
  },
  /* Client ID */
  CLIENT_ID: {
    id: 'clientId',
    name: 'cid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* User Language */
  LANGUAGE: {
    id: 'language',
    name: 'ul',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 20,
    defaultValue: undefined
  },
  /* Library version. For internal use only. */
  LIBRARY_VERSION: {
    id: 'libVersion',
    name: '_v',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* User sample rate override */
  SAMPLE_RATE_OVERRIDE: {
    id: 'sampleRateOverride',
    name: 'usro',
    valueType: analytics.ValueTypes.INTEGER,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Screen Colors */
  SCREEN_COLORS: {
    id: 'screenColors',
    name: 'sd',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 20,
    defaultValue: undefined
  },
  /* Screen Resolution */
  SCREEN_RESOLUTION: {
    id: 'screenResolution',
    name: 'sr',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 20,
    defaultValue: undefined
  },
  /* Tracking ID / Web Property ID */
  TRACKING_ID: {
    id: 'trackingId',
    name: 'tid',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: undefined,
    defaultValue: undefined
  },
  /* Viewport size */
  VIEWPORT_SIZE: {
    id: 'viewportSize',
    name: 'vp',
    valueType: analytics.ValueTypes.TEXT,
    maxLength: 20,
    defaultValue: undefined
  }
};


/**
 * Converts a string to a Parameter, or if a Parameter is passed in,
 * simply returns that Parameter.
 *
 * @param {!analytics.Parameter|string} param A Parameter
 *     from the analytics.Parameters enum, or a string representing a
 *     non-standard Parameter. Currently the only non-standard strings
 *     that are supported are 'metricX' and 'dimensionX' where X is a number.
 * @return {!analytics.Parameter} The parameter definition matching the
 *     given param or name. If no such definition exists, one will be created,
 *     provided that the name can be matched to a known parameter.
 */
analytics.internal.parameters.asParameter = function(param) {
  if (typeof param !== 'string') {
    return param;
  }

  var definition = analytics.internal.parameters.findParameter_(
      param, analytics.Parameters);

  if (goog.isObject(definition)) {
    return definition;
  }

  definition = analytics.internal.parameters.findParameter_(
      param, analytics.internal.Parameters);

  if (goog.isObject(definition)) {
    return definition;
  }

  // If the parameter isn't one of the built in types, check whether it's a
  // valid custom dimension or custom metric. See
  // https://developers.google.com/analytics/devguides/platform/features/customdimsmets
  var match = /^dimension(\d+)$/.exec(param);
  if (match !== null) {
    return analytics.createDimensionParam(parseInt(match[1], 10));
  }
  match = /^metric(\d+)$/.exec(param);
  if (match !== null) {
    return analytics.createMetricParam(parseInt(match[1], 10));
  }

  throw new Error(param + ' is not a valid parameter name.');
};


/**
 * Returns the matchign parameter in the enum, or null if not found.
 *
 * @param {string} id The id of the parameter to find.
 * @param {!Object} params An enum of
 *     `analytics.Parameter` definitions to seach for a matching param.
 * @return {?analytics.Parameter} The matched param, or null if a match
 *     cannot be found.
 * @private
 */
analytics.internal.parameters.findParameter_ = function(id, params) {
  var definition = goog.object.findValue(
      params,
      /** @param {!analytics.Parameter} instance */
      function(instance) {
        // Match if this is a recognized "id" (which happens
        // to be the human readable string). Don't match on
        // 'metric' and 'dimension' as we provide
        // special handling of those parameters below.
        return instance.id == id &&
            id != 'metric' &&
            id != 'dimension';
      });

  return goog.isObject(definition) ? definition : null;
};

//third_party/javascript/closure/structs/structs.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 * @suppress {strictMissingProperties}
 */


goog.provide('goog.structs');

goog.require('goog.array');
goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  'use strict';
  if (col.getCount && typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array<?>} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  'use strict';
  if (col.getValues && typeof col.getValues == 'function') {
    return col.getValues();
  }
  // ES6 Map and Set both define a values function that returns an iterator.
  // The typeof check allows the compiler to remove the Map and Set polyfills
  // if they are otherwise unused throughout the entire binary.
  if ((typeof Map !== 'undefined' && col instanceof Map) ||
      (typeof Set !== 'undefined' && col instanceof Set)) {
    return Array.from(col.values());
  }
  if (typeof col === 'string') {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  'use strict';
  if (col.getKeys && typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (col.getValues && typeof col.getValues == 'function') {
    return undefined;
  }
  // ES6 Map and Set both define a keys function that returns an iterator. For
  // Sets this iterates over the same values as the values iterator.
  // The typeof check allows the compiler to remove the Map and Set polyfills
  // if they are otherwise unused throughout the entire binary.
  if (typeof Map !== 'undefined' && col instanceof Map) {
    return Array.from(col.keys());
  }
  // Unlike the native Set, goog.structs.Set does not expose keys as the values.
  if (typeof Set !== 'undefined' && col instanceof Set) {
    return undefined;
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  'use strict';
  if (col.contains && typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (col.containsValue && typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return goog.array.contains(/** @type {!Array<?>} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  'use strict';
  if (col.isEmpty && typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmptyOrWhitespace because here we treat the
  // string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || typeof col === 'string') {
    return /** @type {!Array<?>} */ (col).length === 0;
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 * @return {void}
 */
goog.structs.clear = function(col) {
  'use strict';
  // NOTE(arv): This should not contain strings because strings are immutable
  if (col.clear && typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear(/** @type {IArrayLike<?>} */ (col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):?} f The function to call for every value.
 *     This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within `f`.
 * @return {void}
 * @template T,S
 * @deprecated Use a more specific method, e.g. native Array.prototype.forEach,
 *     or for-of.
 */
goog.structs.forEach = function(col, f, opt_obj) {
  'use strict';
  if (col.forEach && typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || typeof col === 'string') {
    Array.prototype.forEach.call(/** @type {!Array<?>} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is false the value is not included.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within `f`.
 * @return {!Object|!Array<?>} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 * @template T,S
 */
goog.structs.filter = function(col, f, opt_obj) {
  'use strict';
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return Array.prototype.filter.call(
        /** @type {!Array<?>} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use Array#filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], undefined, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):V} f The function to call for every value.
 *     This function takes 3 arguments (the value, the key or undefined if the
 *     collection has no notion of keys, and the collection) and should return
 *     something. The result will be used as the value in the new collection.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within `f`.
 * @return {!Object<V>|!Array<V>} A new collection with the new values.  If
 *     col is a key-less collection an array is returned.  If col has keys and
 *     values a plain old JS object is returned.
 * @template T,S,V
 */
goog.structs.map = function(col, f, opt_obj) {
  'use strict';
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return Array.prototype.map.call(/** @type {!Array<?>} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(/** @type {?} */ (opt_obj), values[i], keys[i], col);
    }
  } else {
    // We should not use Array#map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(/** @type {?} */ (opt_obj), values[i], undefined, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns false this returns false.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or undefined
 *     if the collection has no notion of keys, and the collection) and should
 *     return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within `f`.
 * @return {boolean} True if any value passes the test.
 * @template T,S
 */
goog.structs.some = function(col, f, opt_obj) {
  'use strict';
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return Array.prototype.some.call(
        /** @type {!Array<?>} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns false this returns false at this point
 *  and does not continue to check the remaining values.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or
 *     undefined if the collection has no notion of keys, and the collection)
 *     and should return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within `f`.
 * @return {boolean} True if all key-value pairs pass the test.
 * @template T,S
 */
goog.structs.every = function(col, f, opt_obj) {
  'use strict';
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || typeof col === 'string') {
    return Array.prototype.every.call(
        /** @type {!Array<?>} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(/** @type {?} */ (opt_obj), values[i], keys && keys[i], col)) {
      return false;
    }
  }
  return true;
};

//analytics/tracking/chrome/parameter_map.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Support for mapping parameters to values.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.ParameterMap');
goog.module.declareLegacyNamespace();

const Parameter = goog.require('analytics.Parameter');
const StructsMap = goog.require('goog.structs.Map');
const Value = goog.require('analytics.Value');
const googArray = goog.require('goog.array');
const structs = goog.require('goog.structs');

/**
 * A map of `Parameter` to `Value`.
 * Individual parameters are identified by name (the query parameter name).
 * Two different instances of `Parameter` with the same `.name`
 * are treated as identical independent of all other attributes in the
 * `Parameter` typedef.
 * <p>As of this writing multiple values per parameter are not supported,
 * though this aspect of GA tracking behavior needs to be verified. So this
 * aspect of the API as well as the associated types are subject to change.
 * @unrestricted
 */
const ParameterMap = class {
  /**
   * @param {...Parameter|Value} var_args
   *     An optional list of alternating key, value pairs.
   */
  constructor(var_args) {
    /**
       @private {!StructsMap.<
        string, ParameterMap.Entry>}
     */
    this.entries_ = new StructsMap();

    if (arguments.length % 2 > 0) {
      throw new Error(
          'Uneven number of arguments to ParameterMap constructor.');
    }
    this.addPairs_(arguments);
  }

  /**
   * Sets the value associated with the parameter replacing any existing
   * value.
   *
   * @param {!Parameter} param
   * @param {!Value} value
   */
  set(param, value) {
    if (value == null) {
      throw new Error('undefined-or-null value for key: ' + param.name);
    }

    this.entries_.set(param.name, {'key': param, 'value': value});
  }

  /**
   * Removes the entry associated w/ key, if any.
   *
   * @param {!Parameter} param
   */
  remove(param) {
    this.entries_.delete(param.name);
  }

  /**
   * Returns the current value associated with the key, or null if it hasn't
   * been set. Does not return the default value if the *same* value has not
   * been previously set, explicitly, by the caller.
   * @param {!Parameter} param
   * @return {?Value} The value or null if not previously set.
   */
  get(param) {
    /** @type {!ParameterMap.Entry} */
    var entry =
        /** @type {ParameterMap.Entry} */ (this.entries_.get(param.name, null));
    return entry === null ? null : entry.value;
  }

  /**
   * Adds all elements from `map`.
   *
   * @param {!ParameterMap} map
   */
  addAll(map) {
    this.entries_.addAll(map.entries_);
  }

  /**
   * Adds elements from list of alternating `Parameter`
   * and `Value` values.
   *
   * @param {!IArrayLike<Parameter|Value>} elements
   * @private
   */
  addPairs_(elements) {
    for (var i = 0; i < elements.length; i += 2) {
      this.set(
          /** @type {Parameter} */ (elements[i]),
          /** @type {Value} */ (elements[i + 1]));
    }
  }

  /**
   * Apply `receiver` to each `ParameterMap.Entry`
   * having been previously set in the map.
   * @param {function(!Parameter, !Value)} receiver
   */
  forEachEntry(receiver) {
    googArray.forEach(
        Array.from(this.entries_.values()),
        /** @param {!ParameterMap.Entry} entry */
        function(entry) {
          receiver(entry.key, entry.value);
        });
  }

  /**
   * Returns an object representation of the parameter map. Callers are free
   * to manipulate the returned object.
   *
   * @return {!Object.<string, Value>}
   */
  toObject() {
    /** @type {!Object.<string, Value>} */
    var params = {};
    this.forEachEntry(
        /**
         * @param {!Parameter} key
         * @param {!Value} value
         */
        function(key, value) {
          // Oddly enough the "id" is the readable name,
          // and the "name" is the short form.
          // e.g. id=description, name=cd.
          params[key.id] = value;
        });
    return params;
  }

  /**
   * Create a copy of *this*.
   * @return {!ParameterMap}
   */
  clone() {
    var copy = new ParameterMap();
    copy.entries_ = this.entries_.clone();
    return copy;
  }

  /**
   * Returns true if this instance contains exactly the same entries
   * as `that`.
   *
   * @param {!ParameterMap} that
   * @return {boolean} True if this instance contains exactly the same entries
   * as `that`.
   */
  equals(that) {
    if (this.entries_.size !== that.entries_.size) {
      return false;
    }

    /** @type {boolean} */
    var result = googArray.every(
        Array.from(this.entries_.values()),
        /**
         * @param {!ParameterMap.Entry} entry
         * @return {boolean} True if this and that have the same key/value pair.
         */
        function(entry) {
          return entry.value == that.get(entry.key);
        });
    return result;
  }

  /**
   * Returns true if this instance contains all entries
   * in `parameters`.
   *
   * @param {!ParameterMap} parameters
   * @return {boolean} True if this instance contains all entries
   *     in `parameters`.
   */
  contains(parameters) {
    /** @type {boolean} */
    var result = googArray.every(
        Array.from(parameters.entries_.values()),
        goog.bind(
            /**
             * @param {!ParameterMap.Entry} entry
             * @return {boolean}
             *     True if this and parameters have the same key/value pair.
             * @this {ParameterMap}
             */
            function(entry) {
              return entry.value == this.get(entry.key);
            },
            this));
    return result;
  }

  /**
   * Returns true if this instance contains `key`.
   *
   * @param {!Parameter} parameter
   * @return {boolean} True if this instance has an entry for
   *     the specified parameter.
   */
  hasParameter(parameter) {
    return this.entries_.has(parameter.name);
  }

  /** @override */
  toString() {
    /** @type {!Object.<string, !Value>} */
    var fields = new Object();
    this.forEachEntry(
        /**
         * @param {!Parameter} key
         * @param {!Value} value
         */
        function(key, value) {
          fields[key.id] = value;
        });
    return JSON.stringify(fields);
  }
};

/**
 * @typedef {{
 *   key: !Parameter,
 *   value: !Value
 * }}
 */
ParameterMap.Entry;

exports = ParameterMap;

;return exports;});

//analytics/tracking/chrome/extras/hit_builders.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview
 * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed
 */
// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Convenience classes for building hits.
 *
 * @see EventBuilder
 *
 * @author smckay@google.com (Steve McKay)
 */
goog.module('analytics.EventBuilder');
goog.module.declareLegacyNamespace();

const Deferred = goog.require('goog.async.Deferred');
const ParameterMap = goog.require('analytics.ParameterMap');
const Parameters = goog.require('analytics.Parameters');
const analytics = goog.require('analytics');

/**
 * A class that aids in the building of event hits. Create instances
 * of this class using `EventBuilder#builder`.
 * @unrestricted
 */
const EventBuilder = class {
  /**
   * @param {function(!ParameterMap)} delegate This is the
   *    connection to our parent builder (or an terminal function).
   *    When we're asked to "collect", we put our params in the map,
   *    then call this function to give our parent builder a chance
   *    to contribute (or a terminal function that ends collection).
   */
  constructor(delegate) {
    /** @private {function(!ParameterMap)} */
    this.delegate_ = delegate;

    /** @private {!analytics.Parameter} */
    this.parameter_;

    /** @private {!analytics.Value} */
    this.value_;
  }

  /**
   * @param {string} category
   *
   * @return {!EventBuilder}
   */
  category(category) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = Parameters.EVENT_CATEGORY;
    builder.value_ = category;
    return builder;
  }

  /**
   * @param {string} action
   *
   * @return {!EventBuilder}
   */
  action(action) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = Parameters.EVENT_ACTION;
    builder.value_ = action;
    return builder;
  }

  /**
   * @param {string} label
   *
   * @return {!EventBuilder}
   */
  label(label) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = Parameters.EVENT_LABEL;
    builder.value_ = label;
    return builder;
  }

  /**
   * @param {number} value
   *
   * @return {!EventBuilder}
   */
  value(value) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = Parameters.EVENT_VALUE;
    builder.value_ = value;
    return builder;
  }

  /**
   * @param {!EventBuilder.Dimension} dimension
   *
   * @return {!EventBuilder}
   */
  dimension(dimension) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = analytics.createDimensionParam(dimension.index);
    builder.value_ = dimension.value;
    return builder;
  }

  /**
   * @param {!EventBuilder.Metric} metric
   *
   * @return {!EventBuilder}
   */
  metric(metric) {
    var builder = new EventBuilder(goog.bind(this.collect, this));
    builder.parameter_ = analytics.createMetricParam(metric.index);
    builder.value_ = metric.value;
    return builder;
  }

  /**
   * @param {!analytics.Tracker} tracker
   *
   * @return {!Deferred}
   */
  send(tracker) {
    var parameters = new ParameterMap();
    this.collect(parameters);
    return tracker.send(analytics.HitTypes.EVENT, parameters);
  }

  /**
   * Collects all parameters in this builder. Only the most
   * "recently" (closest to the leaves) set value will be added
   * when duplicate parameters have been set in the builder.
   *
   * @param {!ParameterMap} parameters
   */
  collect(parameters) {
    this.put_(parameters);
    if (goog.isObject(this.delegate_)) {
      this.delegate_(parameters);
    }
  }

  /**
   * Puts the parameters known to this instance into `parameters`.
   * Parameters will only be added if there is no existing entry.
   *
   * <p>This allows builder instances at the leaves to override values
   * supplied by earlier builders.
   *
   * @param {!ParameterMap} parameters
   * @private
   */
  put_(parameters) {
    if (this.parameter_ != null && this.value_ != null &&
        !parameters.hasParameter(this.parameter_)) {
      parameters.set(this.parameter_, this.value_);
    }
  }

  /**
   * Returns an empty HitBuilder instance. Each call
   * to a mutator method on this class (all methods except
   * `send`), return a new instance of the builder that
   * itself is immutable. That means plenty of object allocations.
   * You might even say more than expected. So you may not want to
   * use this class in performance sensitive code.
   *
   * @return {!EventBuilder}
   */
  static builder() {
    return EventBuilder.EMPTY_;
  }
};

/** @private {!EventBuilder} */
EventBuilder.EMPTY_ = new EventBuilder(goog.nullFunction);

/**
 * @typedef {{
 *   index: number,
 *   value: string
 * }}
 */
EventBuilder.Dimension;

/**
 * @typedef {{
 *   index: number,
 *   value: number
 * }}
 */
EventBuilder.Metric;

exports = EventBuilder;

;return exports;});

//analytics/tracking/chrome/internal/channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for communication channel used to send
 * analytics hits to Google Analytics servers.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.Channel');
goog.module.declareLegacyNamespace();

const Deferred = goog.require('goog.async.Deferred');
const HitType = goog.require('analytics.HitType');
const ParameterMap = goog.require('analytics.ParameterMap');

/**
 * @interface
 */
function Channel() {}

/**
 * Send the data to Google Analytics for processing.
 * @param {!HitType} hitType
 * @param {!ParameterMap} parameters The parameters to send.
 * @return {!Deferred} A Deferred that fires once the hit has
 *     been sent.
 */
Channel.prototype.send;

exports = Channel;

;return exports;});

//analytics/tracking/chrome/tracker.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.provide('analytics.Timing');
goog.provide('analytics.Tracker');

goog.require('analytics.HitType');
goog.require('analytics.Parameter');
goog.require('analytics.Value');

goog.require('goog.async.Deferred');
goog.require('goog.events.EventTarget');
goog.requireType('analytics.EventBuilder');
goog.requireType('analytics.ParameterMap');


/**
 * Provides support for sending hits to Google Analytics using convenient
 * named methods like `sendAppView` and `sendEvent` or the
 * general purpose `send` method.
 *
 * <p>Clients can set session values using `set`. These values, once set,
 * are included in all subsequent hits.
 *
 * <p>For analytics hittypes that are not supported by a named method clients
 * can call `send` with param/value `Object` describing the hit.
 *
 * Obtain a instance using the `analytics.Service#getTracker`.
 *
 * @interface
 */
analytics.Tracker = function() {};


/**
 * Sets an individual value on the `Tracker`, replacing any previously
 * set values with the same param. The value is persisted for the life
 * of the `Tracker` instance, or until replaced by a subsequent call
 * to `set` with the same parameter.
 *
 * @param {!analytics.Parameter|string} param
 * @param {!analytics.Value} value
 */
analytics.Tracker.prototype.set;


/**
 * Sends a hit to Google Analytics. Caller is responsible for ensuring the
 * of the information sent with that hit. Values can be provided either
 * using `set` or using `opt_extraParams`.
 *
 * <p>Whenever possible use a named method like `sendAppView` or
 * `sendEvent`.
 *
 * @param {!analytics.HitType|!analytics.EventBuilder} hitType The hitType
 *     or an EventBuilder. If EventBuilder the hitType and opt_extraParams
 *     are collected from this object, and opt_extraParams will be ignored.
 * @param {(!analytics.ParameterMap|
 *     !Object.<string, !analytics.Value>)=} opt_extraParams
 *     Additional parameters to include in the hit along with any
 *     values previously supplied via calls to `Tracker#set`.
 *     NOTE: These values are NOT persisted in the tracker.
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.send;


/**
 * Sends an AppView hit to Google Analytics.
 *
 * @param {string} description A unique description of the "screen" (
 *     or "place, or "view") within your application. This is should more
 *     specific than your app name, but generally not include any runtime
 *     data. In most cases all "screens" should be known at the time
 *     the app is built. Examples: "MainScreen" or "SettingsView".
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.sendAppView;


/**
 * Sends an Event hit to Google Analytics.
 *
 * @param {string} category Specifies the event category.
 * @param {string} action Specifies the event action.
 * @param {string=} opt_label Specifies the event label.
 * @param {number=} opt_value Specifies the event value.
 *     Values must be non-negative.
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.sendEvent;


/**
 * Sends a Social hit to Google Analytics.
 *
 * @param {string} network Specifies the social network, for example Facebook
 *     or Google Plus.
 * @param {string} action Specifies the social interaction action.
 *     For example on Google Plus when a user clicks the +1 button,
 *     the social action is 'plus'.
 * @param {string} target Specifies the target of a social interaction.
 *     This value is typically a URL but can be any text.
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.sendSocial;


/**
 * Sends an Exception hit to Google Analytics.
 *
 * @param {string=} opt_description Specifies the description of an exception.
 * @param {boolean=} opt_fatal Was the exception fatal.
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.sendException;


/**
 * Sends a Timing hit to Google Analytics.
 *
 * @see analytics.Tracker.startTiming for another handy way to send
 *     timing events.
 *
 * @param {string} category Specifies the category of the timing.
 * @param {string} variable Specifies the variable name of the timing.
 * @param {number} value Specifies the value of the timing.
 * @param {string=} opt_label Specifies the optional label of the timing.
 * @param {number=} opt_sampleRate
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.prototype.sendTiming;


/**
 * Forces the tracker up to start a new session on the next hit.  Note that
 * clients should not usually need to call this as Google Analytics provides
 * automatic session management.
 * @type {function()}
 */
analytics.Tracker.prototype.forceSessionStart;


/**
 * When present, the IP address of the sender will be anonymized.
 * @type {function()}
 */
analytics.Tracker.prototype.anonymizeIps;


/**
 * Creates a new timing object that tracks elapsed time for you.
 *
 * @see analytics.Tracker.sendTiming for a way to send timing events
 *     where callers supply the timing value.
 *
 * @param {string} category
 * @param {string} variable
 * @param {string=} opt_label
 * @param {number=} opt_sampleRate
 * @return {!analytics.Tracker.Timing}
 */
analytics.Tracker.prototype.startTiming;



/**
 * Provides support for timing operations and sending the results to
 * Google Analytics.
 *
 * Obtain an instance using `analytics.Service#createTimer`.
 *
 * @interface
 */
analytics.Tracker.Timing = function() {};


/**
 * Calculates the final timing and sends the information to Google Analytics.
 *
 * @return {!goog.async.Deferred}
 */
analytics.Tracker.Timing.prototype.send;


/**
 * Adds a `analytics.Tracker.Filter` to the request
 * handling pipeline. The filter will be called once for each hit,
 * immediately after the hit is sent.
 *
 * <li>Filters will not be applied when tracking is disabled by the user.
 * <li>Filters are applied in the order they are added.
 *
 * @param {!analytics.Tracker.Filter} filter
 */
analytics.Tracker.prototype.addFilter;


/**
 * A `function` that processes a hit. Filters may
 * optionally return a Deferred instance if async handling
 * is required.
 *
 * @typedef {function(!analytics.Tracker.Hit): (undefined|!goog.async.Deferred)}
 */
analytics.Tracker.Filter;



/**
 * A mutable representation of a hit being sent by client code.
 * This is the payload given to filters. Filters can manipulate
 * parameters directly in the `ParameterMap` accessible
 * via `#getParameters`, and can stop further processing
 * of the hit using the `#cancel` method.
 *
 * @interface
 */
analytics.Tracker.Hit = function() {};


/** @return {!analytics.HitType} */
analytics.Tracker.Hit.prototype.getHitType;


/**
 * @return {!analytics.ParameterMap} A map of the individual parameters
 *     and their values.
 */
analytics.Tracker.Hit.prototype.getParameters;


/**
 * Marks the hit as canceled. The hit will endure no further
 * processing once it has been marked as canceled.
 * @type {function()}
 */
analytics.Tracker.Hit.prototype.cancel;

//analytics/tracking/chrome/internal/service_tracker.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service tracker implementation.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.ServiceTracker');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const ChannelManager = goog.requireType('analytics.internal.ChannelManager');
const EventBuilder = goog.require('analytics.EventBuilder');
const EventHit = goog.requireType('analytics.EventHit');
const ExceptionHit = goog.requireType('analytics.ExceptionHit');
const HitTypes = goog.require('analytics.HitTypes');
const InternalParameters = goog.require('analytics.internal.Parameters');
const ParameterMap = goog.require('analytics.ParameterMap');
const Parameters = goog.require('analytics.Parameters');
const Settings = goog.requireType('analytics.internal.Settings');
const SocialHit = goog.requireType('analytics.SocialHit');
const Tracker = goog.require('analytics.Tracker');
const analytics = goog.requireType('analytics');
const asserts = goog.require('goog.asserts');
const googObject = goog.require('goog.object');
const parameters = goog.require('analytics.internal.parameters');

/**
 * @constructor
 * @implements {Tracker}
 * @struct
 *
 * @param {!Settings} settings
 * @param {!ChannelManager} channelManager
 */
function ServiceTracker(settings, channelManager) {
  /** @private {!ChannelManager} */
  this.channelManager_ = channelManager;

  /** @private {!Channel} */
  this.channel_ = channelManager.getChannel();

  /** @private {!ParameterMap} */
  this.params_ = new ParameterMap();

  /** @private {boolean} */
  this.startSession_ = false;

  /** @private {boolean} */
  this.anonymizeIps_ = false;
}

/** @override */
ServiceTracker.prototype.set = function(param, value) {
  if (value == null) {
    throw new Error(
      'Value must be defined and not null. Parameter=' + param.id);
  }
  var parameter = parameters.asParameter(param);
  this.params_.set(parameter, value);
};

/** @override */
ServiceTracker.prototype.addFilter = function(filter) {
  this.channelManager_.addFilter(filter);
};

/** @override */
ServiceTracker.prototype.send = function(hitType, opt_extraParams) {

  // If the first arg is an EventBuilder, delegate sending
  // to it. It'll eventually end up calling back
  // into this method with specific hittype and params.
  if (hitType instanceof EventBuilder) {
    return hitType.send(this);
  }

  var hit = this.params_.clone();
  if (opt_extraParams instanceof ParameterMap) {
    hit.addAll(opt_extraParams);
  } else if (goog.isObject(opt_extraParams)) {
    googObject.forEach(opt_extraParams, function(value, key) {
      if (value != null) {
        hit.set(parameters.asParameter(key), value);
      }
    }, this);
  }

  if (this.startSession_) {
    this.startSession_ = false;
    hit.set(Parameters.SESSION_CONTROL, 'start');
  }

  if (this.anonymizeIps_) {
    hit.set(InternalParameters.ANONYMIZE_IP, true);
  }

  return this.channel_.send(hitType, hit);
};

/** @override */
ServiceTracker.prototype.sendAppView = function(description) {

  /** @type {!analytics.AppViewHit} */
  var hit = {
    'description': description
  };
  this.set(Parameters.DESCRIPTION, description);
  return this.send(HitTypes.APPVIEW, hit);
};

/** @override */
ServiceTracker.prototype.sendEvent = function(
    category, action, opt_label, opt_value) {
  if (typeof opt_value === 'number') asserts.assert(opt_value >= 0);

  /** @type {!EventHit} */
  var hit = {
    'eventCategory': category,
    'eventAction': action,
    'eventLabel': opt_label,
    'eventValue': opt_value
  };
  return this.send(HitTypes.EVENT, hit);
};

/** @override */
ServiceTracker.prototype.sendSocial = function(network, action, target) {
  /** @type {!SocialHit} */
  var hit = {
    'socialNetwork': network,
    'socialAction': action,
    'socialTarget': target
  };
  return this.send(HitTypes.SOCIAL, hit);
};

/** @override */
ServiceTracker.prototype.sendException = function(opt_description, opt_fatal) {
  /** @type {!ExceptionHit} */
  var hit = {
    'exDescription': opt_description,
    'exFatal': opt_fatal
  };
  return this.send(HitTypes.EXCEPTION, hit);
};

/** @override */
ServiceTracker.prototype.sendTiming = function(
    category, variable, value, opt_label, opt_sampleRate) {
  return this.send(HitTypes.TIMING, {
    'timingCategory': category,
    'timingVar': variable,
    'timingLabel': opt_label,
    'timingValue': value,
    'sampleRateOverride': opt_sampleRate
  });
};

/** @override */
ServiceTracker.prototype.forceSessionStart = function() {
  this.startSession_ = true;
};

/** @override */
ServiceTracker.prototype.anonymizeIps = function() {
  this.anonymizeIps_ = true;
};

/** @override */
ServiceTracker.prototype.startTiming = function(
    category, variable, opt_label, opt_sampleRate) {
  return new ServiceTracker.Timing(
      this, category, variable, opt_label, opt_sampleRate);
};

/**
 * Tracks timing information and send information to Google Analytics.
 *
 * @constructor
 * @implements {Tracker.Timing}
 *
 * @param {!Tracker} tracker
 * @param {string} category
 * @param {string} variable
 * @param {string=} opt_label
 * @param {number=} opt_sampleRate
 */
ServiceTracker.Timing = function(
    tracker, category, variable, opt_label, opt_sampleRate) {
  /** @private {?Tracker} */
  this.tracker_ = tracker;

  /** @private {string} */
  this.category_ = category;

  /** @private {string} */
  this.variable_ = variable;

  /** @private {string|undefined} */
  this.label_ = opt_label;

  /** @private {number|undefined} */
  this.sampleRate_ = opt_sampleRate;

  /** @private {number} */
  this.startTime_ = Date.now();
};

/** @override */
ServiceTracker.Timing.prototype.send = function() {
  var deferred = this.tracker_.sendTiming(
      this.category_,
      this.variable_,
      Date.now() - this.startTime_,
      this.label_,
      this.sampleRate_);

  // The timing instance can only be used once.
  this.tracker_ = null;
  return deferred;
};

exports = ServiceTracker;

;return exports;});

//analytics/tracking/chrome/internal/google_analytics_service.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview The primary implementation of the GoogleAnalytics
 * interface.
 * @author kenobi@google.com (Ben Kwa)
 * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed
 */

goog.module('analytics.internal.GoogleAnalyticsService');
goog.module.declareLegacyNamespace();

const GoogleAnalytics = goog.require('analytics.GoogleAnalytics');
const Parameters = goog.require('analytics.internal.Parameters');
const ServiceTracker = goog.require('analytics.internal.ServiceTracker');
const dom = goog.require('goog.dom');

/**
 * Do not construct this directly, instead call `analytics.getService`.
 * @implements {GoogleAnalytics}
 */
const GoogleAnalyticsService = class {
  /**
   * @param {string} libVersion The string that identifies this version of this
   *     library.
   * @param {string} appName The Chromium Platform App name.
   * @param {string} appVersion The version of the platform app.
   * @param {!analytics.internal.Settings} settings
   * @param {!analytics.internal.ChannelManager.Factory} channelFactory
   */
  constructor(libVersion, appName, appVersion, settings, channelFactory) {
    /** @private {string} */
    this.libVersion_ = libVersion;

    /** @private {string} */
    this.appName_ = appName;

    /** @private {string} */
    this.appVersion_ = appVersion;

    /** @private {!analytics.internal.Settings} */
    this.settings_ = settings;

    /** @private {!analytics.internal.ChannelManager.Factory} */
    this.channelFactory_ = channelFactory;
  }

  /** @override */
  getTracker(trackingId) {
    var tracker =
        new ServiceTracker(this.settings_, this.channelFactory_.create());

    tracker.set(Parameters.LIBRARY_VERSION, this.libVersion_);
    tracker.set(Parameters.API_VERSION, 1);
    tracker.set(Parameters.APP_NAME, this.appName_);
    tracker.set(Parameters.APP_VERSION, this.appVersion_);
    tracker.set(Parameters.TRACKING_ID, trackingId);

    GoogleAnalyticsService.addEnvironmentalParams_(tracker);

    return tracker;
  }

  /** @override */
  getConfig() {
    return this.settings_.whenReady();
  }

  /**
   * Adds environmental details like screen size, color depth.
   * @param {!analytics.Tracker} tracker
   * @private
   */
  static addEnvironmentalParams_(tracker) {
    var value = navigator.language || navigator.browserLanguage;
    if (value) {
      tracker.set(Parameters.LANGUAGE, value);
    }

    // Note: We're using ['foo'] notation to avoid issues with missing
    // externs and the possibility of the closure compiler renaming fields.
    value = screen.colorDepth + '-bit';
    if (value) {
      tracker.set(Parameters.SCREEN_COLORS, value);
    }

    value = [screen.width, screen.height].join('x');

    if (value) {
      tracker.set(Parameters.SCREEN_RESOLUTION, value);
    }

    var size = dom.getViewportSize();
    value = [size.width, size.height].join('x');

    if (value) {
      tracker.set(Parameters.VIEWPORT_SIZE, value);
    }
  }
};

exports = GoogleAnalyticsService;

;return exports;});

//analytics/tracking/chrome/internal/has_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for building and manipulating
 * the chain of `Channel` instances used
 * for runtime request processing.
 *
 * @author smckay@google.com (Steve McKay)
 */
goog.module('analytics.internal.HasChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.requireType('analytics.internal.Channel');

/**
 * An object that contains a `Channel`.
 *
 * @interface
 */
function HasChannel() {}

/**
 * @return {!Channel} channel
 */
HasChannel.prototype.getChannel;

exports = HasChannel;

;return exports;});

//analytics/tracking/chrome/internal/channel_manager.js
// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for building and manipulating
 * the chain of `Channel` instances used
 * for runtime request processing.
 * @author smckay@google.com (Steve McKay)
 * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed
 */
goog.provide('analytics.internal.ChannelManager');
goog.provide('analytics.internal.ChannelManager.Factory');

goog.require('analytics.internal.HasChannel');
goog.requireType('analytics.Tracker');



/**
 * A ChannelManager provides support for runtime manipulation
 * of the `Channel` that processes requests.
 *
 * @interface
 * @extends {analytics.internal.HasChannel}
 */
analytics.internal.ChannelManager = function() {};


/**
 * Installs the supplied filter.
 *
 * @param {!analytics.Tracker.Filter} filter
 */
analytics.internal.ChannelManager.prototype.addFilter;



/**
 * A ChannelManager.Factory provides for the creation
 * of `ChannelManager` instances.
 *
 * @interface
 */
analytics.internal.ChannelManager.Factory = function() {};


/**
 * Returns a service channel manager suitable for use with
 * a single tracker instance. Each tracker instance is paired
 * with a specific service channel providing
 * runtime processing of hits.
 *
 * @return {!analytics.internal.ChannelManager}
 */
analytics.internal.ChannelManager.Factory.prototype.create;

//third_party/javascript/closure/singleton/singleton.js
goog.loadModule(function(exports) {'use strict';/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides an implementation for getInstance() methods.
 */

goog.module('goog.singleton');
goog.module.declareLegacyNamespace();

const reflect = goog.require('goog.reflect');
const {assert} = goog.require('goog.asserts');

/** @type {!Array<function(new: ?): ?>} */
const instantiatedSingletons = [];

/**
 * @template T
 * @record
 */
class Singleton {
  constructor() {
    /** @type {!T} */
    this.instance_;
  }
}

/**
 * Used as the implementation body for a static getInstance method.
 *
 * ```
 * class Foo {
 *   static getInstance() {
 *     return getInstance(Foo);
 *   }
 * }
 * ```
 * @param {function(new: T)} ctor
 * @return {T}
 * @template T
 * @deprecated Singleton patterns are discouraged. Use dependency injection
 *     instead.
 */
exports.getInstance = (ctor) => {
  assert(
      !Object.isSealed(ctor),
      'Cannot use getInstance() with a sealed constructor.');
  const ctorWithInstance = /** @type {!Singleton} */ (ctor);
  if (ctorWithInstance.instance_ &&
      ctorWithInstance.hasOwnProperty(
          reflect.objectProperty('instance_', ctorWithInstance))) {
    return ctorWithInstance.instance_;
  }
  if (goog.DEBUG) {
    // Used to reset singletons in test code.
    instantiatedSingletons.push(ctor);
  }
  const instance = new ctor();
  ctorWithInstance.instance_ = instance;
  return instance;
};

exports.instantiatedSingletons = instantiatedSingletons;

;return exports;});

//analytics/tracking/chrome/internal/dummy_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Dummy communication channel does not not report hits or
 * other information back to Google Analytics. This should be used when
 * the user is either opted out or sampled out of reporting.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.DummyChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');
const singleton = goog.require('goog.singleton');

/**
 * @implements {Channel}
 */
const DummyChannel = class {
  constructor() {}

  /** @override */
  send(hitType, parameters) {
    // Don't report the hit. Just let the caller know it was handled.
    return Deferred.succeed();
  }

  /** @return {!DummyChannel} */
  static getInstance() {
    return singleton.getInstance(DummyChannel);
  }
};

exports = DummyChannel;

;return exports;});

//analytics/tracking/chrome/internal/filter_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Channel that applies client code filters to a hit
 * before it is dispatched for processing by the standard processing
 * pipeline.
 *
 * @author smckay@google.com (Steve McKay)
 */

goog.module('analytics.internal.FilterChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');
const HitType = goog.requireType('analytics.HitType');
const ParameterMap = goog.requireType('analytics.ParameterMap');
const Tracker = goog.require('analytics.Tracker');

/**
 * @implements {Channel}
 */
const FilterChannel = class {
  /**
   * @param {!Channel} delegate
   */
  constructor(delegate) {
    /** @private {!Array.<!Tracker.Filter>} */
    this.filters_ = [];

    /** @private {!Channel} */
    this.delegate_ = delegate;
  }

  /**
   * Adds a `Tracker.Filter` to the list of
   * filters that will be applied to a hit as it traverses
   * the processing pipeline. Filters are applied in the order
   * they are installed.
   *
   * <p>Filters will not be applied when tracking is disabled by the user.
   *
   * @param {!Tracker.Filter} filter
   */
  addFilter(filter) {
    if (typeof filter !== 'function') {
      throw new Error('Invalid filter. Must be a function.');
    }
    this.filters_.push(filter);
  }

  /** @override */
  send(hitType, parameters) {
    if (this.filters_.length == 0) {
      return this.delegate_.send(hitType, parameters);
    } else {
      var hit = new FilterChannel.Hit(hitType, parameters);
      return this.applyFilter_(0, hit).addCallback(
          /**
           * @this {FilterChannel}
           */
          function() {
            if (!hit.canceled_) {
              return this.delegate_.send(hitType, parameters);
            }
          },
          this);
    }
  }

  /**
   * Applies the specified filter, and the next until there are no more,
   * or once cancels the hit.
   *
   * @param {number} index Index of filter to apply.
   * @param {!FilterChannel.Hit} hit
   *
   * @return {!Deferred} Resolves when all filters have been
   *     applied, or hit has been cancelled.
   * @private
   */
  applyFilter_(index, hit) {
    return Deferred.succeed()
        .addCallback(
            /** @this {FilterChannel} */
            function() {
              // TODO(smckay): Once all filter user have been updated
              // just call this directly.
              return this.filters_[index](hit);
            },
            this)
        .addCallback(
            /**
             * Recurses into applyFilter_ if there are more filters to be
             *     applied and the hit has not be cancelled.
             * @this {FilterChannel}
             */
            function() {
              if (++index < this.filters_.length && !hit.canceled_) {
                return this.applyFilter_(index, hit);
              }
            },
            this);
  }
};

/**
 * The implementation of the `Tracker.Hit` used by FilterChannel.
 * @implements {Tracker.Hit}
 */
FilterChannel.Hit = class {
  /**
   * @param {!HitType} type
   * @param {!ParameterMap} parameters
   */
  constructor(type, parameters) {
    /** @private {!HitType} */
    this.type_ = type;

    /** @private {!ParameterMap} */
    this.parameters_ = parameters;

    /** @private {boolean} */
    this.canceled_ = false;
  }

  /** @override */
  getHitType() {
    return this.type_;
  }

  /** @override */
  getParameters() {
    return this.parameters_;
  }

  /** @override */
  cancel() {
    this.canceled_ = true;
  }
};

exports = FilterChannel;

;return exports;});

//analytics/tracking/chrome/internal/diverting_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A channel that diverts `send` calls to a supplied
 * `Array` in the form of a
 * `DivertingChannel.Capture`.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.DivertingChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');

const HitType = goog.requireType('analytics.HitType');
const ParameterMap = goog.requireType('analytics.ParameterMap');

/**
 * @constructor
 * @param {!Array.<!DivertingChannel.Capture>} destination
 * @implements {Channel}
 * @struct
 */
function DivertingChannel(destination) {
  /** @private {!Array.<!DivertingChannel.Capture>} */
  this.destination_ = destination;
}

/**
 * @typedef {{
 *   hitType: !HitType,
 *   parameters: !ParameterMap
 * }}
 */
DivertingChannel.Capture;

/** @override */
DivertingChannel.prototype.send = function(hitType, parameters) {
  this.destination_.push({
    hitType: hitType,
    parameters: parameters
  });
  return Deferred.succeed();
};

exports = DivertingChannel;

;return exports;});

//analytics/tracking/chrome/config.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.module('analytics.Config');
goog.module.declareLegacyNamespace();

/**
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

const Deferred = goog.requireType('goog.async.Deferred');

/**
 * Provides support for reading and manipulating the configuration of the
 * library.
 *
 * Obtain a instance using the `analytics.Service#getConfig`.
 *
 * @interface
 */
function Config() {}

/**
 * As a user of this library you must permit users to opt-out of tracking.
 * This method provides support for persistently enabling or disabling tracking
 * for the current user on the current device.
 *
 * <p>When your code calls `setTrackingPermitted(false)` this library
 * will dynamically disable tracking. This means you are free to instrument
 * your application with analytics tracking code, then enable/disable
 * the sending of tracking information with this method. You do NOT need to
 * guard calls to tracking in your code.
 *
 * <p>For further information on how to support opt-out in your application see
 * https://github.com/GoogleChrome/chrome-platform-analytics/wiki/Respecting-User-Privacy
 *
 * @param {boolean} permitted True if tracking is permitted.
 */
Config.prototype.setTrackingPermitted;

/**
 * Returns true if tracking is enabled.
 *
 * @return {boolean} True if tracking is permitted.
 */
Config.prototype.isTrackingPermitted;

/**
 * Sets the user sample rate. This can be used if you need to reduce the
 * number of users reporting analytics information to Google Analytics.
 * Most clients will not need to set this. Value is NOT persisted
 * across sessions.
 *
 * @param {number} sampleRate User sample rate. An integer from 1 to 100.
 *     If not set defaults to 100.
 */
Config.prototype.setSampleRate;

/**
 * Resets the user id. This is useful for clients wishing to afford users
 * the opportunity to reset the auto-generated user id. Immediately generates
 * a new user ID. Client code can continue using existing tracker objects.
 *
 * @return {!Deferred} Settles once the id has been reset.
 */
Config.prototype.resetUserId;

exports = Config;

;return exports;});

//analytics/tracking/chrome/internal/settings.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface for persistent settings.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.provide('analytics.internal.Settings');

goog.require('analytics.Config');
goog.requireType('goog.async.Deferred');



/**
 * @interface
 * @extends {analytics.Config}
 */
analytics.internal.Settings = function() {};


/**
 * @return {!goog.async.Deferred<?>} A deferred
 *     firing when the settings object is ready to handle method calls.
 */
analytics.internal.Settings.prototype.whenReady;


/**
 * Adds a listener to be notified of changes. This may only be called if the
 * Deferred from whenReady() has succeeded.
 * @param {function(!analytics.internal.Settings.Property)} listener
 */
analytics.internal.Settings.prototype.addChangeListener;


/**
 * Throws an error if the value has not yet been read from storage.
 * @return {string} User id for the current user.
 */
analytics.internal.Settings.prototype.getUserId;


/**
 * @return {number} User sample rate (an int from 1 to 100).
 */
analytics.internal.Settings.prototype.getSampleRate;


/**
 * Cleanup all internal state before being destroyed.
 * This exists solely to tightly manage the lifecycle of the
 * ServiceSettings object when used in integration testing.
 * This is necessitated due to unpredictable object
 * cleanup in IE browsers.
 * @type {function()}
 */
analytics.internal.Settings.prototype.dispose;


/** @typedef {string} */
analytics.internal.Settings.Property;


/**
 * Listenable properties used anywhere a string key is needed to identify.
 * @enum {!analytics.internal.Settings.Property}
 */
analytics.internal.Settings.Properties = {
  USER_ID: 'analytics.user-id',
  TRACKING_PERMITTED: 'analytics.tracking-permitted'
};

//analytics/tracking/chrome/internal/service_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A Channel that delegates hits to a selected delegate channel
 * based on user perferences and environmental information. This allows the GA
 * service to dynamically change the behavior by swapping the delegate channel
 * in response to changes in the environment such as device network
 * status change or user tracking opt-out.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.ServiceChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const DivertingChannel = goog.require('analytics.internal.DivertingChannel');
const Settings = goog.require('analytics.internal.Settings');
const googArray = goog.require('goog.array');

/**
 * @implements {Channel}
 */
const ServiceChannel = class {
  /**
   * @param {!Settings} settings
   * @param {function(): !Channel}
   *     enabledChannelFactory
   * @param {!Channel} disabledChannel
   */
  constructor(settings, enabledChannelFactory, disabledChannel) {
    /** @private {!Settings} */
    this.settings_ = settings;

    /**
     * Queue of hits received pre-settings (and channel) initialization.
     * This is drained and nulled out once the *real* runtime enabled
     * channel is constructed.
     * @private {?Array.<!DivertingChannel.Capture>}
     */
    this.diverted_ = [];

    /**
     * All known delegate channels. When a user opts-in/out or is sampled in/out
     * we'll select the appropriate channel from this map.
     *
     * <p>DO NOT CALL THESE CHANNELS DIRECTLY. Call this.channel_.
     * @private {!ServiceChannel.Channels_}
     */
    this.channels_ = {
      /*
       * Settings are loaded asynchronously, so we don't have the *real* enabled
       * channel initially. For that reason we divert hits sent prior to
       * initialization to a buffer. Once the *real* enabled channel is ready
       * we'll swap this out for the real channel and flush
       * the queue of diverted hits.
       */
      enabled: new DivertingChannel(this.diverted_),
      disabled: disabledChannel
    };

    /**
     * The active delegate channel. This channel is updated when the user
     * opts in/out. We default to the enabled channel knowing that prior
     * to settings being ready it diverts hits to a queue.
     * @private {Channel}
     */
    this.channel_ = this.channels_.enabled;

    this.settings_.whenReady().addCallbacks(
        goog.partial(this.onSettingsReady_, enabledChannelFactory),
        this.onSettingsLoadFailed_, this);
  }

  /**
   * When settings becomes ready we complete channel initialization and
   * install property change listeners.
   * @param {function(): !Channel} enabledChannelFactory
   * @private
   */
  onSettingsReady_(enabledChannelFactory) {
    if (this.diverted_ === null) {
      throw new Error('Channel setup already completed.');
    }

    // Get the "enabled" channel from the factory
    this.channels_.enabled = enabledChannelFactory();
    this.pickChannel_();

    // Drain all hits that were sent prior to now (those that were sent
    // before the settings were available).
    googArray.forEach(
        this.diverted_,
        /** @param {!DivertingChannel.Capture} capture */
        function(capture) {
          this.send(capture.hitType, capture.parameters);
        },
        this);
    this.diverted_ = null;

    this.settings_.addChangeListener(goog.bind(this.onSettingsChanged_, this));
  }

  /**
   * If settings fail to load, switch to the disabled channel and replace the
   * temp-enabled channel we were using with the disabled channel.
   *
   * @private
   */
  onSettingsLoadFailed_() {
    if (this.diverted_ === null) {
      throw new Error('Channel setup already completed.');
    }

    this.channels_.enabled = this.channels_.disabled;
    this.channel_ = this.channels_.disabled;
    this.diverted_ = null;
  }

  /** @override */
  send(hitType, parameters) {
    return this.channel_.send(hitType, parameters);
  }

  /**
   * Updates the selected channel to reflect current settings.
   * @private
   */
  pickChannel_() {
    this.channel_ = this.settings_.isTrackingPermitted() ?
        this.channels_.enabled :
        this.channels_.disabled;
  }

  /**
   * @param {!Settings.Property} property
   * @private
   */
  onSettingsChanged_(property) {
    switch (property) {
      case Settings.Properties.TRACKING_PERMITTED:
        this.pickChannel_();
        break;
    }
  }
};

/**
 * @typedef {{
 *   enabled: !Channel,
 *   disabled: !Channel
 * }}
 * @private
 */
ServiceChannel.Channels_;

exports = ServiceChannel;

;return exports;});

//analytics/tracking/chrome/internal/service_channel_manager.js
// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides `ServiceChannelManager` as well
 * as its factory. See class docs for details.
 *
 * @author smckay@google.com (Steve McKay)
 */
goog.provide('analytics.internal.ServiceChannelManager');
goog.provide('analytics.internal.ServiceChannelManager.Factory');

goog.require('analytics.internal.ChannelManager');
goog.require('analytics.internal.DummyChannel');
goog.require('analytics.internal.FilterChannel');
goog.require('analytics.internal.ServiceChannel');
goog.require('goog.array');
goog.requireType('analytics.Tracker');
goog.requireType('analytics.internal.Channel');
goog.requireType('analytics.internal.HasChannel');
goog.requireType('analytics.internal.Settings');



/**
 * The `ChannelManager` instance providing access to the
 * `Channel` used for processing hits at runtime,
 * as well as support for runtime manipulation of request-
 * processing (specifically the ability to add filters).
 * @implements {analytics.internal.ChannelManager}
 */
analytics.internal.ServiceChannelManager = class {
  /**
   * @param {!analytics.internal.Settings} settings
   * @param {!analytics.internal.HasChannel} sharedChannelProvider
   *     Factory for creating the shared channel.
   *     Called once the settings object becomes ready.
   *     The resulting channel is shared between all `ServiceChannel`
   *     instances.
   */
  constructor(settings, sharedChannelProvider) {
    /**
     * This is initialized only when ServiceChannel asks for the
     * channel via the injected factory. This is deferred
     * until settings are loaded.
     *
     * @private {!analytics.internal.FilterChannel}
     */
    this.filterChannel_;

    /**
     * Buffer of any filters installed before the filter channel is
     * created.
     *
     * @private {Array.<!analytics.Tracker.Filter>}
     */
    this.bufferedFilters_ = [];

    var filterChannelFactory = goog.bind(
        /**
         * Returns the head of a chain of channels used for processing
         * hits when tracking is enabled. ServiceChannel will call
         * this once settings becomes *ready*.
         *
         * <p>This funky little arrangement allows us to handle
         * hits before we know if tracking is enabled. This affords
         * as a fully synchronous public tracking interface, including
         * construction. See `ServiceChannel` for details.
         *
         * @return {!analytics.internal.Channel}
         * @this {analytics.internal.ServiceChannelManager}
         */
        function() {
          this.filterChannel_ = new analytics.internal.FilterChannel(
              sharedChannelProvider.getChannel());
          // drain the buffer of filters installed before
          // the filter channel was created.
          goog.array.forEach(
              this.bufferedFilters_,
              /**
               * @param {!analytics.Tracker.Filter} filter
               * @this {analytics.internal.ServiceChannelManager}
               */
              function(filter) {
                this.filterChannel_.addFilter(filter);
              },
              this);
          this.bufferedFilters_ = null;
          return this.filterChannel_;
        },
        this);

    /** @private {!analytics.internal.Channel} */
    this.channel_ = new analytics.internal.ServiceChannel(
        settings, filterChannelFactory,
        analytics.internal.DummyChannel.getInstance());
  }

  /** @override */
  getChannel() {
    return this.channel_;
  }

  /** @override */
  addFilter(filter) {
    if (this.filterChannel_) {
      this.filterChannel_.addFilter(filter);
    } else {
      this.bufferedFilters_.push(filter);
    }
  }
};



/**
 * The `ChannelManager.Factory` responsible for creating the
 * concrete `ChannelManager` (and consequently the concrete channels).
 * @implements {analytics.internal.ChannelManager.Factory}
 */
analytics.internal.ServiceChannelManager.Factory = class {
  /**
   * @param {!analytics.internal.Settings} settings
   * @param {!analytics.internal.HasChannel} sharedChannelProvider
   *     Provider of the the shared channel.
   *     Called only once the shared settings object becomes ready.
   *     The resulting channel is shared between all `ServiceChannel`
   *     instances.
   */
  constructor(settings, sharedChannelProvider) {
    /** @private {!analytics.internal.Settings} */
    this.settings_ = settings;

    /**
     * Used to lazily create the shared channel.
     * @private {!analytics.internal.HasChannel}
     */
    this.sharedChannelProvider_ = sharedChannelProvider;
  }

  /** @override */
  create() {
    return new analytics.internal.ServiceChannelManager(
        this.settings_, this.sharedChannelProvider_);
  }
};

//analytics/tracking/chrome/internal/identifier.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Support for generating random UUIDs.
 * According to wikipedia.
 * Version 4 UUIDs have the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx where
 * x is any hexadecimal digit and y is one of 8, 9, a, or b
 * (e.g., f47ac10b-58cc-4372-a567-0e02b2c3d479).
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.Identifier');
goog.module.declareLegacyNamespace();

const googMath = goog.require('goog.math');

/** @type {string} */
const UUID_FMT = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

/** @type {RegExp} */
const UUID_MATCHER =
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;

/**
 * @return {string} A randomly generated UUID V4.
 */
function generateUuid() {
  var chars = UUID_FMT.split('');
  for (var i = 0, len = chars.length; i < len; i++) {
    switch (chars[i]) {
      case 'x':
        chars[i] = googMath.randomInt(16).toString(16);
        break;
      case 'y':
        chars[i] = (googMath.randomInt(4) + 8).toString(16);
        break;
    }
  }

  return chars.join('');
}

/**
 * @param {string} id
 * @return {boolean} True if the UUID is a valid V4 id.
 */
function isValidUuid(id) {
  return UUID_MATCHER.test(id);
}

exports = {
  generateUuid,
  isValidUuid,
};

;return exports;});

//third_party/javascript/closure/mochikit/async/deferredlist.js
/**
 * @license
 * Copyright 2005, 2007 Bob Ippolito. All Rights Reserved.
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: MIT
 */

// Portions of this code are from MochiKit, received by The Closure
// Library Authors under the MIT license. All other code is Copyright
// The Closure Library Authors.

/**
 * @fileoverview Class for tracking multiple asynchronous operations and
 * handling the results. The DeferredList object here is patterned after the
 * DeferredList object in the Twisted python networking framework.
 *
 * Based on the MochiKit code.
 *
 * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html
 *
 * @author brenneman@google.com (Shawn Brenneman)
 */

goog.provide('goog.async.DeferredList');

goog.require('goog.async.Deferred');



/**
 * Constructs an object that waits on the results of multiple asynchronous
 * operations and marshals the results. It is itself a <code>Deferred</code>,
 * and may have an execution sequence of callback functions added to it. Each
 * <code>DeferredList</code> instance is single use and may be fired only once.
 *
 * The default behavior of a <code>DeferredList</code> is to wait for a success
 * or error result from every <code>Deferred</code> in its input list. Once
 * every result is available, the <code>DeferredList</code>'s execution sequence
 * is fired with a list of <code>[success, result]</code> array pairs, where
 * <code>success</code> is a boolean indicating whether <code>result</code> was
 * the product of a callback or errback. The list's completion criteria and
 * result list may be modified by setting one or more of the boolean options
 * documented below.
 *
 * <code>Deferred</code> instances passed into a <code>DeferredList</code> are
 * independent, and may have additional callbacks and errbacks added to their
 * execution sequences after they are passed as inputs to the list.
 *
 * @param {!Array<!goog.async.Deferred>} list An array of deferred results to
 *     wait for.
 * @param {boolean=} opt_fireOnOneCallback Whether to stop waiting as soon as
 *     one input completes successfully. In this case, the
 *     <code>DeferredList</code>'s callback chain will be called with a two
 *     element array, <code>[index, result]</code>, where <code>index</code>
 *     identifies which input <code>Deferred</code> produced the successful
 *     <code>result</code>.
 * @param {boolean=} opt_fireOnOneErrback Whether to stop waiting as soon as one
 *     input reports an error. The failing result is passed to the
 *     <code>DeferredList</code>'s errback sequence.
 * @param {boolean=} opt_consumeErrors When true, any errors fired by a
 *     <code>Deferred</code> in the input list will be captured and replaced
 *     with a succeeding null result. Any callbacks added to the
 *     <code>Deferred</code> after its use in the <code>DeferredList</code> will
 *     receive null instead of the error.
 * @param {Function=} opt_canceler A function that will be called if the
 *     <code>DeferredList</code> is canceled. @see goog.async.Deferred#cancel
 * @param {Object=} opt_defaultScope The default scope to invoke callbacks or
 *     errbacks in.
 * @constructor
 * @extends {goog.async.Deferred}
 */
goog.async.DeferredList = function(
    list, opt_fireOnOneCallback, opt_fireOnOneErrback, opt_consumeErrors,
    opt_canceler, opt_defaultScope) {
  'use strict';
  goog.async.DeferredList.base(
      this, 'constructor', opt_canceler, opt_defaultScope);

  /**
   * The list of Deferred objects to wait for.
   * @const {!Array<!goog.async.Deferred>}
   * @private
   */
  this.list_ = list;

  /**
   * The stored return values of the Deferred objects.
   * @const {!Array}
   * @private
   */
  this.deferredResults_ = [];

  /**
   * Whether to fire on the first successful callback instead of waiting for
   * every Deferred to complete.
   * @const {boolean}
   * @private
   */
  this.fireOnOneCallback_ = !!opt_fireOnOneCallback;

  /**
   * Whether to fire on the first error result received instead of waiting for
   * every Deferred to complete.
   * @const {boolean}
   * @private
   */
  this.fireOnOneErrback_ = !!opt_fireOnOneErrback;

  /**
   * Whether to stop error propagation on the input Deferred objects. If the
   * DeferredList sees an error from one of the Deferred inputs, the error will
   * be captured, and the Deferred will be returned to success state with a null
   * return value.
   * @const {boolean}
   * @private
   */
  this.consumeErrors_ = !!opt_consumeErrors;

  /**
   * The number of input deferred objects that have fired.
   * @private {number}
   */
  this.numFinished_ = 0;

  for (let i = 0; i < list.length; i++) {
    const d = list[i];
    d.addCallbacks(goog.bind(this.handleCallback_, this, i, true),
                   goog.bind(this.handleCallback_, this, i, false));
  }

  if (list.length == 0 && !this.fireOnOneCallback_) {
    this.callback(this.deferredResults_);
  }
};
goog.inherits(goog.async.DeferredList, goog.async.Deferred);


/**
 * Registers the result from an input deferred callback or errback. The result
 * is returned and may be passed to additional handlers in the callback chain.
 *
 * @param {number} index The index of the firing deferred object in the input
 *     list.
 * @param {boolean} success Whether the result is from a callback or errback.
 * @param {*} result The result of the callback or errback.
 * @return {*} The result, to be handled by the next handler in the deferred's
 *     callback chain (if any). If consumeErrors is set, an error result is
 *     replaced with null.
 * @private
 */
goog.async.DeferredList.prototype.handleCallback_ = function(
    index, success, result) {
  'use strict';
  this.numFinished_++;
  this.deferredResults_[index] = [success, result];

  if (!this.hasFired()) {
    if (this.fireOnOneCallback_ && success) {
      this.callback([index, result]);
    } else if (this.fireOnOneErrback_ && !success) {
      this.errback(result);
    } else if (this.numFinished_ == this.list_.length) {
      this.callback(this.deferredResults_);
    }
  }

  if (this.consumeErrors_ && !success) {
    result = null;
  }

  return result;
};


/** @override */
goog.async.DeferredList.prototype.errback = function(res) {
  'use strict';
  goog.async.DeferredList.base(this, 'errback', res);

  // On error, cancel any pending requests.
  for (let i = 0; i < this.list_.length; i++) {
    this.list_[i].cancel();
  }
};


/**
 * Creates a <code>DeferredList</code> that gathers results from multiple
 * <code>Deferred</code> inputs. If all inputs succeed, the callback is fired
 * with the list of results as a flat array. If any input fails, the list's
 * errback is fired immediately with the offending error, and all other pending
 * inputs are canceled.
 *
 * @param {!Array<!goog.async.Deferred>} list The list of <code>Deferred</code>
 *     inputs to wait for.
 * @return {!goog.async.Deferred} The deferred list of results from the inputs
 *     if they all succeed, or the error result of the first input to fail.
 */
goog.async.DeferredList.gatherResults = function(list) {
  'use strict';
  return new goog.async.DeferredList(list, false, true)
      .addCallback(function(results) {
        'use strict';
        const output = [];
        for (let i = 0; i < results.length; i++) {
          output[i] = results[i][1];
        }
        return output;
      });
};

//analytics/tracking/chrome/internal/service_settings.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview The "official" GA instance of service settings. This class
 * is responsible for service state. This includes generating/persisting user
 * ids, finding ALL sources of "opt-out", allowing a user to opt-out of tracking
 * and persisting this information.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.ServiceSettings');
goog.module.declareLegacyNamespace();

const AsyncStorage = goog.require('analytics.internal.AsyncStorage');
const Config = goog.requireType('analytics.Config');
const Deferred = goog.require('goog.async.Deferred');
const DeferredList = goog.require('goog.async.DeferredList');
const Identifier = goog.require('analytics.internal.Identifier');
const Settings = goog.require('analytics.internal.Settings');
const events = goog.require('goog.events');
const googArray = goog.require('goog.array');

/**
 * @implements {Settings}
 */
const ServiceSettings = class {
  /**
   * @param {!AsyncStorage} storage
   */
  constructor(storage) {
    /** @private {!AsyncStorage} */
    this.storage_ = storage;

    /** @private {number} */
    this.sampleRate_ = 100;

    /**
     * Callbacks to trigger when settings change.
     * @private {!Array.<function(!Settings.Property)>}
     */
    this.changeListeners_ = [];

    /** @private {?string} */
    this.userId_ = null;

    /** @private {?boolean} */
    this.permitted_ = null;

    /** @private {!Deferred} */
    this.ready_ = this.init_();

    /**
     * In certain testing circumstances we want to tightly control
     * the lifecycle of this object (well its listeners).
     * @private {events.Key}
     */
    this.storageListenerKey_;

    // Finally, once we're initialized, add a change listener
    // on the underlying storage in case a settings instance
    // in another script context changes the settings.
    this.ready_.addCallback(function() {
      this.storageListenerKey_ = events.listen(
          this.storage_, AsyncStorage.Event.STORAGE_CHANGED,
          goog.bind(this.handleStorageChanged_, this));
    }, this);
  }

  /**
   * Initializes this.userId_ and this.permitted_ from storage, firing the
   * this.ready_ deferred when both are done loading.
   *
   * @return {!Deferred.<!Config>}
   *     Fires when settings is fully initialized.
   * @private
   */
  init_() {
    return this.loadSettings_().addCallback(
        /**
         * @return {!Config}
         * @this {ServiceSettings}
         */
        function() {
          return this;
        },
        this);
  }

  /**
   * Initializes this.userId_ and this.permitted_ from storage, then
   * fires a deferred.
   *
   * @return {!Deferred} Fires when settings is fully initialized.
   * @private
   */
  loadSettings_() {
    return DeferredList.gatherResults(
        [this.loadTrackingPermitted_(), this.loadUserId_()]);
  }

  /** @override */
  whenReady() {
    return this.ready_.branch();
  }

  /**
   * Called when the chrome.storage area changes underneath us. This
   * could happen if there are multiple script contexts (multiple
   * pages) with separate settings instances. We want to honor
   * changes in settings from other scripts that are part of the
   * same app.
   *
   * @private
   */
  handleStorageChanged_() {
    this.assertReady_();
    var userId = this.getUserId();
    var trackingPermitted = this.isTrackingPermitted();
    this.loadSettings_().addCallback(function() {
      if (userId != this.getUserId()) {
        this.firePropertyChangedEvent_(Settings.Properties.USER_ID);
      }
      if (trackingPermitted != this.isTrackingPermitted()) {
        this.firePropertyChangedEvent_(Settings.Properties.TRACKING_PERMITTED);
      }
    }, this);
  }

  /** @override */
  addChangeListener(listener) {
    this.assertReady_();
    this.changeListeners_.push(listener);
  }

  /** @override */
  setTrackingPermitted(permitted) {
    this.assertReady_();

    var changed = this.permitted_ != permitted;

    this.permitted_ = permitted;
    this.storage_.set(
        Settings.Properties.TRACKING_PERMITTED, permitted.toString());

    if (changed) {
      this.firePropertyChangedEvent_(Settings.Properties.TRACKING_PERMITTED);
    }
  }

  /** @override */
  isTrackingPermitted() {
    this.assertReady_();

    return /** @type {boolean} */ (this.permitted_) &&
        !this.isOptOutViaPlugin_();
  }

  /**
   * Loads the tracking permitted setting.
   * @return {!Deferred} A deferred firing when the setting is
   *     loaded.
   * @private
   */
  loadTrackingPermitted_() {
    return this.storage_.get(Settings.Properties.TRACKING_PERMITTED)
        .addCallback(function(value) {
          // Tracking is permitted by default.
          this.permitted_ = true;
          if (value !== undefined) {
            switch (value) {
              case 'true':
                this.permitted_ = true;
                break;
              case 'false':
                this.permitted_ = false;
                break;
            }
          }
        }, this);
  }

  /**
   * Check whether the user is opted out via the plugin which adds a function to
   * the global scope. This only works on web pages (i.e. not in a Chrome app).
   *
   * @return {boolean} True if the user should be considered to have opted out
   *     because they installed the GA opt-out plugin.
   * @private
   */
  isOptOutViaPlugin_() {
    var prefs = goog.global[ServiceSettings.USER_PREFS_];
    return prefs && prefs[ServiceSettings.OPTOUT_FUNCTION_] &&
        prefs[ServiceSettings.OPTOUT_FUNCTION_]();
  }

  /** @override */
  getUserId() {
    this.assertReady_();
    if (typeof this.userId_ !== 'string') {
      throw new Error('Invalid state. UserID is not a string.');
    }
    return this.userId_;
  }

  /**
   * Loads the user id from local storage. If it isn't present, creates it and
   * writes it to local storage.
   * @return {!Deferred} A deferred firing when the user id is
   *     loaded.
   * @private
   */
  loadUserId_() {
    return this.storage_.get(Settings.Properties.USER_ID)
        .addCallback(function(id) {
          if (id !== undefined) {
            this.userId_ = id;
          } else {
            this.initializeUserId_();
          }
        }, this);
  }

  /**
   * Loads the user id from local storage. If it isn't present, creates it and
   * writes it to local storage.
   * @return {!Deferred} A deferred firing when the user id is
   *     loaded.
   * @private
   */
  initializeUserId_() {
    this.userId_ = Identifier.generateUuid();
    return this.storage_.set(Settings.Properties.USER_ID, this.userId_)
        .addCallback(function() {
          this.firePropertyChangedEvent_(Settings.Properties.USER_ID);
        }, this);
  }

  /** @override */
  setSampleRate(sampleRate) {
    this.assertReady_();
    this.sampleRate_ = sampleRate;
  }

  /** @override */
  getSampleRate() {
    this.assertReady_();
    return this.sampleRate_;
  }

  /** @override */
  resetUserId() {
    return this.initializeUserId_();
  }

  /**
   * Fires the property changed event for the supplied property.
   *
   * @param {!Settings.Property} property
   * @private
   */
  firePropertyChangedEvent_(property) {
    googArray.forEach(
        this.changeListeners_,
        /** @param {function(!Settings.Property)} listener */
        function(listener) {
          listener(property);
        });
  }

  /** @override */
  dispose() {
    if (this.storageListenerKey_ != null) {
      events.unlistenByKey(this.storageListenerKey_);
    }
  }

  /** @private */
  assertReady_() {
    if (!this.whenReady().hasFired()) {
      throw new Error(
          'Settings object accessed prior to entering ready state.');
    }
  }
};

/**
 * User prefs added by the Google Analytics opt-out plugin.
 * @private {string}
 */
ServiceSettings.USER_PREFS_ = '_gaUserPrefs';

/**
 * Name of the opt-out function added by the Google Analytics opt-out plugin.
 * @private {string}
 */
ServiceSettings.OPTOUT_FUNCTION_ = 'ioo';

exports = ServiceSettings;

;return exports;});

//analytics/tracking/chrome/internal/async_settings_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A channel that adds missing or useful attributes needed
 * to complete the sending of a hit. This allows the addition of information
 * not available at the time the tracker was initialized such as user id.
 * For this reason it should be ahead of any channels in the channel pipeline
 * depending on the user id.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.AsyncSettingsChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Parameters = goog.require('analytics.internal.Parameters');
const Settings = goog.require('analytics.internal.Settings');

/**
 * @implements {Channel}
 */
const AsyncSettingsChannel = class {
  /**
   * @param {!Settings} settings A "ready" settings object.
   * @param {!Channel} delegate
   */
  constructor(settings, delegate) {
    /** @private {!Settings} */
    this.settings_ = settings;

    /** @private {!Channel} */
    this.delegate_ = delegate;
  }

  /** @override */
  send(hitType, parameters) {
    parameters.set(Parameters.CLIENT_ID, this.settings_.getUserId());
    return this.delegate_.send(hitType, parameters);
  }
};

exports = AsyncSettingsChannel;

;return exports;});

//analytics/tracking/chrome/internal/parameter_filter_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A Channel that filters parameters in a hit per business rules.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.ParameterFilterChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Parameter = goog.require('analytics.Parameter');
const ParameterMap = goog.requireType('analytics.ParameterMap');
const Value = goog.requireType('analytics.Value');
const ValueTypes = goog.require('analytics.ValueTypes');

/**
 * @implements {Channel}
 */
const ParameterFilterChannel = class {
  /**
   * @param {!Channel} delegate
   */
  constructor(delegate) {
    /** @private {!Channel} */
    this.delegate_ = delegate;
  }

  /** @override */
  send(hitType, parameters) {
    ParameterFilterChannel.truncateStrings_(parameters);
    ParameterFilterChannel.removeDefaults_(parameters);
    return this.delegate_.send(hitType, parameters);
  }

  /**
   * @param {!ParameterMap} parameters
   * @private
   */
  static truncateStrings_(parameters) {
    parameters.forEachEntry(
        /**
         * @param {!Parameter} parameter
         * @param {!Value} value
         */
        function(parameter, value) {
          if (parameter.maxLength !== undefined &&
              parameter.valueType == ValueTypes.TEXT &&
              parameter.maxLength > 0 && value.length > parameter.maxLength) {
            parameters.set(parameter, value.substring(0, parameter.maxLength));
          }
        });
  }

  /**
   * @param {!ParameterMap} parameters
   * @private
   */
  static removeDefaults_(parameters) {
    parameters.forEachEntry(
        /**
         * @param {!Parameter} parameter
         * @param {!Value} value
         */
        function(parameter, value) {
          if (parameter.defaultValue !== undefined &&
              value == parameter.defaultValue) {
            parameters.remove(parameter);
          }
        });
  }
};

exports = ParameterFilterChannel;

;return exports;});

//analytics/tracking/chrome/result.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Error objects describing failed operations.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.provide('analytics.Result');
goog.provide('analytics.Results');
goog.provide('analytics.Status');


/**
 * All known status codes.
 * @enum {string}
 */
analytics.Status = {
  // The request was not sent due to the device being offline.
  DEVICE_OFFLINE: 'device-offline',
  // The encoded payload of a hit is TOOOOOOOO long (more than about 8k chars)
  PAYLOAD_TOO_BIG: 'payload-too-big',
  // The request was not sent due to rate limiting.
  RATE_LIMITED: 'rate-limited',
  // The request was not sent because the user is not in the sample set.
  SAMPLED_OUT: 'sampled-out',
  // The request was successfully processed by the library and sent to
  // Google Analytics for further processing.
  SENT: 'sent'
};


/**
 * @typedef {{
 *   status: analytics.Status,
 *   details: *
 * }}
 */
analytics.Result;


/**
 * Well known results objects. Results with dynamic content cannot be
 * declared here for obvious reasons.
 * @enum {!analytics.Result}
 */
analytics.Results = {
  DEVICE_OFFLINE: {
    status: analytics.Status.DEVICE_OFFLINE,
    details: undefined
  },
  PAYLOAD_TOO_BIG: {
    status: analytics.Status.PAYLOAD_TOO_BIG,
    details: undefined
  },
  RATE_LIMITED: {
    status: analytics.Status.RATE_LIMITED,
    details: undefined
  },
  SAMPLED_OUT: {
    status: analytics.Status.SAMPLED_OUT,
    details: undefined
  },
  SENT: {
    status: analytics.Status.SENT,
    details: undefined
  }
};

//analytics/tracking/chrome/internal/rate_limiting_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A Channel that limits the rate at which hits are delegated
 * to a delegate Channel.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.RateLimitingChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');
const HitType = goog.require('analytics.HitType');
const HitTypes = goog.require('analytics.HitTypes');
const Results = goog.require('analytics.Results');

const TokenBucket = goog.requireType('analytics.internal.TokenBucket');
const analytics = goog.requireType('analytics');

/**
 * @implements {Channel}
 */
const RateLimitingChannel = class {
  /**
   * @param {!TokenBucket} tokens
   * @param {!Channel} delegate
   */
  constructor(tokens, delegate) {
    /** @private {!TokenBucket} */
    this.tokens_ = tokens;

    /** @private {!Channel} */
    this.delegate_ = delegate;
  }

  /** @override */
  send(hitType, parameters) {
    return this.canDelegate_(hitType) ?
        this.delegate_.send(hitType, parameters) :
        Deferred.succeed(Results.RATE_LIMITED);
  }

  /**
   * @param {!HitType} hitType
   * @return {boolean} True if we can delegate the hit.
   * @private
   */
  canDelegate_(hitType) {
    return this.tokens_.consumeTokens(1) || hitType == HitTypes.ITEM ||
        hitType == HitTypes.TRANSACTION;
  }
};

exports = RateLimitingChannel;

;return exports;});

//analytics/tracking/chrome/internal/token_bucket.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple single aspect "token bucket" implementation.
 * See http://en.wikipedia.org/wiki/Token_bucket for details of the pattern.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.TokenBucket');
goog.module.declareLegacyNamespace();

const asserts = goog.require('goog.asserts');

/**
 * @param {number} initialTokens The initial number of tokens in the bucket.
 * @param {number} maxTokens The max number of tokens that can be accumulated.
 * @param {TokenBucket.FillRate|number} fillRate The number
 *     of tokens to be added per millisecond. Only whole tokens are added.
 * @param {function(): number=} opt_timeSource A function that returns
 *     the current time in milliseconds. Useful for testing or warping
 *     the reality of time. Stick with the former case.
 * @constructor
 * @struct
 */
function TokenBucket(initialTokens, maxTokens, fillRate, opt_timeSource) {
  asserts.assert(initialTokens >= 0);
  asserts.assert(maxTokens > 0);
  asserts.assert(fillRate >= 0);

  /** @private {number} */
  this.availableTokens_ = initialTokens;

  /** @private {number} */
  this.maxTokens_ = maxTokens;

  /** @private {number} */
  this.fillRate_ = fillRate;

  /** @private {function(): number} */
  this.timeSource_ =
      opt_timeSource ||
      /** @return {number} */
      function() {
        return (new Date()).getTime();
      };

  /**
   * Timestamp when we last filled the bucket.
   * @private {number}
   */
  this.lastFilled_ = this.timeSource_();
}

/**
 * @param {number} tokens
 * @return {boolean} True if the tokens were available and thusly consumed.
 */
TokenBucket.prototype.consumeTokens = function(tokens) {
  this.fillTokens_();

  if (tokens > this.availableTokens_) {
    return false;
  }

  this.availableTokens_ -= tokens;
  return true;
};

/**
 * Adds as many tokens to the bucket as are allowed by the configuration.
 * @private
 */
TokenBucket.prototype.fillTokens_ = function() {
  var now = this.timeSource_();
  var elapsedMillis = (now - this.lastFilled_);
  var tokens = Math.floor(elapsedMillis * this.fillRate_);

  if (tokens > 0) {
    this.availableTokens_ =
        Math.min(this.availableTokens_ + tokens, this.maxTokens_);

    this.lastFilled_ = now;
  }
};

/**
 * @enum {number}
 */
TokenBucket.FillRate = {
  ONE_EVERY_SECOND: .001,
  ONE_EVERY_TWO_SECONDS: .0005
};

exports = TokenBucket;

;return exports;});

//analytics/tracking/chrome/internal/user_sampling_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A Channel that samples out hits based on the sample rate
 * established in settings.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.UserSamplingChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');
const HitType = goog.require('analytics.HitType');
const HitTypes = goog.require('analytics.HitTypes');
const ParameterMap = goog.requireType('analytics.ParameterMap');
const Parameters = goog.require('analytics.internal.Parameters');
const Results = goog.require('analytics.Results');
const Settings = goog.require('analytics.internal.Settings');
const Value = goog.require('analytics.Value');

/**
 * @implements {Channel}
 */
const UserSamplingChannel = class {
  /**
   * @param {!Settings} settings
   * @param {!Channel} delegate
   */
  constructor(settings, delegate) {
    /** @private {!Settings} */
    this.settings_ = settings;

    /** @private {!Channel} */
    this.delegate_ = delegate;
  }

  /** @override */
  send(hitType, parameters) {
    var clientId = parameters.get(Parameters.CLIENT_ID);

    // Since all digits in the id are random, we just pull the four hex digits
    // from the second component in the id giving us a range of 0 - 65535. The
    // sample rate we test against is scaled up to be proportionate with this
    // range.
    var idPart = parseInt(clientId.split('-')[1], 16);
    var base16SampleRate =
        (this.getSampleRate_(hitType, parameters) *
         UserSamplingChannel.SAMPLE_RATE_SCALE_);
    return idPart < base16SampleRate ?
        this.delegate_.send(hitType, parameters) :
        Deferred.succeed(Results.SAMPLED_OUT);
  }

  /**
   * Return the sample rate for the channel. The default value is part of the
   * tracker's state, but may be overridden in the parameters map. If an
   * override is found in the parameters map, it is removed so that it won't be
   * passed to GA erroneously.
   *
   * Note that the override functionality is currently only supported for TIMING
   * hits. For other hit types, the default value from the tracker's settings is
   * returned.
   *
   * @param {!HitType} hitType The hit type.
   * @param {!ParameterMap} parameters The parameters to send.
   * @return {Value}
   * @private
   */
  getSampleRate_(hitType, parameters) {
    if (hitType != HitTypes.TIMING) {
      return this.settings_.getSampleRate();
    }
    var sampleRateOverride = parameters.get(Parameters.SAMPLE_RATE_OVERRIDE);
    if (sampleRateOverride) {
      parameters.remove(Parameters.SAMPLE_RATE_OVERRIDE);
    }
    return sampleRateOverride || this.settings_.getSampleRate();
  }
};

/** @private {number} */
UserSamplingChannel.SAMPLE_RATE_SCALE_ = 655.36;

exports = UserSamplingChannel;

;return exports;});

//third_party/javascript/closure/net/networkstatusmonitor.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base class for objects monitoring and exposing runtime
 * network status information.
 */

goog.provide('goog.net.NetworkStatusMonitor');

goog.require('goog.events.Listenable');



/**
 * Base class for network status information providers.
 * @interface
 * @extends {goog.events.Listenable}
 */
goog.net.NetworkStatusMonitor = function() {};


/**
 * Enum for the events dispatched by the OnlineHandler.
 * @enum {string}
 */
goog.net.NetworkStatusMonitor.EventType = {
  ONLINE: 'online',
  OFFLINE: 'offline',
};


/**
 * @return {boolean} Whether the system is online or otherwise.
 */
goog.net.NetworkStatusMonitor.prototype.isOnline;

//third_party/javascript/closure/json/json.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview JSON utility functions.
 */


goog.provide('goog.json');
goog.provide('goog.json.Replacer');
goog.provide('goog.json.Reviver');
goog.provide('goog.json.Serializer');


/**
 * @define {boolean} If true, use the native JSON parsing API.
 * NOTE: The default `goog.json.parse` implementation is able to handle
 * invalid JSON. JSPB used to produce invalid JSON which is not the case
 * anymore so this is safe to enable for parsing JSPB. Using native JSON is
 * faster and safer than the default implementation using `eval`.
 */
goog.json.USE_NATIVE_JSON = goog.define('goog.json.USE_NATIVE_JSON', false);

/**
 * @define {boolean} If true, try the native JSON parsing API first. If it
 * fails, log an error and use `eval` instead. This is useful when
 * transitioning to `goog.json.USE_NATIVE_JSON`. The error logger needs to
 * be set by `goog.json.setErrorLogger`. If it is not set then the error
 * is ignored.
 */
goog.json.TRY_NATIVE_JSON = goog.define('goog.json.TRY_NATIVE_JSON', true);


/**
 * Tests if a string is an invalid JSON string. This only ensures that we are
 * not using any invalid characters
 * @param {string} s The string to test.
 * @return {boolean} True if the input is a valid JSON string.
 */
goog.json.isValid = function(s) {
  'use strict';
  // All empty whitespace is not valid.
  if (/^\s*$/.test(s)) {
    return false;
  }

  // This is taken from http://www.json.org/json2.js which is released to the
  // public domain.
  // Changes: We dissallow \u2028 Line separator and \u2029 Paragraph separator
  // inside strings.  We also treat \u2028 and \u2029 as whitespace which they
  // are in the RFC but IE and Safari does not match \s to these so we need to
  // include them in the reg exps in all places where whitespace is allowed.
  // We allowed \x7f inside strings because some tools don't escape it,
  // e.g. http://www.json.org/java/org/json/JSONObject.java

  // Parsing happens in three stages. In the first stage, we run the text
  // against regular expressions that look for non-JSON patterns. We are
  // especially concerned with '()' and 'new' because they can cause invocation,
  // and '=' because it can cause mutation. But just to be safe, we want to
  // reject all unexpected forms.

  // We split the first stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace all backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters, but only when followed
  // by a colon, comma, closing bracket or end of string. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

  // Don't make these static since they have the global flag.
  const backslashesRe = /\\["\\\/bfnrtu]/g;
  const simpleValuesRe =
      /(?:"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)[\s\u2028\u2029]*(?=:|,|]|}|$)/g;
  const openBracketsRe = /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g;
  const remainderRe = /^[\],:{}\s\u2028\u2029]*$/;

  return remainderRe.test(
      s.replace(backslashesRe, '@')
          .replace(simpleValuesRe, ']')
          .replace(openBracketsRe, ''));
};

/**
 * Logs a parsing error in `JSON.parse` solvable by using `eval`
 * if `goog.json.TRY_NATIVE_JSON` is enabled.
 * @private {function(string, !Error)} The first parameter is the error message,
 *     the second is the exception thrown by `JSON.parse`.
 */
goog.json.errorLogger_ = goog.nullFunction;


/**
 * Sets an error logger to use if there's a recoverable parsing error and
 * `goog.json.TRY_NATIVE_JSON` is enabled.
 * @param {function(string, !Error)} errorLogger The first parameter is the
 *     error message, the second is the exception thrown by `JSON.parse`.
 */
goog.json.setErrorLogger = function(errorLogger) {
  'use strict';
  goog.json.errorLogger_ = errorLogger;
};


/**
 * Parses a JSON string and returns the result. This throws an exception if
 * the string is an invalid JSON string.
 *
 * Note that this is very slow on large strings. Use JSON.parse if possible.
 *
 * @param {*} s The JSON string to parse.
 * @throws Error if s is invalid JSON.
 * @return {Object} The object generated from the JSON string, or null.
 * @deprecated Use JSON.parse.
 */
goog.json.parse = goog.json.USE_NATIVE_JSON ?
    /** @type {function(*):Object} */ (goog.global['JSON']['parse']) :
    function(s) {
      'use strict';
      let error;
      if (goog.json.TRY_NATIVE_JSON) {
        try {
          return goog.global['JSON']['parse'](s);
        } catch (ex) {
          error = ex;
        }
      }
      const o = String(s);
      if (goog.json.isValid(o)) {

        try {
          const result = /** @type {?Object} */ (eval('(' + o + ')'));
          if (error) {
            goog.json.errorLogger_('Invalid JSON: ' + o, error);
          }
          return result;
        } catch (ex) {
        }
      }
      throw new Error('Invalid JSON string: ' + o);
    };


/**
 * JSON replacer, as defined in Section 15.12.3 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * TODO(nicksantos): Array should also be a valid replacer.
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Replacer;


/**
 * JSON reviver, as defined in Section 15.12.2 of the ES5 spec.
 * @see http://ecma-international.org/ecma-262/5.1/#sec-15.12.3
 *
 * @typedef {function(this:Object, string, *): *}
 */
goog.json.Reviver;


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @param {?goog.json.Replacer=} opt_replacer A replacer function
 *     called for each (key, value) pair that determines how the value
 *     should be serialized. By defult, this just returns the value
 *     and allows default serialization to kick in.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.serialize = goog.json.USE_NATIVE_JSON ?
    /** @type {function(*, ?goog.json.Replacer=):string} */
    (goog.global['JSON']['stringify']) :
    function(object, opt_replacer) {
      'use strict';
      // NOTE(nicksantos): Currently, we never use JSON.stringify.
      //
      // The last time I evaluated this, JSON.stringify had subtle bugs and
      // behavior differences on all browsers, and the performance win was not
      // large enough to justify all the issues. This may change in the future
      // as browser implementations get better.
      //
      // assertSerialize in json_test contains if branches for the cases
      // that fail.
      return new goog.json.Serializer(opt_replacer).serialize(object);
    };



/**
 * Class that is used to serialize JSON objects to a string.
 * @param {?goog.json.Replacer=} opt_replacer Replacer.
 * @constructor
 */
goog.json.Serializer = function(opt_replacer) {
  'use strict';
  /**
   * @type {goog.json.Replacer|null|undefined}
   * @private
   */
  this.replacer_ = opt_replacer;
};


/**
 * Serializes an object or a value to a JSON string.
 *
 * @param {*} object The object to serialize.
 * @throws Error if there are loops in the object graph.
 * @return {string} A JSON string representation of the input.
 */
goog.json.Serializer.prototype.serialize = function(object) {
  'use strict';
  const sb = [];
  this.serializeInternal(object, sb);
  return sb.join('');
};


/**
 * Serializes a generic value to a JSON string
 * @protected
 * @param {*} object The object to serialize.
 * @param {Array<string>} sb Array used as a string builder.
 * @throws Error if there are loops in the object graph.
 */
goog.json.Serializer.prototype.serializeInternal = function(object, sb) {
  'use strict';
  if (object == null) {
    // undefined == null so this branch covers undefined as well as null
    sb.push('null');
    return;
  }

  if (typeof object == 'object') {
    if (Array.isArray(object)) {
      this.serializeArray(object, sb);
      return;
    } else if (
        object instanceof String || object instanceof Number ||
        object instanceof Boolean) {
      object = object.valueOf();
      // Fall through to switch below.
    } else {
      this.serializeObject_(/** @type {!Object} */ (object), sb);
      return;
    }
  }

  switch (typeof object) {
    case 'string':
      this.serializeString_(object, sb);
      break;
    case 'number':
      this.serializeNumber_(object, sb);
      break;
    case 'boolean':
      sb.push(String(object));
      break;
    case 'function':
      sb.push('null');
      break;
    default:
      throw new Error('Unknown type: ' + typeof object);
  }
};


/**
 * Character mappings used internally for goog.string.quote
 * @private
 * @type {!Object}
 */
goog.json.Serializer.charToJsonCharCache_ = {
  '\"': '\\"',
  '\\': '\\\\',
  '/': '\\/',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',

  '\x0B': '\\u000b'  // '\v' is not supported in JScript
};


/**
 * Regular expression used to match characters that need to be replaced.
 * The S60 browser has a bug where unicode characters are not matched by
 * regular expressions. The condition below detects such behaviour and
 * adjusts the regular expression accordingly.
 * @private
 * @type {!RegExp}
 */
goog.json.Serializer.charsToReplace_ = /\uffff/.test('\uffff') ?
    /[\\\"\x00-\x1f\x7f-\uffff]/g :
    /[\\\"\x00-\x1f\x7f-\xff]/g;


/**
 * Serializes a string to a JSON string
 * @private
 * @param {string} s The string to serialize.
 * @param {Array<string>} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeString_ = function(s, sb) {
  'use strict';
  // The official JSON implementation does not work with international
  // characters.
  sb.push('"', s.replace(goog.json.Serializer.charsToReplace_, function(c) {
    'use strict';
    // caching the result improves performance by a factor 2-3
    let rv = goog.json.Serializer.charToJsonCharCache_[c];
    if (!rv) {
      rv = '\\u' + (c.charCodeAt(0) | 0x10000).toString(16).substr(1);
      goog.json.Serializer.charToJsonCharCache_[c] = rv;
    }
    return rv;
  }), '"');
};


/**
 * Serializes a number to a JSON string
 * @private
 * @param {number} n The number to serialize.
 * @param {Array<string>} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeNumber_ = function(n, sb) {
  'use strict';
  sb.push(isFinite(n) && !isNaN(n) ? String(n) : 'null');
};


/**
 * Serializes an array to a JSON string
 * @param {Array<string>} arr The array to serialize.
 * @param {Array<string>} sb Array used as a string builder.
 * @protected
 */
goog.json.Serializer.prototype.serializeArray = function(arr, sb) {
  'use strict';
  const l = arr.length;
  sb.push('[');
  let sep = '';
  for (let i = 0; i < l; i++) {
    sb.push(sep);

    const value = arr[i];
    this.serializeInternal(
        this.replacer_ ? this.replacer_.call(arr, String(i), value) : value,
        sb);

    sep = ',';
  }
  sb.push(']');
};


/**
 * Serializes an object to a JSON string
 * @private
 * @param {!Object} obj The object to serialize.
 * @param {Array<string>} sb Array used as a string builder.
 */
goog.json.Serializer.prototype.serializeObject_ = function(obj, sb) {
  'use strict';
  sb.push('{');
  let sep = '';
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      // Skip functions.
      if (typeof value != 'function') {
        sb.push(sep);
        this.serializeString_(key, sb);
        sb.push(':');

        this.serializeInternal(
            this.replacer_ ? this.replacer_.call(obj, key, value) : value, sb);

        sep = ',';
      }
    }
  }
  sb.push('}');
};

//third_party/javascript/closure/json/hybrid.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview Utility to attempt native JSON processing, falling back to
 *     goog.json if not available.
 *
 *     This is intended as a drop-in for current users of goog.json who want
 *     to take advantage of native JSON if present.
 */

goog.provide('goog.json.hybrid');

goog.require('goog.asserts');
goog.require('goog.json');


/**
 * Attempts to serialize the JSON string natively, falling back to
 * `goog.json.serialize` if unsuccessful.
 * @param {!Object} obj JavaScript object to serialize to JSON.
 * @return {string} Resulting JSON string.
 */
goog.json.hybrid.stringify = goog.json.USE_NATIVE_JSON ?
    goog.global['JSON']['stringify'] :
    function(obj) {
      'use strict';
      if (goog.global.JSON) {
        try {
          return goog.global.JSON.stringify(obj);
        } catch (e) {
          // Native serialization failed.  Fall through to retry with
          // goog.json.serialize.
        }
      }

      return goog.json.serialize(obj);
    };


/**
 * Attempts to parse the JSON string natively, falling back to
 * the supplied `fallbackParser` if unsuccessful.
 * @param {string} jsonString JSON string to parse.
 * @param {function(string):Object} fallbackParser Fallback JSON parser used
 *     if native
 * @return {?Object} Resulting JSON object.
 * @private
 */
goog.json.hybrid.parse_ = function(jsonString, fallbackParser) {
  'use strict';
  if (goog.global.JSON) {
    try {
      var obj = goog.global.JSON.parse(jsonString);
      goog.asserts.assert(typeof obj == 'object');
      return /** @type {?Object} */ (obj);
    } catch (e) {
      // Native parse failed.  Fall through to retry with goog.json.parse.
    }
  }

  return fallbackParser(jsonString);
};


/**
 * Attempts to parse the JSON string natively, falling back to
 * `goog.json.parse` if unsuccessful.
 * @param {string} jsonString JSON string to parse.
 * @return {?Object} Resulting JSON object.
 */
goog.json.hybrid.parse = goog.json.USE_NATIVE_JSON ?
    goog.global['JSON']['parse'] :
    function(jsonString) {
      'use strict';
      return goog.json.hybrid.parse_(jsonString, goog.json.parse);
    };

//third_party/javascript/closure/log/log.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Basic strippable logging definitions.
 * @see http://go/closurelogging
 */

goog.provide('goog.log');
goog.provide('goog.log.Level');
goog.provide('goog.log.LogBuffer');
goog.provide('goog.log.LogRecord');
goog.provide('goog.log.Logger');

goog.require('goog.asserts');
goog.require('goog.debug');


/**
 * A message value that can be handled by a goog.log.Logger.
 *
 * Functions are treated like callbacks, but are only called when the event's
 * log level is enabled. This is useful for logging messages that are expensive
 * to construct.
 *
 * @typedef {string|function(): string}
 */
goog.log.Loggable;

/** @define {boolean} Whether logging is enabled. */
goog.log.ENABLED = goog.define('goog.log.ENABLED', goog.debug.LOGGING_ENABLED);

/** @const */
goog.log.ROOT_LOGGER_NAME = '';


// TODO(b/170408987): Make goog.log.Level an enum.
/**
 * The goog.log.Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging goog.log.Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * <p>
 * Clients should normally use the predefined goog.log.Level constants such
 * as goog.log.Level.SEVERE.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (highest value)
 * <li>WARNING
 * <li>INFO
 * <li>CONFIG
 * <li>FINE
 * <li>FINER
 * <li>FINEST  (lowest value)
 * </ul>
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 *
 * @final
 */
goog.log.Level = class Level {
  /**
   * @param {string} name The name of the level.
   * @param {number} value The numeric value of the level.
   */
  constructor(name, value) {
    /**
     * The name of the level
     * @type {string}
     * @const
     */
    this.name = name;

    /**
     * The numeric value of the level
     * @type {number}
     */
    this.value = value;
  }

  /**
   * @return {string} String representation of the logger level.
   * @override
   */
  toString() {
    return this.name;
  }
};


/**
 * OFF is a special level that can be used to turn off logging.
 * This level is initialized to <CODE>Infinity</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.OFF = new goog.log.Level('OFF', Infinity);


/**
 * SHOUT is a message level for extra debugging loudness.
 * This level is initialized to <CODE>1200</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.SHOUT = new goog.log.Level('SHOUT', 1200);


/**
 * SEVERE is a message level indicating a serious failure.
 * This level is initialized to <CODE>1000</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.SEVERE = new goog.log.Level('SEVERE', 1000);


/**
 * WARNING is a message level indicating a potential problem.
 * This level is initialized to <CODE>900</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.WARNING = new goog.log.Level('WARNING', 900);


/**
 * INFO is a message level for informational messages.
 * This level is initialized to <CODE>800</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.INFO = new goog.log.Level('INFO', 800);


/**
 * CONFIG is a message level for static configuration messages.
 * This level is initialized to <CODE>700</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.CONFIG = new goog.log.Level('CONFIG', 700);


/**
 * FINE is a message level providing tracing information.
 * This level is initialized to <CODE>500</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.FINE = new goog.log.Level('FINE', 500);


/**
 * FINER indicates a fairly detailed tracing message.
 * This level is initialized to <CODE>400</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.FINER = new goog.log.Level('FINER', 400);

/**
 * FINEST indicates a highly detailed tracing message.
 * This level is initialized to <CODE>300</CODE>.
 * @type {!goog.log.Level}
 */

goog.log.Level.FINEST = new goog.log.Level('FINEST', 300);


/**
 * ALL indicates that all messages should be logged.
 * This level is initialized to <CODE>0</CODE>.
 * @type {!goog.log.Level}
 */
goog.log.Level.ALL = new goog.log.Level('ALL', 0);


/**
 * The predefined levels.
 * @type {!Array<!goog.log.Level>}
 * @final
 */
goog.log.Level.PREDEFINED_LEVELS = [
  goog.log.Level.OFF, goog.log.Level.SHOUT, goog.log.Level.SEVERE,
  goog.log.Level.WARNING, goog.log.Level.INFO, goog.log.Level.CONFIG,
  goog.log.Level.FINE, goog.log.Level.FINER, goog.log.Level.FINEST,
  goog.log.Level.ALL
];


/**
 * A lookup map used to find the level object based on the name or value of
 * the level object.
 * @type {?Object}
 * @private
 */
goog.log.Level.predefinedLevelsCache_ = null;


/**
 * Creates the predefined levels cache and populates it.
 * @private
 */
goog.log.Level.createPredefinedLevelsCache_ = function() {
  goog.log.Level.predefinedLevelsCache_ = {};
  for (let i = 0, level; level = goog.log.Level.PREDEFINED_LEVELS[i]; i++) {
    goog.log.Level.predefinedLevelsCache_[level.value] = level;
    goog.log.Level.predefinedLevelsCache_[level.name] = level;
  }
};


/**
 * Gets the predefined level with the given name.
 * @param {string} name The name of the level.
 * @return {!goog.log.Level|null} The level, or null if none found.
 */
goog.log.Level.getPredefinedLevel = function(name) {
  if (!goog.log.Level.predefinedLevelsCache_) {
    goog.log.Level.createPredefinedLevelsCache_();
  }

  return goog.log.Level.predefinedLevelsCache_[name] || null;
};


/**
 * Gets the highest predefined level <= #value.
 * @param {number} value goog.log.Level value.
 * @return {!goog.log.Level|null} The level, or null if none found.
 */
goog.log.Level.getPredefinedLevelByValue = function(value) {
  if (!goog.log.Level.predefinedLevelsCache_) {
    goog.log.Level.createPredefinedLevelsCache_();
  }

  if (value in /** @type {!Object} */ (goog.log.Level.predefinedLevelsCache_)) {
    return goog.log.Level.predefinedLevelsCache_[value];
  }

  for (let i = 0; i < goog.log.Level.PREDEFINED_LEVELS.length; ++i) {
    let level = goog.log.Level.PREDEFINED_LEVELS[i];
    if (level.value <= value) {
      return level;
    }
  }
  return null;
};


/** @interface */
goog.log.Logger = class Logger {
  /**
   * Gets the name of the Logger.
   * @return {string}
   * @public
   */
  getName() {}
};


/**
 * Only for compatibility with goog.debug.Logger.Level, which is how many users
 * access Level.
 * TODO(kelvinjin): Remove these definitions.
 * @final
 */
goog.log.Logger.Level = goog.log.Level;


/**
 * A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 * @final
 */
goog.log.LogBuffer = class LogBuffer {
  /**
   * @param {number=} capacity The capacity of this LogBuffer instance.
   */
  constructor(capacity) {
    /**
     * The buffer's capacity.
     * @type {number}
     * @private
     */
    this.capacity_ =
        typeof capacity === 'number' ? capacity : goog.log.LogBuffer.CAPACITY;

    /**
     * The array to store the records.
     * @type {!Array<!goog.log.LogRecord|undefined>}
     * @private
     */
    this.buffer_;

    /**
     * The index of the most recently added record, or -1 if there are no
     * records.
     * @type {number}
     * @private
     */
    this.curIndex_;

    /**
     * Whether the buffer is at capacity.
     * @type {boolean}
     * @private
     */
    this.isFull_;

    this.clear();
  }


  /**
   * Adds a log record to the buffer, possibly overwriting the oldest record.
   * @param {!goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @return {!goog.log.LogRecord} The log record.
   */
  addRecord(level, msg, loggerName) {
    if (!this.isBufferingEnabled()) {
      return new goog.log.LogRecord(level, msg, loggerName);
    }
    const curIndex = (this.curIndex_ + 1) % this.capacity_;
    this.curIndex_ = curIndex;
    if (this.isFull_) {
      const ret = this.buffer_[curIndex];
      ret.reset(level, msg, loggerName);
      return ret;
    }
    this.isFull_ = curIndex == this.capacity_ - 1;
    return this.buffer_[curIndex] =
               new goog.log.LogRecord(level, msg, loggerName);
  }

  /**
   * Calls the given function for each buffered log record, starting with the
   * oldest one.
   * TODO(kelvinjin): Make this a [Symbol.iterator] once all usages of
   * goog.debug.LogBuffer can be deleted.
   * @param {!goog.log.LogRecordHandler} func The function to call.
   */
  forEachRecord(func) {
    const buffer = this.buffer_;
    // Corner case: no records.
    if (!buffer[0]) {
      return;
    }
    const curIndex = this.curIndex_;
    let i = this.isFull_ ? curIndex : -1;
    do {
      i = (i + 1) % this.capacity_;
      func(/** @type {!goog.log.LogRecord} */ (buffer[i]));
    } while (i !== curIndex);
  }

  /**
   * @return {boolean} Whether the log buffer is enabled.
   */
  isBufferingEnabled() {
    return this.capacity_ > 0;
  }

  /**
   * @return {boolean} Return whether the log buffer is full.
   */
  isFull() {
    return this.isFull_;
  }

  /**
   * Removes all buffered log records.
   */
  clear() {
    this.buffer_ = new Array(this.capacity_);
    this.curIndex_ = -1;
    this.isFull_ = false;
  }
};


/**
 * @type {!goog.log.LogBuffer|undefined}
 * @private
 */
goog.log.LogBuffer.instance_;


/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.log.LogBuffer.CAPACITY = goog.define('goog.debug.LogBuffer.CAPACITY', 0);


/**
 * A static method that always returns the same instance of goog.log.LogBuffer.
 * @return {!goog.log.LogBuffer} The goog.log.LogBuffer singleton instance.
 */
goog.log.LogBuffer.getInstance = function() {
  if (!goog.log.LogBuffer.instance_) {
    goog.log.LogBuffer.instance_ =
        new goog.log.LogBuffer(goog.log.LogBuffer.CAPACITY);
  }
  return goog.log.LogBuffer.instance_;
};


/**
 * Whether the log buffer is enabled.
 * @return {boolean}
 */
goog.log.LogBuffer.isBufferingEnabled = function() {
  return goog.log.LogBuffer.getInstance().isBufferingEnabled();
};


/**
 * LogRecord objects are used to pass logging requests between the logging
 * framework and individual log handlers. These objects should not be
 * constructed or reset by application code.
 */
goog.log.LogRecord = class LogRecord {
  /**
   * @param {?goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @param {number=} time Time this log record was created if other than
   *     now. If 0, we use #goog.now.
   * @param {number=} sequenceNumber Sequence number of this log record.
   *     This should only be passed in when restoring a log record from
   *     persistence.
   */
  constructor(level, msg, loggerName, time, sequenceNumber) {
    /**
     * Level of the LogRecord.
     * @type {!goog.log.Level}
     * @private
     */
    this.level_;

    /**
     * Name of the logger that created the record.
     * @type {string}
     * @private
     */
    this.loggerName_;

    /**
     * Message associated with the record
     * @type {string}
     * @private
     */
    this.msg_;

    /**
     * Time the LogRecord was created.
     * @type {number}
     * @private
     */
    this.time_;

    /**
     * Sequence number for the LogRecord. Each record has a unique sequence
     * number that is greater than all log records created before it.
     * @type {number}
     * @private
     */
    this.sequenceNumber_;

    /**
     * Exception associated with the record
     * @type {?Object}
     * @private
     */
    this.exception_ = null;

    this.reset(
        level || goog.log.Level.OFF, msg, loggerName, time, sequenceNumber);
  };

  /**
   * Sets all fields of the log record.
   * @param {!goog.log.Level} level One of the level identifiers.
   * @param {string} msg The string message.
   * @param {string} loggerName The name of the source logger.
   * @param {number=} time Time this log record was created if other than
   *     now. If 0, we use #goog.now.
   * @param {number=} sequenceNumber Sequence number of this log record.
   *     This should only be passed in when restoring a log record from
   *     persistence.
   */
  reset(level, msg, loggerName, time, sequenceNumber) {
    this.time_ = time || goog.now();
    this.level_ = level;
    this.msg_ = msg;
    this.loggerName_ = loggerName;
    this.exception_ = null;
    this.sequenceNumber_ = typeof sequenceNumber === 'number' ?
        sequenceNumber :
        goog.log.LogRecord.nextSequenceNumber_;
  };


  /**
   * Gets the source Logger's name.
   *
   * @return {string} source logger name (may be null).
   */
  getLoggerName() {
    return this.loggerName_;
  };


  /**
   * Sets the source Logger's name.
   *
   * @param {string} name The logger name.
   */
  setLoggerName(name) {
    this.loggerName_ = name;
  };


  /**
   * Gets the exception that is part of the log record.
   *
   * @return {?Object} the exception.
   */
  getException() {
    return this.exception_;
  };


  /**
   * Sets the exception that is part of the log record.
   * @param {?Object} exception the exception.
   */
  setException(exception) {
    this.exception_ = exception;
  };


  /**
   * Gets the logging message level, for example Level.SEVERE.
   * @return {!goog.log.Level} the logging message level.
   */
  getLevel() {
    return this.level_;
  };


  /**
   * Sets the logging message level, for example Level.SEVERE.
   * @param {!goog.log.Level} level the logging message level.
   */
  setLevel(level) {
    this.level_ = level;
  };


  /**
   * Gets the "raw" log message, before localization or formatting.
   * @return {string} the raw message string.
   */
  getMessage() {
    return this.msg_;
  };


  /**
   * Sets the "raw" log message, before localization or formatting.
   *
   * @param {string} msg the raw message string.
   */
  setMessage(msg) {
    this.msg_ = msg;
  };


  /**
   * Gets event time in milliseconds since 1970.
   * @return {number} event time in millis since 1970.
   */
  getMillis() {
    return this.time_;
  };


  /**
   * Sets event time in milliseconds since 1970.
   * @param {number} time event time in millis since 1970.
   */
  setMillis(time) {
    this.time_ = time;
  };


  /**
   * Gets the sequence number. Sequence numbers are normally assigned when a
   * LogRecord is constructed or reset in incrementally increasing order.
   * @return {number}
   */
  getSequenceNumber() {
    return this.sequenceNumber_;
  };
};


/**
 * A sequence counter for assigning increasing sequence numbers to LogRecord
 * objects.
 * @type {number}
 * @private
 */
goog.log.LogRecord.nextSequenceNumber_ = 0;


/**
 * A type that describes a function that handles logs.
 * @typedef {function(!goog.log.LogRecord): ?}
 */
goog.log.LogRecordHandler;


/**
 * A LogRegistryEntry_ contains data about a Logger.
 * @final
 */
goog.log.LogRegistryEntry_ = class LogRegistryEntry_ {
  /**
   * @param {string} name
   * @param {!goog.log.LogRegistryEntry_|null=} parent
   */
  constructor(name, parent = null) {
    /**
     * The minimum log level that a message must be for it to be logged by the
     * Logger corresponding to this LogRegistryEntry_. If null, the parent's
     * log level is used instead.
     * @type {?goog.log.Level}
     */
    this.level = null;

    /**
     * A list of functions that will be called when the Logger corresponding to
     * this LogRegistryEntry_ is used to log a message.
     * @type {!Array<!goog.log.LogRecordHandler>}
     */
    this.handlers = [];

    /**
     * A reference to LogRegistryEntry_ objects that correspond to the direct
     * ancestor of the Logger represented by this LogRegistryEntry_ object
     * (via name, treated as a dot-separated namespace).
     * @type {!goog.log.LogRegistryEntry_|null}
     */
    this.parent = parent || null;

    /**
     * A list of references to LogRegistryEntry_ objects that correspond to the
     * direct descendants of the Logger represented by this LogRegistryEntry_
     * object (via name, treated as a dot-separated namespace).
     * @type {!Array<!goog.log.LogRegistryEntry_>}
     */
    this.children = [];

    /**
     * A reference to the Logger itself.
     * @type {!goog.log.Logger}
     */
    this.logger = /** @type {!goog.log.Logger} */ ({getName: () => name});
  }

  /**
   * Returns the effective level of the logger based on its ancestors' levels.
   * @return {!goog.log.Level} The level.
   */
  getEffectiveLevel() {
    if (this.level) {
      return this.level;
    } else if (this.parent) {
      return this.parent.getEffectiveLevel();
    }
    goog.asserts.fail('Root logger has no level set.');
    return goog.log.Level.OFF;
  };

  /**
   * Calls the log handlers associated with this Logger, followed by those of
   * its parents, etc. until the root Logger's associated log handlers are
   * called.
   * @param {!goog.log.LogRecord} logRecord The log record to pass to each
   *     handler.
   */
  publish(logRecord) {
    let target = this;
    while (target) {
      target.handlers.forEach(handler => {
        handler(logRecord);
      });
      target = target.parent;
    }
  }
};


/**
 * A LogRegistry_ owns references to all loggers, and is responsible for storing
 * all the internal state needed for loggers to operate correctly.
 *
 * @final
 */
goog.log.LogRegistry_ = class LogRegistry_ {
  constructor() {
    /**
     * Per-log information retained by this LogRegistry_.
     * @type {!Object<string, !goog.log.LogRegistryEntry_>}
     */
    this.entries = {};

    // The root logger.
    const rootLogRegistryEntry =
        new goog.log.LogRegistryEntry_(goog.log.ROOT_LOGGER_NAME);
    rootLogRegistryEntry.level = goog.log.Level.CONFIG;
    this.entries[goog.log.ROOT_LOGGER_NAME] = rootLogRegistryEntry;
  }

  /**
   * Gets the LogRegistry_ entry under the given name, creating the entry if one
   * doesn't already exist.
   * @param {string} name The name to look up.
   * @param {?goog.log.Level=} level If provided, override the default logging
   *     level of the returned Logger with the provided level.
   * @return {!goog.log.LogRegistryEntry_}
   */
  getLogRegistryEntry(name, level) {
    const entry = this.entries[name];
    if (entry) {
      if (level !== undefined) {
        entry.level = level;
      }
      return entry;
    } else {
      // The logger and its associated registry entry needs to be created.

      // Get its parent first.
      const lastDotIndex = name.lastIndexOf('.');
      const parentName = name.substr(0, lastDotIndex);
      const parentLogRegistryEntry = this.getLogRegistryEntry(parentName);

      // Now create the new entry, linking it with its parent.
      const logRegistryEntry =
          new goog.log.LogRegistryEntry_(name, parentLogRegistryEntry);
      this.entries[name] = logRegistryEntry;
      parentLogRegistryEntry.children.push(logRegistryEntry);

      if (level !== undefined) {
        logRegistryEntry.level = level;
      }

      return logRegistryEntry;
    }
  }

  /**
   * Get a list of all loggers.
   * @return {!Array<!goog.log.Logger>}
   */
  getAllLoggers() {
    return Object.keys(this.entries)
        .map(loggerName => this.entries[loggerName].logger);
  }
};

/**
 * A static method that always returns the same instance of LogRegistry_.
 * @return {!goog.log.LogRegistry_} The LogRegistry_ singleton instance.
 */
goog.log.LogRegistry_.getInstance = function() {
  if (!goog.log.LogRegistry_.instance_) {
    goog.log.LogRegistry_.instance_ = new goog.log.LogRegistry_();
  }
  return /** @type {!goog.log.LogRegistry_} */ (
      goog.log.LogRegistry_.instance_);
};

/**
 * @type {!goog.log.LogRegistry_|undefined}
 * @private
 */
goog.log.LogRegistry_.instance_;


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise, a new logger is
 * created. If a new logger is created, it will be configured to send logging
 * output to its parent's handlers.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 *     name and should normally be based on the package name or class name of
 *     the subsystem, such as goog.net.BrowserChannel.
 * @param {?goog.log.Level=} level If provided, override the default logging
 *     level with the provided level. This parameter is deprecated; prefer using
 *     goog.log.setLevel to set the logger's level instead.
 *     TODO(b/170974948): Delete this parameter.
 * @return {!goog.log.Logger|null} The named logger, or null if logging is
 *     disabled.
 */
goog.log.getLogger = function(name, level) {
  if (goog.log.ENABLED) {
    const loggerEntry =
        goog.log.LogRegistry_.getInstance().getLogRegistryEntry(name, level);
    return loggerEntry.logger;
  } else {
    return null;
  }
};


/**
 * Returns the root logger.
 *
 * @return {!goog.log.Logger|null} The root logger, or null if logging is
 *     disabled.
 */
goog.log.getRootLogger = function() {
  // MOE:begin_strip
  // NOTE: This intentionally doesn't call goog.log.getLogger to prevent
  // ROOT_LOGGER_NAME from getting replaced during compilation, as correct
  // behavior hinges on it remaining an empty string.
  // MOE:end_strip
  if (goog.log.ENABLED) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        goog.log.ROOT_LOGGER_NAME);
    return loggerEntry.logger;
  } else {
    return null;
  }
};


// TODO(johnlenz): try to tighten the types to these functions.
/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecordHandler} handler Handler function to
 *     add.
 */
goog.log.addHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.handlers.push(handler);
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecordHandler} handler Handler function to
 *     remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.log.removeHandler = function(logger, handler) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    const indexOfHandler = loggerEntry.handlers.indexOf(handler);
    if (indexOfHandler !== -1) {
      loggerEntry.handlers.splice(indexOfHandler, 1);
      return true;
    }
  }
  return false;
};


/**
 * Set the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value goog.log.Level.OFF can be used to turn off logging. If the
 * new level is null, it means that this node should inherit its level from its
 * nearest ancestor with a specific (non-null) level value.
 *
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Level|null} level The new level.
 */
goog.log.setLevel = function(logger, level) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.level = level;
  }
};


/**
 * Gets the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value goog.log.Level.OFF can be used to turn off logging. If the
 * level is null, it means that this node should inherit its level from its
 * nearest ancestor with a specific (non-null) level value.
 *
 * @param {?goog.log.Logger} logger
 * @return {!goog.log.Level|null} The level.
 */
goog.log.getLevel = function(logger) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    return loggerEntry.level;
  }
  return null;
};


/**
 * Returns the effective level of the logger based on its ancestors' levels.
 * @param {?goog.log.Logger} logger
 * @return {!goog.log.Level} The level.
 */
goog.log.getEffectiveLevel = function(logger) {
  if (goog.log.ENABLED && logger) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    return loggerEntry.getEffectiveLevel();
  }
  return goog.log.Level.OFF;
};


/**
 * Checks if a message of the given level would actually be logged by this
 * logger. This check is based on the goog.log.Loggers effective level, which
 * may be inherited from its parent.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level The level to check.
 * @return {boolean} Whether the message would be logged.
 */
goog.log.isLoggable = function(logger, level) {
  if (goog.log.ENABLED && logger && level) {
    return level.value >= goog.log.getEffectiveLevel(logger).value;
  }
  return false;
};


/**
 * Gets a list of all loggers.
 * @return {!Array<!goog.log.Logger>}
 */
goog.log.getAllLoggers = function() {
  if (goog.log.ENABLED) {
    return goog.log.LogRegistry_.getInstance().getAllLoggers();
  }
  return [];
};


/**
 * Creates a log record. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(kelvinjin): Delete this method from the public API.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level One of the level identifiers.
 * @param {string} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 * @return {!goog.log.LogRecord}
 */
goog.log.getLogRecord = function(logger, level, msg, exception) {
  const logRecord = goog.log.LogBuffer.getInstance().addRecord(
      level || goog.log.Level.OFF, msg, logger.getName());
  if (exception) {
    logRecord.setException(exception);
  }
  return logRecord;
};


/**
 * Logs a goog.log.LogRecord. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(kelvinjin): Delete this method from the public API.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.LogRecord} logRecord A log record to log.
 */
goog.log.publishLogRecord = function(logger, logRecord) {
  if (goog.log.ENABLED && logger &&
      goog.log.isLoggable(logger, logRecord.getLevel())) {
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    loggerEntry.publish(logRecord);
  }
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * TODO(b/170975192): The level parameter should be made required.
 * @param {?goog.log.Logger} logger
 * @param {?goog.log.Level} level One of the level identifiers.
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 */
goog.log.log = function(logger, level, msg, exception) {
  if (goog.log.ENABLED && logger && goog.log.isLoggable(logger, level)) {
    level = level || goog.log.Level.OFF;
    const loggerEntry = goog.log.LogRegistry_.getInstance().getLogRegistryEntry(
        logger.getName());
    // Message callbacks can be useful when a log message is expensive to build.
    if (typeof msg === 'function') {
      msg = msg();
    }
    const logRecord = goog.log.LogBuffer.getInstance().addRecord(
        level, msg, logger.getName());
    if (exception) {
      logRecord.setException(exception);
    }
    // Publish logs.
    loggerEntry.publish(logRecord);
  }
};


/**
 * Logs a message at the goog.log.Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 */
goog.log.error = function(logger, msg, exception) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.SEVERE, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 */
goog.log.warning = function(logger, msg, exception) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.WARNING, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 */
goog.log.info = function(logger, msg, exception) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.INFO, msg, exception);
  }
};


/**
 * Logs a message at the goog.log.Level.FINE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {?goog.log.Logger} logger
 * @param {!goog.log.Loggable} msg The message to log.
 * @param {?Error|?Object=} exception An exception associated with the
 *     message.
 */
goog.log.fine = function(logger, msg, exception) {
  if (goog.log.ENABLED && logger) {
    goog.log.log(logger, goog.log.Level.FINE, msg, exception);
  }
};

//third_party/javascript/closure/net/errorcode.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Error codes shared between goog.net.IframeIo and
 * goog.net.XhrIo.
 */

goog.provide('goog.net.ErrorCode');


/**
 * Error codes
 * @enum {number}
 */
goog.net.ErrorCode = {

  /**
   * There is no error condition.
   */
  NO_ERROR: 0,

  /**
   * The most common error from iframeio, unfortunately, is that the browser
   * responded with an error page that is classed as a different domain. The
   * situations, are when a browser error page  is shown -- 404, access denied,
   * DNS failure, connection reset etc.)
   *
   */
  ACCESS_DENIED: 1,

  /**
   * Currently the only case where file not found will be caused is when the
   * code is running on the local file system and a non-IE browser makes a
   * request to a file that doesn't exist.
   */
  FILE_NOT_FOUND: 2,

  /**
   * If Firefox shows a browser error page, such as a connection reset by
   * server or access denied, then it will fail silently without the error or
   * load handlers firing.
   */
  FF_SILENT_ERROR: 3,

  /**
   * Custom error provided by the client through the error check hook.
   */
  CUSTOM_ERROR: 4,

  /**
   * Exception was thrown while processing the request.
   */
  EXCEPTION: 5,

  /**
   * The Http response returned a non-successful http status code.
   */
  HTTP_ERROR: 6,

  /**
   * The request was aborted.
   */
  ABORT: 7,

  /**
   * The request timed out.
   */
  TIMEOUT: 8,

  /**
   * The resource is not available offline.
   */
  OFFLINE: 9,
};


/**
 * Returns a friendly error message for an error code. These messages are for
 * debugging and are not localized.
 * @param {goog.net.ErrorCode} errorCode An error code.
 * @return {string} A message for debugging.
 */
goog.net.ErrorCode.getDebugMessage = function(errorCode) {
  'use strict';
  switch (errorCode) {
    case goog.net.ErrorCode.NO_ERROR:
      return 'No Error';

    case goog.net.ErrorCode.ACCESS_DENIED:
      return 'Access denied to content document';

    case goog.net.ErrorCode.FILE_NOT_FOUND:
      return 'File not found';

    case goog.net.ErrorCode.FF_SILENT_ERROR:
      return 'Firefox silently errored';

    case goog.net.ErrorCode.CUSTOM_ERROR:
      return 'Application custom error';

    case goog.net.ErrorCode.EXCEPTION:
      return 'An exception occurred';

    case goog.net.ErrorCode.HTTP_ERROR:
      return 'Http response at 400 or 500 level';

    case goog.net.ErrorCode.ABORT:
      return 'Request was aborted';

    case goog.net.ErrorCode.TIMEOUT:
      return 'Request timed out';

    case goog.net.ErrorCode.OFFLINE:
      return 'The resource is not available offline';

    default:
      return 'Unrecognized error code';
  }
};

//third_party/javascript/closure/net/eventtype.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Common events for the network classes.
 */


goog.provide('goog.net.EventType');


/**
 * Event names for network events
 * @enum {string}
 */
goog.net.EventType = {
  COMPLETE: 'complete',
  SUCCESS: 'success',
  ERROR: 'error',
  ABORT: 'abort',
  READY: 'ready',
  READY_STATE_CHANGE: 'readystatechange',
  TIMEOUT: 'timeout',
  INCREMENTAL_DATA: 'incrementaldata',
  PROGRESS: 'progress',
  // DOWNLOAD_PROGRESS and UPLOAD_PROGRESS are special events dispatched by
  // goog.net.XhrIo to allow binding listeners specific to each type of
  // progress.
  DOWNLOAD_PROGRESS: 'downloadprogress',
  UPLOAD_PROGRESS: 'uploadprogress',
};

//third_party/javascript/closure/net/httpstatus.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Constants for HTTP status codes.
 */

goog.provide('goog.net.HttpStatus');


/**
 * HTTP Status Codes defined in RFC 2616, RFC 6585, RFC 4918 and RFC 7538.
 * @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
 * @see http://tools.ietf.org/html/rfc6585
 * @see https://tools.ietf.org/html/rfc4918
 * @see https://tools.ietf.org/html/rfc7538
 * @enum {number}
 */
goog.net.HttpStatus = {
  // Informational 1xx
  CONTINUE: 100,
  SWITCHING_PROTOCOLS: 101,

  // Successful 2xx
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NON_AUTHORITATIVE_INFORMATION: 203,
  NO_CONTENT: 204,
  RESET_CONTENT: 205,
  PARTIAL_CONTENT: 206,
  MULTI_STATUS: 207,

  // Redirection 3xx
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  USE_PROXY: 305,
  TEMPORARY_REDIRECT: 307,
  PERMANENT_REDIRECT: 308,

  // Client Error 4xx
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  REQUEST_ENTITY_TOO_LARGE: 413,
  REQUEST_URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  REQUEST_RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  UNPROCESSABLE_ENTITY: 422,
  LOCKED: 423,
  FAILED_DEPENDENCY: 424,
  PRECONDITION_REQUIRED: 428,
  TOO_MANY_REQUESTS: 429,
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,

  // Server Error 5xx
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,
  INSUFFICIENT_STORAGE: 507,
  NETWORK_AUTHENTICATION_REQUIRED: 511,

  /*
   * IE returns this code for 204 due to its use of URLMon, which returns this
   * code for 'Operation Aborted'. The status text is 'Unknown', the response
   * headers are ''. Known to occur on IE 6 on XP through IE9 on Win7.
   */
  QUIRK_IE_NO_CONTENT: 1223,
};


/**
 * Returns whether the given status should be considered successful.
 *
 * Successful codes are OK (200), CREATED (201), ACCEPTED (202),
 * NO CONTENT (204), PARTIAL CONTENT (206), NOT MODIFIED (304),
 * and IE's no content code (1223).
 *
 * @param {number} status The status code to test.
 * @return {boolean} Whether the status code should be considered successful.
 */
goog.net.HttpStatus.isSuccess = function(status) {
  'use strict';
  switch (status) {
    case goog.net.HttpStatus.OK:
    case goog.net.HttpStatus.CREATED:
    case goog.net.HttpStatus.ACCEPTED:
    case goog.net.HttpStatus.NO_CONTENT:
    case goog.net.HttpStatus.PARTIAL_CONTENT:
    case goog.net.HttpStatus.NOT_MODIFIED:
    case goog.net.HttpStatus.QUIRK_IE_NO_CONTENT:
      return true;

    default:
      return false;
  }
};

//third_party/javascript/closure/net/xhrlike.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

goog.provide('goog.net.XhrLike');



/**
 * Interface for the common parts of XMLHttpRequest.
 *
 * Mostly copied from externs/w3c_xml.js.
 *
 * @interface
 * @see http://www.w3.org/TR/XMLHttpRequest/
 */
goog.net.XhrLike = function() {};


/**
 * Typedef that refers to either native or custom-implemented XHR objects.
 * @typedef {!goog.net.XhrLike|!XMLHttpRequest}
 */
goog.net.XhrLike.OrNative;


/**
 * @type {function()|null|undefined}
 * @see http://www.w3.org/TR/XMLHttpRequest/#handler-xhr-onreadystatechange
 */
goog.net.XhrLike.prototype.onreadystatechange;


/**
 * @type {?ArrayBuffer|?Blob|?Document|?Object|?string}
 * @see https://xhr.spec.whatwg.org/#response-object
 */
goog.net.XhrLike.prototype.response;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
 */
goog.net.XhrLike.prototype.responseText;


/**
 * @type {string}
 * @see https://xhr.spec.whatwg.org/#the-responsetype-attribute
 */
goog.net.XhrLike.prototype.responseType;


/**
 * @type {Document}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsexml-attribute
 */
goog.net.XhrLike.prototype.responseXML;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#readystate
 */
goog.net.XhrLike.prototype.readyState;


/**
 * @type {number}
 * @see http://www.w3.org/TR/XMLHttpRequest/#status
 */
goog.net.XhrLike.prototype.status;


/**
 * @type {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#statustext
 */
goog.net.XhrLike.prototype.statusText;


/**
 * @param {string} method
 * @param {string} url
 * @param {?boolean=} opt_async
 * @param {?string=} opt_user
 * @param {?string=} opt_password
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method
 */
goog.net.XhrLike.prototype.open = function(
    method, url, opt_async, opt_user, opt_password) {};


/**
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=} opt_data
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
 */
goog.net.XhrLike.prototype.send = function(opt_data) {};


/**
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method
 */
goog.net.XhrLike.prototype.abort = function() {};


/**
 * @param {string} header
 * @param {string} value
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method
 */
goog.net.XhrLike.prototype.setRequestHeader = function(header, value) {};


/**
 * @param {string} header
 * @return {?string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 */
goog.net.XhrLike.prototype.getResponseHeader = function(header) {};


/**
 * @return {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
 */
goog.net.XhrLike.prototype.getAllResponseHeaders = function() {};

/**
 * @type {?function(!TrustTokenAttributeType): void | undefined}
 * @see https://docs.google.com/document/d/1qUjtKgA7nMv9YGMhi0xWKEojkSITKzGLdIcZgoz6ZkI.
 */
goog.net.XhrLike.prototype.setTrustToken = function(trustTokenAttribute) {};

//third_party/javascript/closure/net/xmlhttpfactory.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Interface for a factory for creating XMLHttpRequest objects
 * and metadata about them.
 */

goog.provide('goog.net.XmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');



/**
 * Abstract base class for an XmlHttpRequest factory.
 * @constructor
 */
goog.net.XmlHttpFactory = function() {};


/**
 * Cache of options - we only actually call internalGetOptions once.
 * @type {?Object}
 * @private
 */
goog.net.XmlHttpFactory.prototype.cachedOptions_ = null;


/**
 * @return {!goog.net.XhrLike.OrNative} A new XhrLike instance.
 */
goog.net.XmlHttpFactory.prototype.createInstance = goog.abstractMethod;


/**
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 */
goog.net.XmlHttpFactory.prototype.getOptions = function() {
  'use strict';
  return this.cachedOptions_ ||
      (this.cachedOptions_ = this.internalGetOptions());
};


/**
 * Override this method in subclasses to preserve the caching offered by
 * getOptions().
 * @return {Object} Options describing how xhr objects obtained from this
 *     factory should be used.
 * @protected
 */
goog.net.XmlHttpFactory.prototype.internalGetOptions = goog.abstractMethod;

//third_party/javascript/closure/net/wrapperxmlhttpfactory.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Implementation of XmlHttpFactory which allows construction from
 * simple factory methods.
 */

goog.provide('goog.net.WrapperXmlHttpFactory');

/** @suppress {extraRequire} Typedef. */
goog.require('goog.net.XhrLike');
goog.require('goog.net.XmlHttpFactory');



/**
 * An xhr factory subclass which can be constructed using two factory methods.
 * This exists partly to allow the preservation of goog.net.XmlHttp.setFactory()
 * with an unchanged signature.
 * @param {function():!goog.net.XhrLike.OrNative} xhrFactory
 *     A function which returns a new XHR object.
 * @param {function():!Object} optionsFactory A function which returns the
 *     options associated with xhr objects from this factory.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 * @final
 */
goog.net.WrapperXmlHttpFactory = function(xhrFactory, optionsFactory) {
  'use strict';
  goog.net.XmlHttpFactory.call(this);

  /**
   * XHR factory method.
   * @type {function() : !goog.net.XhrLike.OrNative}
   * @private
   */
  this.xhrFactory_ = xhrFactory;

  /**
   * Options factory method.
   * @type {function() : !Object}
   * @private
   */
  this.optionsFactory_ = optionsFactory;
};
goog.inherits(goog.net.WrapperXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.createInstance = function() {
  'use strict';
  return this.xhrFactory_();
};


/** @override */
goog.net.WrapperXmlHttpFactory.prototype.getOptions = function() {
  'use strict';
  return this.optionsFactory_();
};

//third_party/javascript/closure/net/xmlhttp.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Low level handling of XMLHttpRequest.
 */

goog.provide('goog.net.DefaultXmlHttpFactory');
goog.provide('goog.net.XmlHttp');
goog.provide('goog.net.XmlHttp.OptionType');
goog.provide('goog.net.XmlHttp.ReadyState');
goog.provide('goog.net.XmlHttpDefines');

goog.require('goog.asserts');
goog.require('goog.net.WrapperXmlHttpFactory');
goog.require('goog.net.XmlHttpFactory');
goog.requireType('goog.net.XhrLike');


/**
 * Static class for creating XMLHttpRequest objects.
 * @return {!goog.net.XhrLike.OrNative} A new XMLHttpRequest object.
 */
goog.net.XmlHttp = function() {
  'use strict';
  return goog.net.XmlHttp.factory_.createInstance();
};


/**
 * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to
 *     true bypasses the ActiveX probing code.
 * NOTE(ruilopes): Due to the way JSCompiler works, this define *will not* strip
 * out the ActiveX probing code from binaries.  To achieve this, use
 * `goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR` instead.
 * TODO(ruilopes): Collapse both defines.
 */
goog.net.XmlHttp.ASSUME_NATIVE_XHR =
    goog.define('goog.net.XmlHttp.ASSUME_NATIVE_XHR', false);


/** @const */
goog.net.XmlHttpDefines = {};


/**
 * @define {boolean} Whether to assume XMLHttpRequest exists. Setting this to
 *     true eliminates the ActiveX probing code.
 */
goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR =
    goog.define('goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR', false);


/**
 * Gets the options to use with the XMLHttpRequest objects obtained using
 * the static methods.
 * @return {Object} The options.
 */
goog.net.XmlHttp.getOptions = function() {
  'use strict';
  return goog.net.XmlHttp.factory_.getOptions();
};


/**
 * Type of options that an XmlHttp object can have.
 * @enum {number}
 */
goog.net.XmlHttp.OptionType = {
  /**
   * Whether a goog.nullFunction should be used to clear the onreadystatechange
   * handler instead of null.
   */
  USE_NULL_FUNCTION: 0,

  /**
   * NOTE(pupius): In IE if send() errors on a *local* request the readystate
   * is still changed to COMPLETE.  We need to ignore it and allow the
   * try/catch around send() to pick up the error.
   */
  LOCAL_REQUEST_ERROR: 1,
};


/**
 * Status constants for XMLHTTP, matches:
 * https://msdn.microsoft.com/en-us/library/ms534361(v=vs.85).aspx
 * @enum {number}
 */
goog.net.XmlHttp.ReadyState = {
  /**
   * Constant for when xmlhttprequest.readyState is uninitialized
   */
  UNINITIALIZED: 0,

  /**
   * Constant for when xmlhttprequest.readyState is loading.
   */
  LOADING: 1,

  /**
   * Constant for when xmlhttprequest.readyState is loaded.
   */
  LOADED: 2,

  /**
   * Constant for when xmlhttprequest.readyState is in an interactive state.
   */
  INTERACTIVE: 3,

  /**
   * Constant for when xmlhttprequest.readyState is completed
   */
  COMPLETE: 4,
};


/**
 * The global factory instance for creating XMLHttpRequest objects.
 * @type {goog.net.XmlHttpFactory}
 * @private
 */
goog.net.XmlHttp.factory_;


/**
 * Sets the factories for creating XMLHttpRequest objects and their options.
 * @param {Function} factory The factory for XMLHttpRequest objects.
 * @param {Function} optionsFactory The factory for options.
 * @deprecated Use setGlobalFactory instead.
 */
goog.net.XmlHttp.setFactory = function(factory, optionsFactory) {
  'use strict';
  goog.net.XmlHttp.setGlobalFactory(new goog.net.WrapperXmlHttpFactory(
      goog.asserts.assert(factory), goog.asserts.assert(optionsFactory)));
};


/**
 * Sets the global factory object.
 * @param {!goog.net.XmlHttpFactory} factory New global factory object.
 */
goog.net.XmlHttp.setGlobalFactory = function(factory) {
  'use strict';
  goog.net.XmlHttp.factory_ = factory;
};



/**
 * Default factory to use when creating xhr objects.  You probably shouldn't be
 * instantiating this directly, but rather using it via goog.net.XmlHttp.
 * @extends {goog.net.XmlHttpFactory}
 * @constructor
 */
goog.net.DefaultXmlHttpFactory = function() {
  'use strict';
  goog.net.XmlHttpFactory.call(this);
};
goog.inherits(goog.net.DefaultXmlHttpFactory, goog.net.XmlHttpFactory);


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.createInstance = function() {
  'use strict';
  const progId = this.getProgId_();
  if (progId) {
    return new ActiveXObject(progId);
  } else {
    return new XMLHttpRequest();
  }
};


/** @override */
goog.net.DefaultXmlHttpFactory.prototype.internalGetOptions = function() {
  'use strict';
  const progId = this.getProgId_();
  const options = {};
  if (progId) {
    options[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] = true;
    options[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] = true;
  }
  return options;
};


/**
 * The ActiveX PROG ID string to use to create xhr's in IE. Lazily initialized.
 * @type {string|undefined}
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.ieProgId_;


/**
 * Initialize the private state used by other functions.
 * @return {string} The ActiveX PROG ID string to use to create xhr's in IE.
 * @private
 */
goog.net.DefaultXmlHttpFactory.prototype.getProgId_ = function() {
  'use strict';
  if (goog.net.XmlHttp.ASSUME_NATIVE_XHR ||
      goog.net.XmlHttpDefines.ASSUME_NATIVE_XHR) {
    return '';
  }

  // The following blog post describes what PROG IDs to use to create the
  // XMLHTTP object in Internet Explorer:
  // http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
  // However we do not (yet) fully trust that this will be OK for old versions
  // of IE on Win9x so we therefore keep the last 2.
  if (!this.ieProgId_ && typeof XMLHttpRequest == 'undefined' &&
      typeof ActiveXObject != 'undefined') {
    // Candidate Active X types.
    const ACTIVE_X_IDENTS = [
      'MSXML2.XMLHTTP.6.0',
      'MSXML2.XMLHTTP.3.0',
      'MSXML2.XMLHTTP',
      'Microsoft.XMLHTTP',
    ];
    for (let i = 0; i < ACTIVE_X_IDENTS.length; i++) {
      const candidate = ACTIVE_X_IDENTS[i];

      try {
        new ActiveXObject(candidate);
        // NOTE(pupius): cannot assign progid and return candidate in one line
        // because JSCompiler complaings: BUG 658126
        this.ieProgId_ = candidate;
        return candidate;
      } catch (e) {
        // do nothing; try next choice
      }
    }

    // couldn't find any matches
    throw new Error(
        'Could not create ActiveXObject. ActiveX might be disabled,' +
        ' or MSXML might not be installed');
  }

  return /** @type {string} */ (this.ieProgId_);
};


// Set the global factory to an instance of the default factory.
goog.net.XmlHttp.setGlobalFactory(new goog.net.DefaultXmlHttpFactory());

//third_party/javascript/closure/timer/timer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A timer class to which other classes and objects can listen on.
 * This is only an abstraction above `setInterval`.
 *
 * @see ../demos/timers.html
 */

goog.provide('goog.Timer');

goog.require('goog.Promise');
goog.require('goog.events.EventTarget');
goog.requireType('goog.Thenable');



/**
 * Class for handling timing events.
 *
 * @param {number=} opt_interval Number of ms between ticks (default: 1ms).
 * @param {Object=} opt_timerObject  An object that has `setTimeout`,
 *     `setInterval`, `clearTimeout` and `clearInterval`
 *     (e.g., `window`).
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.Timer = function(opt_interval, opt_timerObject) {
  'use strict';
  goog.events.EventTarget.call(this);

  /**
   * Number of ms between ticks
   * @private {number}
   */
  this.interval_ = opt_interval || 1;

  /**
   * An object that implements `setTimeout`, `setInterval`,
   * `clearTimeout` and `clearInterval`. We default to the window
   * object. Changing this on {@link goog.Timer.prototype} changes the object
   * for all timer instances which can be useful if your environment has some
   * other implementation of timers than the `window` object.
   * @private {{setTimeout:!Function, clearTimeout:!Function}}
   */
  this.timerObject_ = /** @type {{setTimeout, clearTimeout}} */ (
      opt_timerObject || goog.Timer.defaultTimerObject);

  /**
   * Cached `tick_` bound to the object for later use in the timer.
   * @private {Function}
   * @const
   */
  this.boundTick_ = goog.bind(this.tick_, this);

  /**
   * Firefox browser often fires the timer event sooner (sometimes MUCH sooner)
   * than the requested timeout. So we compare the time to when the event was
   * last fired, and reschedule if appropriate. See also
   * {@link goog.Timer.intervalScale}.
   * @private {number}
   */
  this.last_ = goog.now();
};
goog.inherits(goog.Timer, goog.events.EventTarget);


/**
 * Maximum timeout value.
 *
 * Timeout values too big to fit into a signed 32-bit integer may cause overflow
 * in FF, Safari, and Chrome, resulting in the timeout being scheduled
 * immediately. It makes more sense simply not to schedule these timeouts, since
 * 24.8 days is beyond a reasonable expectation for the browser to stay open.
 *
 * @private {number}
 * @const
 */
goog.Timer.MAX_TIMEOUT_ = 2147483647;


/**
 * A timer ID that cannot be returned by any known implementation of
 * `window.setTimeout`. Passing this value to `window.clearTimeout`
 * should therefore be a no-op.
 *
 * @private {number}
 * @const
 */
goog.Timer.INVALID_TIMEOUT_ID_ = -1;


/**
 * Whether this timer is enabled
 * @type {boolean}
 */
goog.Timer.prototype.enabled = false;


/**
 * An object that implements `setTimeout`, `setInterval`,
 * `clearTimeout` and `clearInterval`. We default to the global
 * object. Changing `goog.Timer.defaultTimerObject` changes the object for
 * all timer instances which can be useful if your environment has some other
 * implementation of timers you'd like to use.
 * @type {{setTimeout, clearTimeout}}
 */
goog.Timer.defaultTimerObject = goog.global;


/**
 * Variable that controls the timer error correction. If the timer is called
 * before the requested interval times `intervalScale`, which often
 * happens on Mozilla, the timer is rescheduled.
 * @see {@link #last_}
 * @type {number}
 */
goog.Timer.intervalScale = 0.8;


/**
 * Variable for storing the result of `setInterval`.
 * @private {?number}
 */
goog.Timer.prototype.timer_ = null;


/**
 * Gets the interval of the timer.
 * @return {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.getInterval = function() {
  'use strict';
  return this.interval_;
};


/**
 * Sets the interval of the timer.
 * @param {number} interval Number of ms between ticks.
 */
goog.Timer.prototype.setInterval = function(interval) {
  'use strict';
  this.interval_ = interval;
  if (this.timer_ && this.enabled) {
    // Stop and then start the timer to reset the interval.
    this.stop();
    this.start();
  } else if (this.timer_) {
    this.stop();
  }
};


/**
 * Callback for the `setTimeout` used by the timer.
 * @private
 */
goog.Timer.prototype.tick_ = function() {
  'use strict';
  if (this.enabled) {
    var elapsed = goog.now() - this.last_;
    if (elapsed > 0 && elapsed < this.interval_ * goog.Timer.intervalScale) {
      this.timer_ = this.timerObject_.setTimeout(
          this.boundTick_, this.interval_ - elapsed);
      return;
    }

    // Prevents setInterval from registering a duplicate timeout when called
    // in the timer event handler.
    if (this.timer_) {
      this.timerObject_.clearTimeout(this.timer_);
      this.timer_ = null;
    }

    this.dispatchTick();
    // The timer could be stopped in the timer event handler.
    if (this.enabled) {
      // Stop and start to ensure there is always only one timeout even if
      // start is called in the timer event handler.
      this.stop();
      this.start();
    }
  }
};


/**
 * Dispatches the TICK event. This is its own method so subclasses can override.
 */
goog.Timer.prototype.dispatchTick = function() {
  'use strict';
  this.dispatchEvent(goog.Timer.TICK);
};


/**
 * Starts the timer.
 */
goog.Timer.prototype.start = function() {
  'use strict';
  this.enabled = true;

  // If there is no interval already registered, start it now
  if (!this.timer_) {
    // IMPORTANT!
    // window.setInterval in FireFox has a bug - it fires based on
    // absolute time, rather than on relative time. What this means
    // is that if a computer is sleeping/hibernating for 24 hours
    // and the timer interval was configured to fire every 1000ms,
    // then after the PC wakes up the timer will fire, in rapid
    // succession, 3600*24 times.
    // This bug is described here and is already fixed, but it will
    // take time to propagate, so for now I am switching this over
    // to setTimeout logic.
    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643
    //
    this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_);
    this.last_ = goog.now();
  }
};


/**
 * Stops the timer.
 */
goog.Timer.prototype.stop = function() {
  'use strict';
  this.enabled = false;
  if (this.timer_) {
    this.timerObject_.clearTimeout(this.timer_);
    this.timer_ = null;
  }
};


/** @override */
goog.Timer.prototype.disposeInternal = function() {
  'use strict';
  goog.Timer.superClass_.disposeInternal.call(this);
  this.stop();
  delete this.timerObject_;
};


/**
 * Constant for the timer's event type.
 * @const
 */
goog.Timer.TICK = 'tick';


/**
 * Calls the given function once, after the optional pause.
 * <p>
 * The function is always called asynchronously, even if the delay is 0. This
 * is a common trick to schedule a function to run after a batch of browser
 * event processing.
 *
 * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function
 *     or object that has a handleEvent method.
 * @param {number=} opt_delay Milliseconds to wait; default is 0.
 * @param {SCOPE=} opt_handler Object in whose scope to call the listener.
 * @return {number} A handle to the timer ID.
 * @template SCOPE
 */
goog.Timer.callOnce = function(listener, opt_delay, opt_handler) {
  'use strict';
  if (typeof listener === 'function') {
    if (opt_handler) {
      listener = goog.bind(listener, opt_handler);
    }
  } else if (listener && typeof listener.handleEvent == 'function') {
    // using typeof to prevent strict js warning
    listener = goog.bind(listener.handleEvent, listener);
  } else {
    throw new Error('Invalid listener argument');
  }

  if (Number(opt_delay) > goog.Timer.MAX_TIMEOUT_) {
    // Timeouts greater than MAX_INT return immediately due to integer
    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don't
    // schedule anything at all.
    return goog.Timer.INVALID_TIMEOUT_ID_;
  } else {
    return goog.Timer.defaultTimerObject.setTimeout(listener, opt_delay || 0);
  }
};


/**
 * Clears a timeout initiated by {@link #callOnce}.
 * @param {?number} timerId A timer ID.
 */
goog.Timer.clear = function(timerId) {
  'use strict';
  goog.Timer.defaultTimerObject.clearTimeout(timerId);
};


/**
 * @param {number} delay Milliseconds to wait.
 * @param {(RESULT|goog.Thenable<RESULT>|Thenable)=} opt_result The value
 *     with which the promise will be resolved.
 * @return {!goog.Promise<RESULT>} A promise that will be resolved after
 *     the specified delay, unless it is canceled first.
 * @template RESULT
 */
goog.Timer.promise = function(delay, opt_result) {
  'use strict';
  var timerKey = null;
  return new goog
      .Promise(function(resolve, reject) {
        'use strict';
        timerKey = goog.Timer.callOnce(function() {
          'use strict';
          resolve(opt_result);
        }, delay);
        if (timerKey == goog.Timer.INVALID_TIMEOUT_ID_) {
          reject(new Error('Failed to schedule timer.'));
        }
      })
      .thenCatch(function(error) {
        'use strict';
        // Clear the timer. The most likely reason is "cancel" signal.
        goog.Timer.clear(timerKey);
        throw error;
      });
};

//third_party/javascript/closure/uri/utils.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Simple utilities for dealing with URI strings.
 *
 * This package is deprecated in favour of the Closure URL package (goog.url)
 * when manipulating URIs for use by a browser. This package uses regular
 * expressions to parse a potential URI which can fall out of sync with how a
 * browser will actually interpret the URI. See
 * `goog.uri.utils.setUrlPackageSupportLoggingHandler` for one way to identify
 * URIs that should instead be parsed using the URL package.
 *
 * This is intended to be a lightweight alternative to constructing goog.Uri
 * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless
 * of how much of its functionality you use, this is designed to be a set of
 * mostly-independent utilities so that the compiler includes only what is
 * necessary for the task.  Estimated savings of porting is 5k pre-gzip and
 * 1.5k post-gzip.  To ensure the savings remain, future developers should
 * avoid adding new functionality to existing functions, but instead create
 * new ones and factor out shared code.
 *
 * Many of these utilities have limited functionality, tailored to common
 * cases.  The query parameter utilities assume that the parameter keys are
 * already encoded, since most keys are compile-time alphanumeric strings.  The
 * query parameter mutation utilities also do not tolerate fragment identifiers.
 *
 * By design, these functions can be slower than goog.Uri equivalents.
 * Repeated calls to some of functions may be quadratic in behavior for IE,
 * although the effect is somewhat limited given the 2kb limit.
 *
 * One advantage of the limited functionality here is that this approach is
 * less sensitive to differences in URI encodings than goog.Uri, since these
 * functions operate on strings directly, rather than decoding them and
 * then re-encoding.
 *
 * Uses features of RFC 3986 for parsing/formatting URIs:
 *   http://www.ietf.org/rfc/rfc3986.txt
 */

goog.provide('goog.uri.utils');
goog.provide('goog.uri.utils.ComponentIndex');
goog.provide('goog.uri.utils.QueryArray');
goog.provide('goog.uri.utils.QueryValue');
goog.provide('goog.uri.utils.StandardQueryParam');

goog.require('goog.asserts');
goog.require('goog.string');


/**
 * Character codes inlined to avoid object allocations due to charCode.
 * @enum {number}
 * @private
 */
goog.uri.utils.CharCode_ = {
  AMPERSAND: 38,
  EQUAL: 61,
  HASH: 35,
  QUESTION: 63
};


/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|number|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
goog.uri.utils.buildFromEncodedParts = function(
    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,
    opt_fragment) {
  'use strict';
  var out = '';

  if (opt_scheme) {
    out += opt_scheme + ':';
  }

  if (opt_domain) {
    out += '//';

    if (opt_userInfo) {
      out += opt_userInfo + '@';
    }

    out += opt_domain;

    if (opt_port) {
      out += ':' + opt_port;
    }
  }

  if (opt_path) {
    out += opt_path;
  }

  if (opt_queryData) {
    out += '?' + opt_queryData;
  }

  if (opt_fragment) {
    out += '#' + opt_fragment;
  }

  return out;
};


/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 *
 * TODO(jameswr): separate out the authority terminating characters once this
 * file is moved to ES6.
 * @type {!RegExp}
 * @private
 */
goog.uri.utils.splitRe_ = new RegExp(
    '^' +  // Anchor against the entire string.
    '(?:' +
    '([^:/?#.]+)' +  // scheme - ignore special characters
                     // used by other URL parts such as :,
                     // ?, /, #, and .
    ':)?' +
    '(?://' +
    '(?:([^\\\\/?#]*)@)?' +  // userInfo
    '([^\\\\/?#]*?)' +       // domain
    '(?::([0-9]+))?' +       // port
    '(?=[\\\\/?#]|$)' +      // authority-terminating character.
    ')?' +
    '([^?#]+)?' +          // path
    '(?:\\?([^#]*))?' +    // query
    '(?:#([\\s\\S]*))?' +  // fragment. Can't use '.*' with 's' flag as Firefox
                           // doesn't support the flag, and can't use an
                           // "everything set" ([^]) as IE10 doesn't match any
                           // characters with it.
    '$');


/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
goog.uri.utils.ComponentIndex = {
  SCHEME: 1,
  USER_INFO: 2,
  DOMAIN: 3,
  PORT: 4,
  PATH: 5,
  QUERY_DATA: 6,
  FRAGMENT: 7
};

/**
 * @type {?function(string)}
 * @private
 */
goog.uri.utils.urlPackageSupportLoggingHandler_ = null;

/**
 * @param {?function(string)} handler The handler function to call when a URI
 *     with a protocol that is better supported by the Closure URL package is
 *     detected.
 */
goog.uri.utils.setUrlPackageSupportLoggingHandler = function(handler) {
  'use strict';
  goog.uri.utils.urlPackageSupportLoggingHandler_ = handler;
};

/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
goog.uri.utils.split = function(uri) {
  'use strict';
  // See @return comment -- never null.
  var result = /** @type {!Array<string|undefined>} */ (
      uri.match(goog.uri.utils.splitRe_));
  if (goog.uri.utils.urlPackageSupportLoggingHandler_ &&
      ['http', 'https', 'ws', 'wss',
       'ftp'].indexOf(result[goog.uri.utils.ComponentIndex.SCHEME]) >= 0) {
    goog.uri.utils.urlPackageSupportLoggingHandler_(uri);
  }
  return result;
};


/**
 * @param {?string} uri A possibly null string.
 * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986
 *     reserved characters will not be removed.
 * @return {?string} The string URI-decoded, or null if uri is null.
 * @private
 */
goog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {
  'use strict';
  if (!uri) {
    return uri;
  }

  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);
};


/**
 * Gets a URI component by index.
 *
 * It is preferred to use the getPathEncoded() variety of functions ahead,
 * since they are more readable.
 *
 * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.
 * @param {string} uri The URI to examine.
 * @return {?string} The still-encoded component, or null if the component
 *     is not present.
 * @private
 */
goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {
  'use strict';
  // Convert undefined, null, and empty string into null.
  return goog.uri.utils.split(uri)[componentIndex] || null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The protocol or scheme, or null if none.  Does not
 *     include trailing colons or slashes.
 */
goog.uri.utils.getScheme = function(uri) {
  'use strict';
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.SCHEME, uri);
};


/**
 * Gets the effective scheme for the URL.  If the URL is relative then the
 * scheme is derived from the page's location.
 * @param {string} uri The URI to examine.
 * @return {string} The protocol or scheme, always lower case.
 */
goog.uri.utils.getEffectiveScheme = function(uri) {
  'use strict';
  var scheme = goog.uri.utils.getScheme(uri);
  if (!scheme && goog.global.self && goog.global.self.location) {
    var protocol = goog.global.self.location.protocol;
    scheme = protocol.substr(0, protocol.length - 1);
  }
  // NOTE: When called from a web worker in Firefox 3.5, location may be null.
  // All other browsers with web workers support self.location from the worker.
  return scheme ? scheme.toLowerCase() : '';
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The user name still encoded, or null if none.
 */
goog.uri.utils.getUserInfoEncoded = function(uri) {
  'use strict';
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.USER_INFO, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded user info, or null if none.
 */
goog.uri.utils.getUserInfo = function(uri) {
  'use strict';
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getUserInfoEncoded(uri));
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The domain name still encoded, or null if none.
 */
goog.uri.utils.getDomainEncoded = function(uri) {
  'use strict';
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.DOMAIN, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded domain, or null if none.
 */
goog.uri.utils.getDomain = function(uri) {
  'use strict';
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?number} The port number, or null if none.
 */
goog.uri.utils.getPort = function(uri) {
  'use strict';
  // Coerce to a number.  If the result of getComponentByIndex_ is null or
  // non-numeric, the number coersion yields NaN.  This will then return
  // null for all non-numeric cases (though also zero, which isn't a relevant
  // port number).
  return Number(
             goog.uri.utils.getComponentByIndex_(
                 goog.uri.utils.ComponentIndex.PORT, uri)) ||
      null;
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The path still encoded, or null if none. Includes the
 *     leading slash, if any.
 */
goog.uri.utils.getPathEncoded = function(uri) {
  'use strict';
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.PATH, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded path, or null if none.  Includes the leading
 *     slash, if any.
 */
goog.uri.utils.getPath = function(uri) {
  'use strict';
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The query data still encoded, or null if none.  Does not
 *     include the question mark itself.
 */
goog.uri.utils.getQueryData = function(uri) {
  'use strict';
  return goog.uri.utils.getComponentByIndex_(
      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The fragment identifier, or null if none.  Does not
 *     include the hash mark itself.
 */
goog.uri.utils.getFragmentEncoded = function(uri) {
  'use strict';
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? null : uri.substr(hashIndex + 1);
};


/**
 * @param {string} uri The URI to examine.
 * @param {?string} fragment The encoded fragment identifier, or null if none.
 *     Does not include the hash mark itself.
 * @return {string} The URI with the fragment set.
 */
goog.uri.utils.setFragmentEncoded = function(uri, fragment) {
  'use strict';
  return goog.uri.utils.removeFragment(uri) + (fragment ? '#' + fragment : '');
};


/**
 * @param {string} uri The URI to examine.
 * @return {?string} The decoded fragment identifier, or null if none.  Does
 *     not include the hash mark.
 */
goog.uri.utils.getFragment = function(uri) {
  'use strict';
  return goog.uri.utils.decodeIfPossible_(
      goog.uri.utils.getFragmentEncoded(uri));
};


/**
 * Extracts everything up to the port of the URI.
 * @param {string} uri The URI string.
 * @return {string} Everything up to and including the port.
 */
goog.uri.utils.getHost = function(uri) {
  'use strict';
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      pieces[goog.uri.utils.ComponentIndex.SCHEME],
      pieces[goog.uri.utils.ComponentIndex.USER_INFO],
      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
      pieces[goog.uri.utils.ComponentIndex.PORT]);
};


/**
 * Returns the origin for a given URL.
 * @param {string} uri The URI string.
 * @return {string} Everything up to and including the port.
 */
goog.uri.utils.getOrigin = function(uri) {
  'use strict';
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,
      pieces[goog.uri.utils.ComponentIndex.DOMAIN],
      pieces[goog.uri.utils.ComponentIndex.PORT]);
};


/**
 * Extracts the path of the URL and everything after.
 * @param {string} uri The URI string.
 * @return {string} The URI, starting at the path and including the query
 *     parameters and fragment identifier.
 */
goog.uri.utils.getPathAndAfter = function(uri) {
  'use strict';
  var pieces = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],
      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],
      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Gets the URI with the fragment identifier removed.
 * @param {string} uri The URI to examine.
 * @return {string} Everything preceding the hash mark.
 */
goog.uri.utils.removeFragment = function(uri) {
  'use strict';
  // The hash mark may not appear in any other part of the URL.
  var hashIndex = uri.indexOf('#');
  return hashIndex < 0 ? uri : uri.substr(0, hashIndex);
};


/**
 * Ensures that two URI's have the exact same domain, scheme, and port.
 *
 * Unlike the version in goog.Uri, this checks protocol, and therefore is
 * suitable for checking against the browser's same-origin policy.
 *
 * @param {string} uri1 The first URI.
 * @param {string} uri2 The second URI.
 * @return {boolean} Whether they have the same scheme, domain and port.
 */
goog.uri.utils.haveSameDomain = function(uri1, uri2) {
  'use strict';
  var pieces1 = goog.uri.utils.split(uri1);
  var pieces2 = goog.uri.utils.split(uri2);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==
      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &&
      pieces1[goog.uri.utils.ComponentIndex.PORT] ==
      pieces2[goog.uri.utils.ComponentIndex.PORT];
};


/**
 * Asserts that there are no fragment or query identifiers, only in uncompiled
 * mode.
 * @param {string} uri The URI to examine.
 * @private
 */
goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {
  'use strict';
  goog.asserts.assert(
      uri.indexOf('#') < 0 && uri.indexOf('?') < 0,
      'goog.uri.utils: Fragment or query identifiers are not supported: [%s]',
      uri);
};


/**
 * Supported query parameter values by the parameter serializing utilities.
 *
 * If a value is null or undefined, the key-value pair is skipped, as an easy
 * way to omit parameters conditionally.  Non-array parameters are converted
 * to a string and URI encoded.  Array values are expanded into multiple
 * &key=value pairs, with each element stringized and URI-encoded.
 *
 * @typedef {*}
 */
goog.uri.utils.QueryValue;


/**
 * An array representing a set of query parameters with alternating keys
 * and values.
 *
 * Keys are assumed to be URI encoded already and live at even indices.  See
 * goog.uri.utils.QueryValue for details on how parameter values are encoded.
 *
 * Example:
 * <pre>
 * var data = [
 *   // Simple param: ?name=BobBarker
 *   'name', 'BobBarker',
 *   // Conditional param -- may be omitted entirely.
 *   'specialDietaryNeeds', hasDietaryNeeds() ? getDietaryNeeds() : null,
 *   // Multi-valued param: &house=LosAngeles&house=NewYork&house=null
 *   'house', ['LosAngeles', 'NewYork', null]
 * ];
 * </pre>
 *
 * @typedef {!Array<string|goog.uri.utils.QueryValue>}
 */
goog.uri.utils.QueryArray;


/**
 * Parses encoded query parameters and calls callback function for every
 * parameter found in the string.
 *
 * Missing value of parameter (e.g. “…&key&…”) is treated as if the value was an
 * empty string.  Keys may be empty strings (e.g. “…&=value&…”) which also means
 * that “…&=&…” and “…&&…” will result in an empty key and value.
 *
 * @param {string} encodedQuery Encoded query string excluding question mark at
 *     the beginning.
 * @param {function(string, string)} callback Function called for every
 *     parameter found in query string.  The first argument (name) will not be
 *     urldecoded (so the function is consistent with buildQueryData), but the
 *     second will.  If the parameter has no value (i.e. “=” was not present)
 *     the second argument (value) will be an empty string.
 */
goog.uri.utils.parseQueryData = function(encodedQuery, callback) {
  'use strict';
  if (!encodedQuery) {
    return;
  }
  var pairs = encodedQuery.split('&');
  for (var i = 0; i < pairs.length; i++) {
    var indexOfEquals = pairs[i].indexOf('=');
    var name = null;
    var value = null;
    if (indexOfEquals >= 0) {
      name = pairs[i].substring(0, indexOfEquals);
      value = pairs[i].substring(indexOfEquals + 1);
    } else {
      name = pairs[i];
    }
    callback(name, value ? goog.string.urlDecode(value) : '');
  }
};


/**
 * Split the URI into 3 parts where the [1] is the queryData without a leading
 * '?'. For example, the URI http://foo.com/bar?a=b#abc returns
 * ['http://foo.com/bar','a=b','#abc'].
 * @param {string} uri The URI to parse.
 * @return {!Array<string>} An array representation of uri of length 3 where the
 *     middle value is the queryData without a leading '?'.
 * @private
 */
goog.uri.utils.splitQueryData_ = function(uri) {
  'use strict';
  // Find the query data and hash.
  var hashIndex = uri.indexOf('#');
  if (hashIndex < 0) {
    hashIndex = uri.length;
  }
  var questionIndex = uri.indexOf('?');
  var queryData;
  if (questionIndex < 0 || questionIndex > hashIndex) {
    questionIndex = hashIndex;
    queryData = '';
  } else {
    queryData = uri.substring(questionIndex + 1, hashIndex);
  }
  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];
};


/**
 * Join an array created by splitQueryData_ back into a URI.
 * @param {!Array<string>} parts A URI in the form generated by splitQueryData_.
 * @return {string} The joined URI.
 * @private
 */
goog.uri.utils.joinQueryData_ = function(parts) {
  'use strict';
  return parts[0] + (parts[1] ? '?' + parts[1] : '') + parts[2];
};


/**
 * @param {string} queryData
 * @param {string} newData
 * @return {string}
 * @private
 */
goog.uri.utils.appendQueryData_ = function(queryData, newData) {
  'use strict';
  if (!newData) {
    return queryData;
  }
  return queryData ? queryData + '&' + newData : newData;
};


/**
 * @param {string} uri
 * @param {string} queryData
 * @return {string}
 * @private
 */
goog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {
  'use strict';
  if (!queryData) {
    return uri;
  }
  var parts = goog.uri.utils.splitQueryData_(uri);
  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);
  return goog.uri.utils.joinQueryData_(parts);
};


/**
 * Appends key=value pairs to an array, supporting multi-valued objects.
 * @param {*} key The key prefix.
 * @param {goog.uri.utils.QueryValue} value The value to serialize.
 * @param {!Array<string>} pairs The array to which the 'key=value' strings
 *     should be appended.
 * @private
 */
goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {
  'use strict';
  goog.asserts.assertString(key);
  if (Array.isArray(value)) {
    // Convince the compiler it's an array.
    goog.asserts.assertArray(value);
    for (var j = 0; j < value.length; j++) {
      // Convert to string explicitly, to short circuit the null and array
      // logic in this function -- this ensures that null and undefined get
      // written as literal 'null' and 'undefined', and arrays don't get
      // expanded out but instead encoded in the default way.
      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);
    }
  } else if (value != null) {
    // Skip a top-level null or undefined entirely.
    pairs.push(
        key +
        // Check for empty string. Zero gets encoded into the url as literal
        // strings.  For empty string, skip the equal sign, to be consistent
        // with UriBuilder.java.
        (value === '' ? '' : '=' + goog.string.urlEncode(value)));
  }
};


/**
 * Builds a query data string from a sequence of alternating keys and values.
 * Currently generates "&key&" for empty args.
 *
 * @param {!IArrayLike<string|goog.uri.utils.QueryValue>} keysAndValues
 *     Alternating keys and values. See the QueryArray typedef.
 * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {
  'use strict';
  goog.asserts.assert(
      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,
      'goog.uri.utils: Key/value lists must be even in length.');

  var params = [];
  for (var i = opt_startIndex || 0; i < keysAndValues.length; i += 2) {
    var key = /** @type {string} */ (keysAndValues[i]);
    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);
  }
  return params.join('&');
};


/**
 * Builds a query data string from a map.
 * Currently generates "&key&" for empty args.
 *
 * @param {!Object<string, goog.uri.utils.QueryValue>} map An object where keys
 *     are URI-encoded parameter keys, and the values are arbitrary types
 *     or arrays. Keys with a null value are dropped.
 * @return {string} The encoded query string, in the form 'a=1&b=2'.
 */
goog.uri.utils.buildQueryDataFromMap = function(map) {
  'use strict';
  var params = [];
  for (var key in map) {
    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);
  }
  return params.join('&');
};


/**
 * Appends URI parameters to an existing URI.
 *
 * The variable arguments may contain alternating keys and values.  Keys are
 * assumed to be already URI encoded.  The values should not be URI-encoded,
 * and will instead be encoded by this function.
 * <pre>
 * appendParams('http://www.foo.com?existing=true',
 *     'key1', 'value1',
 *     'key2', 'value?willBeEncoded',
 *     'key3', ['valueA', 'valueB', 'valueC'],
 *     'key4', null);
 * result: 'http://www.foo.com?existing=true&' +
 *     'key1=value1&' +
 *     'key2=value%3FwillBeEncoded&' +
 *     'key3=valueA&key3=valueB&key3=valueC'
 * </pre>
 *
 * A single call to this function will not exhibit quadratic behavior in IE,
 * whereas multiple repeated calls may, although the effect is limited by
 * fact that URL's generally can't exceed 2kb.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}
 * var_args
 *     An array or argument list conforming to goog.uri.utils.QueryArray.
 * @return {string} The URI with all query parameters added.
 */
goog.uri.utils.appendParams = function(uri, var_args) {
  'use strict';
  var queryData = arguments.length == 2 ?
      goog.uri.utils.buildQueryData(arguments[1], 0) :
      goog.uri.utils.buildQueryData(arguments, 1);
  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);
};


/**
 * Appends query parameters from a map.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object<goog.uri.utils.QueryValue>} map An object where keys are
 *     URI-encoded parameter keys, and the values are arbitrary types or arrays.
 *     Keys with a null value are dropped.
 * @return {string} The new parameters.
 */
goog.uri.utils.appendParamsFromMap = function(uri, map) {
  'use strict';
  var queryData = goog.uri.utils.buildQueryDataFromMap(map);
  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);
};


/**
 * Appends a single URI parameter.
 *
 * Repeated calls to this can exhibit quadratic behavior in IE6 due to the
 * way string append works, though it should be limited given the 2kb limit.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} key The key, which must already be URI encoded.
 * @param {*=} opt_value The value, which will be stringized and encoded
 *     (assumed not already to be encoded).  If omitted, undefined, or null, the
 *     key will be added as a valueless parameter.
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.appendParam = function(uri, key, opt_value) {
  'use strict';
  var value = (opt_value != null) ? '=' + goog.string.urlEncode(opt_value) : '';
  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);
};


/**
 * Finds the next instance of a query parameter with the specified name.
 *
 * Does not instantiate any objects.
 *
 * @param {string} uri The URI to search.  May contain a fragment identifier
 *     if opt_hashIndex is specified.
 * @param {number} startIndex The index to begin searching for the key at.  A
 *     match may be found even if this is one character after the ampersand.
 * @param {string} keyEncoded The URI-encoded key.
 * @param {number} hashOrEndIndex Index to stop looking at.  If a hash
 *     mark is present, it should be its index, otherwise it should be the
 *     length of the string.
 * @return {number} The position of the first character in the key's name,
 *     immediately after either a question mark or a dot.
 * @private
 */
goog.uri.utils.findParam_ = function(
    uri, startIndex, keyEncoded, hashOrEndIndex) {
  'use strict';
  var index = startIndex;
  var keyLength = keyEncoded.length;

  // Search for the key itself and post-filter for surronuding punctuation,
  // rather than expensively building a regexp.
  while ((index = uri.indexOf(keyEncoded, index)) >= 0 &&
         index < hashOrEndIndex) {
    var precedingChar = uri.charCodeAt(index - 1);
    // Ensure that the preceding character is '&' or '?'.
    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||
        precedingChar == goog.uri.utils.CharCode_.QUESTION) {
      // Ensure the following character is '&', '=', '#', or NaN
      // (end of string).
      var followingChar = uri.charCodeAt(index + keyLength);
      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||
          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||
          followingChar == goog.uri.utils.CharCode_.HASH) {
        return index;
      }
    }
    index += keyLength + 1;
  }

  return -1;
};


/**
 * Regular expression for finding a hash mark or end of string.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.hashOrEndRe_ = /#|$/;


/**
 * Determines if the URI contains a specific key.
 *
 * Performs no object instantiations.
 *
 * @param {string} uri The URI to process.  May contain a fragment
 *     identifier.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {boolean} Whether the key is present.
 */
goog.uri.utils.hasParam = function(uri, keyEncoded) {
  'use strict';
  return goog.uri.utils.findParam_(
             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) >= 0;
};


/**
 * Gets the first value of a query parameter.
 * @param {string} uri The URI to process.  May contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {?string} The first value of the parameter (URI-decoded), or null
 *     if the parameter is not found.
 */
goog.uri.utils.getParamValue = function(uri, keyEncoded) {
  'use strict';
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var foundIndex =
      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);

  if (foundIndex < 0) {
    return null;
  } else {
    var endPosition = uri.indexOf('&', foundIndex);
    if (endPosition < 0 || endPosition > hashOrEndIndex) {
      endPosition = hashOrEndIndex;
    }
    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > endPosition.
    return goog.string.urlDecode(
        uri.substr(foundIndex, endPosition - foundIndex));
  }
};


/**
 * Gets all values of a query parameter.
 * @param {string} uri The URI to process.  May contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.
 * @return {!Array<string>} All URI-decoded values with the given key.
 *     If the key is not found, this will have length 0, but never be null.
 */
goog.uri.utils.getParamValues = function(uri, keyEncoded) {
  'use strict';
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var result = [];

  while ((foundIndex = goog.uri.utils.findParam_(
              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Find where this parameter ends, either the '&' or the end of the
    // query parameters.
    position = uri.indexOf('&', foundIndex);
    if (position < 0 || position > hashOrEndIndex) {
      position = hashOrEndIndex;
    }

    // Progress forth to the end of the "key=" or "key&" substring.
    foundIndex += keyEncoded.length + 1;
    // Use substr, because it (unlike substring) will return empty string
    // if foundIndex > position.
    result.push(
        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));
  }

  return result;
};


/**
 * Regexp to find trailing question marks and ampersands.
 * @type {RegExp}
 * @private
 */
goog.uri.utils.trailingQueryPunctuationRe_ = /[?&]($|#)/;


/**
 * Removes all instances of a query parameter.
 * @param {string} uri The URI to process.  Must not contain a fragment.
 * @param {string} keyEncoded The URI-encoded key.
 * @return {string} The URI with all instances of the parameter removed.
 */
goog.uri.utils.removeParam = function(uri, keyEncoded) {
  'use strict';
  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);
  var position = 0;
  var foundIndex;
  var buffer = [];

  // Look for a query parameter.
  while ((foundIndex = goog.uri.utils.findParam_(
              uri, position, keyEncoded, hashOrEndIndex)) >= 0) {
    // Get the portion of the query string up to, but not including, the ?
    // or & starting the parameter.
    buffer.push(uri.substring(position, foundIndex));
    // Progress to immediately after the '&'.  If not found, go to the end.
    // Avoid including the hash mark.
    position = Math.min(
        (uri.indexOf('&', foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);
  }

  // Append everything that is remaining.
  buffer.push(uri.substr(position));

  // Join the buffer, and remove trailing punctuation that remains.
  return buffer.join('').replace(
      goog.uri.utils.trailingQueryPunctuationRe_, '$1');
};


/**
 * Replaces all existing definitions of a parameter with a single definition.
 *
 * Repeated calls to this can exhibit quadratic behavior due to the need to
 * find existing instances and reconstruct the string, though it should be
 * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap
 * to update multiple parameters in bulk.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {string} keyEncoded The key, which must already be URI encoded.
 * @param {*} value The value, which will be stringized and encoded (assumed
 *     not already to be encoded).
 * @return {string} The URI with the query parameter added.
 */
goog.uri.utils.setParam = function(uri, keyEncoded, value) {
  'use strict';
  return goog.uri.utils.appendParam(
      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);
};


/**
 * Effeciently set or remove multiple query parameters in a URI. Order of
 * unchanged parameters will not be modified, all updated parameters will be
 * appended to the end of the query. Params with values of null or undefined are
 * removed.
 *
 * @param {string} uri The URI to process.
 * @param {!Object<string, goog.uri.utils.QueryValue>} params A list of
 *     parameters to update. If null or undefined, the param will be removed.
 * @return {string} An updated URI where the query data has been updated with
 *     the params.
 */
goog.uri.utils.setParamsFromMap = function(uri, params) {
  'use strict';
  var parts = goog.uri.utils.splitQueryData_(uri);
  var queryData = parts[1];
  var buffer = [];
  if (queryData) {
    queryData.split('&').forEach(function(pair) {
      'use strict';
      var indexOfEquals = pair.indexOf('=');
      var name = indexOfEquals >= 0 ? pair.substr(0, indexOfEquals) : pair;
      if (!params.hasOwnProperty(name)) {
        buffer.push(pair);
      }
    });
  }
  parts[1] = goog.uri.utils.appendQueryData_(
      buffer.join('&'), goog.uri.utils.buildQueryDataFromMap(params));
  return goog.uri.utils.joinQueryData_(parts);
};


/**
 * Generates a URI path using a given URI and a path with checks to
 * prevent consecutive "//". The baseUri passed in must not contain
 * query or fragment identifiers. The path to append may not contain query or
 * fragment identifiers.
 *
 * @param {string} baseUri URI to use as the base.
 * @param {string} path Path to append.
 * @return {string} Updated URI.
 */
goog.uri.utils.appendPath = function(baseUri, path) {
  'use strict';
  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);

  // Remove any trailing '/'
  if (goog.string.endsWith(baseUri, '/')) {
    baseUri = baseUri.substr(0, baseUri.length - 1);
  }
  // Remove any leading '/'
  if (goog.string.startsWith(path, '/')) {
    path = path.substr(1);
  }
  return '' + baseUri + '/' + path;
};


/**
 * Replaces the path.
 * @param {string} uri URI to use as the base.
 * @param {string} path New path.
 * @return {string} Updated URI.
 */
goog.uri.utils.setPath = function(uri, path) {
  'use strict';
  // Add any missing '/'.
  if (!goog.string.startsWith(path, '/')) {
    path = '/' + path;
  }
  var parts = goog.uri.utils.split(uri);
  return goog.uri.utils.buildFromEncodedParts(
      parts[goog.uri.utils.ComponentIndex.SCHEME],
      parts[goog.uri.utils.ComponentIndex.USER_INFO],
      parts[goog.uri.utils.ComponentIndex.DOMAIN],
      parts[goog.uri.utils.ComponentIndex.PORT], path,
      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],
      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);
};


/**
 * Standard supported query parameters.
 * @enum {string}
 */
goog.uri.utils.StandardQueryParam = {

  /** Unused parameter for unique-ifying. */
  RANDOM: 'zx'
};


/**
 * Sets the zx parameter of a URI to a random value.
 * @param {string} uri Any URI.
 * @return {string} That URI with the "zx" parameter added or replaced to
 *     contain a random string.
 */
goog.uri.utils.makeUnique = function(uri) {
  'use strict';
  return goog.uri.utils.setParam(
      uri, goog.uri.utils.StandardQueryParam.RANDOM,
      goog.string.getRandomString());
};

//third_party/javascript/closure/net/xhrio.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Wrapper class for handling XmlHttpRequests.
 *
 * One off requests can be sent through goog.net.XhrIo.send() or an
 * instance can be created to send multiple requests.  Each request uses its
 * own XmlHttpRequest object and handles clearing of the event callback to
 * ensure no leaks.
 *
 * XhrIo is event based, it dispatches events on success, failure, finishing,
 * ready-state change, or progress (download and upload).
 *
 * The ready-state or timeout event fires first, followed by
 * a generic completed event. Then the abort, error, or success event
 * is fired as appropriate. Progress events are fired as they are
 * received. Lastly, the ready event will fire to indicate that the
 * object may be used to make another request.
 *
 * The error event may also be called before completed and
 * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.
 *
 * This class does not support multiple requests, queuing, or prioritization.
 *
 * When progress events are supported by the browser, and progress is
 * enabled via .setProgressEventsEnabled(true), the
 * goog.net.EventType.PROGRESS event will be the re-dispatched browser
 * progress event. Additionally, a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event
 * will be fired for download and upload progress respectively.
 */


goog.provide('goog.net.XhrIo');
goog.provide('goog.net.XhrIo.ResponseType');

goog.require('goog.Timer');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.EventTarget');
goog.require('goog.json.hybrid');
goog.require('goog.log');
goog.require('goog.net.ErrorCode');
goog.require('goog.net.EventType');
goog.require('goog.net.HttpStatus');
goog.require('goog.net.XmlHttp');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.userAgent');
goog.requireType('goog.Uri');
goog.requireType('goog.debug.ErrorHandler');
goog.requireType('goog.net.XhrLike');
goog.requireType('goog.net.XmlHttpFactory');

goog.scope(function() {

'use strict';
/**
 * Basic class for handling XMLHttpRequests.
 * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when
 *     creating XMLHttpRequest objects.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.net.XhrIo = function(opt_xmlHttpFactory) {
  'use strict';
  XhrIo.base(this, 'constructor');

  /**
   * Map of default headers to add to every request, use:
   * XhrIo.headers.set(name, value)
   * @type {!goog.structs.Map}
   */
  this.headers = new goog.structs.Map();

  /**
   * Optional XmlHttpFactory
   * @private {goog.net.XmlHttpFactory}
   */
  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;

  /**
   * Whether XMLHttpRequest is active.  A request is active from the time send()
   * is called until onReadyStateChange() is complete, or error() or abort()
   * is called.
   * @private {boolean}
   */
  this.active_ = false;

  /**
   * The XMLHttpRequest object that is being used for the transfer.
   * @private {?goog.net.XhrLike.OrNative}
   */
  this.xhr_ = null;

  /**
   * The options to use with the current XMLHttpRequest object.
   * @private {?Object}
   */
  this.xhrOptions_ = null;

  /**
   * Last URL that was requested.
   * @private {string|goog.Uri}
   */
  this.lastUri_ = '';

  /**
   * Method for the last request.
   * @private {string}
   */
  this.lastMethod_ = '';

  /**
   * Last error code.
   * @private {!goog.net.ErrorCode}
   */
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;

  /**
   * Last error message.
   * @private {Error|string}
   */
  this.lastError_ = '';

  /**
   * Used to ensure that we don't dispatch an multiple ERROR events. This can
   * happen in IE when it does a synchronous load and one error is handled in
   * the ready state change and one is handled due to send() throwing an
   * exception.
   * @private {boolean}
   */
  this.errorDispatched_ = false;

  /**
   * Used to make sure we don't fire the complete event from inside a send call.
   * @private {boolean}
   */
  this.inSend_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.open.
   * @private {boolean}
   */
  this.inOpen_ = false;

  /**
   * Used in determining if a call to {@link #onReadyStateChange_} is from
   * within a call to this.xhr_.abort.
   * @private {boolean}
   */
  this.inAbort_ = false;

  /**
   * Number of milliseconds after which an incomplete request will be aborted
   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout
   * is set.
   * @private {number}
   */
  this.timeoutInterval_ = 0;

  /**
   * Timer to track request timeout.
   * @private {?number}
   */
  this.timeoutId_ = null;

  /**
   * The requested type for the response. The empty string means use the default
   * XHR behavior.
   * @private {goog.net.XhrIo.ResponseType}
   */
  this.responseType_ = ResponseType.DEFAULT;

  /**
   * Whether a "credentialed" request is to be sent (one that is aware of
   * cookies and authentication). This is applicable only for cross-domain
   * requests and more recent browsers that support this part of the HTTP Access
   * Control standard.
   *
   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute
   *
   * @private {boolean}
   */
  this.withCredentials_ = false;

  /**
   * Whether progress events are enabled for this request. This is
   * disabled by default because setting a progress event handler
   * causes pre-flight OPTIONS requests to be sent for CORS requests,
   * even in cases where a pre-flight request would not otherwise be
   * sent.
   *
   * @see http://xhr.spec.whatwg.org/#security-considerations
   *
   * Note that this can cause problems for Firefox 22 and below, as an
   * older "LSProgressEvent" will be dispatched by the browser. That
   * progress event is no longer supported, and can lead to failures,
   * including throwing exceptions.
   *
   * @see http://bugzilla.mozilla.org/show_bug.cgi?id=845631
   * @see b/23469793
   *
   * @private {boolean}
   */
  this.progressEventsEnabled_ = false;

  /**
   * True if we can use XMLHttpRequest's timeout directly.
   * @private {boolean}
   */
  this.useXhr2Timeout_ = false;

  /**
   * Specification for Trust Token operations (issuance, signing, and
   * redemption).
   * @private {?TrustTokenAttributeType}
   */
  this.trustToken_ = null;
};
goog.inherits(goog.net.XhrIo, goog.events.EventTarget);

const XhrIo = goog.net.XhrIo;

/**
 * Response types that may be requested for XMLHttpRequests.
 * @enum {string}
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute
 */
goog.net.XhrIo.ResponseType = {
  DEFAULT: '',
  TEXT: 'text',
  DOCUMENT: 'document',
  // Not supported as of Chrome 10.0.612.1 dev
  BLOB: 'blob',
  ARRAY_BUFFER: 'arraybuffer',
};

const ResponseType = goog.net.XhrIo.ResponseType;


/**
 * A reference to the XhrIo logger
 * @private {?goog.log.Logger}
 * @const
 */
goog.net.XhrIo.prototype.logger_ = goog.log.getLogger('goog.net.XhrIo');


/**
 * The Content-Type HTTP header name
 * @type {string}
 */
goog.net.XhrIo.CONTENT_TYPE_HEADER = 'Content-Type';


/**
 * The Content-Transfer-Encoding HTTP header name
 * @type {string}
 */
goog.net.XhrIo.CONTENT_TRANSFER_ENCODING = 'Content-Transfer-Encoding';


/**
 * The pattern matching the 'http' and 'https' URI schemes
 * @type {!RegExp}
 */
goog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;

const HTTP_SCHEME_PATTERN = goog.net.XhrIo.HTTP_SCHEME_PATTERN;


/**
 * The methods that typically come along with form data.  We set different
 * headers depending on whether the HTTP action is one of these.
 * @type {!Array<string>}
 */
goog.net.XhrIo.METHODS_WITH_FORM_DATA = ['POST', 'PUT'];


/**
 * The Content-Type HTTP header value for a url-encoded form
 * @type {string}
 */
goog.net.XhrIo.FORM_CONTENT_TYPE =
    'application/x-www-form-urlencoded;charset=utf-8';


/**
 * The XMLHttpRequest Level two timeout delay ms property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_TIMEOUT_ = 'timeout';


/**
 * The XMLHttpRequest Level two ontimeout handler property name.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 *
 * @private {string}
 * @const
 */
goog.net.XhrIo.XHR2_ON_TIMEOUT_ = 'ontimeout';


/**
 * All non-disposed instances of goog.net.XhrIo created
 * by {@link goog.net.XhrIo.send} are in this Array.
 * @see goog.net.XhrIo.cleanup
 * @private {!Array<!goog.net.XhrIo>}
 */
goog.net.XhrIo.sendInstances_ = [];


/**
 * Static send that creates a short lived instance of XhrIo to send the
 * request.
 * @see goog.net.XhrIo.cleanup
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {?function(this:goog.net.XhrIo, ?)=} opt_callback Callback function
 *     for when request is complete.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}
 *     opt_content Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 * @param {number=} opt_timeoutInterval Number of milliseconds after which an
 *     incomplete request will be aborted; 0 means no timeout is set.
 * @param {boolean=} opt_withCredentials Whether to send credentials with the
 *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.
 * @return {!goog.net.XhrIo} The sent XhrIo.
 */
goog.net.XhrIo.send = function(
    url, opt_callback, opt_method, opt_content, opt_headers,
    opt_timeoutInterval, opt_withCredentials) {
  'use strict';
  const x = new goog.net.XhrIo();
  goog.net.XhrIo.sendInstances_.push(x);
  if (opt_callback) {
    x.listen(goog.net.EventType.COMPLETE, opt_callback);
  }
  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);
  if (opt_timeoutInterval) {
    x.setTimeoutInterval(opt_timeoutInterval);
  }
  if (opt_withCredentials) {
    x.setWithCredentials(opt_withCredentials);
  }
  x.send(url, opt_method, opt_content, opt_headers);
  return x;
};


/**
 * Disposes all non-disposed instances of goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send}.
 * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance
 * it creates when the request completes or fails.  However, if
 * the request never completes, then the goog.net.XhrIo is not disposed.
 * This can occur if the window is unloaded before the request completes.
 * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo
 * it creates and make the client of {@link goog.net.XhrIo.send} be
 * responsible for disposing it in this case.  However, this makes things
 * significantly more complicated for the client, and the whole point
 * of {@link goog.net.XhrIo.send} is that it's simple and easy to use.
 * Clients of {@link goog.net.XhrIo.send} should call
 * {@link goog.net.XhrIo.cleanup} when doing final
 * cleanup on window unload.
 */
goog.net.XhrIo.cleanup = function() {
  'use strict';
  const instances = goog.net.XhrIo.sendInstances_;
  while (instances.length) {
    instances.pop().dispose();
  }
};


/**
 * Installs exception protection for all entry point introduced by
 * goog.net.XhrIo instances which are not protected by
 * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},
 * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or
 * {@link goog.events.protectBrowserEventEntryPoint}.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point(s).
 */
goog.net.XhrIo.protectEntryPoints = function(errorHandler) {
  'use strict';
  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
      errorHandler.protectEntryPoint(
          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
};


/**
 * Disposes of the specified goog.net.XhrIo created by
 * {@link goog.net.XhrIo.send} and removes it from
 * {@link goog.net.XhrIo.pendingStaticSendInstances_}.
 * @private
 */
goog.net.XhrIo.prototype.cleanupSend_ = function() {
  'use strict';
  this.dispose();
  goog.array.remove(goog.net.XhrIo.sendInstances_, this);
};


/**
 * Returns the number of milliseconds after which an incomplete request will be
 * aborted, or 0 if no timeout is set.
 * @return {number} Timeout interval in milliseconds.
 */
goog.net.XhrIo.prototype.getTimeoutInterval = function() {
  'use strict';
  return this.timeoutInterval_;
};


/**
 * Sets the number of milliseconds after which an incomplete request will be
 * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no
 * timeout is set.
 * @param {number} ms Timeout interval in milliseconds; 0 means none.
 */
goog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {
  'use strict';
  this.timeoutInterval_ = Math.max(0, ms);
};


/**
 * Sets the desired type for the response. At time of writing, this is only
 * supported in very recent versions of WebKit (10.0.612.1 dev and later).
 *
 * If this is used, the response may only be accessed via {@link #getResponse}.
 *
 * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.
 */
goog.net.XhrIo.prototype.setResponseType = function(type) {
  'use strict';
  this.responseType_ = type;
};


/**
 * Gets the desired type for the response.
 * @return {goog.net.XhrIo.ResponseType} The desired type for the response.
 */
goog.net.XhrIo.prototype.getResponseType = function() {
  'use strict';
  return this.responseType_;
};


/**
 * Sets whether a "credentialed" request that is aware of cookie and
 * authentication information should be made. This option is only supported by
 * browsers that support HTTP Access Control. As of this writing, this option
 * is not supported in IE.
 *
 * @param {boolean} withCredentials Whether this should be a "credentialed"
 *     request.
 */
goog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {
  'use strict';
  this.withCredentials_ = withCredentials;
};


/**
 * Gets whether a "credentialed" request is to be sent.
 * @return {boolean} The desired type for the response.
 */
goog.net.XhrIo.prototype.getWithCredentials = function() {
  'use strict';
  return this.withCredentials_;
};


/**
 * Sets whether progress events are enabled for this request. Note
 * that progress events require pre-flight OPTIONS request handling
 * for CORS requests, and may cause trouble with older browsers. See
 * progressEventsEnabled_ for details.
 * @param {boolean} enabled Whether progress events should be enabled.
 */
goog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {
  'use strict';
  this.progressEventsEnabled_ = enabled;
};


/**
 * Gets whether progress events are enabled.
 * @return {boolean} Whether progress events are enabled for this request.
 */
goog.net.XhrIo.prototype.getProgressEventsEnabled = function() {
  'use strict';
  return this.progressEventsEnabled_;
};

/**
 * Specify a Trust Tokens operation to execute alongside the request.
 * @param {!TrustTokenAttributeType} trustToken a Trust Tokens operation to
 *     execute.
 */
goog.net.XhrIo.prototype.setTrustToken = function(trustToken) {
  'use strict';
  this.trustToken_ = trustToken;
};

/**
 * Instance send that actually uses XMLHttpRequest to make a server call.
 * @param {string|goog.Uri} url Uri to make request to.
 * @param {string=} opt_method Send method, default: GET.
 * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}
 *     opt_content Body data.
 * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the
 *     request.
 * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different
 * types of parameters for opt_headers.
 */
goog.net.XhrIo.prototype.send = function(
    url, opt_method, opt_content, opt_headers) {
  'use strict';
  if (this.xhr_) {
    throw new Error(
        '[goog.net.XhrIo] Object is active with another request=' +
        this.lastUri_ + '; newUri=' + url);
  }

  const method = opt_method ? opt_method.toUpperCase() : 'GET';

  this.lastUri_ = url;
  this.lastError_ = '';
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;
  this.lastMethod_ = method;
  this.errorDispatched_ = false;
  this.active_ = true;

  // Use the factory to create the XHR object and options
  this.xhr_ = this.createXhr();
  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() :
                                            goog.net.XmlHttp.getOptions();

  // Set up the onreadystatechange callback
  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);

  // Set up upload/download progress events, if progress events are supported.
  if (this.getProgressEventsEnabled() && 'onprogress' in this.xhr_) {
    this.xhr_.onprogress = goog.bind(function(e) {
      'use strict';
      this.onProgressHandler_(e, true);
    }, this);
    if (this.xhr_.upload) {
      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);
    }
  }

  /**
   * Try to open the XMLHttpRequest (always async), if an error occurs here it
   * is generally permission denied
   */
  try {
    goog.log.fine(this.logger_, this.formatMsg_('Opening Xhr'));
    this.inOpen_ = true;
    this.xhr_.open(method, String(url), true);  // Always async!
    this.inOpen_ = false;
  } catch (err) {
    goog.log.fine(
        this.logger_, this.formatMsg_('Error opening Xhr: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
    return;
  }

  // We can't use null since this won't allow requests with form data to have a
  // content length specified which will cause some proxies to return a 411
  // error.
  const content = opt_content || '';

  const headers = this.headers.clone();

  // Add headers specific to this request
  if (opt_headers) {
    goog.structs.forEach(opt_headers, function(value, key) {
      'use strict';
      headers.set(key, value);
    });
  }

  // Find whether a content type header is set, ignoring case.
  // HTTP header names are case-insensitive.  See:
  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
  const contentTypeKey = headers.getKeys().find(
      header => goog.string.caseInsensitiveEquals(
          goog.net.XhrIo.CONTENT_TYPE_HEADER, header));

  const contentIsFormData =
      (goog.global['FormData'] && (content instanceof goog.global['FormData']));
  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &&
      !contentTypeKey && !contentIsFormData) {
    // For requests typically with form data, default to the url-encoded form
    // content type unless this is a FormData request.  For FormData,
    // the browser will automatically add a multipart/form-data content type
    // with an appropriate multipart boundary.
    headers.set(
        goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);
  }

  // Add the headers to the Xhr object
  headers.forEach(function(value, key) {
    'use strict';
    this.xhr_.setRequestHeader(key, value);
  }, this);

  if (this.responseType_) {
    this.xhr_.responseType = this.responseType_;
  }
  // Set xhr_.withCredentials only when the value is different, or else in
  // synchronous XMLHtppRequest.open Firefox will throw an exception.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=736340
  if ('withCredentials' in this.xhr_ &&
      this.xhr_.withCredentials !== this.withCredentials_) {
    this.xhr_.withCredentials = this.withCredentials_;
  }

  if ('setTrustToken' in this.xhr_ && this.trustToken_) {
    try {
      this.xhr_.setTrustToken(this.trustToken_);
    } catch (err) {
      goog.log.fine(
          this.logger_, this.formatMsg_('Error SetTrustToken: ' + err.message));
    }
  }
  /**
   * Try to send the request, or other wise report an error (404 not found).
   */
  try {
    this.cleanUpTimeoutTimer_();  // Paranoid, should never be running.
    if (this.timeoutInterval_ > 0) {
      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);
      goog.log.fine(
          this.logger_,
          this.formatMsg_(
              'Will abort after ' + this.timeoutInterval_ +
              'ms if incomplete, xhr2 ' + this.useXhr2Timeout_));
      if (this.useXhr2Timeout_) {
        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;
        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =
            goog.bind(this.timeout_, this);
      } else {
        this.timeoutId_ =
            goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);
      }
    }
    goog.log.fine(this.logger_, this.formatMsg_('Sending request'));
    this.inSend_ = true;
    this.xhr_.send(content);
    this.inSend_ = false;

  } catch (err) {
    goog.log.fine(this.logger_, this.formatMsg_('Send error: ' + err.message));
    this.error_(goog.net.ErrorCode.EXCEPTION, err);
  }
};


/**
 * Determines if the argument is an XMLHttpRequest that supports the level 2
 * timeout value and event.
 *
 * Currently, FF 21.0 OS X has the fields but won't actually call the timeout
 * handler.  Perhaps the confusion in the bug referenced below hasn't
 * entirely been resolved.
 *
 * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816
 *
 * @param {!goog.net.XhrLike.OrNative} xhr The request.
 * @return {boolean} True if the request supports level 2 timeout.
 * @private
 */
goog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {
  'use strict';
  return goog.userAgent.IE && goog.userAgent.isVersionOrHigher(9) &&
      typeof xhr[goog.net.XhrIo.XHR2_TIMEOUT_] === 'number' &&
      xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_] !== undefined;
};


/**
 * Creates a new XHR object.
 * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.
 * @protected
 */
goog.net.XhrIo.prototype.createXhr = function() {
  'use strict';
  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() :
                                goog.net.XmlHttp();
};


/**
 * The request didn't complete after {@link goog.net.XhrIo#timeoutInterval_}
 * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts
 * the request.
 * @private
 */
goog.net.XhrIo.prototype.timeout_ = function() {
  'use strict';
  if (typeof goog == 'undefined') {
    // If goog is undefined then the callback has occurred as the application
    // is unloading and will error.  Thus we let it silently fail.
  } else if (this.xhr_) {
    this.lastError_ =
        'Timed out after ' + this.timeoutInterval_ + 'ms, aborting';
    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;
    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));
    this.dispatchEvent(goog.net.EventType.TIMEOUT);
    this.abort(goog.net.ErrorCode.TIMEOUT);
  }
};


/**
 * Something errorred, so inactivate, fire error callback and clean up
 * @param {goog.net.ErrorCode} errorCode The error code.
 * @param {Error} err The error object.
 * @private
 */
goog.net.XhrIo.prototype.error_ = function(errorCode, err) {
  'use strict';
  this.active_ = false;
  if (this.xhr_) {
    this.inAbort_ = true;
    this.xhr_.abort();  // Ensures XHR isn't hung (FF)
    this.inAbort_ = false;
  }
  this.lastError_ = err;
  this.lastErrorCode_ = errorCode;
  this.dispatchErrors_();
  this.cleanUpXhr_();
};


/**
 * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do
 * not dispatch multiple error events.
 * @private
 */
goog.net.XhrIo.prototype.dispatchErrors_ = function() {
  'use strict';
  if (!this.errorDispatched_) {
    this.errorDispatched_ = true;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ERROR);
  }
};


/**
 * Abort the current XMLHttpRequest
 * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -
 *     defaults to ABORT.
 */
goog.net.XhrIo.prototype.abort = function(opt_failureCode) {
  'use strict';
  if (this.xhr_ && this.active_) {
    goog.log.fine(this.logger_, this.formatMsg_('Aborting'));
    this.active_ = false;
    this.inAbort_ = true;
    this.xhr_.abort();
    this.inAbort_ = false;
    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;
    this.dispatchEvent(goog.net.EventType.COMPLETE);
    this.dispatchEvent(goog.net.EventType.ABORT);
    this.cleanUpXhr_();
  }
};


/**
 * Nullifies all callbacks to reduce risks of leaks.
 * @override
 * @protected
 */
goog.net.XhrIo.prototype.disposeInternal = function() {
  'use strict';
  if (this.xhr_) {
    // We explicitly do not call xhr_.abort() unless active_ is still true.
    // This is to avoid unnecessarily aborting a successful request when
    // dispose() is called in a callback triggered by a complete response, but
    // in which browser cleanup has not yet finished.
    // (See http://b/issue?id=1684217.)
    if (this.active_) {
      this.active_ = false;
      this.inAbort_ = true;
      this.xhr_.abort();
      this.inAbort_ = false;
    }
    this.cleanUpXhr_(true);
  }

  XhrIo.base(this, 'disposeInternal');
};


/**
 * Internal handler for the XHR object's readystatechange event.  This method
 * checks the status and the readystate and fires the correct callbacks.
 * If the request has ended, the handlers are cleaned up and the XHR object is
 * nullified.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChange_ = function() {
  'use strict';
  if (this.isDisposed()) {
    // This method is the target of an untracked goog.Timer.callOnce().
    return;
  }
  if (!this.inOpen_ && !this.inSend_ && !this.inAbort_) {
    // Were not being called from within a call to this.xhr_.send
    // this.xhr_.abort, or this.xhr_.open, so this is an entry point
    this.onReadyStateChangeEntryPoint_();
  } else {
    this.onReadyStateChangeHelper_();
  }
};


/**
 * Used to protect the onreadystatechange handler entry point.  Necessary
 * as {#onReadyStateChange_} maybe called from within send or abort, this
 * method is only called when {#onReadyStateChange_} is called as an
 * entry point.
 * {@see #protectEntryPoints}
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {
  'use strict';
  this.onReadyStateChangeHelper_();
};


/**
 * Helper for {@link #onReadyStateChange_}.  This is used so that
 * entry point calls to {@link #onReadyStateChange_} can be routed through
 * {@link #onReadyStateChangeEntryPoint_}.
 * @private
 */
goog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {
  'use strict';
  if (!this.active_) {
    // can get called inside abort call
    return;
  }

  if (typeof goog == 'undefined') {
    // NOTE(pupius): If goog is undefined then the callback has occurred as the
    // application is unloading and will error.  Thus we let it silently fail.

  } else if (
      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &&
      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &&
      this.getStatus() == 2) {
    // NOTE(pupius): In IE if send() errors on a *local* request the readystate
    // is still changed to COMPLETE.  We need to ignore it and allow the
    // try/catch around send() to pick up the error.
    goog.log.fine(
        this.logger_,
        this.formatMsg_('Local request error detected and ignored'));

  } else {
    // In IE when the response has been cached we sometimes get the callback
    // from inside the send call and this usually breaks code that assumes that
    // XhrIo is asynchronous.  If that is the case we delay the callback
    // using a timer.
    if (this.inSend_ &&
        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {
      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);
      return;
    }

    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);

    // readyState indicates the transfer has finished
    if (this.isComplete()) {
      goog.log.fine(this.logger_, this.formatMsg_('Request complete'));

      this.active_ = false;

      try {
        // Call the specific callbacks for success or failure. Only call the
        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)
        if (this.isSuccess()) {
          this.dispatchEvent(goog.net.EventType.COMPLETE);
          this.dispatchEvent(goog.net.EventType.SUCCESS);
        } else {
          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;
          this.lastError_ =
              this.getStatusText() + ' [' + this.getStatus() + ']';
          this.dispatchErrors_();
        }
      } finally {
        this.cleanUpXhr_();
      }
    }
  }
};


/**
 * Internal handler for the XHR object's onprogress event. Fires both a generic
 * PROGRESS event and either a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event to
 * allow specific binding for each XHR progress event.
 * @param {!ProgressEvent} e XHR progress event.
 * @param {boolean=} opt_isDownload Whether the current progress event is from a
 *     download. Used to determine whether DOWNLOAD_PROGRESS or UPLOAD_PROGRESS
 *     event should be dispatched.
 * @private
 */
goog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {
  'use strict';
  goog.asserts.assert(
      e.type === goog.net.EventType.PROGRESS,
      'goog.net.EventType.PROGRESS is of the same type as raw XHR progress.');
  this.dispatchEvent(
      goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));
  this.dispatchEvent(goog.net.XhrIo.buildProgressEvent_(
      e,
      opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS :
                       goog.net.EventType.UPLOAD_PROGRESS));
};


/**
 * Creates a representation of the native ProgressEvent. IE doesn't support
 * constructing ProgressEvent via "new", and the alternatives (e.g.,
 * ProgressEvent.initProgressEvent) are non-standard or deprecated.
 * @param {!ProgressEvent} e XHR progress event.
 * @param {!goog.net.EventType} eventType The type of the event.
 * @return {!ProgressEvent} The progress event.
 * @private
 */
goog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {
  'use strict';
  return /** @type {!ProgressEvent} */ ({
    type: eventType,
    lengthComputable: e.lengthComputable,
    loaded: e.loaded,
    total: e.total,
  });
};


/**
 * Remove the listener to protect against leaks, and nullify the XMLHttpRequest
 * object.
 * @param {boolean=} opt_fromDispose If this is from the dispose (don't want to
 *     fire any events).
 * @private
 */
goog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {
  'use strict';
  if (this.xhr_) {
    // Cancel any pending timeout event handler.
    this.cleanUpTimeoutTimer_();

    // Save reference so we can mark it as closed after the READY event.  The
    // READY event may trigger another request, thus we must nullify this.xhr_
    const xhr = this.xhr_;
    const clearedOnReadyStateChange =
        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?
        goog.nullFunction :
        null;
    this.xhr_ = null;
    this.xhrOptions_ = null;

    if (!opt_fromDispose) {
      this.dispatchEvent(goog.net.EventType.READY);
    }

    try {
      // NOTE(pupius): Not nullifying in FireFox can still leak if the callbacks
      // are defined in the same scope as the instance of XhrIo. But, IE doesn't
      // allow you to set the onreadystatechange to NULL so nullFunction is
      // used.
      xhr.onreadystatechange = clearedOnReadyStateChange;
    } catch (e) {
      // This seems to occur with a Gears HTTP request. Delayed the setting of
      // this onreadystatechange until after READY is sent out and catching the
      // error to see if we can track down the problem.
      goog.log.error(
          this.logger_,
          'Problem encountered resetting onreadystatechange: ' + e.message);
    }
  }
};


/**
 * Make sure the timeout timer isn't running.
 * @private
 */
goog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {
  'use strict';
  if (this.xhr_ && this.useXhr2Timeout_) {
    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;
  }
  if (this.timeoutId_) {
    goog.Timer.clear(this.timeoutId_);
    this.timeoutId_ = null;
  }
};


/**
 * @return {boolean} Whether there is an active request.
 */
goog.net.XhrIo.prototype.isActive = function() {
  'use strict';
  return !!this.xhr_;
};


/**
 * @return {boolean} Whether the request has completed.
 */
goog.net.XhrIo.prototype.isComplete = function() {
  'use strict';
  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;
};


/**
 * @return {boolean} Whether the request completed with a success.
 */
goog.net.XhrIo.prototype.isSuccess = function() {
  'use strict';
  const status = this.getStatus();
  // A zero status code is considered successful for local files.
  return goog.net.HttpStatus.isSuccess(status) ||
      status === 0 && !this.isLastUriEffectiveSchemeHttp_();
};


/**
 * @return {boolean} whether the effective scheme of the last URI that was
 *     fetched was 'http' or 'https'.
 * @private
 */
goog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {
  'use strict';
  const scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));
  return HTTP_SCHEME_PATTERN.test(scheme);
};


/**
 * Get the readystate from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.
 */
goog.net.XhrIo.prototype.getReadyState = function() {
  'use strict';
  return this.xhr_ ?
      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :
      goog.net.XmlHttp.ReadyState.UNINITIALIZED;
};


/**
 * Get the status from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {number} Http status.
 */
goog.net.XhrIo.prototype.getStatus = function() {
  'use strict';
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is receiving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.status :
        -1;
  } catch (e) {
    return -1;
  }
};


/**
 * Get the status text from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @return {string} Status text.
 */
goog.net.XhrIo.prototype.getStatusText = function() {
  'use strict';
  /**
   * IE doesn't like you checking status until the readystate is greater than 2
   * (i.e. it is receiving or complete).  The try/catch is used for when the
   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.
   */
  try {
    return this.getReadyState() > goog.net.XmlHttp.ReadyState.LOADED ?
        this.xhr_.statusText :
        '';
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get status: ' + e.message);
    return '';
  }
};


/**
 * Get the last Uri that was requested
 * @return {string} Last Uri.
 */
goog.net.XhrIo.prototype.getLastUri = function() {
  'use strict';
  return String(this.lastUri_);
};


/**
 * Get the response text from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {string} Result from the server, or '' if no result available.
 */
goog.net.XhrIo.prototype.getResponseText = function() {
  'use strict';
  try {
    return this.xhr_ ? this.xhr_.responseText : '';
  } catch (e) {
    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute
    // states that responseText should return '' (and responseXML null)
    // when the state is not LOADING or DONE. Instead, IE can
    // throw unexpected exceptions, for example when a request is aborted
    // or no data is available yet.
    goog.log.fine(this.logger_, 'Can not get responseText: ' + e.message);
    return '';
  }
};


/**
 * Get the response body from the Xhr object. This property is only available
 * in IE since version 7 according to MSDN:
 * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx
 * Will only return correct result when called from the context of a callback.
 *
 * One option is to construct a VBArray from the returned object and convert
 * it to a JavaScript array using the toArray method:
 * `(new window['VBArray'](xhrIo.getResponseBody())).toArray()`
 * This will result in an array of numbers in the range of [0..255]
 *
 * Another option is to use the VBScript CStr method to convert it into a
 * string as outlined in http://stackoverflow.com/questions/1919972
 *
 * @return {Object} Binary result from the server or null if not available.
 */
goog.net.XhrIo.prototype.getResponseBody = function() {
  'use strict';
  try {
    if (this.xhr_ && 'responseBody' in this.xhr_) {
      return this.xhr_['responseBody'];
    }
  } catch (e) {
    // IE can throw unexpected exceptions, for example when a request is aborted
    // or no data is yet available.
    goog.log.fine(this.logger_, 'Can not get responseBody: ' + e.message);
  }
  return null;
};


/**
 * Get the response XML from the Xhr object
 * Will only return correct result when called from the context of a callback.
 * @return {Document} The DOM Document representing the XML file, or null
 * if no result available.
 */
goog.net.XhrIo.prototype.getResponseXml = function() {
  'use strict';
  try {
    return this.xhr_ ? this.xhr_.responseXML : null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get responseXML: ' + e.message);
    return null;
  }
};


/**
 * Get the response and evaluates it as JSON from the Xhr object
 * Will only return correct result when called from the context of a callback
 * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for
 *     stripping of the response before parsing. This needs to be set only if
 *     your backend server prepends the same prefix string to the JSON response.
 * @throws Error if the response text is invalid JSON.
 * @return {Object|undefined} JavaScript object.
 */
goog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {
  'use strict';
  if (!this.xhr_) {
    return undefined;
  }

  let responseText = this.xhr_.responseText;
  if (opt_xssiPrefix && responseText.indexOf(opt_xssiPrefix) == 0) {
    responseText = responseText.substring(opt_xssiPrefix.length);
  }

  return goog.json.hybrid.parse(responseText);
};


/**
 * Get the response as the type specificed by {@link #setResponseType}. At time
 * of writing, this is only directly supported in very recent versions of WebKit
 * (10.0.612.1 dev and later). If the field is not supported directly, we will
 * try to emulate it.
 *
 * Emulating the response means following the rules laid out at
 * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute
 *
 * On browsers with no support for this (Chrome < 10, Firefox < 4, etc), only
 * response types of DEFAULT or TEXT may be used, and the response returned will
 * be the text response.
 *
 * On browsers with Mozilla's draft support for array buffers (Firefox 4, 5),
 * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the
 * response returned will be either the text response or the Mozilla
 * implementation of the array buffer response.
 *
 * On browsers will full support, any valid response type supported by the
 * browser may be used, and the response provided by the browser will be
 * returned.
 *
 * @return {*} The response.
 */
goog.net.XhrIo.prototype.getResponse = function() {
  'use strict';
  try {
    if (!this.xhr_) {
      return null;
    }
    if ('response' in this.xhr_) {
      return this.xhr_.response;
    }
    switch (this.responseType_) {
      case ResponseType.DEFAULT:
      case ResponseType.TEXT:
        return this.xhr_.responseText;
      // DOCUMENT and BLOB don't need to be handled here because they are
      // introduced in the same spec that adds the .response field, and would
      // have been caught above.
      // ARRAY_BUFFER needs an implementation for Firefox 4, where it was
      // implemented using a draft spec rather than the final spec.
      case ResponseType.ARRAY_BUFFER:
        if ('mozResponseArrayBuffer' in this.xhr_) {
          return this.xhr_.mozResponseArrayBuffer;
        }
    }
    // Fell through to a response type that is not supported on this browser.
    goog.log.error(
        this.logger_,
        'Response type ' + this.responseType_ + ' is not ' +
            'supported on this browser');
    return null;
  } catch (e) {
    goog.log.fine(this.logger_, 'Can not get response: ' + e.message);
    return null;
  }
};


/**
 * Get the value of the response-header with the given name from the Xhr object
 * Will only return correct result when called from the context of a callback
 * and the request has completed
 * @param {string} key The name of the response-header to retrieve.
 * @return {string|undefined} The value of the response-header named key.
 */
goog.net.XhrIo.prototype.getResponseHeader = function(key) {
  'use strict';
  if (!this.xhr_ || !this.isComplete()) {
    return undefined;
  }

  const value = this.xhr_.getResponseHeader(key);
  return value === null ? undefined : value;
};


/**
 * Gets the text of all the headers in the response.
 * Will only return correct result when called from the context of a callback
 * and the request has completed.
 * @return {string} The value of the response headers or empty string.
 */
goog.net.XhrIo.prototype.getAllResponseHeaders = function() {
  'use strict';
  // getAllResponseHeaders can return null if no response has been received,
  // ensure we always return an empty string.
  return this.xhr_ && this.isComplete() ?
      (this.xhr_.getAllResponseHeaders() || '') :
      '';
};


/**
 * Returns all response headers as a key-value map.
 * Multiple values for the same header key can be combined into one,
 * separated by a comma and a space.
 * Note that the native getResponseHeader method for retrieving a single header
 * does a case insensitive match on the header name. This method does not
 * include any case normalization logic, it will just return a key-value
 * representation of the headers.
 * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
 * @return {!Object<string, string>} An object with the header keys as keys
 *     and header values as values.
 */
goog.net.XhrIo.prototype.getResponseHeaders = function() {
  'use strict';
  // TODO(b/120371595): Make this function parse headers as per the spec
  // (https://tools.ietf.org/html/rfc2616#section-4.2).

  const headersObject = {};
  const headersArray = this.getAllResponseHeaders().split('\r\n');
  for (let i = 0; i < headersArray.length; i++) {
    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {
      continue;
    }
    const keyValue =
        goog.string.splitLimit(headersArray[i], ':', /* maxSplitCount= */ 1);
    const key = keyValue[0];
    let value = keyValue[1];

    if (typeof value !== 'string') {
      // There must be a value but it can be the empty string.
      continue;
    }

    // Whitespace at the start and end of the value is meaningless.
    value = value.trim();
    // The key should not contain whitespace but we currently ignore that.

    const values = headersObject[key] || [];
    headersObject[key] = values;
    values.push(value);
  }

  return goog.object.map(headersObject, function(values) {
    'use strict';
    return values.join(', ');
  });
};


/**
 * Get the value of the response-header with the given name from the Xhr object.
 * As opposed to {@link #getResponseHeader}, this method does not require that
 * the request has completed.
 * @param {string} key The name of the response-header to retrieve.
 * @return {?string} The value of the response-header, or null if it is
 *     unavailable.
 */
goog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {
  'use strict';
  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;
};


/**
 * Gets the text of all the headers in the response. As opposed to
 * {@link #getAllResponseHeaders}, this method does not require that the request
 * has completed.
 * @return {string} The value of the response headers or empty string.
 */
goog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {
  'use strict';
  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : '';
};


/**
 * Get the last error message
 * @return {!goog.net.ErrorCode} Last error code.
 */
goog.net.XhrIo.prototype.getLastErrorCode = function() {
  'use strict';
  return this.lastErrorCode_;
};


/**
 * Get the last error message
 * @return {string} Last error message.
 */
goog.net.XhrIo.prototype.getLastError = function() {
  'use strict';
  return typeof this.lastError_ === 'string' ? this.lastError_ :
                                               String(this.lastError_);
};


/**
 * Adds the last method, status and URI to the message.  This is used to add
 * this information to the logging calls.
 * @param {string} msg The message text that we want to add the extra text to.
 * @return {string} The message with the extra text appended.
 * @private
 */
goog.net.XhrIo.prototype.formatMsg_ = function(msg) {
  'use strict';
  return msg + ' [' + this.lastMethod_ + ' ' + this.lastUri_ + ' ' +
      this.getStatus() + ']';
};


// Register the xhr handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      'use strict';
      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =
          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);
    });
});  // goog.scope

//third_party/javascript/closure/string/stringformat.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Implementation of sprintf-like, python-%-operator-like,
 * .NET-String.Format-like functionality. Uses JS string's replace method to
 * extract format specifiers and sends those specifiers to a handler function,
 * which then, based on conversion type part of the specifier, calls the
 * appropriate function to handle the specific conversion.
 * For specific functionality implemented, look at formatRe below, or look
 * at the tests.
 */

goog.provide('goog.string.format');

goog.require('goog.string');


// TODO(johnlenz): goog.string.format should not accept undefined as a parameter
/**
 * Performs sprintf-like conversion, i.e. puts the values in a template.
 * DO NOT use it instead of built-in conversions in simple cases such as
 * 'Cost: %.2f' as it would introduce unnecessary latency opposed to
 * 'Cost: ' + cost.toFixed(2).
 * @param {string} formatString Template string containing % specifiers.
 * @param {...(string|number|undefined)} var_args Values formatString is to
 *     be filled with.
 * @return {string} Formatted string.
 */
goog.string.format = function(formatString, var_args) {
  'use strict';
  // Convert the arguments to an array (MDC recommended way).
  const args = Array.prototype.slice.call(arguments);

  // Try to get the template.
  const template = args.shift();
  if (typeof template == 'undefined') {
    throw new Error('[goog.string.format] Template required');
  }

  // This re is used for matching, it also defines what is supported.
  const formatRe = /%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g;

  /**
   * Chooses which conversion function to call based on type conversion
   * specifier.
   * @param {string} match Contains the re matched string.
   * @param {string} flags Formatting flags.
   * @param {string} width Replacement string minimum width.
   * @param {string} dotp Matched precision including a dot.
   * @param {string} precision Specifies floating point precision.
   * @param {string} type Type conversion specifier.
   * @param {string} offset Matching location in the original string.
   * @param {string} wholeString Has the actualString being searched.
   * @return {string} Formatted parameter.
   */
  function replacerDemuxer(
      match, flags, width, dotp, precision, type, offset, wholeString) {
    // The % is too simple and doesn't take an argument.
    if (type == '%') {
      return '%';
    }

    // Try to get the actual value from parent function.
    const value = args.shift();

    // If we didn't get any arguments, fail.
    if (typeof value == 'undefined') {
      throw new Error('[goog.string.format] Not enough arguments');
    }

    // Patch the value argument to the beginning of our type specific call.
    arguments[0] = value;

    return goog.string.format.demuxes_[type].apply(null, arguments);
  }

  return template.replace(formatRe, replacerDemuxer);
};


/**
 * Contains various conversion functions (to be filled in later on).
 * @private {!Object}
 */
goog.string.format.demuxes_ = {};


/**
 * Processes %s conversion specifier.
 * @param {string} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['s'] = function(
    value, flags, width, dotp, precision, type, offset, wholeString) {
  'use strict';
  let replacement = value;
  // If no padding is necessary we're done.
  // The check for '' is necessary because Firefox incorrectly provides the
  // empty string instead of undefined for non-participating capture groups,
  // and isNaN('') == false.
  if (isNaN(width) || width == '' || replacement.length >= Number(width)) {
    return replacement;
  }

  // Otherwise we should find out where to put spaces.
  if (flags.indexOf('-', 0) > -1) {
    replacement = replacement +
        goog.string.repeat(' ', Number(width) - replacement.length);
  } else {
    replacement = goog.string.repeat(' ', Number(width) - replacement.length) +
        replacement;
  }
  return replacement;
};


/**
 * Processes %f conversion specifier.
 * @param {string} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['f'] = function(
    value, flags, width, dotp, precision, type, offset, wholeString) {
  'use strict';
  let replacement = value.toString();

  // The check for '' is necessary because Firefox incorrectly provides the
  // empty string instead of undefined for non-participating capture groups,
  // and isNaN('') == false.
  if (!(isNaN(precision) || precision == '')) {
    replacement = parseFloat(value).toFixed(precision);
  }

  // Generates sign string that will be attached to the replacement.
  let sign;
  if (Number(value) < 0) {
    sign = '-';
  } else if (flags.indexOf('+') >= 0) {
    sign = '+';
  } else if (flags.indexOf(' ') >= 0) {
    sign = ' ';
  } else {
    sign = '';
  }

  if (Number(value) >= 0) {
    replacement = sign + replacement;
  }

  // If no padding is necessary we're done.
  if (isNaN(width) || replacement.length >= Number(width)) {
    return replacement;
  }

  // We need a clean signless replacement to start with
  replacement = isNaN(precision) ? Math.abs(Number(value)).toString() :
                                   Math.abs(Number(value)).toFixed(precision);

  const padCount = Number(width) - replacement.length - sign.length;

  // Find out which side to pad, and if it's left side, then which character to
  // pad, and set the sign on the left and padding in the middle.
  if (flags.indexOf('-', 0) >= 0) {
    replacement = sign + replacement + goog.string.repeat(' ', padCount);
  } else {
    // Decides which character to pad.
    const paddingChar = (flags.indexOf('0', 0) >= 0) ? '0' : ' ';
    replacement =
        sign + goog.string.repeat(paddingChar, padCount) + replacement;
  }

  return replacement;
};


/**
 * Processes %d conversion specifier.
 * @param {string} value Contains the formatRe matched string.
 * @param {string} flags Formatting flags.
 * @param {string} width Replacement string minimum width.
 * @param {string} dotp Matched precision including a dot.
 * @param {string} precision Specifies floating point precision.
 * @param {string} type Type conversion specifier.
 * @param {string} offset Matching location in the original string.
 * @param {string} wholeString Has the actualString being searched.
 * @return {string} Replacement string.
 */
goog.string.format.demuxes_['d'] = function(
    value, flags, width, dotp, precision, type, offset, wholeString) {
  'use strict';
  return goog.string.format.demuxes_['f'](
      parseInt(value, 10) /* value */, flags, width, dotp, 0 /* precision */,
      type, offset, wholeString);
};


// These are additional aliases, for integer conversion.
goog.string.format.demuxes_['i'] = goog.string.format.demuxes_['d'];
goog.string.format.demuxes_['u'] = goog.string.format.demuxes_['d'];

//third_party/javascript/closure/uri/uri.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Class for parsing and formatting URIs.
 *
 * This package is deprecated in favour of the Closure URL package (goog.url)
 * when manipulating URIs for use by a browser. This package uses regular
 * expressions to parse a potential URI which can fall out of sync with how a
 * browser will actually interpret the URI. See
 * `goog.uri.utils.setUrlPackageSupportLoggingHandler` for one way to identify
 * URIs that should instead be parsed using the URL package.
 *
 * Use goog.Uri(string) to parse a URI string.  Use goog.Uri.create(...) to
 * create a new instance of the goog.Uri object from Uri parts.
 *
 * e.g: <code>var myUri = new goog.Uri(window.location);</code>
 *
 * Implements RFC 3986 for parsing/formatting URIs.
 * http://www.ietf.org/rfc/rfc3986.txt
 *
 * Some changes have been made to the interface (more like .NETs), though the
 * internal representation is now of un-encoded parts, this will change the
 * behavior slightly.
 */

goog.provide('goog.Uri');
goog.provide('goog.Uri.QueryData');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.string');
goog.require('goog.structs');
goog.require('goog.structs.Map');
goog.require('goog.uri.utils');
goog.require('goog.uri.utils.ComponentIndex');
goog.require('goog.uri.utils.StandardQueryParam');



/**
 * This class contains setters and getters for the parts of the URI.
 * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part
 * -- so<code>goog.Uri.parse('/foo%20bar').getPath()</code> will return the
 * decoded path, <code>/foo bar</code>.
 *
 * Reserved characters (see RFC 3986 section 2.2) can be present in
 * their percent-encoded form in scheme, domain, and path URI components and
 * will not be auto-decoded. For example:
 * <code>goog.Uri.parse('rel%61tive/path%2fto/resource').getPath()</code> will
 * return <code>relative/path%2fto/resource</code>.
 *
 * The constructor accepts an optional unparsed, raw URI string.  The parser
 * is relaxed, so special characters that aren't escaped but don't cause
 * ambiguities will not cause parse failures.
 *
 * All setters return <code>this</code> and so may be chained, a la
 * <code>goog.Uri.parse('/foo').setFragment('part').toString()</code>.
 *
 * @param {*=} opt_uri Optional string URI to parse
 *        (use goog.Uri.create() to create a URI from parts), or if
 *        a goog.Uri is passed, a clone is created.
 * @param {boolean=} opt_ignoreCase If true, #getParameterValue will ignore
 * the case of the parameter name.
 *
 * @throws URIError If opt_uri is provided and URI is malformed (that is,
 *     if decodeURIComponent fails on any of the URI components).
 * @constructor
 * @struct
 */
goog.Uri = function(opt_uri, opt_ignoreCase) {
  'use strict';
  /**
   * Scheme such as "http".
   * @private {string}
   */
  this.scheme_ = '';

  /**
   * User credentials in the form "username:password".
   * @private {string}
   */
  this.userInfo_ = '';

  /**
   * Domain part, e.g. "www.google.com".
   * @private {string}
   */
  this.domain_ = '';

  /**
   * Port, e.g. 8080.
   * @private {?number}
   */
  this.port_ = null;

  /**
   * Path, e.g. "/tests/img.png".
   * @private {string}
   */
  this.path_ = '';

  /**
   * The fragment without the #.
   * @private {string}
   */
  this.fragment_ = '';

  /**
   * Whether or not this Uri should be treated as Read Only.
   * @private {boolean}
   */
  this.isReadOnly_ = false;

  /**
   * Whether or not to ignore case when comparing query params.
   * @private {boolean}
   */
  this.ignoreCase_ = false;

  /**
   * Object representing query data.
   * @private {!goog.Uri.QueryData}
   */
  this.queryData_;

  // Parse in the uri string
  var m;
  if (opt_uri instanceof goog.Uri) {
    this.ignoreCase_ = (opt_ignoreCase !== undefined) ? opt_ignoreCase :
                                                        opt_uri.getIgnoreCase();
    this.setScheme(opt_uri.getScheme());
    this.setUserInfo(opt_uri.getUserInfo());
    this.setDomain(opt_uri.getDomain());
    this.setPort(opt_uri.getPort());
    this.setPath(opt_uri.getPath());
    this.setQueryData(opt_uri.getQueryData().clone());
    this.setFragment(opt_uri.getFragment());
  } else if (opt_uri && (m = goog.uri.utils.split(String(opt_uri)))) {
    this.ignoreCase_ = !!opt_ignoreCase;

    // Set the parts -- decoding as we do so.
    // COMPATIBILITY NOTE - In IE, unmatched fields may be empty strings,
    // whereas in other browsers they will be undefined.
    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);
    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);
    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);
    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);
    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);
    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);
    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);

  } else {
    this.ignoreCase_ = !!opt_ignoreCase;
    this.queryData_ = new goog.Uri.QueryData(null, this.ignoreCase_);
  }
};


/**
 * Parameter name added to stop caching.
 * @type {string}
 */
goog.Uri.RANDOM_PARAM = goog.uri.utils.StandardQueryParam.RANDOM;


/**
 * @return {string} The string form of the url.
 * @override
 */
goog.Uri.prototype.toString = function() {
  'use strict';
  var out = [];

  var scheme = this.getScheme();
  if (scheme) {
    out.push(
        goog.Uri.encodeSpecialChars_(
            scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true),
        ':');
  }

  var domain = this.getDomain();
  if (domain || scheme == 'file') {
    out.push('//');

    var userInfo = this.getUserInfo();
    if (userInfo) {
      out.push(
          goog.Uri.encodeSpecialChars_(
              userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true),
          '@');
    }

    out.push(goog.Uri.removeDoubleEncoding_(goog.string.urlEncode(domain)));

    var port = this.getPort();
    if (port != null) {
      out.push(':', String(port));
    }
  }

  var path = this.getPath();
  if (path) {
    if (this.hasDomain() && path.charAt(0) != '/') {
      out.push('/');
    }
    out.push(goog.Uri.encodeSpecialChars_(
        path,
        path.charAt(0) == '/' ? goog.Uri.reDisallowedInAbsolutePath_ :
                                goog.Uri.reDisallowedInRelativePath_,
        true));
  }

  var query = this.getEncodedQuery();
  if (query) {
    out.push('?', query);
  }

  var fragment = this.getFragment();
  if (fragment) {
    out.push(
        '#',
        goog.Uri.encodeSpecialChars_(
            fragment, goog.Uri.reDisallowedInFragment_));
  }
  return out.join('');
};


/**
 * Resolves the given relative URI (a goog.Uri object), using the URI
 * represented by this instance as the base URI.
 *
 * There are several kinds of relative URIs:<br>
 * 1. foo - replaces the last part of the path, the whole query and fragment<br>
 * 2. /foo - replaces the path, the query and fragment<br>
 * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>
 * 4. ?foo - replace the query and fragment<br>
 * 5. #foo - replace the fragment only
 *
 * Additionally, if relative URI has a non-empty path, all ".." and "."
 * segments will be resolved, as described in RFC 3986.
 *
 * @param {!goog.Uri} relativeUri The relative URI to resolve.
 * @return {!goog.Uri} The resolved URI.
 */
goog.Uri.prototype.resolve = function(relativeUri) {
  'use strict';
  var absoluteUri = this.clone();

  // we satisfy these conditions by looking for the first part of relativeUri
  // that is not blank and applying defaults to the rest

  var overridden = relativeUri.hasScheme();

  if (overridden) {
    absoluteUri.setScheme(relativeUri.getScheme());
  } else {
    overridden = relativeUri.hasUserInfo();
  }

  if (overridden) {
    absoluteUri.setUserInfo(relativeUri.getUserInfo());
  } else {
    overridden = relativeUri.hasDomain();
  }

  if (overridden) {
    absoluteUri.setDomain(relativeUri.getDomain());
  } else {
    overridden = relativeUri.hasPort();
  }

  var path = relativeUri.getPath();
  if (overridden) {
    absoluteUri.setPort(relativeUri.getPort());
  } else {
    overridden = relativeUri.hasPath();
    if (overridden) {
      // resolve path properly
      if (path.charAt(0) != '/') {
        // path is relative
        if (this.hasDomain() && !this.hasPath()) {
          // RFC 3986, section 5.2.3, case 1
          path = '/' + path;
        } else {
          // RFC 3986, section 5.2.3, case 2
          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');
          if (lastSlashIndex != -1) {
            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;
          }
        }
      }
      path = goog.Uri.removeDotSegments(path);
    }
  }

  if (overridden) {
    absoluteUri.setPath(path);
  } else {
    overridden = relativeUri.hasQuery();
  }

  if (overridden) {
    absoluteUri.setQueryData(relativeUri.getQueryData().clone());
  } else {
    overridden = relativeUri.hasFragment();
  }

  if (overridden) {
    absoluteUri.setFragment(relativeUri.getFragment());
  }

  return absoluteUri;
};


/**
 * Clones the URI instance.
 * @return {!goog.Uri} New instance of the URI object.
 */
goog.Uri.prototype.clone = function() {
  'use strict';
  return new goog.Uri(this);
};


/**
 * @return {string} The encoded scheme/protocol for the URI.
 */
goog.Uri.prototype.getScheme = function() {
  'use strict';
  return this.scheme_;
};


/**
 * Sets the scheme/protocol.
 * @throws URIError If opt_decode is true and newScheme is malformed (that is,
 *     if decodeURIComponent fails).
 * @param {string} newScheme New scheme value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setScheme = function(newScheme, opt_decode) {
  'use strict';
  this.enforceReadOnly();
  this.scheme_ =
      opt_decode ? goog.Uri.decodeOrEmpty_(newScheme, true) : newScheme;

  // remove an : at the end of the scheme so somebody can pass in
  // window.location.protocol
  if (this.scheme_) {
    this.scheme_ = this.scheme_.replace(/:$/, '');
  }
  return this;
};


/**
 * @return {boolean} Whether the scheme has been set.
 */
goog.Uri.prototype.hasScheme = function() {
  'use strict';
  return !!this.scheme_;
};


/**
 * @return {string} The decoded user info.
 */
goog.Uri.prototype.getUserInfo = function() {
  'use strict';
  return this.userInfo_;
};


/**
 * Sets the userInfo.
 * @throws URIError If opt_decode is true and newUserInfo is malformed (that is,
 *     if decodeURIComponent fails).
 * @param {string} newUserInfo New userInfo value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setUserInfo = function(newUserInfo, opt_decode) {
  'use strict';
  this.enforceReadOnly();
  this.userInfo_ =
      opt_decode ? goog.Uri.decodeOrEmpty_(newUserInfo) : newUserInfo;
  return this;
};


/**
 * @return {boolean} Whether the user info has been set.
 */
goog.Uri.prototype.hasUserInfo = function() {
  'use strict';
  return !!this.userInfo_;
};


/**
 * @return {string} The decoded domain.
 */
goog.Uri.prototype.getDomain = function() {
  'use strict';
  return this.domain_;
};


/**
 * Sets the domain.
 * @throws URIError If opt_decode is true and newDomain is malformed (that is,
 *     if decodeURIComponent fails).
 * @param {string} newDomain New domain value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setDomain = function(newDomain, opt_decode) {
  'use strict';
  this.enforceReadOnly();
  this.domain_ =
      opt_decode ? goog.Uri.decodeOrEmpty_(newDomain, true) : newDomain;
  return this;
};


/**
 * @return {boolean} Whether the domain has been set.
 */
goog.Uri.prototype.hasDomain = function() {
  'use strict';
  return !!this.domain_;
};


/**
 * @return {?number} The port number.
 */
goog.Uri.prototype.getPort = function() {
  'use strict';
  return this.port_;
};


/**
 * Sets the port number.
 * @param {*} newPort Port number. Will be explicitly casted to a number.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPort = function(newPort) {
  'use strict';
  this.enforceReadOnly();

  if (newPort) {
    newPort = Number(newPort);
    if (isNaN(newPort) || newPort < 0) {
      throw new Error('Bad port number ' + newPort);
    }
    this.port_ = newPort;
  } else {
    this.port_ = null;
  }

  return this;
};


/**
 * @return {boolean} Whether the port has been set.
 */
goog.Uri.prototype.hasPort = function() {
  'use strict';
  return this.port_ != null;
};


/**
 * @return {string} The decoded path.
 */
goog.Uri.prototype.getPath = function() {
  'use strict';
  return this.path_;
};


/**
 * Sets the path.
 * @throws URIError If opt_decode is true and newPath is malformed (that is,
 *     if decodeURIComponent fails).
 * @param {string} newPath New path value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setPath = function(newPath, opt_decode) {
  'use strict';
  this.enforceReadOnly();
  this.path_ = opt_decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;
  return this;
};


/**
 * @return {boolean} Whether the path has been set.
 */
goog.Uri.prototype.hasPath = function() {
  'use strict';
  return !!this.path_;
};


/**
 * @return {boolean} Whether the query string has been set.
 */
goog.Uri.prototype.hasQuery = function() {
  'use strict';
  return this.queryData_.toString() !== '';
};


/**
 * Sets the query data.
 * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 *     Applies only if queryData is a string.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQueryData = function(queryData, opt_decode) {
  'use strict';
  this.enforceReadOnly();

  if (queryData instanceof goog.Uri.QueryData) {
    this.queryData_ = queryData;
    this.queryData_.setIgnoreCase(this.ignoreCase_);
  } else {
    if (!opt_decode) {
      // QueryData accepts encoded query string, so encode it if
      // opt_decode flag is not true.
      queryData = goog.Uri.encodeSpecialChars_(
          queryData, goog.Uri.reDisallowedInQuery_);
    }
    this.queryData_ = new goog.Uri.QueryData(queryData, this.ignoreCase_);
  }

  return this;
};


/**
 * Sets the URI query.
 * @param {string} newQuery New query value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setQuery = function(newQuery, opt_decode) {
  'use strict';
  return this.setQueryData(newQuery, opt_decode);
};


/**
 * @return {string} The encoded URI query, not including the ?.
 */
goog.Uri.prototype.getEncodedQuery = function() {
  'use strict';
  return this.queryData_.toString();
};


/**
 * @return {string} The decoded URI query, not including the ?.
 */
goog.Uri.prototype.getDecodedQuery = function() {
  'use strict';
  return this.queryData_.toDecodedString();
};


/**
 * Returns the query data.
 * @return {!goog.Uri.QueryData} QueryData object.
 */
goog.Uri.prototype.getQueryData = function() {
  'use strict';
  return this.queryData_;
};


/**
 * @return {string} The encoded URI query, not including the ?.
 *
 * Warning: This method, unlike other getter methods, returns encoded
 * value, instead of decoded one.
 */
goog.Uri.prototype.getQuery = function() {
  'use strict';
  return this.getEncodedQuery();
};


/**
 * Sets the value of the named query parameters, clearing previous values for
 * that key.
 *
 * @param {string} key The parameter to set.
 * @param {*} value The new value. Value does not need to be encoded.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValue = function(key, value) {
  'use strict';
  this.enforceReadOnly();
  this.queryData_.set(key, value);
  return this;
};


/**
 * Sets the values of the named query parameters, clearing previous values for
 * that key.  Not new values will currently be moved to the end of the query
 * string.
 *
 * So, <code>goog.Uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])
 * </code> yields <tt>foo?a=b&e=f&c=new</tt>.</p>
 *
 * @param {string} key The parameter to set.
 * @param {*} values The new values. If values is a single
 *     string then it will be treated as the sole value. Values do not need to
 *     be encoded.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setParameterValues = function(key, values) {
  'use strict';
  this.enforceReadOnly();

  if (!Array.isArray(values)) {
    values = [String(values)];
  }

  this.queryData_.setValues(key, values);

  return this;
};


/**
 * Returns the value<b>s</b> for a given cgi parameter as a list of decoded
 * query parameter values.
 * @param {string} name The parameter to get values for.
 * @return {!Array<?>} The values for a given cgi parameter as a list of
 *     decoded query parameter values.
 */
goog.Uri.prototype.getParameterValues = function(name) {
  'use strict';
  return this.queryData_.getValues(name);
};


/**
 * Returns the first value for a given cgi parameter or undefined if the given
 * parameter name does not appear in the query string.
 * @param {string} paramName Unescaped parameter name.
 * @return {string|undefined} The first value for a given cgi parameter or
 *     undefined if the given parameter name does not appear in the query
 *     string.
 */
goog.Uri.prototype.getParameterValue = function(paramName) {
  'use strict';
  return /** @type {string|undefined} */ (this.queryData_.get(paramName));
};


/**
 * @return {string} The URI fragment, not including the #.
 */
goog.Uri.prototype.getFragment = function() {
  'use strict';
  return this.fragment_;
};


/**
 * Sets the URI fragment.
 * @throws URIError If opt_decode is true and newFragment is malformed (that is,
 *     if decodeURIComponent fails).
 * @param {string} newFragment New fragment value.
 * @param {boolean=} opt_decode Optional param for whether to decode new value.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.setFragment = function(newFragment, opt_decode) {
  'use strict';
  this.enforceReadOnly();
  this.fragment_ =
      opt_decode ? goog.Uri.decodeOrEmpty_(newFragment) : newFragment;
  return this;
};


/**
 * @return {boolean} Whether the URI has a fragment set.
 */
goog.Uri.prototype.hasFragment = function() {
  'use strict';
  return !!this.fragment_;
};


/**
 * Returns true if this has the same domain as that of uri2.
 * @param {!goog.Uri} uri2 The URI object to compare to.
 * @return {boolean} true if same domain; false otherwise.
 */
goog.Uri.prototype.hasSameDomainAs = function(uri2) {
  'use strict';
  return ((!this.hasDomain() && !uri2.hasDomain()) ||
          this.getDomain() == uri2.getDomain()) &&
      ((!this.hasPort() && !uri2.hasPort()) ||
       this.getPort() == uri2.getPort());
};


/**
 * Adds a random parameter to the Uri.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.makeUnique = function() {
  'use strict';
  this.enforceReadOnly();
  this.setParameterValue(goog.Uri.RANDOM_PARAM, goog.string.getRandomString());

  return this;
};


/**
 * Removes the named query parameter.
 *
 * @param {string} key The parameter to remove.
 * @return {!goog.Uri} Reference to this URI object.
 */
goog.Uri.prototype.removeParameter = function(key) {
  'use strict';
  this.enforceReadOnly();
  this.queryData_.remove(key);
  return this;
};


/**
 * Sets whether Uri is read only. If this goog.Uri is read-only,
 * enforceReadOnly_ will be called at the start of any function that may modify
 * this Uri.
 * @param {boolean} isReadOnly whether this goog.Uri should be read only.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setReadOnly = function(isReadOnly) {
  'use strict';
  this.isReadOnly_ = isReadOnly;
  return this;
};


/**
 * @return {boolean} Whether the URI is read only.
 */
goog.Uri.prototype.isReadOnly = function() {
  'use strict';
  return this.isReadOnly_;
};


/**
 * Checks if this Uri has been marked as read only, and if so, throws an error.
 * This should be called whenever any modifying function is called.
 */
goog.Uri.prototype.enforceReadOnly = function() {
  'use strict';
  if (this.isReadOnly_) {
    throw new Error('Tried to modify a read-only Uri');
  }
};


/**
 * Sets whether to ignore case.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 * @return {!goog.Uri} Reference to this Uri object.
 */
goog.Uri.prototype.setIgnoreCase = function(ignoreCase) {
  'use strict';
  this.ignoreCase_ = ignoreCase;
  if (this.queryData_) {
    this.queryData_.setIgnoreCase(ignoreCase);
  }
  return this;
};


/**
 * @return {boolean} Whether to ignore case.
 */
goog.Uri.prototype.getIgnoreCase = function() {
  'use strict';
  return this.ignoreCase_;
};


//==============================================================================
// Static members
//==============================================================================


/**
 * Creates a uri from the string form.  Basically an alias of new goog.Uri().
 * If a Uri object is passed to parse then it will return a clone of the object.
 *
 * @throws URIError If parsing the URI is malformed. The passed URI components
 *     should all be parseable by decodeURIComponent.
 * @param {*} uri Raw URI string or instance of Uri
 *     object.
 * @param {boolean=} opt_ignoreCase Whether to ignore the case of parameter
 * names in #getParameterValue.
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.parse = function(uri, opt_ignoreCase) {
  'use strict';
  return uri instanceof goog.Uri ? uri.clone() :
                                   new goog.Uri(uri, opt_ignoreCase);
};


/**
 * Creates a new goog.Uri object from unencoded parts.
 *
 * @param {?string=} opt_scheme Scheme/protocol or full URI to parse.
 * @param {?string=} opt_userInfo username:password.
 * @param {?string=} opt_domain www.google.com.
 * @param {?number=} opt_port 9830.
 * @param {?string=} opt_path /some/path/to/a/file.html.
 * @param {string|goog.Uri.QueryData=} opt_query a=1&b=2.
 * @param {?string=} opt_fragment The fragment without the #.
 * @param {boolean=} opt_ignoreCase Whether to ignore parameter name case in
 *     #getParameterValue.
 *
 * @return {!goog.Uri} The new URI object.
 */
goog.Uri.create = function(
    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_query,
    opt_fragment, opt_ignoreCase) {
  'use strict';
  var uri = new goog.Uri(null, opt_ignoreCase);

  // Only set the parts if they are defined and not empty strings.
  opt_scheme && uri.setScheme(opt_scheme);
  opt_userInfo && uri.setUserInfo(opt_userInfo);
  opt_domain && uri.setDomain(opt_domain);
  opt_port && uri.setPort(opt_port);
  opt_path && uri.setPath(opt_path);
  opt_query && uri.setQueryData(opt_query);
  opt_fragment && uri.setFragment(opt_fragment);

  return uri;
};


/**
 * Resolves a relative Uri against a base Uri, accepting both strings and
 * Uri objects.
 *
 * @param {*} base Base Uri.
 * @param {*} rel Relative Uri.
 * @return {!goog.Uri} Resolved uri.
 */
goog.Uri.resolve = function(base, rel) {
  'use strict';
  if (!(base instanceof goog.Uri)) {
    base = goog.Uri.parse(base);
  }

  if (!(rel instanceof goog.Uri)) {
    rel = goog.Uri.parse(rel);
  }

  return base.resolve(rel);
};


/**
 * Removes dot segments in given path component, as described in
 * RFC 3986, section 5.2.4.
 *
 * @param {string} path A non-empty path component.
 * @return {string} Path component with removed dot segments.
 */
goog.Uri.removeDotSegments = function(path) {
  'use strict';
  if (path == '..' || path == '.') {
    return '';

  } else if (
      !goog.string.contains(path, './') && !goog.string.contains(path, '/.')) {
    // This optimization detects uris which do not contain dot-segments,
    // and as a consequence do not require any processing.
    return path;

  } else {
    var leadingSlash = goog.string.startsWith(path, '/');
    var segments = path.split('/');
    var out = [];

    for (var pos = 0; pos < segments.length;) {
      var segment = segments[pos++];

      if (segment == '.') {
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else if (segment == '..') {
        if (out.length > 1 || out.length == 1 && out[0] != '') {
          out.pop();
        }
        if (leadingSlash && pos == segments.length) {
          out.push('');
        }
      } else {
        out.push(segment);
        leadingSlash = true;
      }
    }

    return out.join('/');
  }
};


/**
 * Decodes a value or returns the empty string if it isn't defined or empty.
 * @throws URIError If decodeURIComponent fails to decode val.
 * @param {string|undefined} val Value to decode.
 * @param {boolean=} opt_preserveReserved If true, restricted characters will
 *     not be decoded.
 * @return {string} Decoded value.
 * @private
 */
goog.Uri.decodeOrEmpty_ = function(val, opt_preserveReserved) {
  'use strict';
  // Don't use UrlDecode() here because val is not a query parameter.
  if (!val) {
    return '';
  }

  // decodeURI has the same output for '%2f' and '%252f'. We double encode %25
  // so that we can distinguish between the 2 inputs. This is later undone by
  // removeDoubleEncoding_.
  return opt_preserveReserved ? decodeURI(val.replace(/%25/g, '%2525')) :
                                decodeURIComponent(val);
};


/**
 * If unescapedPart is non null, then escapes any characters in it that aren't
 * valid characters in a url and also escapes any special characters that
 * appear in extra.
 *
 * @param {*} unescapedPart The string to encode.
 * @param {RegExp} extra A character set of characters in [\01-\177].
 * @param {boolean=} opt_removeDoubleEncoding If true, remove double percent
 *     encoding.
 * @return {?string} null iff unescapedPart == null.
 * @private
 */
goog.Uri.encodeSpecialChars_ = function(
    unescapedPart, extra, opt_removeDoubleEncoding) {
  'use strict';
  if (typeof unescapedPart === 'string') {
    var encoded = encodeURI(unescapedPart).replace(extra, goog.Uri.encodeChar_);
    if (opt_removeDoubleEncoding) {
      // encodeURI double-escapes %XX sequences used to represent restricted
      // characters in some URI components, remove the double escaping here.
      encoded = goog.Uri.removeDoubleEncoding_(encoded);
    }
    return encoded;
  }
  return null;
};


/**
 * Converts a character in [\01-\177] to its unicode character equivalent.
 * @param {string} ch One character string.
 * @return {string} Encoded string.
 * @private
 */
goog.Uri.encodeChar_ = function(ch) {
  'use strict';
  var n = ch.charCodeAt(0);
  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);
};


/**
 * Removes double percent-encoding from a string.
 * @param  {string} doubleEncodedString String
 * @return {string} String with double encoding removed.
 * @private
 */
goog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {
  'use strict';
  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');
};


/**
 * Regular expression for characters that are disallowed in the scheme or
 * userInfo part of the URI.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\/\?@]/g;


/**
 * Regular expression for characters that are disallowed in a relative path.
 * Colon is included due to RFC 3986 3.3.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInRelativePath_ = /[\#\?:]/g;


/**
 * Regular expression for characters that are disallowed in an absolute path.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInAbsolutePath_ = /[\#\?]/g;


/**
 * Regular expression for characters that are disallowed in the query.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInQuery_ = /[\#\?@]/g;


/**
 * Regular expression for characters that are disallowed in the fragment.
 * @type {RegExp}
 * @private
 */
goog.Uri.reDisallowedInFragment_ = /#/g;


/**
 * Checks whether two URIs have the same domain.
 * @param {string} uri1String First URI string.
 * @param {string} uri2String Second URI string.
 * @return {boolean} true if the two URIs have the same domain; false otherwise.
 */
goog.Uri.haveSameDomain = function(uri1String, uri2String) {
  'use strict';
  // Differs from goog.uri.utils.haveSameDomain, since this ignores scheme.
  // TODO(gboyer): Have this just call goog.uri.util.haveSameDomain.
  var pieces1 = goog.uri.utils.split(uri1String);
  var pieces2 = goog.uri.utils.split(uri2String);
  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==
      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &&
      pieces1[goog.uri.utils.ComponentIndex.PORT] ==
      pieces2[goog.uri.utils.ComponentIndex.PORT];
};



/**
 * Class used to represent URI query parameters.  It is essentially a hash of
 * name-value pairs, though a name can be present more than once.
 *
 * Has the same interface as the collections in goog.structs.
 *
 * @param {?string=} opt_query Optional encoded query string to parse into
 *     the object.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @constructor
 * @struct
 * @final
 */
goog.Uri.QueryData = function(opt_query, opt_ignoreCase) {
  'use strict';
  /**
   * The map containing name/value or name/array-of-values pairs.
   * May be null if it requires parsing from the query string.
   *
   * We need to use a Map because we cannot guarantee that the key names will
   * not be problematic for IE.
   *
   * @private {?goog.structs.Map<string, !Array<*>>}
   */
  this.keyMap_ = null;

  /**
   * The number of params, or null if it requires computing.
   * @private {?number}
   */
  this.count_ = null;

  /**
   * Encoded query string, or null if it requires computing from the key map.
   * @private {?string}
   */
  this.encodedQuery_ = opt_query || null;

  /**
   * If true, ignore the case of the parameter name in #get.
   * @private {boolean}
   */
  this.ignoreCase_ = !!opt_ignoreCase;
};


/**
 * If the underlying key map is not yet initialized, it parses the
 * query string and fills the map with parsed data.
 * @private
 */
goog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {
  'use strict';
  if (!this.keyMap_) {
    this.keyMap_ = new goog.structs.Map();
    this.count_ = 0;
    if (this.encodedQuery_) {
      var self = this;
      goog.uri.utils.parseQueryData(this.encodedQuery_, function(name, value) {
        'use strict';
        self.add(goog.string.urlDecode(name), value);
      });
    }
  }
};


/**
 * Creates a new query data instance from a map of names and values.
 *
 * @param {!goog.structs.Map<string, ?>|!Object} map Map of string parameter
 *     names to parameter value. If parameter value is an array, it is
 *     treated as if the key maps to each individual value in the
 *     array.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromMap = function(map, opt_ignoreCase) {
  'use strict';
  var keys = goog.structs.getKeys(map);
  if (typeof keys == 'undefined') {
    throw new Error('Keys are undefined');
  }

  var queryData = new goog.Uri.QueryData(null, opt_ignoreCase);
  var values = goog.structs.getValues(map);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = values[i];
    if (!Array.isArray(value)) {
      queryData.add(key, value);
    } else {
      queryData.setValues(key, value);
    }
  }
  return queryData;
};


/**
 * Creates a new query data instance from parallel arrays of parameter names
 * and values. Allows for duplicate parameter names. Throws an error if the
 * lengths of the arrays differ.
 *
 * @param {!Array<string>} keys Parameter names.
 * @param {!Array<?>} values Parameter values.
 * @param {boolean=} opt_ignoreCase If true, ignore the case of the parameter
 *     name in #get.
 * @return {!goog.Uri.QueryData} The populated query data instance.
 */
goog.Uri.QueryData.createFromKeysValues = function(
    keys, values, opt_ignoreCase) {
  'use strict';
  if (keys.length != values.length) {
    throw new Error('Mismatched lengths for keys/values');
  }
  var queryData = new goog.Uri.QueryData(null, opt_ignoreCase);
  for (var i = 0; i < keys.length; i++) {
    queryData.add(keys[i], values[i]);
  }
  return queryData;
};


/**
 * @return {?number} The number of parameters.
 */
goog.Uri.QueryData.prototype.getCount = function() {
  'use strict';
  this.ensureKeyMapInitialized_();
  return this.count_;
};


/**
 * Adds a key value pair.
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.add = function(key, value) {
  'use strict';
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  key = this.getKeyName_(key);
  var values = this.keyMap_.get(key);
  if (!values) {
    this.keyMap_.set(key, (values = []));
  }
  values.push(value);
  this.count_ = goog.asserts.assertNumber(this.count_) + 1;
  return this;
};


/**
 * Removes all the params with the given key.
 * @param {string} key Name.
 * @return {boolean} Whether any parameter was removed.
 */
goog.Uri.QueryData.prototype.remove = function(key) {
  'use strict';
  this.ensureKeyMapInitialized_();

  key = this.getKeyName_(key);
  if (this.keyMap_.containsKey(key)) {
    this.invalidateCache_();

    // Decrement parameter count.
    this.count_ =
        goog.asserts.assertNumber(this.count_) - this.keyMap_.get(key).length;
    return this.keyMap_.remove(key);
  }
  return false;
};


/**
 * Clears the parameters.
 */
goog.Uri.QueryData.prototype.clear = function() {
  'use strict';
  this.invalidateCache_();
  this.keyMap_ = null;
  this.count_ = 0;
};


/**
 * @return {boolean} Whether we have any parameters.
 */
goog.Uri.QueryData.prototype.isEmpty = function() {
  'use strict';
  this.ensureKeyMapInitialized_();
  return this.count_ == 0;
};


/**
 * Whether there is a parameter with the given name
 * @param {string} key The parameter name to check for.
 * @return {boolean} Whether there is a parameter with the given name.
 */
goog.Uri.QueryData.prototype.containsKey = function(key) {
  'use strict';
  this.ensureKeyMapInitialized_();
  key = this.getKeyName_(key);
  return this.keyMap_.containsKey(key);
};


/**
 * Whether there is a parameter with the given value.
 * @param {*} value The value to check for.
 * @return {boolean} Whether there is a parameter with the given value.
 */
goog.Uri.QueryData.prototype.containsValue = function(value) {
  'use strict';
  // NOTE(arv): This solution goes through all the params even if it was the
  // first param. We can get around this by not reusing code or by switching to
  // iterators.
  var vals = this.getValues();
  return goog.array.contains(vals, value);
};


/**
 * Runs a callback on every key-value pair in the map, including duplicate keys.
 * This won't maintain original order when duplicate keys are interspersed (like
 * getKeys() / getValues()).
 * @param {function(this:SCOPE, ?, string, !goog.Uri.QueryData)} f
 * @param {SCOPE=} opt_scope The value of "this" inside f.
 * @template SCOPE
 */
goog.Uri.QueryData.prototype.forEach = function(f, opt_scope) {
  'use strict';
  this.ensureKeyMapInitialized_();
  this.keyMap_.forEach(function(values, key) {
    'use strict';
    values.forEach(function(value) {
      'use strict';
      f.call(opt_scope, value, key, this);
    }, this);
  }, this);
};


/**
 * Returns all the keys of the parameters. If a key is used multiple times
 * it will be included multiple times in the returned array
 * @return {!Array<string>} All the keys of the parameters.
 */
goog.Uri.QueryData.prototype.getKeys = function() {
  'use strict';
  this.ensureKeyMapInitialized_();
  // We need to get the values to know how many keys to add.
  var vals = this.keyMap_.getValues();
  var keys = this.keyMap_.getKeys();
  var rv = [];
  for (var i = 0; i < keys.length; i++) {
    var val = vals[i];
    for (var j = 0; j < val.length; j++) {
      rv.push(keys[i]);
    }
  }
  return rv;
};


/**
 * Returns all the values of the parameters with the given name. If the query
 * data has no such key this will return an empty array. If no key is given
 * all values wil be returned.
 * @param {string=} opt_key The name of the parameter to get the values for.
 * @return {!Array<?>} All the values of the parameters with the given name.
 */
goog.Uri.QueryData.prototype.getValues = function(opt_key) {
  'use strict';
  this.ensureKeyMapInitialized_();
  var rv = [];
  if (typeof opt_key === 'string') {
    if (this.containsKey(opt_key)) {
      rv = rv.concat(this.keyMap_.get(this.getKeyName_(opt_key)));
    }
  } else {
    // Return all values.
    var values = this.keyMap_.getValues();
    for (var i = 0; i < values.length; i++) {
      rv = rv.concat(values[i]);
    }
  }
  return rv;
};


/**
 * Sets a key value pair and removes all other keys with the same value.
 *
 * @param {string} key Name.
 * @param {*} value Value.
 * @return {!goog.Uri.QueryData} Instance of this object.
 */
goog.Uri.QueryData.prototype.set = function(key, value) {
  'use strict';
  this.ensureKeyMapInitialized_();
  this.invalidateCache_();

  // TODO(chrishenry): This could be better written as
  // this.remove(key), this.add(key, value), but that would reorder
  // the key (since the key is first removed and then added at the
  // end) and we would have to fix unit tests that depend on key
  // ordering.
  key = this.getKeyName_(key);
  if (this.containsKey(key)) {
    this.count_ =
        goog.asserts.assertNumber(this.count_) - this.keyMap_.get(key).length;
  }
  this.keyMap_.set(key, [value]);
  this.count_ = goog.asserts.assertNumber(this.count_) + 1;
  return this;
};


/**
 * Returns the first value associated with the key. If the query data has no
 * such key this will return undefined or the optional default.
 * @param {string} key The name of the parameter to get the value for.
 * @param {*=} opt_default The default value to return if the query data
 *     has no such key.
 * @return {*} The first string value associated with the key, or opt_default
 *     if there's no value.
 */
goog.Uri.QueryData.prototype.get = function(key, opt_default) {
  'use strict';
  if (!key) {
    return opt_default;
  }
  var values = this.getValues(key);
  return values.length > 0 ? String(values[0]) : opt_default;
};


/**
 * Sets the values for a key. If the key already exists, this will
 * override all of the existing values that correspond to the key.
 * @param {string} key The key to set values for.
 * @param {!Array<?>} values The values to set.
 */
goog.Uri.QueryData.prototype.setValues = function(key, values) {
  'use strict';
  this.remove(key);

  if (values.length > 0) {
    this.invalidateCache_();
    this.keyMap_.set(this.getKeyName_(key), goog.array.clone(values));
    this.count_ = goog.asserts.assertNumber(this.count_) + values.length;
  }
};


/**
 * @return {string} Encoded query string.
 * @override
 */
goog.Uri.QueryData.prototype.toString = function() {
  'use strict';
  if (this.encodedQuery_) {
    return this.encodedQuery_;
  }

  if (!this.keyMap_) {
    return '';
  }

  var sb = [];

  // In the past, we use this.getKeys() and this.getVals(), but that
  // generates a lot of allocations as compared to simply iterating
  // over the keys.
  var keys = this.keyMap_.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var encodedKey = goog.string.urlEncode(key);
    var val = this.getValues(key);
    for (var j = 0; j < val.length; j++) {
      var param = encodedKey;
      // Ensure that null and undefined are encoded into the url as
      // literal strings.
      if (val[j] !== '') {
        param += '=' + goog.string.urlEncode(val[j]);
      }
      sb.push(param);
    }
  }

  return this.encodedQuery_ = sb.join('&');
};


/**
 * @throws URIError If URI is malformed (that is, if decodeURIComponent fails on
 *     any of the URI components).
 * @return {string} Decoded query string.
 */
goog.Uri.QueryData.prototype.toDecodedString = function() {
  'use strict';
  return goog.Uri.decodeOrEmpty_(this.toString());
};


/**
 * Invalidate the cache.
 * @private
 */
goog.Uri.QueryData.prototype.invalidateCache_ = function() {
  'use strict';
  this.encodedQuery_ = null;
};


/**
 * Removes all keys that are not in the provided list. (Modifies this object.)
 * @param {Array<string>} keys The desired keys.
 * @return {!goog.Uri.QueryData} a reference to this object.
 */
goog.Uri.QueryData.prototype.filterKeys = function(keys) {
  'use strict';
  this.ensureKeyMapInitialized_();
  this.keyMap_.forEach(function(value, key) {
    'use strict';
    if (!goog.array.contains(keys, key)) {
      this.remove(key);
    }
  }, this);
  return this;
};


/**
 * Clone the query data instance.
 * @return {!goog.Uri.QueryData} New instance of the QueryData object.
 */
goog.Uri.QueryData.prototype.clone = function() {
  'use strict';
  var rv = new goog.Uri.QueryData();
  rv.encodedQuery_ = this.encodedQuery_;
  if (this.keyMap_) {
    rv.keyMap_ = this.keyMap_.clone();
    rv.count_ = this.count_;
  }
  return rv;
};


/**
 * Helper function to get the key name from a JavaScript object. Converts
 * the object to a string, and to lower case if necessary.
 * @private
 * @param {*} arg The object to get a key name from.
 * @return {string} valid key name which can be looked up in #keyMap_.
 */
goog.Uri.QueryData.prototype.getKeyName_ = function(arg) {
  'use strict';
  var keyName = String(arg);
  if (this.ignoreCase_) {
    keyName = keyName.toLowerCase();
  }
  return keyName;
};


/**
 * Ignore case in parameter names.
 * NOTE: If there are already key/value pairs in the QueryData, and
 * ignoreCase_ is set to false, the keys will all be lower-cased.
 * @param {boolean} ignoreCase whether this goog.Uri should ignore case.
 */
goog.Uri.QueryData.prototype.setIgnoreCase = function(ignoreCase) {
  'use strict';
  var resetKeys = ignoreCase && !this.ignoreCase_;
  if (resetKeys) {
    this.ensureKeyMapInitialized_();
    this.invalidateCache_();
    this.keyMap_.forEach(function(value, key) {
      'use strict';
      var lowerCase = key.toLowerCase();
      if (key != lowerCase) {
        this.remove(key);
        this.setValues(lowerCase, value);
      }
    }, this);
  }
  this.ignoreCase_ = ignoreCase;
};


/**
 * Extends a query data object with another query data or map like object. This
 * operates 'in-place', it does not create a new QueryData object.
 *
 * @param {...(?goog.Uri.QueryData|?goog.structs.Map<?, ?>|?Object)} var_args
 *     The object from which key value pairs will be copied. Note: does not
 *     accept null.
 * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different
 * types of parameters.
 */
goog.Uri.QueryData.prototype.extend = function(var_args) {
  'use strict';
  for (var i = 0; i < arguments.length; i++) {
    var data = arguments[i];
    goog.structs.forEach(data, function(value, key) {
      'use strict';
      this.add(key, value);
    }, this);
  }
};

//analytics/tracking/chrome/internal/xhr_channel.js
goog.loadModule(function(exports) {'use strict';// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Channel that sends hits to GA servers using XHR.
 *
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 */

goog.module('analytics.internal.XhrChannel');
goog.module.declareLegacyNamespace();

const Channel = goog.require('analytics.internal.Channel');
const Deferred = goog.require('goog.async.Deferred');
const HitType = goog.requireType('analytics.HitType');
const NetworkStatusMonitor = goog.require('goog.net.NetworkStatusMonitor');
const Parameter = goog.require('analytics.Parameter');
const ParameterMap = goog.require('analytics.ParameterMap');
const Parameters = goog.require('analytics.Parameters');
const Results = goog.require('analytics.Results');
const Status = goog.require('analytics.Status');
const Uri = goog.require('goog.Uri');
const Value = goog.requireType('analytics.Value');
const XhrIo = goog.require('goog.net.XhrIo');
const format = goog.require('goog.string.format');

/**
 * @implements {Channel}
 */
const XhrChannel = class {
  /**
   * @param {string} serverUrl
   * @param {number} maxPostLength The maximum lengh of the POST payload
   *     in characters.
   * @param {!NetworkStatusMonitor} networkStatus
   */
  constructor(serverUrl, maxPostLength, networkStatus) {
    /** @private {string} */
    this.serverUrl_ = serverUrl;

    /** @private {number} */
    this.maxPostLength_ = maxPostLength;

    /** @private {NetworkStatusMonitor} */
    this.networkStatus_ = networkStatus;
  }

  /** @override */
  send(hitType, parameters) {
    // Don't try to upload anything if the network is unavailable.
    if (!this.networkStatus_.isOnline()) {
      return Deferred.fail(Results.DEVICE_OFFLINE);
    }

    var deferred = new Deferred();

    var queryString = this.toQueryString_(hitType, parameters);
    if (queryString.length > this.maxPostLength_) {
      deferred.errback({
        status: Status.PAYLOAD_TOO_BIG,
        details: format(
            'Encoded hit length == %s, but should be <= %s.',
            queryString.length, this.maxPostLength_)
      });
    } else {
      var callback = function() {
        deferred.callback(Results.SENT);
      };
      XhrIo.send(this.serverUrl_, callback, 'POST', queryString);
    }
    return deferred;
  }

  /**
   * @param {!HitType} hitType
   * @param {!ParameterMap} parameters
   * @return {string} The parameters formatted as a URL query string.
   * @private
   */
  toQueryString_(hitType, parameters) {
    /** @type {Uri.QueryData} */
    var queryData = new Uri.QueryData();
    queryData.add(Parameters.HIT_TYPE.name, hitType);
    parameters.forEachEntry(
        /**
         * @param {!Parameter} key
         * @param {!Value} value
         */
        function(key, value) {
          queryData.add(key.name, value.toString());
        });
    return queryData.toString();
  }
};

exports = XhrChannel;

;return exports;});

//third_party/javascript/closure/events/eventhandler.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Class to create objects which want to handle multiple events
 * and have their listeners easily cleaned up via a dispose method.
 *
 * Example:
 * <pre>
 * function Something() {
 *   Something.base(this);
 *
 *   ... set up object ...
 *
 *   // Add event listeners
 *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);
 *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);
 *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);
 *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);
 * }
 * goog.inherits(Something, goog.events.EventHandler);
 *
 * Something.prototype.disposeInternal = function() {
 *   Something.base(this, 'disposeInternal');
 *   goog.dom.removeNode(this.container);
 * };
 *
 *
 * // Then elsewhere:
 *
 * var activeSomething = null;
 * function openSomething() {
 *   activeSomething = new Something();
 * }
 *
 * function closeSomething() {
 *   if (activeSomething) {
 *     activeSomething.dispose();  // Remove event listeners
 *     activeSomething = null;
 *   }
 * }
 * </pre>
 */

goog.provide('goog.events.EventHandler');

goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.object');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.EventId');
goog.requireType('goog.events.EventTarget');
goog.requireType('goog.events.EventWrapper');



/**
 * Super class for objects that want to easily manage a number of event
 * listeners.  It allows a short cut to listen and also provides a quick way
 * to remove all events listeners belonging to this object.
 * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.
 * @constructor
 * @extends {goog.Disposable}
 * @template SCOPE
 */
goog.events.EventHandler = function(opt_scope) {
  'use strict';
  goog.Disposable.call(this);
  // TODO(mknichel): Rename this to this.scope_ and fix the classes in google3
  // that access this private variable. :(
  this.handler_ = opt_scope;

  /**
   * Keys for events that are being listened to.
   * @type {!Object<!goog.events.Key>}
   * @private
   */
  this.keys_ = {};
};
goog.inherits(goog.events.EventHandler, goog.Disposable);


/**
 * Utility array used to unify the cases of listening for an array of types
 * and listening for a single event, without using recursion or allocating
 * an array each time.
 * @type {!Array<string>}
 * @const
 * @private
 */
goog.events.EventHandler.typeArray_ = [];


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
 *     opt_fn Optional callback function to be used as the listener or an object
 *     with handleEvent function.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template EVENTOBJ, THIS
 */
goog.events.EventHandler.prototype.listen = function(
    src, type, opt_fn, opt_options) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  return self.listen_(src, type, opt_fn, opt_options);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|!AddEventListenerOptions|undefined} options
 * @param {T} scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template T, EVENTOBJ, THIS
 */
goog.events.EventHandler.prototype.listenWithScope = function(
    src, type, fn, options, scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  // TODO(mknichel): Deprecate this function.
  return self.listen_(src, type, fn, options, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted then the
 * EventHandler's handleEvent method will be used.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn
 *     Optional callback function to be used as the listener or an object with
 *     handleEvent function.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template EVENTOBJ, THIS
 * @private
 */
goog.events.EventHandler.prototype.listen_ = function(
    src, type, opt_fn, opt_options, opt_scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  if (!Array.isArray(type)) {
    if (type) {
      goog.events.EventHandler.typeArray_[0] = type.toString();
    }
    type = goog.events.EventHandler.typeArray_;
  }
  for (var i = 0; i < type.length; i++) {
    var listenerObj = goog.events.listen(
        src, type[i], opt_fn || self.handleEvent, opt_options || false,
        opt_scope || self.handler_ || self);

    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return self;
    }

    var key = listenerObj.key;
    self.keys_[key] = listenerObj;
  }

  return self;
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
 * opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template EVENTOBJ, THIS
 */
goog.events.EventHandler.prototype.listenOnce = function(
    src, type, opt_fn, opt_options) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  return self.listenOnce_(src, type, opt_fn, opt_options);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired the
 * event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|
 *     null|undefined} fn Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template T, EVENTOBJ, THIS
 */
goog.events.EventHandler.prototype.listenOnceWithScope = function(
    src, type, fn, capture, scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  // TODO(mknichel): Deprecate this function.
  return self.listenOnce_(src, type, fn, capture, scope);
};


/**
 * Listen to an event on a Listenable.  If the function is omitted, then the
 * EventHandler's handleEvent method will be used. After the event has fired
 * the event listener is removed from the target. If an array of event types is
 * provided, each event type will be listened to once.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type to listen for or array of event types.
 * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn
 *    Optional callback function to be used as the listener or an object with
 *    handleEvent function.
 * @param {(boolean|!AddEventListenerOptions)=} opt_options
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template EVENTOBJ, THIS
 * @private
 */
goog.events.EventHandler.prototype.listenOnce_ = function(
    src, type, opt_fn, opt_options, opt_scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      self.listenOnce_(src, type[i], opt_fn, opt_options, opt_scope);
    }
  } else {
    var listenerObj = goog.events.listenOnce(
        src, type, opt_fn || self.handleEvent, opt_options,
        opt_scope || self.handler_ || self);
    if (!listenerObj) {
      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT
      // (goog.events.CaptureSimulationMode) in IE8-, it will return null
      // value.
      return self;
    }

    var key = listenerObj.key;
    self.keys_[key] = listenerObj;
  }

  return self;
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template THIS
 */
goog.events.EventHandler.prototype.listenWithWrapper = function(
    src, wrapper, listener, opt_capt) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  // TODO(mknichel): Remove the opt_scope from this function and then
  // templatize it.
  return self.listenWithWrapper_(src, wrapper, listener, opt_capt);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}
 *     listener Optional callback function to be used as the
 *     listener or an object with handleEvent function.
 * @param {boolean|undefined} capture Optional whether to use capture phase.
 * @param {T} scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template T, THIS
 */
goog.events.EventHandler.prototype.listenWithWrapperAndScope = function(
    src, wrapper, listener, capture, scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  // TODO(mknichel): Deprecate this function.
  return self.listenWithWrapper_(src, wrapper, listener, capture, scope);
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.EventTarget}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.EventTarget} src The node to listen to
 *     events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template THIS
 * @private
 */
goog.events.EventHandler.prototype.listenWithWrapper_ = function(
    src, wrapper, listener, opt_capt, opt_scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  wrapper.listen(
      src, listener, opt_capt, opt_scope || self.handler_ || self, self);
  return self;
};


/**
 * @return {number} Number of listeners registered by this handler.
 */
goog.events.EventHandler.prototype.getListenerCount = function() {
  'use strict';
  var count = 0;
  for (var key in this.keys_) {
    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {
      count++;
    }
  }
  return count;
};


/**
 * Unlistens on an event.
 * @param {goog.events.ListenableType} src Event source.
 * @param {string|Array<string>|
 *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}
 *     type Event type or array of event types to unlisten to.
 * @param {function(this:?, EVENTOBJ):?|{handleEvent:function(?):?}|null=}
 *     opt_fn Optional callback function to be used as the listener or an object
 *     with handleEvent function.
 * @param {(boolean|!EventListenerOptions)=} opt_options
 * @param {Object=} opt_scope Object in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template EVENTOBJ, THIS
 */
goog.events.EventHandler.prototype.unlisten = function(
    src, type, opt_fn, opt_options, opt_scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      self.unlisten(src, type[i], opt_fn, opt_options, opt_scope);
    }
  } else {
    var capture =
        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
    var listener = goog.events.getListener(
        src, type, opt_fn || self.handleEvent, capture,
        opt_scope || self.handler_ || self);

    if (listener) {
      goog.events.unlistenByKey(listener);
      delete self.keys_[listener.key];
    }
  }

  return self;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.EventTarget} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @return {THIS} This object, allowing for chaining of calls.
 * @this {THIS}
 * @template THIS
 */
goog.events.EventHandler.prototype.unlistenWithWrapper = function(
    src, wrapper, listener, opt_capt, opt_scope) {
  'use strict';
  var self = /** @type {!goog.events.EventHandler} */ (this);
  wrapper.unlisten(
      src, listener, opt_capt, opt_scope || self.handler_ || self, self);
  return self;
};


/**
 * Unlistens to all events.
 */
goog.events.EventHandler.prototype.removeAll = function() {
  'use strict';
  goog.object.forEach(this.keys_, function(listenerObj, key) {
    'use strict';
    if (this.keys_.hasOwnProperty(key)) {
      goog.events.unlistenByKey(listenerObj);
    }
  }, this);

  this.keys_ = {};
};


/**
 * Disposes of this EventHandler and removes all listeners that it registered.
 * @override
 * @protected
 */
goog.events.EventHandler.prototype.disposeInternal = function() {
  'use strict';
  goog.events.EventHandler.superClass_.disposeInternal.call(this);
  this.removeAll();
};


/**
 * Default event handler
 * @param {goog.events.Event} e Event object.
 */
goog.events.EventHandler.prototype.handleEvent = function(e) {
  'use strict';
  throw new Error('EventHandler.handleEvent not implemented');
};

//third_party/javascript/closure/events/onlinehandler.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview This event handler will dispatch events when
 * `navigator.onLine` changes.  HTML5 defines two events, online and
 * offline that is fired on the window.  As of today 3 browsers support these
 * events: Firefox 3 (Gecko 1.9), Opera 9.5, and IE8.  If we have any of these
 * we listen to the 'online' and 'offline' events on the current window
 * object.  Otherwise we poll the navigator.onLine property to detect changes.
 *
 * Note that this class only reflects what the browser tells us and this usually
 * only reflects changes to the File -> Work Offline menu item.
 *
 * @see ../demos/onlinehandler.html
 */

// TODO(arv): We should probably implement some kind of polling service and/or
// a poll for changes event handler that can be used to fire events when a state
// changes.

goog.provide('goog.events.OnlineHandler');
goog.provide('goog.events.OnlineHandler.EventType');

goog.require('goog.Timer');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.net.NetworkStatusMonitor');



/**
 * Basic object for detecting whether the online state changes.
 * @constructor
 * @extends {goog.events.EventTarget}
 * @implements {goog.net.NetworkStatusMonitor}
 */
goog.events.OnlineHandler = function() {
  'use strict';
  goog.events.OnlineHandler.base(this, 'constructor');

  /**
   * @private {goog.events.EventHandler<!goog.events.OnlineHandler>}
   */
  this.eventHandler_ = new goog.events.EventHandler(this);

  this.eventHandler_.listen(
      window, [goog.events.EventType.ONLINE, goog.events.EventType.OFFLINE],
      this.handleChange_);
};
goog.inherits(goog.events.OnlineHandler, goog.events.EventTarget);


/**
 * Enum for the events dispatched by the OnlineHandler.
 * @enum {string}
 * @deprecated Use goog.net.NetworkStatusMonitor.EventType instead.
 */
goog.events.OnlineHandler.EventType = goog.net.NetworkStatusMonitor.EventType;


/**
 * The time to wait before checking the `navigator.onLine` again.
 * @type {number}
 * @private
 */
goog.events.OnlineHandler.POLL_INTERVAL_ = 250;


/**
 * Stores the last value of the online state so we can detect if this has
 * changed.
 * @type {boolean}
 * @private
 */
goog.events.OnlineHandler.prototype.online_;


/**
 * The timer object used to poll the online state.
 * @type {goog.Timer}
 * @private
 */
goog.events.OnlineHandler.prototype.timer_;


/** @override */
goog.events.OnlineHandler.prototype.isOnline = function() {
  'use strict';
  return navigator.onLine;
};


/**
 * Called every time the timer ticks to see if the state has changed and when
 * the online state changes the method handleChange_ is called.
 * @private
 */
goog.events.OnlineHandler.prototype.handleTick_ = function() {
  'use strict';
  var online = this.isOnline();
  if (online != this.online_) {
    this.online_ = online;
    this.handleChange_();
  }
};


/**
 * Called when the online state changes.  This dispatches the
 * `ONLINE` and `OFFLINE` events respectively.
 * @private
 */
goog.events.OnlineHandler.prototype.handleChange_ = function() {
  'use strict';
  var type = this.isOnline() ? goog.net.NetworkStatusMonitor.EventType.ONLINE :
                               goog.net.NetworkStatusMonitor.EventType.OFFLINE;
  this.dispatchEvent(type);
};


/** @override */
goog.events.OnlineHandler.prototype.disposeInternal = function() {
  'use strict';
  goog.events.OnlineHandler.base(this, 'disposeInternal');
  this.eventHandler_.dispose();
  this.eventHandler_ = null;
  if (this.timer_) {
    this.timer_.dispose();
    this.timer_ = null;
  }
};

//analytics/tracking/chrome/internal/shared_channel_factory.js
goog.loadModule(function(exports) {'use strict';// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A factory that lazily creates the *shared* segment of the
 * `Channel` pipeline.
 *
 * @author smckay@google.com (Steve McKay)
 */
goog.module('analytics.internal.SharedChannelFactory');
goog.module.declareLegacyNamespace();

const AsyncSettingsChannel = goog.require('analytics.internal.AsyncSettingsChannel');
const Channel = goog.requireType('analytics.internal.Channel');
const HasChannel = goog.require('analytics.internal.HasChannel');
const OnlineHandler = goog.require('goog.events.OnlineHandler');
const ParameterFilterChannel = goog.require('analytics.internal.ParameterFilterChannel');
const RateLimitingChannel = goog.require('analytics.internal.RateLimitingChannel');
const Settings = goog.requireType('analytics.internal.Settings');
const TokenBucket = goog.require('analytics.internal.TokenBucket');
const UserSamplingChannel = goog.require('analytics.internal.UserSamplingChannel');
const XhrChannel = goog.require('analytics.internal.XhrChannel');

/**
 * A factory that lazily creates the *shared* segment of the
 * `Channel` pipeline. This segement handles requests
 * for users when tracking enabled, and is shared across
 * all tracker instances.
 * @implements {HasChannel}
 */
const SharedChannelFactory = class {
  /**
   * @param {!Settings} settings A settings object that
   *     may not yet be ready. The object will be ready before
   *     the `getChannel` method is called.
   * @param {string} serverAddress The URL of the GA server.
   * @param {number} maxPostLength The maximum number of characters
   *     that can be included in the POST payload.
   */
  constructor(settings, serverAddress, maxPostLength) {
    /** @private {!Settings} */
    this.settings_ = settings;

    /** @private {string} */
    this.serverAddress_ = serverAddress;

    /** @private {number} */
    this.maxPostLength_ = maxPostLength;

    /** @private {!Channel} */
    this.channel_;
  }

  /** @override */
  getChannel() {
    if (!this.channel_) {
      this.channel_ = this.createChannel_();
    }
    return this.channel_;
  }

  /**
   * A factory that lazily creates the runtime Channel pipeline that handles
   * requests for users with tracking enabled. The use of a factory enables
   * delayed initialization of the pipeline. Deferred initialization is
   * necessitated by asynchronous loading of settings from local storage.
   *
   * @return {!Channel}
   * @private
   */
  createChannel_() {
    if (!this.settings_.whenReady().hasFired()) {
      throw new Error(
          'Cannot construct shared channel prior to settings being ready.');
    }

    var networkStatus = new OnlineHandler();

    var xhrChannel =
        new XhrChannel(this.serverAddress_, this.maxPostLength_, networkStatus);

    var paramFilterChannel = new ParameterFilterChannel(xhrChannel);

    var tokenBucket = new TokenBucket(
        60,   // initialTokens
        500,  // maxTokens
        TokenBucket.FillRate.ONE_EVERY_TWO_SECONDS);

    var limitingChannel =
        new RateLimitingChannel(tokenBucket, paramFilterChannel);

    var samplingChannel =
        new UserSamplingChannel(this.settings_, limitingChannel);

    return new AsyncSettingsChannel(this.settings_, samplingChannel);
  }
};

exports = SharedChannelFactory;

;return exports;});

//analytics/tracking/chrome/analytics.js
// Copyright 2013 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides support for creating service objects.
 * @author smckay@google.com (Steve McKay)
 * @author tbreisacher@google.com (Tyler Breisacher)
 * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed
 */

goog.provide('analytics.LIBRARY_VERSION');
goog.provide('analytics.getService');
goog.provide('analytics.resetForTesting');

goog.require('analytics.internal.ChromeStorage');
goog.require('analytics.internal.GoogleAnalyticsService');
goog.require('analytics.internal.ServiceChannelManager');
goog.require('analytics.internal.ServiceSettings');
goog.require('analytics.internal.SharedChannelFactory');
goog.require('goog.string');
goog.require('goog.structs.Map');


/**
 * The current version of this library. Should be increased whenever we make a
 * major change to the library.
 * @const {string}
 */
analytics.LIBRARY_VERSION = 'ca1.6.0';


/**
 * The URL of the GA server. This library only communicates over SSL.
 * @private {string}
 */
analytics.GA_SERVER_ = 'https://www.google-analytics.com/collect';


/**
 * The maximum number of characters that can be included in the POST payload.
 * @private {number}
 */
analytics.MAX_POST_LENGTH_ = 8192;


/**
 * @private {!goog.structs.Map.<string,
 *     analytics.internal.GoogleAnalyticsService>}
 */
analytics.serviceInstances_ = new goog.structs.Map();


/**
 * @private {!analytics.internal.Settings}
 */
analytics.settings_;


/**
 * @private {!analytics.internal.ChannelManager.Factory}
 */
analytics.channelFactory_;


/**
 * Resets the global runtime state for the purposes of testing.
 *
 * @suppress {checkTypes}
 */
analytics.resetForTesting = function() {
  if (!goog.isObject(analytics.settings_)) {
    throw new Error('Invalid analytics.settings_');
  }
  analytics.settings_.dispose();
  analytics.settings_ = undefined;
  analytics.channelFactory_ = undefined;
  analytics.serviceInstances_ = new goog.structs.Map();
};


/**
 * Returns a service instance for the named Chrome Platform App/Extension.
 * Generally you'll only ever want to call this with a single name that
 * identifies the host Chrome Platform App/Extension or extension using the
 * library. This name is used to scope hits to your app on Google Analytics.
 *
 * @param {string} appName The name of your Chrome Platform App/Extension.
 *     Though library could read the name of the app from the chrome manifest
 *     file as it does with the app version, the name may in fact be translated.
 * @param {string=} opt_appVersion An optional app version.  If provided, this
 *     overrides the default app version (which is read from the app manifest).
 *
 * @return {!analytics.GoogleAnalytics}
 */
analytics.getService = function(appName, opt_appVersion) {
  var service = analytics.serviceInstances_.get(appName, null);
  var appVersion = opt_appVersion || analytics.getAppVersion_();
  if (service === null) {
    service = analytics.createService_(appName, appVersion);
    analytics.serviceInstances_.set(appName, service);
  }
  return service;
};


/**
 * @return {!analytics.internal.Settings}
 * @private
 */
analytics.getSettings_ = function() {
  if (!analytics.settings_) {
    analytics.settings_ = new analytics.internal.ServiceSettings(
        new analytics.internal.ChromeStorage());
  }

  return analytics.settings_;
};


/**
 * @param {string} appName
 * @param {string} appVersion
 *
 * @return {!analytics.internal.GoogleAnalyticsService}
 * @private
 */
analytics.createService_ = function(appName, appVersion) {
  return new analytics.internal.GoogleAnalyticsService(
      analytics.LIBRARY_VERSION,
      appName,
      appVersion,
      analytics.getSettings_(),
      analytics.getChannelFactory_());
};


/**
 * @return {string} version number
 * @private
 */
analytics.getAppVersion_ = function() {
  var manifest = chrome.runtime.getManifest();
  return manifest.version;
};


/**
 * @return {!analytics.internal.ChannelManager.Factory}
 * @private
 */
analytics.getChannelFactory_ = function() {
  if (!analytics.channelFactory_) {
    var settings = analytics.getSettings_();
    analytics.channelFactory_ =
        new analytics.internal.ServiceChannelManager.Factory(
            settings,
            new analytics.internal.SharedChannelFactory(
                settings,
                analytics.GA_SERVER_,
                analytics.MAX_POST_LENGTH_));
  }
  return analytics.channelFactory_;
};


/**
 * The "protocol" portion of URLs in Chrome Apps.
 * @private {string}
 */
analytics.CHROME_APP_PROTOCOL_ = 'chrome-extension:';

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/googleanalytics.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.GoogleAnalytics');
goog.module.declareLegacyNamespace();
const AnalyticsGoogleAnalytics = goog.requireType('analytics.GoogleAnalytics');
const Tracker = goog.requireType('analytics.Tracker');
const getService = goog.require('analytics.getService');

/**
 * The Google Analytics object for recovery tool.
 * @unrestricted
 */
const GoogleAnalytics = class {
  constructor() {
    /**
     * Create a service instance for Google Analytics.
     * @private {!AnalyticsGoogleAnalytics}
     */
    this.analyticsService_ =
        this.analyticsService_ || getService('cros_recovery_tool');

    /**
     * Create a tracker instance for Google Analytics.
     * @private {!Tracker}
     */
    this.tracker_ =
        this.tracker_ || this.analyticsService_.getTracker('UA-51966559-1');

    // Initialize Google Analytics.
    if (chrome.metricsPrivate &&
        chrome.metricsPrivate.getIsCrashReportingEnabled) {
      chrome.metricsPrivate.getIsCrashReportingEnabled(this.initAnalytics_);
    } else {
      // Disable Google Analytics by default.
      this.initAnalytics_(false);
    }
  }

  /**
   * Method to initialize Google Analytics.
   *
   * @param {boolean} enabled Whether Google Analytics is enabled.
   * @private
   */
  initAnalytics_(enabled) {
    // Enable/disable Google Analytics. In dev mode, this.analyticsService_
    // could be None.
    if (this.analyticsService_) {
      this.analyticsService_.getConfig().addCallback(function(config) {
        config.setTrackingPermitted(enabled);
      });
    }
  }

  /**
   * Set the dimension chromeVersion for Google Analytics.
   *
   * @param {string} chromeVersion The version of Chrome.
   */
  setDimensionChromeVersion(chromeVersion) {
    this.tracker_.set('dimension1', chromeVersion);
  }

  /**
   * Set the dimension appVersion for Google Analytics.
   *
   * @param {string} appVersion The version of the recovery tool.
   */
  setDimensionAppVersion(appVersion) {
    this.tracker_.set('dimension2', appVersion);
  }

  /**
   * Set the dimension platform for Google Analytics.
   *
   * @param {string} platform The platform (Mac, Windows, etc) on which the
   * recovery tool is running.
   */
  setDimensionPlatform(platform) {
    this.tracker_.set('dimension3', platform);
  }

  /**
   * Set the dimension driveModel for Google Analytics.
   *
   * @param {string} driveModel The model of the drive.
   */
  setDimensionDriveModel(driveModel) {
    this.tracker_.set('dimension4', driveModel);
  }

  /**
   * Set the dimension driveType for Google Analytics.
   * TODO(andycai) Investigate more to see if we can get drive type (SD vs USB).
   * @param {string} driveType The type of the drive.
   */
  setDimensionDriveType(driveType) {
    this.tracker_.set('dimension5', driveType);
  }

  /**
   * Set the dimension targetChromebookHwid for Google Analytics.
   *
   * @param {string} targetChromebookHwid The hwid of Chromebook to
   * be recovered.
   */
  setDimensionTargetChromebookHwid(targetChromebookHwid) {
    this.tracker_.set('dimension6', targetChromebookHwid);
  }

  /**
   * Set the dimension selectionMethod for Google Analytics.
   *
   * @param {string} selectionMethod The method of selecting device/image.
   */
  setDimensionSelectionMethod(selectionMethod) {
    this.tracker_.set('dimension7', selectionMethod);
  }

  /**
   * Set the dimension targetChromebookModel for Google Analytics.
   *
   * @param {string} targetChromebookModel The model of Chromebook to
   * be recovered.
   */
  setDimensionTargetChromebookModel(targetChromebookModel) {
    this.tracker_.set('dimension8', targetChromebookModel);
  }

  /**
   * Set the dimension errorReason for Google Analytics.
   *
   * @param {string} errorReason The reason that recovery failed.
   */
  setDimensionErrorReason(errorReason) {
    this.tracker_.set('dimension9', errorReason);
  }

  /**
   * Set the dimension driveCapacity for Google Analytics.
   *
   * @param {string} driveCapacity The capacity of the drive.
   */
  setDimensionDriveCapacity(driveCapacity) {
    this.tracker_.set('dimension10', driveCapacity);
  }

  /**
   * Set the dimension driveIsRemovable for Google Analytics.
   *
   * @param {boolean} driveIsRemovable True if the drive indicates
   *     itself as removable.
   */
  setDimensionDriveIsRemovable(driveIsRemovable) {
    this.tracker_.set('dimension11', driveIsRemovable.toString());
  }

  /**
   * Set the dimension appType for Google Analytics.
   *
   * @param {string} appType The Chrome app type.
   */
  setDimensionAppType(appType) {
    this.tracker_.set('dimension12', appType);
  }

  /**
   * Send a page view to Google Analytics.
   *
   * @param {string} pageView The name of current page view.
   */
  sendPageView(pageView) {
    this.tracker_.sendAppView(pageView);
  }

  /**
   * Send timing to Google Analytics.
   *
   * @param {string} timingVar The string to identify the variable being
   *  recorded.
   * @param {number} timingVal The number of milliseconds in elapsed time.
   */
  sendTiming(timingVar, timingVal) {
    this.tracker_.sendTiming(
        GoogleAnalytics.TIMING_CATEGORY_RECOVERY, timingVar, timingVal);
  }

  /**
   * Send failed_download_recovery_json event to Google Analytics.
   */
  sendFailedDownloadRecoveryJsonEvent() {
    this.tracker_.sendEvent(
        GoogleAnalytics.eventCategory.FAILED_DOWNLOAD_RECOVERY_JSON,
        GoogleAnalytics.eventAction.FAILED_DOWNLOAD_RECOVERY_JSON);
  }

  /**
   * Send image_writer_error event to Google Analytics.
   */
  sendImageWriterErrorEvent() {
    this.tracker_.sendEvent(
        GoogleAnalytics.eventCategory.IMAGE_WRITER_ERROR,
        GoogleAnalytics.eventAction.IMAGE_WRITER_ERROR);
  }
};

/**
 * Event Category
 * @enum {string}
 */
GoogleAnalytics.eventCategory = {
  FAILED_DOWNLOAD_RECOVERY_JSON: 'failed_download_recovery_json',
  IMAGE_WRITER_ERROR: 'image_writer_error'
};

/**
 * Event Action
 * @enum {string}
 */
GoogleAnalytics.eventAction = {
  FAILED_DOWNLOAD_RECOVERY_JSON: 'failed_download_recovery_json',
  IMAGE_WRITER_ERROR: 'image_writer_error'
};

/**
 * Timing Category
 * @type {string}
 */
GoogleAnalytics.TIMING_CATEGORY_RECOVERY = 'recovery_timing';

/**
 * Timing Variable
 * @enum {string}
 */
GoogleAnalytics.timingVar = {
  DOWNLOAD_RECOVERY_JSON: 'download_recovery_json',
  DOWNLOAD_IMAGE: 'download_image',
  UNPACK_IMAGE: 'unpack_image',
  VERIFY_DOWNLOADED_IMAGE: 'verify_downloaded_image',
  BURN_IMAGE: 'burn_image',
  VERIFY_BURNED_IMAGE: 'verify_burned_image'
};

/**
 * Page View
 * @enum {string}
 */
GoogleAnalytics.pageView = {
  FIRST_PAGE: 'first_page',
  WELCOME_PAGE: 'welcome_page',
  UNSUPPORTED_PAGE: 'unsupported_page',
  SELECT_DEVICE_PAGE: 'select_device_page',
  SELECT_TARGET_PAGE: 'select_target_page',
  WRITE_CONFIRM_PAGE: 'write_confirm_page',
  WRITE_PAGE: 'write_page',
  WRITE_COMPLETE_PAGE: 'write_complete_page',
  ERASE_SELECT_TARGET_PAGE: 'erase_select_target_page',
  ERASE_CONFIRM_PAGE: 'erase_confirm_page',
  ERASE_PAGE: 'erase_page',
  ERASE_COMPLETE_PAGE: 'erase_complete_page'
};

/**
 * Selection Methods
 * @enum {string}
 */
GoogleAnalytics.selection = {
  HWID: 'HWID',
  MODEL: 'Model',
  LOCAL_IMAGE: 'LocalImage'
};

/**
 * Selection Methods
 * @enum {string}
 */
GoogleAnalytics.appType = {
  CHROMEBOOK: 'Chromebook',
  ONHUB: 'OnHub',
  WORKSPACE_HARDWARE: 'WorkspaceHardware'
};

exports = GoogleAnalytics;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/types.js
/**
 * @fileoverview Common type definitions.
 * @suppress {useOfGoogProvide}
 */

goog.provide('recovery.AppConfig');
goog.provide('recovery.Capabilities');
goog.provide('recovery.DeviceInfo');
goog.provide('recovery.DeviceInfoChromebook');
goog.provide('recovery.DeviceInfoDummy');
goog.provide('recovery.DeviceInfoLocal');
goog.provide('recovery.Platform');
goog.provide('recovery.Runtime');
goog.provide('recovery.Stage');


/**
 * Alias for DeviceInfo of a dummy device.
 * @typedef {{name: string, photourl: string}}
 */
recovery.DeviceInfoDummy;


/**
 * Alias for DeviceInfo of a chromebook.
 * @typedef {{
 *     manufacturer: string,
 *     model: string,
 *     name: string,
 *     photourl: ?string,
 *     hwids: !Array<string>,
 *     filesize: number,
 *     url: string,
 *     md5: string,
 *     local: boolean,
 *     hwidmatch: string,
 *     hwidMatchRegExp: ?RegExp,
 *     modelFamilies: ?goog.structs.Set
 * }}
 */
recovery.DeviceInfoChromebook;


/**
 * Alias for DeviceInfo of a chromebook.
 * @typedef {{
 *     file: !Entry,
 *     name: string,
 *     photourl: string,
 *     local: boolean
 * }}
 */
recovery.DeviceInfoLocal;


/**
 * Alias for device info as stored in our recovery config files.
 * @typedef {!recovery.DeviceInfoDummy|!recovery.DeviceInfoChromebook|
 *           !recovery.DeviceInfoLocal}
 */
recovery.DeviceInfo;

/**
 * A record of what capabilities the browser has.
 * @typedef {{destroyPartitions: boolean, platform: !recovery.Platform,
 *            saveAsDownload: boolean, writeImage: boolean,
 *            runtime: !recovery.Runtime}}
 */
recovery.Capabilities;


/**
 * Possible platforms the app is running on, for capability detection.
 * @enum {string}
 */
recovery.Platform = {
  LINUX: 'Linux',
  CHROMEOS: 'CrOS',
  MAC: 'Mac',
  WIN: 'Windows',
  OTHER: 'Unknown Platform'
};


/**
 * Possible stage identifiers.
 * @enum {string}
 */
recovery.Stage = {
  UNKNOWN: 'unknown',
  DOWNLOAD: 'download',
  VERIFY_DOWNLOAD: 'verifyDownload',
  UNZIP: 'unzip',
  WRITE: 'write',
  VERIFY_WRITE: 'verifyWrite',
  COMPLETE: 'complete'
};

/**
 * Possible application runtimes.
 * @enum {string}
 */
recovery.Runtime = {
  CHROME_APP: 'chromeApp',
  EXTENSION: 'extension'
};

/**
 * AppConfig is application configuration for each app types.
 * @typedef {{
 *     messageCatalogPostfix: string,
 *     recovery_config_url: string,
 *     imageMap: !Object<string,string>,
 *     analyticsAppType: string,
 *     allowPopulateUsingModelNumber: boolean,
 *     sampleHwid: string,
 *     allowSelectByHwid: boolean,
 *     selectByModelFirst: boolean
 * }}
 */
recovery.AppConfig;

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/imagewriterprivate_stub.js
/**
 * @fileoverview A stub API to emulate the Chrome Recovery Image API for
 * development.  See http://go/imagewriterprivateapi.
 *
 * In order to allow this stub to be tested without having to load it over the
 * actual chrome API, we place it in its own namespace.  Then if chrome does not
 * have the ImageWriterPrivate API we install the stub.
 */

goog.require('goog.array');
goog.require('goog.object');
goog.require('recovery.Stage');

goog.provide('recovery.ChromeEventStub');
goog.provide('recovery.ImageWriterPrivateStub');

goog.scope(function() {


/**
 * A stub API to fake the chrome.imageWriterPrivate API.
 * @unrestricted
 */
recovery.ImageWriterPrivateStub = class {
  constructor() {
    /**
     * An event that signifies a drive was attached.
     * @const {!ChromeEventStub}
     */
    this.onDeviceAttached = new recovery.ChromeEventStub();
    /**
     * An event that signifies a drive was removed.
     * @const {!ChromeEventStub}
     */
    this.onDeviceRemoved = new recovery.ChromeEventStub();
    /**
     * An event that is periodically triggered as the operation progresses.
     * @const {!ChromeEventStub}
     */
    this.onWriteProgress = new recovery.ChromeEventStub();
    /**
     * An even that triggers when the operation is complete.
     * @const {!ChromeEventStub}
     */
    this.onWriteComplete = new recovery.ChromeEventStub();
    /**
     * An even that triggers when there is an error during an operation.
     * @const {!ChromeEventStub}
     */
    this.onWriteError = new recovery.ChromeEventStub();


    /**
     * The first position in the drive list to expose.
     * @private {number}
     */
    this.firstDrive_ = 0;
    /**
     * The number of devices to expose.
     * @type {number}
     */
    this.numExposedDrives = 2;
    /**
     * The ID of the interval that triggers the changing of exposed drives.
     * @private {?number}
     */
    this.driveIntervalId_ = null;
    /**
     * The ID of the interval that triggers the progress updates.
     * @private {?number}
     */
    this.progressIntervalId_ = null;
    /**
     * The stage of the current operation.
     * @private {recovery.Stage}
     */
    this.progressStage_ = recovery.Stage.UNKNOWN;
    /**
     * The progress of the current stage, as a percentage.
     * @private {number}
     */
    this.progressPercent_ = 0;
    /**
     * The stages the operation has pending.
     * @private {!Array.<recovery.Stage>}
     */
    this.stagesRemaining_ = [];
    /**
     * The drive for the current operation request, if any.
     * @private {?string}
     */
    this.writeDrive_ = null;


    /**
     * The name of the write stage to have a fail on.
     * @private {?recovery.Stage}
     */
    this.failOnStage_ = null;
    /**
     * The percentage at which that stage will fail, [0,100].
     * @private {number}
     */
    this.failOnPercent_ = 0;
    /**
     * The error code of the failure.
     * @private {string}
     */
    this.failureErrorMessage_ = 'TESTING';
  }

  /**
   * Starts rotating the drives, keeping two active at all times and
   * rotating through all the drives.
   */
  rotateDrives() {
    this.driveIntervalId_ = window.setInterval(goog.bind(function() {
      this.onDeviceRemoved.trigger(
          ImageWriterPrivateStub.DRIVES_[this.firstDrive_]);
      this.onDeviceAttached.trigger(
          ImageWriterPrivateStub.DRIVES_
              [(this.firstDrive_ + this.numExposedDrives) %
               ImageWriterPrivateStub.DRIVES_.length]);
      this.firstDrive_ =
          (this.firstDrive_ + 1) % ImageWriterPrivateStub.DRIVES_.length;
    }, this), ImageWriterPrivateStub.DRIVE_ROTATION_DELAY_MS_);
  }

  /**
   * Stops drive rotation.
   */
  freezeDrives() {
    window.clearInterval(this.driveIntervalId_);
  }

  /**
   * Sets the API to throw an error.
   * @param {recovery.Stage} stage The stage to fail on.
   * @param {number} percent The percentage to fail at.
   * @param {string} message The error message to return.
   */
  failOn(stage, percent, message) {
    this.failOnStage_ = stage;
    this.failOnPercent_ = percent;
    this.failureErrorMessage_ = message;
  }

  /**
   * Retrieves a list of available DRIVES_.
   *
   * @param {function(!chrome.imageWriterPrivate.DriveList)} callback A callback
   *     that receives the list of drives.
   */
  listRemovableStorageDevices(callback) {
    var result = [];

    for (var i = 0; i < this.numExposedDrives; i++) {
      var index =
          (this.firstDrive_ + i) % ImageWriterPrivateStub.DRIVES_.length;
      // Clone each drive, to simulate how the real ImageWriterPrivateStub
      // returns a list of new drive objects.
      result.push(goog.object.clone(ImageWriterPrivateStub.DRIVES_[index]));
    }
    // Simulate API semantics.
    window.setTimeout(function() {
      callback(result);
    }, ImageWriterPrivateStub.CALLBACK_DELAY_MS_);
  }

  /**
   * Begins writing an image from a URL.
   *
   * @param {string} devId The ID of the drive to write to.
   * @param {string} url The URL of the image to write.
   * @param {!Object} options Extra options for the ImageWriterPrivateStub.
   * @param {function()} callback Callback to indicate when the write starts.
   */
  writeFromUrl(devId, url, options, callback) {
    if (this.writeDrive_) {
      return;
    }

    this.writeDrive_ = devId;

    this.stagesRemaining_ = [
      recovery.Stage.DOWNLOAD, recovery.Stage.VERIFY_DOWNLOAD,
      recovery.Stage.UNZIP, recovery.Stage.WRITE, recovery.Stage.VERIFY_WRITE,
      recovery.Stage.COMPLETE
    ];

    this.progressIntervalId_ = window.setInterval(
        goog.bind(this.makeProgress_, this),
        ImageWriterPrivateStub.PROGRESS_UPDATE_DELAY_MS_);

    // Simulate API semantics.
    window.setTimeout(callback, ImageWriterPrivateStub.CALLBACK_DELAY_MS_);
  }

  /**
   * Begins writing an image from a local file.
   *
   * @param {string} devId The ID of the drive to write to.
   * @param {!Object} file The FileEntry to write.
   * @param {function()} callback Callback to indicate when the write starts.
   */
  writeFromFile(devId, file, callback) {
    if (this.writeDrive_) {
      return;
    }

    this.writeDrive_ = devId;

    this.stagesRemaining_ = [
      recovery.Stage.WRITE, recovery.Stage.VERIFY_WRITE, recovery.Stage.COMPLETE
    ];

    this.progressIntervalId_ = window.setInterval(
        goog.bind(this.makeProgress_, this),
        ImageWriterPrivateStub.PROGRESS_UPDATE_DELAY_MS_);

    // Simulate API semantics.
    window.setTimeout(callback, ImageWriterPrivateStub.CALLBACK_DELAY_MS_);
  }

  /**
   * Cancels an in-process write.
   *
   * @param {function()} callback Callback called when the cancel completes.
   */
  cancelWrite(callback) {
    this.cleanUpAfterWrite_();
    window.setTimeout(callback, ImageWriterPrivateStub.CALLBACK_DELAY_MS_);
  }

  /**
   * Erases a drive.
   *
   * @param {string} devId The target of the operation.
   * @param {function()} callback The callback that indicates a successful
   *     start.
   */
  destroyPartitions(devId, callback) {
    if (this.writeDrive_) {
      return;
    }

    this.writeDrive_ = devId;

    this.stagesRemaining_ = [recovery.Stage.WRITE, recovery.Stage.COMPLETE];

    this.progressIntervalId_ = window.setInterval(
        goog.bind(this.makeProgress_, this),
        ImageWriterPrivateStub.PROGRESS_UPDATE_DELAY_MS_);

    // Simulate API semantics.
    window.setTimeout(callback, ImageWriterPrivateStub.CALLBACK_DELAY_MS_);
  }

  /**
   * @return {{stage: recovery.Stage,
   *           percentComplete: number}} The current writing state.
   * @private
   */
  getWriteState_() {
    return {stage: this.progressStage_, percentComplete: this.progressPercent_};
  }

  /**
   * Cleans up the writer so it doesn't think another operation is in progress.
   * @private
   */
  cleanUpAfterWrite_() {
    window.clearInterval(this.progressIntervalId_);
    this.writeDrive_ = null;
    this.progressStage_ = recovery.Stage.UNKNOWN;
    this.progressPercent_ = 0;
    this.stagesRemaining_ = [];
  }

  /**
   * Advances the write state by the @code{PROGRESS_UPDATE_STEP_} value,
   * advancing to the next stage or completing as necessary.
   * @private
   */
  makeProgress_() {
    if (this.progressStage_ == recovery.Stage.UNKNOWN) {
      this.progressStage_ = this.stagesRemaining_.shift();
      this.progressPercent_ = 0;
    }

    if (this.progressStage_ == recovery.Stage.COMPLETE) {
      this.onWriteComplete.trigger(this.getWriteState_());
      this.cleanUpAfterWrite_();
      return;
    }

    if (this.failOnStage_ == this.progressStage_ &&
        this.progressPercent_ >= this.failOnPercent_) {
      this.onWriteError.trigger(
          this.getWriteState_(), this.failureErrorMessage_);
      this.cleanUpAfterWrite_();
      return;
    }

    this.onWriteProgress.trigger(this.getWriteState_());

    this.progressPercent_ =
        this.progressPercent_ + ImageWriterPrivateStub.PROGRESS_UPDATE_STEP_;

    if (this.progressPercent_ > 100) {
      this.progressStage_ = this.stagesRemaining_.shift();
      this.progressPercent_ = 0;
    }
  }
};
var ImageWriterPrivateStub = recovery.ImageWriterPrivateStub;


/**
 * The delay before callbacks are triggered.
 * @private {number}
 */
ImageWriterPrivateStub.CALLBACK_DELAY_MS_ = 10;


/**
 * The delay when rotating drives.
 * @private {number}
 */
ImageWriterPrivateStub.DRIVE_ROTATION_DELAY_MS_ = 10000;


/**
 * The delay between progress updates.
 * @private {number}
 */
ImageWriterPrivateStub.PROGRESS_UPDATE_DELAY_MS_ = 50;


/**
 * The amount to increase the progress counter by with each update, in
 * percentage points.
 * @private {number}
 */
ImageWriterPrivateStub.PROGRESS_UPDATE_STEP_ = 10;


/**
 * Dummy drives.  Which of these will be exposed by the API is determined by
 * `this.firstDrive_` and `this.numExposedDrives`.
 * @private {!chrome.imageWriterPrivate.DriveList}
 */
ImageWriterPrivateStub.DRIVES_ = [
  {
    capacity: 7803174912,
    model: 'DataTraveler 2.0',
    storageUnitId: '/dev/sdb',
    vendor: 'Kingston'
  },
  {
    capacity: 3901587456,
    model: 'Cruzer',
    storageUnitId: '/dev/sdc',
    vendor: 'SanDisk'
  },
  {
    capacity: 3901587456,
    model: 'Store \'n\' Go',
    storageUnitId: '/dev/sdd',
    vendor: 'Verbatim'
  },
  {
    capacity: 215606349824,
    model: 'Extreme',
    storageUnitId: '/dev/sde',
    vendor: 'SanDisk'
  }
];


/**
 * A stub version of Chrome's built in events.  An instance of this class can be
 * used instead of a native chrome event and should support the same interface
 * but with the addition of the `trigger` function which will call all the
 * event listeners.
 * @unrestricted
 */
recovery.ChromeEventStub = class {
  constructor() {
    /**
     * The list of listeners on this event.
     * @private {!Array.<recovery.ChromeEventStub.Callback>}
     */
    this.listeners_ = [];
  }

  /**
   * Triggers an event which calls all listeners of that event with any
   * arguments provided.
   * @param {...*} var_args
   */
  trigger(var_args) {
    var args = arguments;
    this.listeners_.forEach(function(listener) {
      listener.apply(undefined, args);
    });
  }

  /**
   * Adds a listener to this event.
   * @param {ChromeEventStub.Callback} listener The listener function.
   */
  addListener(listener) {
    this.listeners_.push(listener);
  }

  /**
   * Removes a listener from this event.
   * @param {ChromeEventStub.Callback} listener The listener function.
   */
  removeListener(listener) {
    goog.array.remove(this.listeners_, listener);
  }

  /**
   * @param {ChromeEventStub.Callback} listener The listener function.
   * @return {boolean} Whether the listener has been added to this event.
   */
  hasListener(listener) {
    return this.listeners_.indexOf(listener) >= 0;
  }

  /**
   * @return {boolean} Whether this event has any listener.
   */
  hasListeners() {
    return this.listeners_.length > 0;
  }
};
var ChromeEventStub = recovery.ChromeEventStub;


/**
 * The type of a callback/listener.  Since we do not know the data an arbitrary
 * event will provide we cannot be more precise in our types.
 * @typedef {function(...*)}
 */
ChromeEventStub.Callback;
});  // goog.scope

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/recovery.js
/**
 * @fileoverview Initialization of app-wide constants and information.
 * @suppress {useOfGoogProvide}
 */

goog.provide('recovery');
goog.provide('recovery.appConfig');
goog.provide('recovery.devices');
goog.provide('recovery.logger');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.log');
goog.require('goog.string');
goog.require('recovery.GoogleAnalytics');
goog.require('recovery.ImageWriterPrivateStub');
goog.require('recovery.Platform');
goog.require('recovery.Runtime');
goog.requireType('recovery.AppConfig');
goog.requireType('recovery.Capabilities');
goog.requireType('recovery.DeviceInfo');
goog.requireType('recovery.DeviceInfoDummy');

/** @const {?goog.log.Logger} */
recovery.logger = goog.log.getLogger('recovery');


/**
 * Installs the stub API for testing when it is not available.
 * @suppress {checkTypes} The API is untyped.
 */
recovery.installImageWriterStub = function() {
  chrome.imageWriterPrivate = new recovery.ImageWriterPrivateStub();
  goog.log.warning(
      recovery.logger, 'You are using the ImageWriterPrivate stub API.');
};

if (!chrome.imageWriterPrivate) {
  recovery.installImageWriterStub();
}


/**
 * Detects the current capabilities of the browser.
 * @return {!recovery.Capabilities}
 */
recovery.probeCapabilities = function() {
  let milestone = parseInt(
      goog.string.splitLimit(
          goog.labs.userAgent.browser.getVersion(), '.', 1)[0],
      10);
  if (isNaN(milestone)) {
    milestone = 0;
  }

  let platform = recovery.Platform.OTHER;
  if (goog.labs.userAgent.platform.isChromeOS()) {
    platform = recovery.Platform.CHROMEOS;
  } else if (goog.labs.userAgent.platform.isLinux()) {
    platform = recovery.Platform.LINUX;
  } else if (goog.labs.userAgent.platform.isMacintosh()) {
    platform = recovery.Platform.MAC;
  } else if (goog.labs.userAgent.platform.isWindows()) {
    platform = recovery.Platform.WIN;
  }

  // Chrome Extensions don't have chrome.app.window available, use it for
  // platform detection.
  const runtime = chrome.app && chrome.app['window'] ?
      recovery.Runtime.CHROME_APP :
      recovery.Runtime.EXTENSION;

  return {
    platform: platform,
    writeImage: (platform == recovery.Platform.CHROMEOS ||
                platform == recovery.Platform.WIN ||
                (platform == recovery.Platform.MAC && milestone >= 37)),
    destroyPartitions: milestone >= 36,
    saveAsDownload: false,
    runtime: runtime
  };
};


/**
 * The current API capabilities determined by chrome version.
 * @const {!recovery.Capabilities}
 */
recovery.CAPABILITIES = recovery.probeCapabilities();


/**
 * Gets the configuration when working as Chromebook recovery app.
 * @return {!recovery.AppConfig}
 * @private
 */
function getAppConfigForChromebook_() {
  return {
    messageCatalogPostfix: '',
    recovery_config_url: '' +
        'https://dl.google.com/dl/edgedl/chromeos/recovery/recovery.json',
    imageMap: {
      'Acer C7 Chromebook': 'img/devices/parrot.jpg',
      'Acer C7 Chromebook IVB': 'img/devices/parrot.jpg',
      'Acer AC700-1099 Wifi': 'img/devices/zgb.jpg',
      'Acer AC700-1529 3G': 'img/devices/zgb.jpg',
      'Acer C720 Chromebook': 'img/devices/peppy.jpg',
      'ASUS Chromebox': 'img/devices/panther.jpg',
      'Cr-48': 'img/devices/mario.jpg',
      'Dell Chromebook 11': 'img/devices/wolf.jpg',
      'Google Chromebook Pixel': 'img/devices/link.jpg',
      'HP Pavilion Chromebook 14': 'img/devices/butterfly.jpg',
      'HP Chromebook 14 q000-q099 / HP Chromebook 14-SMB Atheros': '' +
          'img/devices/falco.jpg',
      'HP Chromebook 14 q000-q099 WP2 / HP Chromebook 14-SMB Intel Corp':
          'img/devices/falco.jpg',
      'HP Chromebook 11 1100-1199 / HP Chromebook 11 G1': '' +
          'img/devices/spring.jpg',
      'HP Chromebox CB1-(000-099) / HP Chromebox G1': '' +
          'img/devices/zako.jpg',
      'Lenovo Thinkpad X131e Chromebook': 'img/devices/stout.jpg',
      'Samsung Chromebook': 'img/devices/snow.jpg',
      'Samsung Chromebook Series 5 Non-US-Wifi': 'img/devices/alex.jpg',
      'Samsung Chromebook Series 5 Non-US 3G': 'img/devices/alex.jpg',
      'Samsung Chromebook Series 5 US-Wifi': 'img/devices/alex.jpg',
      'Samsung Chromebook Series 5 US-3G': 'img/devices/alex.jpg',
      'Samsung Chromebook Series 5 550': 'img/devices/lumpy.jpg',
      'Samsung Chromebox Series 3': 'img/devices/stumpy.jpg',
      'Toshiba Chromebook': 'img/devices/leon.jpg'
    },
    analyticsAppType: recovery.GoogleAnalytics.appType.CHROMEBOOK,
    allowPopulateUsingModelNumber: true,
    sampleHwid: 'LINK DALE A-C 1126',
    allowSelectByHwid: true,
    selectByModelFirst: false
  };
}


/**
 * Gets the configuration when working as OnHub recovery app.
 * @return {!recovery.AppConfig}
 * @private
 */
function getAppConfigForOnHub_() {
  return {
    messageCatalogPostfix: '_ON_HUB',
    recovery_config_url:
        'https://dl.google.com/dl/edgedl/chromeos/recovery/onhub_recovery.json',
    imageMap: {
      'OnHub TGR 1900': 'img/devices/whirlwind.jpg',
      'OnHub SRT-AC1900': 'img/devices/arkham.jpg'
    },
    analyticsAppType: recovery.GoogleAnalytics.appType.ONHUB,
    allowPopulateUsingModelNumber: false,
    sampleHwid: 'WHIRLWIND A-C 1126',
    allowSelectByHwid: false,
    selectByModelFirst: true
  };
}

/**
 * Gets the configuration when working as the Meet Compute System recovery app.
 * @return {!recovery.AppConfig}
 * @private
 */
function getAppConfigForWorkspaceHardware_() {
  return {
    messageCatalogPostfix: '_WORKSPACE_HARDWARE',
    recovery_config_url:
        'https://dl.google.com/dl/edgedl/chromeos/recovery/workspaceHardware_recovery.json',
    imageMap: {
      'Acer Chromebase 24': 'img/devices/buddy.png',
      'Meet Compute System - Series One': 'img/devices/endeavour.png',
      'Asus Meet Compute System': 'img/devices/excelsior.png',
      'CTL Meet Compute System': 'img/devices/excelsior.png',
      'ASUS Chromebox 3 (CN65)': 'img/devices/teemo.png',
      'CTL Chromebox CBx1': 'img/devices/wukong.png',
      'Acer Chromebase CA24I2': 'img/devices/karma.png',
    },
    analyticsAppType: recovery.GoogleAnalytics.appType.WORKSPACE_HARDWARE,
    allowPopulateUsingModelNumber: false,
    sampleHwid: 'ENDEAVOUR A-C 1126',
    allowSelectByHwid: true,
    selectByModelFirst: false
  };
}

/**
 * Gets the app configuration.
 * @return {!recovery.AppConfig}
 * @private
 */
function getAppConfig_() {
  const isOnHub =
      (window['appType'] == 'OnHub' || window.location.search == '?OnHub');
  const isWorkspaceHardware =
      (window['appType'] == 'WorkspaceHardware' ||
       window.location.search == '?WorkspaceHardware');
  console.log('App running in OnHub mode:' + isOnHub);
  if (isOnHub) {
    return getAppConfigForOnHub_();
  } else if (isWorkspaceHardware) {
    return getAppConfigForWorkspaceHardware_();
  } else {
    return getAppConfigForChromebook_();
  }
}


/**
 * Application configuration based on application types.
 * @const {!recovery.AppConfig}
 * @export
 */
recovery.appConfig = getAppConfig_();

/**
 * A dummy device displayed before a HWID is entered.
 * @const {!recovery.DeviceInfoDummy}
 * @export
 */
recovery.DUMMY_DEVICE = {
  name: '',
  photourl: 'img/devices/unknown.png'
};


/**
 * Image to be displayed if no specific device image is found.
 * @const {string}
 * @export
 */
recovery.UNKNOWN_DEVICE_IMAGE = 'img/devices/unknown.png';

/**
 * URL for the recovery config file.
 * @const {string}
 * @export
 */
recovery.RECOVERY_CONFIG_URL = recovery.appConfig.recovery_config_url;


/**
 * A map from HWID to hardware model used when a HWID is entered.
 * @type {!Object<string, ?recovery.DeviceInfo>}
 * @export
 */
recovery.hwidMap = {};


/**
 * A list of devices.
 * @type {!Array<?recovery.DeviceInfo>}
 * @export
 */
recovery.devices = [];


/**
 * A list of manufacturers to display in the 'select device by make/model' flow.
 * @type {!Object<string, !Object<string, ?recovery.DeviceInfo>>}
 * @export
 */
recovery.oems = {};


// TODO(stephenlin): Populate image urls in recovery.json file so that this
// map isn't needed. crbug.com/423918
/**
 * The map of devices to images.
 * Update recovery.json to provide this information.
 * @type {!Object<string, string>}
 * @export
 */
recovery.imageMap = recovery.appConfig.imageMap;


/**
 * Gets the device that matches the HWID if there is one.
 *
 * @param {string} hwid The HWID to check.
 * @return {?recovery.DeviceInfo}
 */
recovery.getMatchingDevice = function(hwid) {
  const matchingDevices = recovery.devices.filter(function(device) {
    return device.hwidMatchRegExp && device.hwidMatchRegExp.test(hwid);
  });

  // NOTE: If more than one match then user has not entered enough of the
  // HWID to distinguish.
  if (matchingDevices.length == 1) {
    return matchingDevices[0];
  }

  // Check for exact match.
  return recovery.hwidMap[hwid];
};


/**
 * Returns true if the hwid is a valid model family (e.g. PEPPY).
 * @param {string} hwid The HWID to check.
 * @return {boolean}
 */
recovery.isValidModelFamilyPrefix = function(hwid) {
  for (let d = 0; d < recovery.devices.length; d++) {
    const device = recovery.devices[d];
    const modelFamilies = device.modelFamilies.getValues();
    for (let p = 0; p < modelFamilies.length; p++) {
      const prefix = modelFamilies[p];
      // Check prefix in both directions. e.g.:
      //   "LINK" starts with hwid entry "L"
      //   HWID entry "LINK DALE" starts with "LINK".
      if (goog.string.startsWith(hwid, prefix) ||
          goog.string.startsWith(prefix, hwid)) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Returns the analytics model token from device. If the device has a
 * list of valid HWIDs, the model is parsed from the first HWID as the first
 * token. Otherwise, the HWID regex pattern is parsed to extract the first
 * token as the analytics model.
 *
 * @param {?recovery.DeviceInfo} device a device object.
 * @return {?string} the analytics model token.
 */
recovery.getDeviceAnalyticsModel = function(device) {
  let model = null;
  if (device) {
    if (device.hwids && device.hwids.length > 0) {
      model = device.hwids[0].split(' ')[0];
    } else if (device.hwidMatchRegExp && device.hwidMatchRegExp.source) {
      const matches = /^\^?(\w+) .*/.exec(device.hwidMatchRegExp.source);
      if (matches && matches.length > 1) {
        model = matches[1];
      }
    }
  }
  return model;
};

//third_party/javascript/closure/structs/collection.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines the collection interface.
 */

goog.provide('goog.structs.Collection');



/**
 * An interface for a collection of values.
 * @interface
 * @template T
 */
goog.structs.Collection = function() {};


/**
 * @param {T} value Value to add to the collection.
 */
goog.structs.Collection.prototype.add;


/**
 * @param {T} value Value to remove from the collection.
 */
goog.structs.Collection.prototype.remove;


/**
 * @param {T} value Value to find in the collection.
 * @return {boolean} Whether the collection contains the specified value.
 */
goog.structs.Collection.prototype.contains;


/**
 * @return {number} The number of values stored in the collection.
 */
goog.structs.Collection.prototype.getCount;

//third_party/javascript/closure/structs/set.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Datastructure: Set.
 *
 *
 * This class implements a set data structure. Adding and removing is O(1). It
 * supports both object and primitive values. Be careful because you can add
 * both 1 and new Number(1), because these are not the same. You can even add
 * multiple new Number(1) because these are not equal.
 */


goog.provide('goog.structs.Set');

goog.require('goog.structs');
goog.require('goog.structs.Collection');
goog.require('goog.structs.Map');
goog.requireType('goog.iter.Iterator');

/**
 * A set that can contain both primitives and objects.  Adding and removing
 * elements is O(1).  Primitives are treated as identical if they have the same
 * type and convert to the same string.  Objects are treated as identical only
 * if they are references to the same object.  WARNING: A goog.structs.Set can
 * contain both 1 and (new Number(1)), because they are not the same.  WARNING:
 * Adding (new Number(1)) twice will yield two distinct elements, because they
 * are two different objects.  WARNING: Any object that is added to a
 * goog.structs.Set will be modified!  Because goog.getUid() is used to
 * identify objects, every object in the set will be mutated.
 * @param {Array<T>|Object<?,T>=} opt_values Initial values to start with.
 * @constructor
 * @implements {goog.structs.Collection<T>}
 * @implements {Iterable<T>}
 * @final
 * @template T
 * @deprecated This type is misleading: use ES6 Set instead.
 */
goog.structs.Set = function(opt_values) {
  'use strict';
  this.map_ = new goog.structs.Map();


  /**
   * The number of items in this set.
   * @const {number}
   */
  this.size = 0;

  if (opt_values) {
    this.addAll(opt_values);
  }
};

/**
 * A function that returns a unique id.
 * @private @const {function(?Object): number}
 */
goog.structs.Set.getUid_ = goog.getUid;


/**
 * Obtains a unique key for an element of the set.  Primitives will yield the
 * same key if they have the same type and convert to the same string.  Object
 * references will yield the same key only if they refer to the same object.
 * @param {*} val Object or primitive value to get a key for.
 * @return {string} A unique key for this value/object.
 * @private
 */
goog.structs.Set.getKey_ = function(val) {
  'use strict';
  var type = typeof val;
  if (type == 'object' && val || type == 'function') {
    return 'o' + goog.structs.Set.getUid_(/** @type {Object} */ (val));
  } else {
    return type.substr(0, 1) + val;
  }
};


/**
 * @return {number} The number of elements in the set.
 * @override
 * @deprecated Use the `size` property instead, for alignment with ES6 Set.
 */
goog.structs.Set.prototype.getCount = function() {
  'use strict';
  return this.map_.size;
};


/**
 * Add a primitive or an object to the set.
 * @param {T} element The primitive or object to add.
 * @override
 */
goog.structs.Set.prototype.add = function(element) {
  'use strict';
  this.map_.set(goog.structs.Set.getKey_(element), element);
  this.setSizeInternal_(this.map_.size);
};


/**
 * Adds all the values in the given collection to this set.
 * @param {Array<T>|goog.structs.Collection<T>|Object<?,T>} col A collection
 *     containing the elements to add.
 * @deprecated Use `goog.collections.sets.addAll(thisSet, col)` instead,
 *     converting Objects to their values using `Object.values`, for alignment
 *     with ES6 Set.
 */
goog.structs.Set.prototype.addAll = function(col) {
  'use strict';
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.add(values[i]);
  }
  this.setSizeInternal_(this.map_.size);
};


/**
 * Removes all values in the given collection from this set.
 * @param {Array<T>|goog.structs.Collection<T>|Object<?,T>} col A collection
 *     containing the elements to remove.
 * @deprecated Use `goog.collections.sets.removeAll(thisSet, col)` instead,
 *     converting Objects to their values using `Object.values`, for alignment
 *     with ES6 Set.
 */
goog.structs.Set.prototype.removeAll = function(col) {
  'use strict';
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.remove(values[i]);
  }
  this.setSizeInternal_(this.map_.size);
};


/**
 * Removes the given element from this set.
 * @param {T} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 */
goog.structs.Set.prototype.delete = function(element) {
  'use strict';
  const rv = this.map_.remove(goog.structs.Set.getKey_(element));
  this.setSizeInternal_(this.map_.size);
  return rv;
};

/**
 * Removes the given element from this set.
 * @param {T} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 * @override
 * @deprecated Use `delete`, for alignment with ES6 Set.
 */
goog.structs.Set.prototype.remove = function(element) {
  'use strict';
  return this.delete(element);
};


/**
 * Removes all elements from this set.
 */
goog.structs.Set.prototype.clear = function() {
  'use strict';
  this.map_.clear();
  this.setSizeInternal_(0);
};


/**
 * Tests whether this set is empty.
 * @return {boolean} True if there are no elements in this set.
 * @deprecated Use the size property and compare against 0, for alignment with
 *     ES6 Set.
 */
goog.structs.Set.prototype.isEmpty = function() {
  'use strict';
  return this.map_.size === 0;
};


/**
 * Tests whether this set contains the given element.
 * @param {T} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 */
goog.structs.Set.prototype.has = function(element) {
  'use strict';
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};

/**
 * Tests whether this set contains the given element.
 * @param {T} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 * @override
 * @deprecated Use `has` instead, for alignment with ES6 Set.
 */
goog.structs.Set.prototype.contains = function(element) {
  'use strict';
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};


/**
 * Tests whether this set contains all the values in a given collection.
 * Repeated elements in the collection are ignored, e.g.  (new
 * goog.structs.Set([1, 2])).containsAll([1, 1]) is True.
 * @param {goog.structs.Collection<T>|Object} col A collection-like object.
 * @return {boolean} True if the set contains all elements.
 * @deprecated Use `goog.collections.sets.hasAll(thisSet, col)`, converting
 *     Objects to arrays using Object.values, for alignment with ES6 Set.
 */
goog.structs.Set.prototype.containsAll = function(col) {
  'use strict';
  return goog.structs.every(col, this.contains, this);
};


/**
 * Finds all values that are present in both this set and the given collection.
 * @param {Array<S>|Object<?,S>} col A collection.
 * @return {!goog.structs.Set<T|S>} A new set containing all the values
 *     (primitives or objects) present in both this set and the given
 *     collection.
 * @template S
 * @deprecated Use `goog.collections.sets.intersection(thisSet, col)`,
 *     converting Objects to arrays using Object.values, instead for alignment
 *     with ES6 Set.
 */
goog.structs.Set.prototype.intersection = function(col) {
  'use strict';
  var result = new goog.structs.Set();

  var values = goog.structs.getValues(col);
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    if (this.contains(value)) {
      result.add(value);
    }
  }

  return result;
};


/**
 * Finds all values that are present in this set and not in the given
 * collection.
 * @param {Array<T>|goog.structs.Collection<T>|Object<?,T>} col A collection.
 * @return {!goog.structs.Set} A new set containing all the values
 *     (primitives or objects) present in this set but not in the given
 *     collection.
 */
goog.structs.Set.prototype.difference = function(col) {
  'use strict';
  var result = this.clone();
  result.removeAll(col);
  return result;
};


/**
 * Returns an array containing all the elements in this set.
 * @return {!Array<T>} An array containing all the elements in this set.
 * @deprecated Use `Array.from(set.values())` instead, for alignment with ES6
 *     Set.
 */
goog.structs.Set.prototype.getValues = function() {
  'use strict';
  return this.map_.getValues();
};

/**
 * @returns {!IteratorIterable<T>} An ES6 Iterator that iterates over the values
 *     in the set.
 */
goog.structs.Set.prototype.values = function() {
  'use strict';
  return this.map_.values();
};

/**
 * Creates a shallow clone of this set.
 * @return {!goog.structs.Set<T>} A new set containing all the same elements as
 *     this set.
 * @deprecated Use `new Set(thisSet.values())` for alignment with ES6 Set.
 */
goog.structs.Set.prototype.clone = function() {
  'use strict';
  return new goog.structs.Set(this);
};


/**
 * Tests whether the given collection consists of the same elements as this set,
 * regardless of order, without repetition.  Primitives are treated as equal if
 * they have the same type and convert to the same string; objects are treated
 * as equal if they are references to the same object.  This operation is O(n).
 * @param {goog.structs.Collection<T>|Object} col A collection.
 * @return {boolean} True if the given collection consists of the same elements
 *     as this set, regardless of order, without repetition.
 * @deprecated Use `goog.collections.equals(thisSet, col)`, converting Objects
 *     to arrays using Object.values,  instead for alignment with ES6 Set.
 */
goog.structs.Set.prototype.equals = function(col) {
  'use strict';
  return this.getCount() == goog.structs.getCount(col) && this.isSubsetOf(col);
};


/**
 * Tests whether the given collection contains all the elements in this set.
 * Primitives are treated as equal if they have the same type and convert to the
 * same string; objects are treated as equal if they are references to the same
 * object.  This operation is O(n).
 * @param {goog.structs.Collection<T>|Object} col A collection.
 * @return {boolean} True if this set is a subset of the given collection.
 * @deprecated Use `goog.collections.isSubsetOf(thisSet, col)`, converting
 *     Objects to arrays using Object.values, instead for alignment with ES6
 *     Set.
 */
goog.structs.Set.prototype.isSubsetOf = function(col) {
  'use strict';
  var colCount = goog.structs.getCount(col);
  if (this.getCount() > colCount) {
    return false;
  }
  if (!(col instanceof goog.structs.Set) && colCount > 5) {
    // Convert to a goog.structs.Set so that goog.structs.contains runs in
    // O(1) time instead of O(n) time.
    col = new goog.structs.Set(col);
  }
  return goog.structs.every(this, function(value) {
    'use strict';
    return goog.structs.contains(col, value);
  });
};


/**
 * Returns an iterator that iterates over the elements in this set.
 * @param {boolean=} opt_keys This argument is ignored.
 * @return {!goog.iter.Iterator} An iterator over the elements in this set.
 * @deprecated Call `values` and use native iteration, for alignment with ES6
 *     Set.
 */
goog.structs.Set.prototype.__iterator__ = function(opt_keys) {
  'use strict';
  return this.map_.__iterator__(false);
};

/**
 * @return {!IteratorIterable<T>} An ES6 Iterator that iterates over the values
 *     in the set.
 */
goog.structs.Set.prototype[Symbol.iterator] = function() {
  return this.values();
};

/**
 * Assigns to the size property to isolate supressions of const assignment
 * to only where they are needed.
 * @param {number} newSize The size to update to.
 * @private
 */
goog.structs.Set.prototype.setSizeInternal_ = function(newSize) {
  /** @suppress {const} */
  this.size = newSize;
};

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/appcontroller.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Main App controller.
 * @suppress {useOfGoogProvide}
 */
goog.module('recovery.controllers.AppController');
goog.module.declareLegacyNamespace();

const GoogleAnalytics = goog.require('recovery.GoogleAnalytics');
const Runtime = goog.require('recovery.Runtime');
const StructsSet = goog.require('goog.structs.Set');
const XhrIo = goog.require('goog.net.XhrIo');
const appConfig = goog.require('recovery.appConfig');
const recovery = goog.require('recovery');

/**
 * The parent controller for the app and main controller used by AngularJS.
 *
 * @unrestricted
 */
const AppController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.app = this;

    /**
     * A function to trigger scope application.
     * @private {function()}
     */
    this.applyScope_ = goog.bind($scope.$apply, $scope);
    /**
     * The platform we are running on.
     * @type {!recovery.Platform}
     */
    this.platform = recovery.CAPABILITIES.platform;
    /**
     * State for the write operation.
     * @type {{
     *     device: !recovery.DeviceInfo,
     *     target: ?chrome.imageWriterPrivate.DriveInfo,
     *     saveAsDownload: boolean
     * }}
     */
    this.writeParams = {
      device: recovery.DUMMY_DEVICE,
      target: null,
      saveAsDownload: false
    };
    /**
     * The HWID the user entered.
     * @type {string}
     */
    this.userHwid = '';
    /**
     * User's Chromebook HWID. Populated only if user is on a Chromebook.
     * @type {string}
     */
    this.currentChromebookHwid = '';
    /**
     * The OEM the user selected.
     * @type {?string}
     */
    this.selectedOem = null;
    /**
     * The SKU the user selected.
     * @type {?string}
     */
    this.selectedSku = null;
    /**
     * The last error code that occurred.
     * @type {?string}
     */
    this.writeErrorCode = null;
    /**
     * App-level error message key
     * @type {?string}
     */
    this.loadConfigErrorKey = null;
    /**
     * Indicator of whether the config file is loaded or not
     * @type {boolean}
     */
    this.configFileLoaded = false;
    /**
     * Whether the last write was cancelled.
     * @type {boolean}
     */
    this.writeCancelled = false;
    /**
     * The current step to display, if any.  E.g. "Step {step} of 4".
     * @type {?number}
     */
    this.step = AppController.Step.NONE;
    /**
     * Whether to enable the erase-drive option in the menu.
     * @type {boolean}
     */
    this.allowErase = true;
    /**
     * Whether to enable the local-file option in the menu.
     * @type {boolean}
     */
    this.allowLocalFile = true;
    /**
     * The current subview.
     * @type {!AppController.Page}
     */
    this.currentView = AppController.Page.WELCOME;
    /**
     * Whether to show the gear menu.
     * @type {boolean}
     */
    this.showMenu = true;
    /**
     * Whether to enable the feature User Feedback Form.
     * @type {boolean}
     */
    this.userFeedbackFormFeatureEnabled = false;

    if (this.userFeedbackFormFeatureEnabled) {
      this.initializeFeedbackForm();
    }

    /**
     * Whether to show the destroy-partitions menu item.
     * @type {boolean}
     */
    this.showDestroyPartitions = recovery.CAPABILITIES.destroyPartitions;

    /**
     * Whether to show the close window button.
     * @type {boolean}
     */
    this.showCloseWindow =
        recovery.CAPABILITIES.runtime === Runtime.CHROME_APP;

    /**
     * Whether the current platform is Chrome APP or not.
     * @type {boolean}
     */
    this.isChromeApp =
        recovery.CAPABILITIES.runtime === Runtime.CHROME_APP;

    /**
     * Whether the device is online or not.
     * @type {boolean}
     */
    this.online = navigator.onLine;

    /**
     * Create the Google Analytics variable.
     * @type {?GoogleAnalytics}
     */
    this.ga = this.initGa_();

    // If user is using a Chromebook, get the HWID value from the system.
    if (chrome.chromeosInfoPrivate) {
      chrome.chromeosInfoPrivate.get(['hwid'], goog.bind(function(result) {
        this.currentChromebookHwid = result.hwid;
        this.applyScope_();
      }, this));
    }

    /**
     * The time before load recovery.json starts.
     * @type {number}
     */
    this.startTime = Date.now();
    if (!recovery.CAPABILITIES.writeImage) {
      this.unsupportedPlatform();
    } else {
      if (this.online) {
        // Initialize the recovery data.
        this.loadRecoveryJson_(recovery.RECOVERY_CONFIG_URL);
      }
    }
  }

  /**
   * Initialize the Feedback Form.
   */
  initializeFeedbackForm() {
    if (!chrome.feedbackPrivate) console.error('FeedbackPrivate not accesible');

    /**
     * Whether to show the User Feedback Form.
     * The form is only shown if the feature is enabled, the App has permissions
     * to use feedbackPrivate, and the UI language is set to any variation of
     * English.
     * @type {boolean}
     */
    this.showUserFeedbackForm = this.userFeedbackFormFeatureEnabled &&
        chrome.feedbackPrivate && chrome.i18n.getUILanguage().startsWith('en-');

    /**
     * ChromeOS Feedback Form data.
     * @type {{
     *     free_text: string,
     *     language: string,
     *     OEM: string,
     *     SKU: string,
     *     version: number,
     *     usage_frequency: string
     * }}
     */
    this.feedbackFormData = {
      free_text: '',
      language: chrome.i18n.getUILanguage(),
      OEM: '',
      SKU: '',
      version: 1,
      usage_frequency: ''
    };

    /**
     * Whether to send the device model with the ChromeOS feedback.
     * @type {boolean}
     */
    this.feedbackSendDeviceModel = false;
  }

  /**
   * Initialize the Google Analytics.
   * @return {!GoogleAnalytics}
   * @private
   */
  initGa_() {
    let googleAnalytics = new GoogleAnalytics();
    googleAnalytics.setDimensionAppVersion(
        chrome.runtime.getManifest().version);
    googleAnalytics.setDimensionPlatform(this.platform);
    googleAnalytics.setDimensionChromeVersion(
        this.getChromeVersion_(window.navigator.appVersion));
    googleAnalytics.setDimensionAppType(appConfig.analyticsAppType);
    googleAnalytics.sendPageView(GoogleAnalytics.pageView.FIRST_PAGE);
    return googleAnalytics;
  }

  /**
   * Resets the app and returns to the welcome screen.
   */
  reset() {
    this.writeParams = {
      device: recovery.DUMMY_DEVICE,
      target: null,
      saveAsDownload: false
    };

    this.userHwid = '';
    this.selectedOem = null;
    this.selectedSku = null;

    this.welcome();
  }

  /**
   * Get the Chrome version.
   *
   * @param {string} userAgent The userAgent app version.
   * @return {string} The version of Chrome.
   * @private
   */
  getChromeVersion_(userAgent) {
    const matches = userAgent.match(/Chrome\/([0-9.]*)/);
    return matches ? matches[1] : 'n/a';
  }

  /** Closes the app. */
  close() {
    window.close();

    // If a write is still in progress, cancel it.
    chrome.imageWriterPrivate.cancelWrite(goog.nullFunction);
  }

  /**
   * Resets transient errors.
   * @private
   */
  clearErrors_() {
    this.loadConfigErrorKey = null;
    this.writeErrorCode = null;
    this.writeCancelled = false;
  }

  /**
   * Submit ChromeOS feedback to server.
   */
  sendCrosRecoveryFeedback() {
    if (this.feedbackSendDeviceModel) {
      if (this.userHwid == '') {
        this.feedbackFormData['OEM'] = this.selectedOem;
        this.feedbackFormData['SKU'] = this.selectedSku;
      } else {
        this.feedbackFormData['OEM'] = this.writeParams.device.manufacturer;
        this.feedbackFormData['SKU'] = this.writeParams.device.model;
      }
    } else {
      this.feedbackFormData['OEM'] = '';
      this.feedbackFormData['SKU'] = '';
    }

    this.feedbackFormData['free_text'] =
        this.feedbackFormData['free_text'].trim();

    chrome.feedbackPrivate.sendFeedback(
        {
          'categoryTag': 'chromeos-recovery-data',
          'description': JSON.stringify(this.feedbackFormData, null, 2),
          'flow': 'regular',
          'productId': 208,  // Send feedback to Chrome OS.
          'systemInformation': [
            {
              'key': 'appVersion',
              'value': chrome.runtime.getManifest().version
            },
          ],
        },
        function(result, landingPageType) {
          if (result == chrome.feedbackPrivate.Status.SUCCESS) {
            console.log('Feedback: Report sent.');
          } else {
            console.log('Feedback: Report will be sent later.');
          }
        });
  }

  /**
   * Submit ChromeOS feedback to server and close the window.
   */
  sendCrosRecoveryFeedbackAndClose() {
    if (this.showUserFeedbackForm &&
        (this.feedbackFormData['free_text'].trim() != '' ||
         this.feedbackFormData['usage_frequency'].trim() != '' ||
         this.feedbackSendDeviceModel)) {
      this.sendCrosRecoveryFeedback();
    }

    this.close();
  }

  /** Sets the app to the welcome page. */
  welcome() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.allowErase = true;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.WELCOME_PAGE);

    this.currentView = AppController.Page.WELCOME;
  }

  /** Sets the app to the unsupported-platform page. */
  unsupportedPlatform() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.showMenu = false;

    this.ga.sendPageView(GoogleAnalytics.pageView.UNSUPPORTED_PAGE);

    this.currentView = AppController.Page.UNSUPPORTED_PLATFORM;
  }

  /** Sets the app to the device selection page. */
  selectDevice() {
    this.clearErrors_();
    this.step = AppController.Step.SELECT_DEVICE;
    this.allowErase = true;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.SELECT_DEVICE_PAGE);

    this.currentView = AppController.Page.SELECT_DEVICE;
  }

  /** Sets the app to the target selection page. */
  selectTarget() {
    this.clearErrors_();
    this.step = AppController.Step.SELECT_TARGET;
    this.allowErase = true;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.SELECT_TARGET_PAGE);

    this.currentView = AppController.Page.SELECT_TARGET;
  }

  /** Sets the app to the pre-write-confirmation page. */
  writeConfirm() {
    this.step = AppController.Step.WRITE;
    this.allowErase = true;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.WRITE_CONFIRM_PAGE);

    this.currentView = AppController.Page.WRITE_CONFIRM;
  }

  /** Sets the app to the writing page. */
  writeImage() {
    this.clearErrors_();
    this.step = AppController.Step.WRITE;
    this.allowErase = false;
    this.allowLocalFile = false;

    this.ga.sendPageView(GoogleAnalytics.pageView.WRITE_PAGE);

    this.currentView = AppController.Page.WRITE;
  }

  /** Sets the app to the write-complete page.  */
  writeComplete() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.allowErase = true;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.WRITE_COMPLETE_PAGE);

    this.currentView = AppController.Page.WRITE_COMPLETE;
  }

  /** Sets the app to the erase-usb-device page. */
  eraseSelectTarget() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.allowErase = false;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.ERASE_SELECT_TARGET_PAGE);

    this.currentView = AppController.Page.ERASE_SELECT_TARGET;
  }

  /** Sets the app to the pre-erase-confirmation page.  */
  eraseConfirm() {
    this.step = AppController.Step.NONE;
    this.allowErase = false;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.ERASE_CONFIRM_PAGE);

    this.currentView = AppController.Page.ERASE_CONFIRM;
  }

  /** Sets the app to the erasing page.  */
  eraseDevice() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.allowErase = false;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.ERASE_PAGE);

    this.currentView = AppController.Page.ERASE;
  }

  /** Sets the app to the erase-complete page.  */
  eraseComplete() {
    this.clearErrors_();
    this.step = AppController.Step.NONE;
    this.allowErase = false;
    this.allowLocalFile = true;

    this.ga.sendPageView(GoogleAnalytics.pageView.ERASE_COMPLETE_PAGE);

    this.currentView = AppController.Page.ERASE_COMPLETE;
  }

  /** Brings up a file-chooser dialog.  */
  chooseFile() {
    const chromeVersion =
        parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
    const extensions =
        chromeVersion >= 92 ? ['bin', 'zip', 'tar', 'xz'] : ['bin', 'zip'];
    chrome.fileSystem.chooseEntry(
        {accepts: [{extensions: extensions}], acceptsAllTypes: false},
        goog.bind(this.onFileSelected_, this));
  }

  /**
   * Advances the app once a file has been selected.
   * @param {?Entry=} opt_file The selected file.
   * @param {!Array.<!FileEntry>=} opt_fileEntries The selected files, if
   *     multiple.
   * @private
   */
  onFileSelected_(opt_file, opt_fileEntries) {
    if (opt_file) {
      this.writeParams.device = {
        name: opt_file.name,
        local: true,
        file: opt_file,
        photourl: recovery.DUMMY_DEVICE.photourl
      };

      this.ga.setDimensionSelectionMethod(
          GoogleAnalytics.selection.LOCAL_IMAGE);

      this.selectTarget();
      this.applyScope_();
    }
  }

  /** Sends app feedback using the feedback API.  */
  sendFeedback() {
    chrome.runtime.sendMessage(AppController.FEEDBACK_APP_ID_, {
      'requestFeedback': true,
      'feedbackInfo': {
        'categoryTag': 'chromeos-recovery-tool',
        'description': '',
        'systemInformation': [
          {'key': 'appVersion', 'value': chrome.runtime.getManifest().version}
        ]
      }
    });
  }

  /**
   * Populates hwids, oems and hwidMap based on a given json file
   * @param {string} url The json file to download.
   * @private
   */
  loadRecoveryJson_(url) {
    XhrIo.send(
        url,
        goog.bind(AppController.prototype.loadRecoveryJsonCallback_, this));
  }

  /**
   * Callback for loadRecoveryJson
   * @param {!Object} result Result object from XhrIo.send.
   * @private
   */
  loadRecoveryJsonCallback_(result) {
    // Parse response into JSON
    const xhr = result.target;

    if (xhr.getStatus() != 200) {
      this.loadConfigErrorKey = 'ERRMSG_RECOVERY_CONFIG_DOWNLOAD_FAILURE';
      return;
    }

    let response;

    try {
      response = JSON.parse(xhr.getResponseText());
    } catch (e) {
      this.loadConfigErrorKey = 'ERRMSG_RECOVERY_JSON_PARSE_FAILURE';
      return;
    }

    // Populate data structures from config file
    response.forEach(function(device) {
      recovery.devices.push(device);
      device.manufacturer = device.manufacturer.trim();
      device.name = device.name.trim();
      recovery.oems[device.manufacturer] =
          recovery.oems[device.manufacturer] || {};
      recovery.oems[device.manufacturer][device.name] = device;

      // TODO(stephenlin): Once recovery.json has the photourl populated
      // this won't be necessary anymore.
      if (recovery.imageMap[device.name]) {
        device.photourl = recovery.imageMap[device.name];
      } else {
        console.warn('device not found: ' + device.name);
      }

      // Extract the Chrome OS version number to show to the user
      device.chromeOsVersion = /\d+\.\d+\.\d+/.exec(device.file)[0];

      // Prepare regular expressions for matching HWIDs
      device.modelFamilies = new StructsSet();
      if (device.hwidmatch) {
        device.hwidMatchRegExp = new RegExp(device.hwidmatch);

        // Extract model families. e.g.: Extract PEPPY from '^PEPPY .*" pattern.
        const matches = /^\^(\w+)/.exec(device.hwidmatch);
        if (matches && matches.length > 1) {
          device.modelFamilies.add(matches[1]);
        } else {
          console.warn(
              'match pattern does not begin with "^": ' + device.hwidmatch);
        }
      } else {
        // Extract model family(s) from HWIDs when there isn't a match
        // expression. NOTE: The ONLY devices that should have no match
        // expression have the following prefixes: IEC MARIO, ACER ZGB, SAMS
        // ALEX[2R]
        if (device.hwids) {
          device.hwids.forEach(function(hwid) {
            const matches = /^\w+ \w+/.exec(hwid);
            if (matches && matches.length > 0) {
              device.modelFamilies.add(matches[0]);
            }
          });
        }
      }

      // Build HWID-to-device mapping
      if (device.hwids) {
        device.hwids.forEach(function(hwid) {
          recovery.hwidMap[hwid] = device;
        });
      }
    });

    const endTime = Date.now();
    this.ga.sendTiming(
        GoogleAnalytics.timingVar.DOWNLOAD_RECOVERY_JSON,
        endTime - this.startTime);
    this.configFileLoaded = true;
    this.applyScope_();
  }
};
goog.exportSymbol('recovery.controllers.AppController', AppController);

/**
 * The steps of the recovery process.
 * @enum {?number}
 */
AppController.Step = {
  NONE: null,  // Hides step progress UI.
  SELECT_DEVICE: 1,
  SELECT_TARGET: 2,
  WRITE: 3
};

/**
 * The possible pages of the app.
 * @enum {string}
 */
AppController.Page = {
  WELCOME: 'html/welcome.html',
  UNSUPPORTED_PLATFORM: 'html/unsupported.html',
  SELECT_DEVICE: 'html/select_device.html',
  SELECT_TARGET: 'html/select_target.html',
  WRITE_CONFIRM: 'html/write_confirm.html',
  WRITE: 'html/write.html',
  WRITE_COMPLETE: 'html/write_complete.html',
  ERASE_SELECT_TARGET: 'html/erase_select_target.html',
  ERASE_CONFIRM: 'html/erase_confirm.html',
  ERASE: 'html/erase.html',
  ERASE_COMPLETE: 'html/erase_complete.html'
};

/**
 * The App ID of the feedback extension.
 * @const @private {string}
 */
AppController.FEEDBACK_APP_ID_ = 'gfdkimpbcpahaombhbimeihdjnejgicl';

exports = AppController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/listenercollection.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.ListenerCollection');
goog.module.declareLegacyNamespace();

/**
 * Represents a collection of listeners.
 *
 * @unrestricted
 */
const ListenerCollection = class {
  constructor() {
    /**
     * @private {!Array.<function()>} A list of listener-removal functions.
     */
    this.removeList_ = [];
  }

  /**
   * Calls source.addListener(handler) and keeps track of the listener.
   * @param {!Object} source
   * @param {!Function} handler
   * @export
   */
  add(source, handler) {
    source.addListener(handler);
    this.removeList_.push(function() {
      source.removeListener(handler);
    });
  }

  /**
   * Unregisters all added listeners.
   * @export
   */
  removeAll() {
    this.removeList_.forEach(function(removeFunc) {
      removeFunc();
    });
    this.removeList = [];
  }
};
goog.exportSymbol('recovery.ListenerCollection', ListenerCollection);

exports = ListenerCollection;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/rateestimator.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.RateEstimator');
goog.module.declareLegacyNamespace();

/**
 * A simple class that attempts to estimate the rate of a process based on
 * progress events.  The class is designed for increasing counters, so for
 * estimates to be accurate the time and measurements should be monotonically
 * increasing.
 * @unrestricted
 */
const RateEstimator = class {
  /**
   * @param {number} num_samples The number of samples to retain.
   */
  constructor(num_samples) {
    /** @private {number} */
    this.num_samples_ = num_samples;
    /** @private {Array.<{d: number, t: number}>} */
    this.samples_ = [];
  }

  /**
   * Adds a new sample.
   * @param {number} d The current measurement.
   * @param {?number=} opt_t The timestamp of the measurement, defaults to
   *     Date.now();
   */
  addSample(d, opt_t) {
    if (opt_t) {
      this.samples_.push({d: d, t: opt_t});
    } else {
      this.samples_.push({d: d, t: Date.now() / 1000});
    }

    if (this.samples_.length > this.num_samples_) {
      this.samples_.splice(0, this.samples_.length - this.num_samples_);
    }
  }

  /**
   * Estimates the current rate, using whatever units were recorded, or
   * per-second if timestamps are implicit.
   * @return {number|undefined} The estimated rate.
   */
  getRate() {
    if (this.samples_.length < 2) {
      return undefined;
    } else {
      var first = this.samples_[0];
      var last = this.samples_[this.samples_.length - 1];
      var rate = (last.d - first.d) / (last.t - first.t);
      return rate;
    }
  }

  /** Resets the estimator. */
  reset() {
    this.samples_ = [];
  }
};

exports = RateEstimator;

;return exports;});

//third_party/javascript/closure/a11y/aria/attributes.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview The file contains generated enumerations for ARIA states
 * and properties as defined by W3C ARIA standard:
 * http://www.w3.org/TR/wai-aria/.
 *
 * This is auto-generated code. Do not manually edit! For more details
 * about how to edit it via the generator check go/closure-ariagen.
 */

goog.provide('goog.a11y.aria.AutoCompleteValues');
goog.provide('goog.a11y.aria.CheckedValues');
goog.provide('goog.a11y.aria.DropEffectValues');
goog.provide('goog.a11y.aria.ExpandedValues');
goog.provide('goog.a11y.aria.GrabbedValues');
goog.provide('goog.a11y.aria.InvalidValues');
goog.provide('goog.a11y.aria.LivePriority');
goog.provide('goog.a11y.aria.OrientationValues');
goog.provide('goog.a11y.aria.PressedValues');
goog.provide('goog.a11y.aria.RelevantValues');
goog.provide('goog.a11y.aria.SelectedValues');
goog.provide('goog.a11y.aria.SortValues');
goog.provide('goog.a11y.aria.State');


/**
 * ARIA states and properties.
 * @enum {string}
 */
goog.a11y.aria.State = {
  // ARIA property for setting the currently active descendant of an element,
  // for example the selected item in a list box. Value: ID of an element.
  ACTIVEDESCENDANT: 'activedescendant',

  // ARIA property that, if true, indicates that all of a changed region should
  // be presented, instead of only parts. Value: one of {true, false}.
  ATOMIC: 'atomic',

  // ARIA property to specify that input completion is provided. Value:
  // one of {'inline', 'list', 'both', 'none'}.
  AUTOCOMPLETE: 'autocomplete',

  // ARIA state to indicate that an element and its subtree are being updated.
  // Value: one of {true, false}.
  BUSY: 'busy',

  // ARIA state for a checked item. Value: one of {'true', 'false', 'mixed',
  // undefined}.
  CHECKED: 'checked',

  // ARIA state that defines an element's column index or position with respect
  // to the total number of columns within a table, grid, or treegrid.
  // Value: number.
  COLINDEX: 'colindex',

  // ARIA property that identifies the element or elements whose contents or
  // presence are controlled by this element.
  // Value: space-separated IDs of other elements.
  CONTROLS: 'controls',

  // ARIA property that identifies the element or elements that describe
  // this element. Value: space-separated IDs of other elements.
  DESCRIBEDBY: 'describedby',

  // ARIA state for a disabled item. Value: one of {true, false}.
  DISABLED: 'disabled',

  // ARIA property that indicates what functions can be performed when a
  // dragged object is released on the drop target.  Value: one of
  // {'copy', 'move', 'link', 'execute', 'popup', 'none'}.
  DROPEFFECT: 'dropeffect',

  // ARIA state for setting whether the element like a tree node is expanded.
  // Value: one of {true, false, undefined}.
  EXPANDED: 'expanded',

  // ARIA property that identifies the next element (or elements) in the
  // recommended reading order of content. Value: space-separated ids of
  // elements to flow to.
  FLOWTO: 'flowto',

  // ARIA state that indicates an element's "grabbed" state in drag-and-drop.
  // Value: one of {true, false, undefined}.
  GRABBED: 'grabbed',

  // ARIA property indicating whether the element has a popup.
  // Value: one of {true, false}.
  HASPOPUP: 'haspopup',

  // ARIA state indicating that the element is not visible or perceivable
  // to any user. Value: one of {true, false}.
  HIDDEN: 'hidden',

  // ARIA state indicating that the entered value does not conform. Value:
  // one of {false, true, 'grammar', 'spelling'}
  INVALID: 'invalid',

  // ARIA property that provides a label to override any other text, value, or
  // contents used to describe this element. Value: string.
  LABEL: 'label',

  // ARIA property for setting the element which labels another element.
  // Value: space-separated IDs of elements.
  LABELLEDBY: 'labelledby',

  // ARIA property for setting the level of an element in the hierarchy.
  // Value: integer.
  LEVEL: 'level',

  // ARIA property indicating that an element will be updated, and
  // describes the types of updates the user agents, assistive technologies,
  // and user can expect from the live region. Value: one of {'off', 'polite',
  // 'assertive'}.
  LIVE: 'live',

  // ARIA property indicating whether a text box can accept multiline input.
  // Value: one of {true, false}.
  MULTILINE: 'multiline',

  // ARIA property indicating if the user may select more than one item.
  // Value: one of {true, false}.
  MULTISELECTABLE: 'multiselectable',

  // ARIA property indicating if the element is horizontal or vertical.
  // Value: one of {'vertical', 'horizontal'}.
  ORIENTATION: 'orientation',

  // ARIA property creating a visual, functional, or contextual parent/child
  // relationship when the DOM hierarchy can't be used to represent it.
  // Value: Space-separated IDs of elements.
  OWNS: 'owns',

  // ARIA property that defines an element's number of position in a list.
  // Value: integer.
  POSINSET: 'posinset',

  // ARIA state for a pressed item.
  // Value: one of {true, false, undefined, 'mixed'}.
  PRESSED: 'pressed',

  // ARIA property indicating that an element is not editable.
  // Value: one of {true, false}.
  READONLY: 'readonly',

  // ARIA property indicating that change notifications within this subtree
  // of a live region should be announced. Value: one of {'additions',
  // 'removals', 'text', 'all', 'additions text'}.
  RELEVANT: 'relevant',

  // ARIA property indicating that user input is required on this element
  // before a form may be submitted. Value: one of {true, false}.
  REQUIRED: 'required',

  // ARIA state that defines an element's row index or position with respect
  // to the total number of rows within a table, grid, or treegrid.
  // Value: number.
  ROWINDEX: 'rowindex',

  // ARIA state for setting the currently selected item in the list.
  // Value: one of {true, false, undefined}.
  SELECTED: 'selected',

  // ARIA property defining the number of items in a list. Value: integer.
  SETSIZE: 'setsize',

  // ARIA property indicating if items are sorted. Value: one of {'ascending',
  // 'descending', 'none', 'other'}.
  SORT: 'sort',

  // ARIA property for slider maximum value. Value: number.
  VALUEMAX: 'valuemax',

  // ARIA property for slider minimum value. Value: number.
  VALUEMIN: 'valuemin',

  // ARIA property for slider active value. Value: number.
  VALUENOW: 'valuenow',

  // ARIA property for slider active value represented as text.
  // Value: string.
  VALUETEXT: 'valuetext'
};


/**
 * ARIA state values for AutoCompleteValues.
 * @enum {string}
 */
goog.a11y.aria.AutoCompleteValues = {
  // The system provides text after the caret as a suggestion
  // for how to complete the field.
  INLINE: 'inline',
  // A list of choices appears from which the user can choose,
  // but the edit box retains focus.
  LIST: 'list',
  // A list of choices appears and the currently selected suggestion
  // also appears inline.
  BOTH: 'both',
  // No input completion suggestions are provided.
  NONE: 'none'
};


/**
 * ARIA state values for DropEffectValues.
 * @enum {string}
 */
goog.a11y.aria.DropEffectValues = {
  // A duplicate of the source object will be dropped into the target.
  COPY: 'copy',
  // The source object will be removed from its current location
  // and dropped into the target.
  MOVE: 'move',
  // A reference or shortcut to the dragged object
  // will be created in the target object.
  LINK: 'link',
  // A function supported by the drop target is
  // executed, using the drag source as an input.
  EXECUTE: 'execute',
  // There is a popup menu or dialog that allows the user to choose
  // one of the drag operations (copy, move, link, execute) and any other
  // drag functionality, such as cancel.
  POPUP: 'popup',
  // No operation can be performed; effectively
  // cancels the drag operation if an attempt is made to drop on this object.
  NONE: 'none'
};


/**
 * ARIA state values for LivePriority.
 * @enum {string}
 */
goog.a11y.aria.LivePriority = {
  // Updates to the region will not be presented to the user
  // unless the assitive technology is currently focused on that region.
  OFF: 'off',
  // (Background change) Assistive technologies SHOULD announce
  // updates at the next graceful opportunity, such as at the end of
  // speaking the current sentence or when the user pauses typing.
  POLITE: 'polite',
  // This information has the highest priority and assistive
  // technologies SHOULD notify the user immediately.
  // Because an interruption may disorient users or cause them to not complete
  // their current task, authors SHOULD NOT use the assertive value unless the
  // interruption is imperative.
  ASSERTIVE: 'assertive'
};


/**
 * ARIA state values for OrientationValues.
 * @enum {string}
 */
goog.a11y.aria.OrientationValues = {
  // The element is oriented vertically.
  VERTICAL: 'vertical',
  // The element is oriented horizontally.
  HORIZONTAL: 'horizontal'
};


/**
 * ARIA state values for RelevantValues.
 * @enum {string}
 */
goog.a11y.aria.RelevantValues = {
  // Element nodes are added to the DOM within the live region.
  ADDITIONS: 'additions',
  // Text or element nodes within the live region are removed from the DOM.
  REMOVALS: 'removals',
  // Text is added to any DOM descendant nodes of the live region.
  TEXT: 'text',
  // Equivalent to the combination of all values, "additions removals text".
  ALL: 'all'
};


/**
 * ARIA state values for SortValues.
 * @enum {string}
 */
goog.a11y.aria.SortValues = {
  // Items are sorted in ascending order by this column.
  ASCENDING: 'ascending',
  // Items are sorted in descending order by this column.
  DESCENDING: 'descending',
  // There is no defined sort applied to the column.
  NONE: 'none',
  // A sort algorithm other than ascending or descending has been applied.
  OTHER: 'other'
};


/**
 * ARIA state values for CheckedValues.
 * @enum {string}
 */
goog.a11y.aria.CheckedValues = {
  // The selectable element is checked.
  TRUE: 'true',
  // The selectable element is not checked.
  FALSE: 'false',
  // Indicates a mixed mode value for a tri-state
  // checkbox or menuitemcheckbox.
  MIXED: 'mixed',
  // The element does not support being checked.
  UNDEFINED: 'undefined'
};


/**
 * ARIA state values for ExpandedValues.
 * @enum {string}
 */
goog.a11y.aria.ExpandedValues = {
  // The element, or another grouping element it controls, is expanded.
  TRUE: 'true',
  // The element, or another grouping element it controls, is collapsed.
  FALSE: 'false',
  // The element, or another grouping element
  // it controls, is neither expandable nor collapsible; all its
  // child elements are shown or there are no child elements.
  UNDEFINED: 'undefined'
};


/**
 * ARIA state values for GrabbedValues.
 * @enum {string}
 */
goog.a11y.aria.GrabbedValues = {
  // Indicates that the element has been "grabbed" for dragging.
  TRUE: 'true',
  // Indicates that the element supports being dragged.
  FALSE: 'false',
  // Indicates that the element does not support being dragged.
  UNDEFINED: 'undefined'
};


/**
 * ARIA state values for InvalidValues.
 * @enum {string}
 */
goog.a11y.aria.InvalidValues = {
  // There are no detected errors in the value.
  FALSE: 'false',
  // The value entered by the user has failed validation.
  TRUE: 'true',
  // A grammatical error was detected.
  GRAMMAR: 'grammar',
  // A spelling error was detected.
  SPELLING: 'spelling'
};


/**
 * ARIA state values for PressedValues.
 * @enum {string}
 */
goog.a11y.aria.PressedValues = {
  // The element is pressed.
  TRUE: 'true',
  // The element supports being pressed but is not currently pressed.
  FALSE: 'false',
  // Indicates a mixed mode value for a tri-state toggle button.
  MIXED: 'mixed',
  // The element does not support being pressed.
  UNDEFINED: 'undefined'
};


/**
 * ARIA state values for SelectedValues.
 * @enum {string}
 */
goog.a11y.aria.SelectedValues = {
  // The selectable element is selected.
  TRUE: 'true',
  // The selectable element is not selected.
  FALSE: 'false',
  // The element is not selectable.
  UNDEFINED: 'undefined'
};

//third_party/javascript/closure/a11y/aria/datatables.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @fileoverview The file contains data tables generated from the ARIA
 * standard schema http://www.w3.org/TR/wai-aria/.
 *
 * This is auto-generated code. Do not manually edit!
 * MOE:begin_intracomment_strip
 * Details about how to regenerate the datatables.js can be found at:
 * go/aria-datatables.
 * MOE:end_intracomment_strip
 */

goog.provide('goog.a11y.aria.datatables');

goog.require('goog.a11y.aria.State');
goog.require('goog.object');


/**
 * A map that contains mapping between an ARIA state and the default value
 * for it. Note that not all ARIA states have default values.
 *
 * @private {?Object<!goog.a11y.aria.State|string, string|boolean|number>}
 */
goog.a11y.aria.DefaultStateValueMap_;


/**
 * A method that creates a map that contains mapping between an ARIA state and
 * the default value for it. Note that not all ARIA states have default values.
 *
 * @return {!Object<!goog.a11y.aria.State|string, string|boolean|number>}
 *      The names for each of the notification methods.
 */
goog.a11y.aria.datatables.getDefaultValuesMap = function() {
  'use strict';
  if (!goog.a11y.aria.DefaultStateValueMap_) {
    goog.a11y.aria.DefaultStateValueMap_ = goog.object.create(
        goog.a11y.aria.State.ATOMIC, false, goog.a11y.aria.State.AUTOCOMPLETE,
        'none', goog.a11y.aria.State.DROPEFFECT, 'none',
        goog.a11y.aria.State.HASPOPUP, false, goog.a11y.aria.State.LIVE, 'off',
        goog.a11y.aria.State.MULTILINE, false,
        goog.a11y.aria.State.MULTISELECTABLE, false,
        goog.a11y.aria.State.ORIENTATION, 'vertical',
        goog.a11y.aria.State.READONLY, false, goog.a11y.aria.State.RELEVANT,
        'additions text', goog.a11y.aria.State.REQUIRED, false,
        goog.a11y.aria.State.SORT, 'none', goog.a11y.aria.State.BUSY, false,
        goog.a11y.aria.State.DISABLED, false, goog.a11y.aria.State.HIDDEN,
        false, goog.a11y.aria.State.INVALID, 'false');
  }

  return goog.a11y.aria.DefaultStateValueMap_;
};

//third_party/javascript/closure/a11y/aria/roles.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview The file contains generated enumerations for ARIA roles
 * as defined by W3C ARIA standard: http://www.w3.org/TR/wai-aria/.
 *
 * This is auto-generated code. Do not manually edit! For more details
 * about how to edit it via the generator check go/closure-ariagen.
 */

goog.provide('goog.a11y.aria.Role');


/**
 * ARIA role values.
 * @enum {string}
 */
goog.a11y.aria.Role = {
  // ARIA role for an alert element that doesn't need to be explicitly closed.
  ALERT: 'alert',

  // ARIA role for an alert dialog element that takes focus and must be closed.
  ALERTDIALOG: 'alertdialog',

  // ARIA role for an application that implements its own keyboard navigation.
  APPLICATION: 'application',

  // ARIA role for an article.
  ARTICLE: 'article',

  // ARIA role for a banner containing mostly site content, not page content.
  BANNER: 'banner',

  // ARIA role for a button element.
  BUTTON: 'button',

  // ARIA role for a checkbox button element; use with the CHECKED state.
  CHECKBOX: 'checkbox',

  // ARIA role for a column header of a table or grid.
  COLUMNHEADER: 'columnheader',

  // ARIA role for a combo box element.
  COMBOBOX: 'combobox',

  // ARIA role for a supporting section of the document.
  COMPLEMENTARY: 'complementary',

  // ARIA role for a large perceivable region that contains information
  // about the parent document.
  CONTENTINFO: 'contentinfo',

  // ARIA role for a definition of a term or concept.
  DEFINITION: 'definition',

  // ARIA role for a dialog, some descendant must take initial focus.
  DIALOG: 'dialog',

  // ARIA role for a directory, like a table of contents.
  DIRECTORY: 'directory',

  // ARIA role for a part of a page that's a document, not a web application.
  DOCUMENT: 'document',

  // ARIA role for a landmark region logically considered one form.
  FORM: 'form',

  // ARIA role for an interactive control of tabular data.
  GRID: 'grid',

  // ARIA role for a cell in a grid.
  GRIDCELL: 'gridcell',

  // ARIA role for a group of related elements like tree item siblings.
  GROUP: 'group',

  // ARIA role for a heading element.
  HEADING: 'heading',

  // ARIA role for a container of elements that together comprise one image.
  IMG: 'img',

  // ARIA role for a link.
  LINK: 'link',

  // ARIA role for a list of non-interactive list items.
  LIST: 'list',

  // ARIA role for a listbox.
  LISTBOX: 'listbox',

  // ARIA role for a list item.
  LISTITEM: 'listitem',

  // ARIA role for a live region where new information is added.
  LOG: 'log',

  // ARIA landmark role for the main content in a document. Use only once.
  MAIN: 'main',

  // ARIA role for a live region of non-essential information that changes.
  MARQUEE: 'marquee',

  // ARIA role for a mathematical expression.
  MATH: 'math',

  // ARIA role for a popup menu.
  MENU: 'menu',

  // ARIA role for a menubar element containing menu elements.
  MENUBAR: 'menubar',

  // ARIA role for menu item elements.
  MENU_ITEM: 'menuitem',

  // ARIA role for a checkbox box element inside a menu.
  MENU_ITEM_CHECKBOX: 'menuitemcheckbox',

  // ARIA role for a radio button element inside a menu.
  MENU_ITEM_RADIO: 'menuitemradio',

  // ARIA landmark role for a collection of navigation links.
  NAVIGATION: 'navigation',

  // ARIA role for a section ancillary to the main content.
  NOTE: 'note',

  // ARIA role for option items that are  children of combobox, listbox, menu,
  // radiogroup, or tree elements.
  OPTION: 'option',

  // ARIA role for ignorable cosmetic elements with no semantic significance.
  PRESENTATION: 'presentation',

  // ARIA role for a progress bar element.
  PROGRESSBAR: 'progressbar',

  // ARIA role for a radio button element.
  RADIO: 'radio',

  // ARIA role for a group of connected radio button elements.
  RADIOGROUP: 'radiogroup',

  // ARIA role for an important region of the page.
  REGION: 'region',

  // ARIA role for a row of cells in a grid.
  ROW: 'row',

  // ARIA role for a group of one or more rows in a grid.
  ROWGROUP: 'rowgroup',

  // ARIA role for a row header of a table or grid.
  ROWHEADER: 'rowheader',

  // ARIA role for a scrollbar element.
  SCROLLBAR: 'scrollbar',

  // ARIA landmark role for a part of the page providing search functionality.
  SEARCH: 'search',

  // ARIA role for a menu separator.
  SEPARATOR: 'separator',

  // ARIA role for a slider.
  SLIDER: 'slider',

  // ARIA role for a spin button.
  SPINBUTTON: 'spinbutton',

  // ARIA role for a live region with advisory info less severe than an alert.
  STATUS: 'status',

  // ARIA role for a tab button.
  TAB: 'tab',

  // ARIA role for a tab bar (i.e. a list of tab buttons).
  TAB_LIST: 'tablist',

  // ARIA role for a tab page (i.e. the element holding tab contents).
  TAB_PANEL: 'tabpanel',

  // ARIA role for a textbox element.
  TEXTBOX: 'textbox',

  // ARIA role for a textinfo element.
  TEXTINFO: 'textinfo',

  // ARIA role for an element displaying elapsed time or time remaining.
  TIMER: 'timer',

  // ARIA role for a toolbar element.
  TOOLBAR: 'toolbar',

  // ARIA role for a tooltip element.
  TOOLTIP: 'tooltip',

  // ARIA role for a tree.
  TREE: 'tree',

  // ARIA role for a grid whose rows can be expanded and collapsed like a tree.
  TREEGRID: 'treegrid',

  // ARIA role for a tree item that sometimes may be expanded or collapsed.
  TREEITEM: 'treeitem'
};

//third_party/javascript/closure/a11y/aria/aria.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview Utilities for adding, removing and setting ARIA roles and
 * states as defined by W3C ARIA standard: http://www.w3.org/TR/wai-aria/
 * All modern browsers have some form of ARIA support, so no browser checks are
 * performed when adding ARIA to components.
 */

goog.provide('goog.a11y.aria');

goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.a11y.aria.datatables');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.object');
goog.require('goog.string');


/**
 * ARIA states/properties prefix.
 * @private
 */
goog.a11y.aria.ARIA_PREFIX_ = 'aria-';


/**
 * ARIA role attribute.
 * @private
 */
goog.a11y.aria.ROLE_ATTRIBUTE_ = 'role';


/**
 * A list of tag names for which we don't need to set ARIA role and states
 * because they have well supported semantics for screen readers or because
 * they don't contain content to be made accessible.
 * @private
 */
goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_ = goog.object.createSet([
  goog.dom.TagName.A, goog.dom.TagName.AREA, goog.dom.TagName.BUTTON,
  goog.dom.TagName.HEAD, goog.dom.TagName.INPUT, goog.dom.TagName.LINK,
  goog.dom.TagName.MENU, goog.dom.TagName.META, goog.dom.TagName.OPTGROUP,
  goog.dom.TagName.OPTION, goog.dom.TagName.PROGRESS, goog.dom.TagName.STYLE,
  goog.dom.TagName.SELECT, goog.dom.TagName.SOURCE, goog.dom.TagName.TEXTAREA,
  goog.dom.TagName.TITLE, goog.dom.TagName.TRACK
]);


/**
 * A list of roles which are considered container roles.
 * Container roles are ARIA roles which use the aria-activedescendant property
 * to manage their active descendants or children. See
 * {@link http://www.w3.org/TR/wai-aria/states_and_properties
 * #aria-activedescendant} for more information.
 * @private @const {!Array<goog.a11y.aria.Role>}
 */
goog.a11y.aria.CONTAINER_ROLES_ = [
  goog.a11y.aria.Role.COMBOBOX, goog.a11y.aria.Role.GRID,
  goog.a11y.aria.Role.GROUP, goog.a11y.aria.Role.LISTBOX,
  goog.a11y.aria.Role.MENU, goog.a11y.aria.Role.MENUBAR,
  goog.a11y.aria.Role.RADIOGROUP, goog.a11y.aria.Role.ROW,
  goog.a11y.aria.Role.ROWGROUP, goog.a11y.aria.Role.TAB_LIST,
  goog.a11y.aria.Role.TEXTBOX, goog.a11y.aria.Role.TOOLBAR,
  goog.a11y.aria.Role.TREE, goog.a11y.aria.Role.TREEGRID
];


/**
 * Sets the role of an element. If the roleName is
 * empty string or null, the role for the element is removed.
 * We encourage clients to call the goog.a11y.aria.removeRole
 * method instead of setting null and empty string values.
 * Special handling for this case is added to ensure
 * backword compatibility with existing code.
 *
 * @param {!Element} element DOM node to set role of.
 * @param {!goog.a11y.aria.Role|string} roleName role name(s).
 */
goog.a11y.aria.setRole = function(element, roleName) {
  'use strict';
  if (!roleName) {
    // Setting the ARIA role to empty string is not allowed
    // by the ARIA standard.
    goog.a11y.aria.removeRole(element);
  } else {
    if (goog.asserts.ENABLE_ASSERTS) {
      goog.asserts.assert(
          goog.object.containsValue(goog.a11y.aria.Role, roleName),
          'No such ARIA role ' + roleName);
    }
    element.setAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_, roleName);
  }
};


/**
 * Gets role of an element.
 * @param {!Element} element DOM element to get role of.
 * @return {?goog.a11y.aria.Role} ARIA Role name.
 */
goog.a11y.aria.getRole = function(element) {
  'use strict';
  var role = element.getAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
  return /** @type {goog.a11y.aria.Role} */ (role) || null;
};


/**
 * Removes role of an element.
 * @param {!Element} element DOM element to remove the role from.
 */
goog.a11y.aria.removeRole = function(element) {
  'use strict';
  element.removeAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
};


/**
 * Sets the state or property of an element.
 * @param {!Element} element DOM node where we set state.
 * @param {!(goog.a11y.aria.State|string)} stateName State attribute being set.
 *     Automatically adds prefix 'aria-' to the state name if the attribute is
 *     not an extra attribute.
 * @param {string|boolean|number|!Array<string>} value Value
 * for the state attribute.
 */
goog.a11y.aria.setState = function(element, stateName, value) {
  'use strict';
  if (Array.isArray(value)) {
    value = value.join(' ');
  }
  var attrStateName = goog.a11y.aria.getAriaAttributeName_(stateName);
  if (value === '' || value == undefined) {
    var defaultValueMap = goog.a11y.aria.datatables.getDefaultValuesMap();
    // Work around for browsers that don't properly support ARIA.
    // According to the ARIA W3C standard, user agents should allow
    // setting empty value which results in setting the default value
    // for the ARIA state if such exists. The exact text from the ARIA W3C
    // standard (http://www.w3.org/TR/wai-aria/states_and_properties):
    // "When a value is indicated as the default, the user agent
    // MUST follow the behavior prescribed by this value when the state or
    // property is empty or undefined."
    // The defaultValueMap contains the default values for the ARIA states
    // and has as a key the goog.a11y.aria.State constant for the state.
    if (stateName in defaultValueMap) {
      element.setAttribute(attrStateName, defaultValueMap[stateName]);
    } else {
      element.removeAttribute(attrStateName);
    }
  } else {
    element.setAttribute(attrStateName, value);
  }
};


/**
 * Toggles the ARIA attribute of an element.
 * Meant for attributes with a true/false value, but works with any attribute.
 * If the attribute does not have a true/false value, the following rules apply:
 * A not empty attribute will be removed.
 * An empty attribute will be set to true.
 * @param {!Element} el DOM node for which to set attribute.
 * @param {!(goog.a11y.aria.State|string)} attr ARIA attribute being set.
 *     Automatically adds prefix 'aria-' to the attribute name if the attribute
 *     is not an extra attribute.
 */
goog.a11y.aria.toggleState = function(el, attr) {
  'use strict';
  var val = goog.a11y.aria.getState(el, attr);
  if (!goog.string.isEmptyOrWhitespace(goog.string.makeSafe(val)) &&
      !(val == 'true' || val == 'false')) {
    goog.a11y.aria.removeState(el, /** @type {!goog.a11y.aria.State} */ (attr));
    return;
  }
  goog.a11y.aria.setState(el, attr, val == 'true' ? 'false' : 'true');
};


/**
 * Remove the state or property for the element.
 * @param {!Element} element DOM node where we set state.
 * @param {!goog.a11y.aria.State} stateName State name.
 */
goog.a11y.aria.removeState = function(element, stateName) {
  'use strict';
  element.removeAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
};


/**
 * Gets value of specified state or property.
 * @param {!Element} element DOM node to get state from.
 * @param {!goog.a11y.aria.State|string} stateName State name.
 * @return {string} Value of the state attribute.
 */
goog.a11y.aria.getState = function(element, stateName) {
  'use strict';
  // TODO(atincheva): return properly typed value result --
  // boolean, number, string, null. We should be able to chain
  // getState(...) and setState(...) methods.

  var attr =
      /** @type {string|number|boolean} */ (
          element.getAttribute(
              goog.a11y.aria.getAriaAttributeName_(stateName)));
  var isNullOrUndefined = attr == null || attr == undefined;
  return isNullOrUndefined ? '' : String(attr);
};


/**
 * Returns the activedescendant element for the input element by
 * using the activedescendant ARIA property of the given element.
 * @param {!Element} element DOM node to get activedescendant
 *     element for.
 * @return {?Element} DOM node of the activedescendant, if found.
 */
goog.a11y.aria.getActiveDescendant = function(element) {
  'use strict';
  var id =
      goog.a11y.aria.getState(element, goog.a11y.aria.State.ACTIVEDESCENDANT);
  return goog.dom.getOwnerDocument(element).getElementById(id);
};


/**
 * Sets the activedescendant ARIA property value for an element.
 * If the activeElement is not null, it should have an id set.
 * @param {!Element} element DOM node to set activedescendant ARIA property to.
 * @param {?Element} activeElement DOM node being set as activedescendant.
 */
goog.a11y.aria.setActiveDescendant = function(element, activeElement) {
  'use strict';
  var id = '';
  if (activeElement) {
    id = activeElement.id;
    goog.asserts.assert(id, 'The active element should have an id.');
  }

  goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, id);
};


/**
 * Gets the label of the given element.
 * @param {!Element} element DOM node to get label from.
 * @return {string} label The label.
 */
goog.a11y.aria.getLabel = function(element) {
  'use strict';
  return goog.a11y.aria.getState(element, goog.a11y.aria.State.LABEL);
};


/**
 * Sets the label of the given element.
 * @param {!Element} element DOM node to set label to.
 * @param {string} label The label to set.
 */
goog.a11y.aria.setLabel = function(element, label) {
  'use strict';
  goog.a11y.aria.setState(element, goog.a11y.aria.State.LABEL, label);
};


/**
 * Asserts that the element has a role set if it's not an HTML element whose
 * semantics is well supported by most screen readers.
 * Only to be used internally by the ARIA library in goog.a11y.aria.*.
 * @param {!Element} element The element to assert an ARIA role set.
 * @param {!IArrayLike<string>} allowedRoles The child roles of
 * the roles.
 */
goog.a11y.aria.assertRoleIsSetInternalUtil = function(element, allowedRoles) {
  'use strict';
  if (goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_[element.tagName]) {
    return;
  }
  var elementRole = /** @type {string}*/ (goog.a11y.aria.getRole(element));
  goog.asserts.assert(
      elementRole != null, 'The element ARIA role cannot be null.');

  goog.asserts.assert(
      goog.array.contains(allowedRoles, elementRole),
      'Non existing or incorrect role set for element.' +
          'The role set is "' + elementRole + '". The role should be any of "' +
          allowedRoles + '". Check the ARIA specification for more details ' +
          'http://www.w3.org/TR/wai-aria/roles.');
};


/**
 * Gets the boolean value of an ARIA state/property.
 * @param {!Element} element The element to get the ARIA state for.
 * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
 * @return {?boolean} Boolean value for the ARIA state value or null if
 *     the state value is not 'true', not 'false', or not set.
 */
goog.a11y.aria.getStateBoolean = function(element, stateName) {
  'use strict';
  var attr =
      /** @type {string|boolean|null} */ (element.getAttribute(
          goog.a11y.aria.getAriaAttributeName_(stateName)));
  goog.asserts.assert(
      typeof attr === 'boolean' || attr == null || attr == 'true' ||
      attr == 'false');
  if (attr == null) {
    return attr;
  }
  return typeof attr === 'boolean' ? attr : attr == 'true';
};


/**
 * Gets the number value of an ARIA state/property.
 * @param {!Element} element The element to get the ARIA state for.
 * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
 * @return {?number} Number value for the ARIA state value or null if
 *     the state value is not a number or not set.
 */
goog.a11y.aria.getStateNumber = function(element, stateName) {
  'use strict';
  var attr =
      /** @type {string|number} */ (element.getAttribute(
          goog.a11y.aria.getAriaAttributeName_(stateName)));
  goog.asserts.assert(
      (attr == null || !isNaN(Number(attr))) && typeof attr !== 'boolean');
  return attr == null ? null : Number(attr);
};


/**
 * Gets the string value of an ARIA state/property.
 * @param {!Element} element The element to get the ARIA state for.
 * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
 * @return {?string} String value for the ARIA state value or null if
 *     the state value is empty string or not set.
 */
goog.a11y.aria.getStateString = function(element, stateName) {
  'use strict';
  var attr =
      element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  goog.asserts.assert(
      (attr == null || typeof attr === 'string') &&
      (attr == '' || isNaN(Number(attr))) && attr != 'true' && attr != 'false');
  return (attr == null || attr == '') ? null : attr;
};


/**
 * Gets array of strings value of the specified state or
 * property for the element.
 * Only to be used internally by the ARIA library in goog.a11y.aria.*.
 * @param {!Element} element DOM node to get state from.
 * @param {!goog.a11y.aria.State} stateName State name.
 * @return {!IArrayLike<string>} string Array
 *     value of the state attribute.
 */
goog.a11y.aria.getStringArrayStateInternalUtil = function(element, stateName) {
  'use strict';
  var attrValue =
      element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
  return goog.a11y.aria.splitStringOnWhitespace_(attrValue);
};


/**
 * Returns true if element has an ARIA state/property, false otherwise.
 * @param {!Element} element The element to get the ARIA state for.
 * @param {!goog.a11y.aria.State|string} stateName the ARIA state name.
 * @return {boolean}
 */
goog.a11y.aria.hasState = function(element, stateName) {
  'use strict';
  return element.hasAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
};


/**
 * Returns whether the element has a container ARIA role.
 * Container roles are ARIA roles that use the aria-activedescendant property
 * to manage their active descendants or children. See
 * {@link http://www.w3.org/TR/wai-aria/states_and_properties
 * #aria-activedescendant} for more information.
 * @param {!Element} element
 * @return {boolean}
 */
goog.a11y.aria.isContainerRole = function(element) {
  'use strict';
  var role = goog.a11y.aria.getRole(element);
  return goog.array.contains(goog.a11y.aria.CONTAINER_ROLES_, role);
};


/**
 * Splits the input stringValue on whitespace.
 * @param {string} stringValue The value of the string to split.
 * @return {!IArrayLike<string>} string Array
 *     value as result of the split.
 * @private
 */
goog.a11y.aria.splitStringOnWhitespace_ = function(stringValue) {
  'use strict';
  return stringValue ? stringValue.split(/\s+/) : [];
};


/**
 * Adds the 'aria-' prefix to ariaName.
 * @param {string} ariaName ARIA state/property name.
 * @private
 * @return {string} The ARIA attribute name with added 'aria-' prefix.
 * @throws {Error} If no such attribute exists.
 */
goog.a11y.aria.getAriaAttributeName_ = function(ariaName) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.assert(ariaName, 'ARIA attribute cannot be empty.');
    goog.asserts.assert(
        goog.object.containsValue(goog.a11y.aria.State, ariaName),
        'No such ARIA attribute ' + ariaName);
  }
  return goog.a11y.aria.ARIA_PREFIX_ + ariaName;
};

//third_party/javascript/closure/dom/classlist.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for detecting, adding and removing classes.  Prefer
 * this over goog.dom.classes for new code since it attempts to use classList
 * (DOMTokenList: http://dom.spec.whatwg.org/#domtokenlist) which is faster
 * and requires less code.
 *
 * Note: these utilities are meant to operate on HTMLElements and SVGElements
 * and may have unexpected behavior on elements with differing interfaces.
 */


goog.provide('goog.dom.classlist');

goog.require('goog.array');


/**
 * Override this define at build-time if you know your target supports it.
 * @define {boolean} Whether to use the classList property (DOMTokenList).
 */
goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST =
    goog.define('goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST', false);


/**
 * A wrapper which ensures correct functionality when interacting with
 * SVGElements
 * @param {?Element} element DOM node to get the class name of.
 * @return {string}
 * @private
 */
goog.dom.classlist.getClassName_ = function(element) {
  'use strict';
  // If className is an instance of SVGAnimatedString use getAttribute
  return typeof element.className == 'string' ?
      element.className :
      element.getAttribute && element.getAttribute('class') || '';
};


/**
 * Gets an array-like object of class names on an element.
 * @param {Element} element DOM node to get the classes of.
 * @return {!IArrayLike<?>} Class names on `element`.
 */
goog.dom.classlist.get = function(element) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    return element.classList;
  }

  return goog.dom.classlist.getClassName_(element).match(/\S+/g) || [];
};


/**
 * Sets the entire class name of an element.
 * @param {Element} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classlist.set = function(element, className) {
  'use strict';
  // If className is an instance of SVGAnimatedString use setAttribute
  if ((typeof element.className) == 'string') {
    element.className = className;
    return;
  } else if (element.setAttribute) {
    element.setAttribute('class', className);
  }
};


/**
 * Returns true if an element has a class.  This method may throw a DOM
 * exception for an invalid or empty class name if DOMTokenList is used.
 * @param {Element} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classlist.contains = function(element, className) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    return element.classList.contains(className);
  }
  return goog.array.contains(goog.dom.classlist.get(element), className);
};


/**
 * Adds a class to an element.  Does not add multiples of class names.  This
 * method may throw a DOM exception for an invalid or empty class name if
 * DOMTokenList is used.
 * @param {Element} element DOM node to add class to.
 * @param {string} className Class name to add.
 */
goog.dom.classlist.add = function(element, className) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    element.classList.add(className);
    return;
  }

  if (!goog.dom.classlist.contains(element, className)) {
    // Ensure we add a space if this is not the first class name added.
    var oldClassName = goog.dom.classlist.getClassName_(element);
    goog.dom.classlist.set(
        element,
        oldClassName +
            (oldClassName.length > 0 ? (' ' + className) : className));
  }
};


/**
 * Convenience method to add a number of class names at once.
 * @param {Element} element The element to which to add classes.
 * @param {IArrayLike<string>} classesToAdd An array-like object
 * containing a collection of class names to add to the element.
 * This method may throw a DOM exception if classesToAdd contains invalid
 * or empty class names.
 */
goog.dom.classlist.addAll = function(element, classesToAdd) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    Array.prototype.forEach.call(classesToAdd, function(className) {
      'use strict';
      goog.dom.classlist.add(element, className);
    });
    return;
  }

  var classMap = {};

  // Get all current class names into a map.
  Array.prototype.forEach.call(
      goog.dom.classlist.get(element), function(className) {
        'use strict';
        classMap[className] = true;
      });

  // Add new class names to the map.
  Array.prototype.forEach.call(classesToAdd, function(className) {
    'use strict';
    classMap[className] = true;
  });

  // Flatten the keys of the map into the className.
  var newClassName = '';
  for (var className in classMap) {
    newClassName += newClassName.length > 0 ? (' ' + className) : className;
  }
  goog.dom.classlist.set(element, newClassName);
};


/**
 * Removes a class from an element.  This method may throw a DOM exception
 * for an invalid or empty class name if DOMTokenList is used.
 * @param {Element} element DOM node to remove class from.
 * @param {string} className Class name to remove.
 */
goog.dom.classlist.remove = function(element, className) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    element.classList.remove(className);
    return;
  }

  if (goog.dom.classlist.contains(element, className)) {
    // Filter out the class name.
    goog.dom.classlist.set(
        element,
        Array.prototype.filter
            .call(
                goog.dom.classlist.get(element),
                function(c) {
                  'use strict';
                  return c != className;
                })
            .join(' '));
  }
};


/**
 * Removes a set of classes from an element.  Prefer this call to
 * repeatedly calling `goog.dom.classlist.remove` if you want to remove
 * a large set of class names at once.
 * @param {Element} element The element from which to remove classes.
 * @param {IArrayLike<string>} classesToRemove An array-like object
 * containing a collection of class names to remove from the element.
 * This method may throw a DOM exception if classesToRemove contains invalid
 * or empty class names.
 */
goog.dom.classlist.removeAll = function(element, classesToRemove) {
  'use strict';
  if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
    Array.prototype.forEach.call(classesToRemove, function(className) {
      'use strict';
      goog.dom.classlist.remove(element, className);
    });
    return;
  }

  // Filter out those classes in classesToRemove.
  goog.dom.classlist.set(
      element,
      Array.prototype.filter
          .call(
              goog.dom.classlist.get(element),
              function(className) {
                'use strict';
                // If this class is not one we are trying to remove,
                // add it to the array of new class names.
                return !goog.array.contains(classesToRemove, className);
              })
          .join(' '));
};


/**
 * Adds or removes a class depending on the enabled argument.  This method
 * may throw a DOM exception for an invalid or empty class name if DOMTokenList
 * is used.
 * @param {Element} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classlist.enable = function(element, className, enabled) {
  'use strict';
  if (enabled) {
    goog.dom.classlist.add(element, className);
  } else {
    goog.dom.classlist.remove(element, className);
  }
};


/**
 * Adds or removes a set of classes depending on the enabled argument.  This
 * method may throw a DOM exception for an invalid or empty class name if
 * DOMTokenList is used.
 * @param {!Element} element DOM node to add or remove the class on.
 * @param {?IArrayLike<string>} classesToEnable An array-like object
 *     containing a collection of class names to add or remove from the element.
 * @param {boolean} enabled Whether to add or remove the classes (true adds,
 *     false removes).
 */
goog.dom.classlist.enableAll = function(element, classesToEnable, enabled) {
  'use strict';
  var f = enabled ? goog.dom.classlist.addAll : goog.dom.classlist.removeAll;
  f(element, classesToEnable);
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.  This
 * method may throw a DOM exception if the class names are empty or invalid.
 * @param {Element} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classlist.swap = function(element, fromClass, toClass) {
  'use strict';
  if (goog.dom.classlist.contains(element, fromClass)) {
    goog.dom.classlist.remove(element, fromClass);
    goog.dom.classlist.add(element, toClass);
    return true;
  }
  return false;
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.  This method may throw a DOM
 * exception if the class name is empty or invalid.
 * @param {Element} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classlist.toggle = function(element, className) {
  'use strict';
  var add = !goog.dom.classlist.contains(element, className);
  goog.dom.classlist.enable(element, className, add);
  return add;
};


/**
 * Adds and removes a class of an element.  Unlike
 * {@link goog.dom.classlist.swap}, this method adds the classToAdd regardless
 * of whether the classToRemove was present and had been removed.  This method
 * may throw a DOM exception if the class names are empty or invalid.
 *
 * @param {Element} element DOM node to swap classes on.
 * @param {string} classToRemove Class to remove.
 * @param {string} classToAdd Class to add.
 */
goog.dom.classlist.addRemove = function(element, classToRemove, classToAdd) {
  'use strict';
  goog.dom.classlist.remove(element, classToRemove);
  goog.dom.classlist.add(element, classToAdd);
};

//third_party/javascript/closure/dom/vendor.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Vendor prefix getters.
 */

goog.provide('goog.dom.vendor');

goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Returns the JS vendor prefix used in CSS properties. Different vendors
 * use different methods of changing the case of the property names.
 *
 * @return {?string} The JS vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorJsPrefix = function() {
  'use strict';
  if (goog.userAgent.WEBKIT) {
    return 'Webkit';
  } else if (goog.userAgent.GECKO) {
    return 'Moz';
  } else if (goog.userAgent.IE) {
    return 'ms';
  }

  return null;
};


/**
 * Returns the vendor prefix used in CSS properties.
 *
 * @return {?string} The vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorPrefix = function() {
  'use strict';
  if (goog.userAgent.WEBKIT) {
    return '-webkit';
  } else if (goog.userAgent.GECKO) {
    return '-moz';
  } else if (goog.userAgent.IE) {
    return '-ms';
  }

  return null;
};


/**
 * @param {string} propertyName A property name.
 * @param {!Object=} opt_object If provided, we verify if the property exists in
 *     the object.
 * @return {?string} A vendor prefixed property name, or null if it does not
 *     exist.
 */
goog.dom.vendor.getPrefixedPropertyName = function(propertyName, opt_object) {
  'use strict';
  // We first check for a non-prefixed property, if available.
  if (opt_object && propertyName in opt_object) {
    return propertyName;
  }
  var prefix = goog.dom.vendor.getVendorJsPrefix();
  if (prefix) {
    prefix = prefix.toLowerCase();
    var prefixedPropertyName = prefix + goog.string.toTitleCase(propertyName);
    return (opt_object === undefined || prefixedPropertyName in opt_object) ?
        prefixedPropertyName :
        null;
  }
  return null;
};


/**
 * @param {string} eventType An event type.
 * @return {string} A lower-cased vendor prefixed event type.
 */
goog.dom.vendor.getPrefixedEventType = function(eventType) {
  'use strict';
  var prefix = goog.dom.vendor.getVendorJsPrefix() || '';
  return (prefix + eventType).toLowerCase();
};

//third_party/javascript/closure/math/box.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A utility class for representing a numeric box.
 */


goog.provide('goog.math.Box');

goog.require('goog.asserts');
goog.require('goog.math.Coordinate');



/**
 * Class for representing a box. A box is specified as a top, right, bottom,
 * and left. A box is useful for representing margins and padding.
 *
 * This class assumes 'screen coordinates': larger Y coordinates are further
 * from the top of the screen.
 *
 * @param {number} top Top.
 * @param {number} right Right.
 * @param {number} bottom Bottom.
 * @param {number} left Left.
 * @struct
 * @constructor
 */
goog.math.Box = function(top, right, bottom, left) {
  'use strict';
  /**
   * Top
   * @type {number}
   */
  this.top = top;

  /**
   * Right
   * @type {number}
   */
  this.right = right;

  /**
   * Bottom
   * @type {number}
   */
  this.bottom = bottom;

  /**
   * Left
   * @type {number}
   */
  this.left = left;
};


/**
 * Creates a Box by bounding a collection of goog.math.Coordinate objects
 * @param {...goog.math.Coordinate} var_args Coordinates to be included inside
 *     the box.
 * @return {!goog.math.Box} A Box containing all the specified Coordinates.
 */
goog.math.Box.boundingBox = function(var_args) {
  'use strict';
  var box = new goog.math.Box(
      arguments[0].y, arguments[0].x, arguments[0].y, arguments[0].x);
  for (var i = 1; i < arguments.length; i++) {
    box.expandToIncludeCoordinate(arguments[i]);
  }
  return box;
};


/**
 * @return {number} width The width of this Box.
 */
goog.math.Box.prototype.getWidth = function() {
  'use strict';
  return this.right - this.left;
};


/**
 * @return {number} height The height of this Box.
 */
goog.math.Box.prototype.getHeight = function() {
  'use strict';
  return this.bottom - this.top;
};


/**
 * Creates a copy of the box with the same dimensions.
 * @return {!goog.math.Box} A clone of this Box.
 */
goog.math.Box.prototype.clone = function() {
  'use strict';
  return new goog.math.Box(this.top, this.right, this.bottom, this.left);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the box.
   * @return {string} In the form (50t, 73r, 24b, 13l).
   * @override
   */
  goog.math.Box.prototype.toString = function() {
    'use strict';
    return '(' + this.top + 't, ' + this.right + 'r, ' + this.bottom + 'b, ' +
        this.left + 'l)';
  };
}


/**
 * Returns whether the box contains a coordinate or another box.
 *
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.prototype.contains = function(other) {
  'use strict';
  return goog.math.Box.contains(this, other);
};


/**
 * Expands box with the given margins.
 *
 * @param {number|goog.math.Box} top Top margin or box with all margins.
 * @param {number=} opt_right Right margin.
 * @param {number=} opt_bottom Bottom margin.
 * @param {number=} opt_left Left margin.
 * @return {!goog.math.Box} A reference to this Box.
 */
goog.math.Box.prototype.expand = function(
    top, opt_right, opt_bottom, opt_left) {
  'use strict';
  if (goog.isObject(top)) {
    this.top -= top.top;
    this.right += top.right;
    this.bottom += top.bottom;
    this.left -= top.left;
  } else {
    this.top -= /** @type {number} */ (top);
    this.right += Number(opt_right);
    this.bottom += Number(opt_bottom);
    this.left -= Number(opt_left);
  }

  return this;
};


/**
 * Expand this box to include another box.
 * NOTE(bcornell): This is used in code that needs to be very fast, please don't
 * add functionality to this function at the expense of speed (variable
 * arguments, accepting multiple argument types, etc).
 * @param {goog.math.Box} box The box to include in this one.
 */
goog.math.Box.prototype.expandToInclude = function(box) {
  'use strict';
  this.left = Math.min(this.left, box.left);
  this.top = Math.min(this.top, box.top);
  this.right = Math.max(this.right, box.right);
  this.bottom = Math.max(this.bottom, box.bottom);
};


/**
 * Expand this box to include the coordinate.
 * @param {!goog.math.Coordinate} coord The coordinate to be included
 *     inside the box.
 */
goog.math.Box.prototype.expandToIncludeCoordinate = function(coord) {
  'use strict';
  this.top = Math.min(this.top, coord.y);
  this.right = Math.max(this.right, coord.x);
  this.bottom = Math.max(this.bottom, coord.y);
  this.left = Math.min(this.left, coord.x);
};


/**
 * Compares boxes for equality.
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A Box.
 * @return {boolean} True iff the boxes are equal, or if both are null.
 */
goog.math.Box.equals = function(a, b) {
  'use strict';
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.top == b.top && a.right == b.right && a.bottom == b.bottom &&
      a.left == b.left;
};


/**
 * Returns whether a box contains a coordinate or another box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.contains = function(box, other) {
  'use strict';
  if (!box || !other) {
    return false;
  }

  if (other instanceof goog.math.Box) {
    return other.left >= box.left && other.right <= box.right &&
        other.top >= box.top && other.bottom <= box.bottom;
  }

  // other is a Coordinate.
  return other.x >= box.left && other.x <= box.right && other.y >= box.top &&
      other.y <= box.bottom;
};


/**
 * Returns the relative x position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The x position of `coord` relative to the nearest
 *     side of `box`, or zero if `coord` is inside `box`.
 */
goog.math.Box.relativePositionX = function(box, coord) {
  'use strict';
  if (coord.x < box.left) {
    return coord.x - box.left;
  } else if (coord.x > box.right) {
    return coord.x - box.right;
  }
  return 0;
};


/**
 * Returns the relative y position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The y position of `coord` relative to the nearest
 *     side of `box`, or zero if `coord` is inside `box`.
 */
goog.math.Box.relativePositionY = function(box, coord) {
  'use strict';
  if (coord.y < box.top) {
    return coord.y - box.top;
  } else if (coord.y > box.bottom) {
    return coord.y - box.bottom;
  }
  return 0;
};


/**
 * Returns the distance between a coordinate and the nearest corner/side of a
 * box. Returns zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The distance between `coord` and the nearest
 *     corner/side of `box`, or zero if `coord` is inside
 *     `box`.
 */
goog.math.Box.distance = function(box, coord) {
  'use strict';
  var x = goog.math.Box.relativePositionX(box, coord);
  var y = goog.math.Box.relativePositionY(box, coord);
  return Math.sqrt(x * x + y * y);
};


/**
 * Returns whether two boxes intersect.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersects = function(a, b) {
  'use strict';
  return (
      a.left <= b.right && b.left <= a.right && a.top <= b.bottom &&
      b.top <= a.bottom);
};


/**
 * Returns whether two boxes would intersect with additional padding.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @param {number} padding The additional padding.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersectsWithPadding = function(a, b, padding) {
  'use strict';
  return (
      a.left <= b.right + padding && b.left <= a.right + padding &&
      a.top <= b.bottom + padding && b.top <= a.bottom + padding);
};


/**
 * Rounds the fields to the next larger integer values.
 *
 * @return {!goog.math.Box} This box with ceil'd fields.
 */
goog.math.Box.prototype.ceil = function() {
  'use strict';
  this.top = Math.ceil(this.top);
  this.right = Math.ceil(this.right);
  this.bottom = Math.ceil(this.bottom);
  this.left = Math.ceil(this.left);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 *
 * @return {!goog.math.Box} This box with floored fields.
 */
goog.math.Box.prototype.floor = function() {
  'use strict';
  this.top = Math.floor(this.top);
  this.right = Math.floor(this.right);
  this.bottom = Math.floor(this.bottom);
  this.left = Math.floor(this.left);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 *
 * @return {!goog.math.Box} This box with rounded fields.
 */
goog.math.Box.prototype.round = function() {
  'use strict';
  this.top = Math.round(this.top);
  this.right = Math.round(this.right);
  this.bottom = Math.round(this.bottom);
  this.left = Math.round(this.left);
  return this;
};


/**
 * Translates this box by the given offsets. If a `goog.math.Coordinate`
 * is given, then the left and right values are translated by the coordinate's
 * x value and the top and bottom values are translated by the coordinate's y
 * value.  Otherwise, `tx` and `opt_ty` are used to translate the x
 * and y dimension values.
 *
 * @param {number|goog.math.Coordinate} tx The value to translate the x
 *     dimension values by or the coordinate to translate this box by.
 * @param {number=} opt_ty The value to translate y dimension values by.
 * @return {!goog.math.Box} This box after translating.
 */
goog.math.Box.prototype.translate = function(tx, opt_ty) {
  'use strict';
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.right += tx.x;
    this.top += tx.y;
    this.bottom += tx.y;
  } else {
    goog.asserts.assertNumber(tx);
    this.left += tx;
    this.right += tx;
    if (typeof opt_ty === 'number') {
      this.top += opt_ty;
      this.bottom += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y dimension
 * values are scaled by `sx` and `opt_sy` respectively.
 * If `opt_sy` is not given, then `sx` is used for both x and y.
 *
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Box} This box after scaling.
 */
goog.math.Box.prototype.scale = function(sx, opt_sy) {
  'use strict';
  var sy = (typeof opt_sy === 'number') ? opt_sy : sx;
  this.left *= sx;
  this.right *= sx;
  this.top *= sy;
  this.bottom *= sy;
  return this;
};

//third_party/javascript/closure/math/irect.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A record declaration to allow ClientRect and other rectangle
 * like objects to be used with goog.math.Rect.
 */

goog.provide('goog.math.IRect');


/**
 * Record for representing rectangular regions, allows compatibility between
 * things like ClientRect and goog.math.Rect.
 *
 * @record
 */
goog.math.IRect = function() {};


/** @type {number} */
goog.math.IRect.prototype.left;


/** @type {number} */
goog.math.IRect.prototype.top;


/** @type {number} */
goog.math.IRect.prototype.width;


/** @type {number} */
goog.math.IRect.prototype.height;

//third_party/javascript/closure/math/rect.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A utility class for representing rectangles. Some of these
 * functions should be migrated over to non-nullable params.
 */

goog.provide('goog.math.Rect');

goog.require('goog.asserts');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.IRect');
goog.require('goog.math.Size');



/**
 * Class for representing rectangular regions.
 * @param {number} x Left.
 * @param {number} y Top.
 * @param {number} w Width.
 * @param {number} h Height.
 * @struct
 * @constructor
 * @implements {goog.math.IRect}
 */
goog.math.Rect = function(x, y, w, h) {
  'use strict';
  /** @type {number} */
  this.left = x;

  /** @type {number} */
  this.top = y;

  /** @type {number} */
  this.width = w;

  /** @type {number} */
  this.height = h;
};


/**
 * @return {!goog.math.Rect} A new copy of this Rectangle.
 */
goog.math.Rect.prototype.clone = function() {
  'use strict';
  return new goog.math.Rect(this.left, this.top, this.width, this.height);
};


/**
 * Returns a new Box object with the same position and dimensions as this
 * rectangle.
 * @return {!goog.math.Box} A new Box representation of this Rectangle.
 */
goog.math.Rect.prototype.toBox = function() {
  'use strict';
  var right = this.left + this.width;
  var bottom = this.top + this.height;
  return new goog.math.Box(this.top, right, bottom, this.left);
};


/**
 * Creates a new Rect object with the position and size given.
 * @param {!goog.math.Coordinate} position The top-left coordinate of the Rect
 * @param {!goog.math.Size} size The size of the Rect
 * @return {!goog.math.Rect} A new Rect initialized with the given position and
 *     size.
 */
goog.math.Rect.createFromPositionAndSize = function(position, size) {
  'use strict';
  return new goog.math.Rect(position.x, position.y, size.width, size.height);
};


/**
 * Creates a new Rect object with the same position and dimensions as a given
 * Box.  Note that this is only the inverse of toBox if left/top are defined.
 * @param {goog.math.Box} box A box.
 * @return {!goog.math.Rect} A new Rect initialized with the box's position
 *     and size.
 */
goog.math.Rect.createFromBox = function(box) {
  'use strict';
  return new goog.math.Rect(
      box.left, box.top, box.right - box.left, box.bottom - box.top);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size and dimensions of rectangle.
   * @return {string} In the form (50, 73 - 75w x 25h).
   * @override
   */
  goog.math.Rect.prototype.toString = function() {
    'use strict';
    return '(' + this.left + ', ' + this.top + ' - ' + this.width + 'w x ' +
        this.height + 'h)';
  };
}


/**
 * Compares rectangles for equality.
 * @param {goog.math.IRect} a A Rectangle.
 * @param {goog.math.IRect} b A Rectangle.
 * @return {boolean} True iff the rectangles have the same left, top, width,
 *     and height, or if both are null.
 */
goog.math.Rect.equals = function(a, b) {
  'use strict';
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.left == b.left && a.width == b.width && a.top == b.top &&
      a.height == b.height;
};


/**
 * Computes the intersection of this rectangle and the rectangle parameter.  If
 * there is no intersection, returns false and leaves this rectangle as is.
 * @param {goog.math.IRect} rect A Rectangle.
 * @return {boolean} True iff this rectangle intersects with the parameter.
 */
goog.math.Rect.prototype.intersection = function(rect) {
  'use strict';
  var x0 = Math.max(this.left, rect.left);
  var x1 = Math.min(this.left + this.width, rect.left + rect.width);

  if (x0 <= x1) {
    var y0 = Math.max(this.top, rect.top);
    var y1 = Math.min(this.top + this.height, rect.top + rect.height);

    if (y0 <= y1) {
      this.left = x0;
      this.top = y0;
      this.width = x1 - x0;
      this.height = y1 - y0;

      return true;
    }
  }
  return false;
};


/**
 * Returns the intersection of two rectangles. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.IRect} a A Rectangle.
 * @param {goog.math.IRect} b A Rectangle.
 * @return {goog.math.Rect} A new intersection rect (even if width and height
 *     are 0), or null if there is no intersection.
 */
goog.math.Rect.intersection = function(a, b) {
  'use strict';
  // There is no nice way to do intersection via a clone, because any such
  // clone might be unnecessary if this function returns null.  So, we duplicate
  // code from above.

  var x0 = Math.max(a.left, b.left);
  var x1 = Math.min(a.left + a.width, b.left + b.width);

  if (x0 <= x1) {
    var y0 = Math.max(a.top, b.top);
    var y1 = Math.min(a.top + a.height, b.top + b.height);

    if (y0 <= y1) {
      return new goog.math.Rect(x0, y0, x1 - x0, y1 - y0);
    }
  }
  return null;
};


/**
 * Returns whether two rectangles intersect. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.IRect} a A Rectangle.
 * @param {goog.math.IRect} b A Rectangle.
 * @return {boolean} Whether a and b intersect.
 */
goog.math.Rect.intersects = function(a, b) {
  'use strict';
  return (
      a.left <= b.left + b.width && b.left <= a.left + a.width &&
      a.top <= b.top + b.height && b.top <= a.top + a.height);
};


/**
 * Returns whether a rectangle intersects this rectangle.
 * @param {goog.math.IRect} rect A rectangle.
 * @return {boolean} Whether rect intersects this rectangle.
 */
goog.math.Rect.prototype.intersects = function(rect) {
  'use strict';
  return goog.math.Rect.intersects(this, rect);
};


/**
 * Computes the difference regions between two rectangles. The return value is
 * an array of 0 to 4 rectangles defining the remaining regions of the first
 * rectangle after the second has been subtracted.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.IRect} b A Rectangle.
 * @return {!Array<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.difference = function(a, b) {
  'use strict';
  var intersection = goog.math.Rect.intersection(a, b);
  if (!intersection || !intersection.height || !intersection.width) {
    return [a.clone()];
  }

  var result = [];

  var top = a.top;
  var height = a.height;

  var ar = a.left + a.width;
  var ab = a.top + a.height;

  var br = b.left + b.width;
  var bb = b.top + b.height;

  // Subtract off any area on top where A extends past B
  if (b.top > a.top) {
    result.push(new goog.math.Rect(a.left, a.top, a.width, b.top - a.top));
    top = b.top;
    // If we're moving the top down, we also need to subtract the height diff.
    height -= b.top - a.top;
  }
  // Subtract off any area on bottom where A extends past B
  if (bb < ab) {
    result.push(new goog.math.Rect(a.left, bb, a.width, ab - bb));
    height = bb - top;
  }
  // Subtract any area on left where A extends past B
  if (b.left > a.left) {
    result.push(new goog.math.Rect(a.left, top, b.left - a.left, height));
  }
  // Subtract any area on right where A extends past B
  if (br < ar) {
    result.push(new goog.math.Rect(br, top, ar - br, height));
  }

  return result;
};


/**
 * Computes the difference regions between this rectangle and `rect`. The
 * return value is an array of 0 to 4 rectangles defining the remaining regions
 * of this rectangle after the other has been subtracted.
 * @param {goog.math.IRect} rect A Rectangle.
 * @return {!Array<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.prototype.difference = function(rect) {
  'use strict';
  return goog.math.Rect.difference(this, rect);
};


/**
 * Expand this rectangle to also include the area of the given rectangle.
 * @param {goog.math.IRect} rect The other rectangle.
 */
goog.math.Rect.prototype.boundingRect = function(rect) {
  'use strict';
  // We compute right and bottom before we change left and top below.
  var right = Math.max(this.left + this.width, rect.left + rect.width);
  var bottom = Math.max(this.top + this.height, rect.top + rect.height);

  this.left = Math.min(this.left, rect.left);
  this.top = Math.min(this.top, rect.top);

  this.width = right - this.left;
  this.height = bottom - this.top;
};


/**
 * Returns a new rectangle which completely contains both input rectangles.
 * @param {goog.math.IRect} a A rectangle.
 * @param {goog.math.IRect} b A rectangle.
 * @return {goog.math.Rect} A new bounding rect, or null if either rect is
 *     null.
 */
goog.math.Rect.boundingRect = function(a, b) {
  'use strict';
  if (!a || !b) {
    return null;
  }

  var newRect = new goog.math.Rect(a.left, a.top, a.width, a.height);
  newRect.boundingRect(b);

  return newRect;
};


/**
 * Tests whether this rectangle entirely contains another rectangle or
 * coordinate.
 *
 * @param {goog.math.IRect|goog.math.Coordinate} another The rectangle or
 *     coordinate to test for containment.
 * @return {boolean} Whether this rectangle contains given rectangle or
 *     coordinate.
 */
goog.math.Rect.prototype.contains = function(another) {
  'use strict';
  if (another instanceof goog.math.Coordinate) {
    return another.x >= this.left && another.x <= this.left + this.width &&
        another.y >= this.top && another.y <= this.top + this.height;
  } else {  // (another instanceof goog.math.IRect)
    return this.left <= another.left &&
        this.left + this.width >= another.left + another.width &&
        this.top <= another.top &&
        this.top + this.height >= another.top + another.height;
  }
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The squared distance between the point and the closest
 *     point inside the rectangle. Returns 0 if the point is inside the
 *     rectangle.
 */
goog.math.Rect.prototype.squaredDistance = function(point) {
  'use strict';
  var dx = point.x < this.left ?
      this.left - point.x :
      Math.max(point.x - (this.left + this.width), 0);
  var dy = point.y < this.top ? this.top - point.y :
                                Math.max(point.y - (this.top + this.height), 0);
  return dx * dx + dy * dy;
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The distance between the point and the closest point
 *     inside the rectangle. Returns 0 if the point is inside the rectangle.
 */
goog.math.Rect.prototype.distance = function(point) {
  'use strict';
  return Math.sqrt(this.squaredDistance(point));
};


/**
 * @return {!goog.math.Size} The size of this rectangle.
 */
goog.math.Rect.prototype.getSize = function() {
  'use strict';
  return new goog.math.Size(this.width, this.height);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the top-left corner of
 *     the rectangle.
 */
goog.math.Rect.prototype.getTopLeft = function() {
  'use strict';
  return new goog.math.Coordinate(this.left, this.top);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the center of the
 *     rectangle.
 */
goog.math.Rect.prototype.getCenter = function() {
  'use strict';
  return new goog.math.Coordinate(
      this.left + this.width / 2, this.top + this.height / 2);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the bottom-right corner
 *     of the rectangle.
 */
goog.math.Rect.prototype.getBottomRight = function() {
  'use strict';
  return new goog.math.Coordinate(
      this.left + this.width, this.top + this.height);
};


/**
 * Rounds the fields to the next larger integer values.
 * @return {!goog.math.Rect} This rectangle with ceil'd fields.
 */
goog.math.Rect.prototype.ceil = function() {
  'use strict';
  this.left = Math.ceil(this.left);
  this.top = Math.ceil(this.top);
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 * @return {!goog.math.Rect} This rectangle with floored fields.
 */
goog.math.Rect.prototype.floor = function() {
  'use strict';
  this.left = Math.floor(this.left);
  this.top = Math.floor(this.top);
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 * @return {!goog.math.Rect} This rectangle with rounded fields.
 */
goog.math.Rect.prototype.round = function() {
  'use strict';
  this.left = Math.round(this.left);
  this.top = Math.round(this.top);
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Translates this rectangle by the given offsets. If a
 * `goog.math.Coordinate` is given, then the left and top values are
 * translated by the coordinate's x and y values. Otherwise, left and top are
 * translated by `tx` and `opt_ty` respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate left by or the
 *     the coordinate to translate this rect by.
 * @param {number=} opt_ty The value to translate top by.
 * @return {!goog.math.Rect} This rectangle after translating.
 */
goog.math.Rect.prototype.translate = function(tx, opt_ty) {
  'use strict';
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.top += tx.y;
  } else {
    this.left += goog.asserts.assertNumber(tx);
    if (typeof opt_ty === 'number') {
      this.top += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this rectangle by the given scale factors. The left and width values
 * are scaled by `sx` and the top and height values are scaled by
 * `opt_sy`.  If `opt_sy` is not given, then all fields are scaled
 * by `sx`.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Rect} This rectangle after scaling.
 */
goog.math.Rect.prototype.scale = function(sx, opt_sy) {
  'use strict';
  var sy = (typeof opt_sy === 'number') ? opt_sy : sx;
  this.left *= sx;
  this.width *= sx;
  this.top *= sy;
  this.height *= sy;
  return this;
};

//third_party/javascript/closure/style/style.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for element styles.
 *
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 * @see ../demos/style_viewport.html
 */

goog.provide('goog.style');


goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.safe');
goog.require('goog.dom.vendor');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.reflect');
goog.require('goog.string');
goog.require('goog.userAgent');
goog.requireType('goog.events.Event');


/**
 * Sets a style value on an element.
 *
 * This function is not indended to patch issues in the browser's style
 * handling, but to allow easy programmatic access to setting dash-separated
 * style properties.  An example is setting a batch of properties from a data
 * object without overwriting old styles.  When possible, use native APIs:
 * elem.style.propertyKey = 'value' or (if obliterating old styles is fine)
 * elem.style.cssText = 'property1: value1; property2: value2'.
 *
 * @param {Element} element The element to change.
 * @param {string|Object} style If a string, a style name. If an object, a hash
 *     of style names to style values.
 * @param {string|number|boolean=} opt_value If style was a string, then this
 *     should be the value.
 * @return {void}
 */
goog.style.setStyle = function(element, style, opt_value) {
  'use strict';
  if (typeof style === 'string') {
    goog.style.setStyle_(element, opt_value, style);
  } else {
    for (var key in style) {
      goog.style.setStyle_(element, style[key], key);
    }
  }
};


/**
 * Sets a style value on an element, with parameters swapped to work with
 * `goog.object.forEach()`. Prepends a vendor-specific prefix when
 * necessary.
 * @param {Element} element The element to change.
 * @param {string|number|boolean|undefined} value Style value.
 * @param {string} style Style name.
 * @private
 */
goog.style.setStyle_ = function(element, value, style) {
  'use strict';
  var propertyName = goog.style.getVendorJsStyleName_(element, style);

  if (propertyName) {
    // TODO(johnlenz): coerce to string?
    element.style[propertyName] = /** @type {?} */ (value);
  }
};


/**
 * Style name cache that stores previous property name lookups.
 *
 * This is used by setStyle to speed up property lookups, entries look like:
 *   { StyleName: ActualPropertyName }
 *
 * @private {!Object<string, string>}
 */
goog.style.styleNameCache_ = {};


/**
 * Returns the style property name in camel-case. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorJsStyleName_ = function(element, style) {
  'use strict';
  var propertyName = goog.style.styleNameCache_[style];
  if (!propertyName) {
    var camelStyle = goog.string.toCamelCase(style);
    propertyName = camelStyle;

    if (element.style[camelStyle] === undefined) {
      var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
          goog.string.toTitleCase(camelStyle);

      if (element.style[prefixedStyle] !== undefined) {
        propertyName = prefixedStyle;
      }
    }
    goog.style.styleNameCache_[style] = propertyName;
  }

  return propertyName;
};


/**
 * Returns the style property name in CSS notation. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorStyleName_ = function(element, style) {
  'use strict';
  var camelStyle = goog.string.toCamelCase(style);

  if (element.style[camelStyle] === undefined) {
    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
        goog.string.toTitleCase(camelStyle);

    if (element.style[prefixedStyle] !== undefined) {
      return goog.dom.vendor.getVendorPrefix() + '-' + style;
    }
  }

  return style;
};


/**
 * Retrieves an explicitly-set style value of a node. This returns '' if there
 * isn't a style attribute on the element or if this style property has not been
 * explicitly set in script.
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get, css-style (if you have a camel-case
 * property, use element.style[style]).
 * @return {string} Style value.
 */
goog.style.getStyle = function(element, property) {
  'use strict';
  // element.style is '' for well-known properties which are unset.
  // For for browser specific styles as 'filter' is undefined
  // so we need to return '' explicitly to make it consistent across
  // browsers.
  var styleValue = element.style[goog.string.toCamelCase(property)];

  // Using typeof here because of a bug in Safari 5.1, where this value
  // was undefined, but === undefined returned false.
  if (typeof(styleValue) !== 'undefined') {
    return styleValue;
  }

  return element.style[goog.style.getVendorJsStyleName_(element, property)] ||
      '';
};


/**
 * Retrieves a computed style value of a node. It returns empty string if the
 * value cannot be computed (which will be the case in Internet Explorer) or
 * "none" if the property requested is an SVG one and it has not been
 * explicitly set (firefox and webkit).
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getComputedStyle = function(element, property) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(element);
  if (doc.defaultView && doc.defaultView.getComputedStyle) {
    var styles = doc.defaultView.getComputedStyle(element, null);
    if (styles) {
      // element.style[..] is undefined for browser specific styles
      // as 'filter'.
      return styles[property] || styles.getPropertyValue(property) || '';
    }
  }

  return '';
};


/**
 * Gets the cascaded style value of a node, or null if the value cannot be
 * computed (only Internet Explorer can do this).
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getCascadedStyle = function(element, style) {
  'use strict';
  // TODO(nicksantos): This should be documented to return null. #fixTypes
  return /** @type {string} */ (
      element.currentStyle ? element.currentStyle[style] : null);
};


/**
 * Cross-browser pseudo get computed style. It returns the computed style where
 * available. If not available it tries the cascaded style value (IE
 * currentStyle) and in worst case the inline style value.  It shouldn't be
 * called directly, see http://wiki/Main/ComputedStyleVsCascadedStyle for
 * discussion.
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (must be camelCase, not css-style.).
 * @return {string} Style value.
 * @private
 */
goog.style.getStyle_ = function(element, style) {
  'use strict';
  return goog.style.getComputedStyle(element, style) ||
      goog.style.getCascadedStyle(element, style) ||
      (element.style && element.style[style]);
};


/**
 * Retrieves the computed value of the box-sizing CSS attribute.
 * Browser support: http://caniuse.com/css3-boxsizing.
 * @param {!Element} element The element whose box-sizing to get.
 * @return {?string} 'content-box', 'border-box' or 'padding-box'. null if
 *     box-sizing is not supported (IE7 and below).
 */
goog.style.getComputedBoxSizing = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'boxSizing') ||
      goog.style.getStyle_(element, 'MozBoxSizing') ||
      goog.style.getStyle_(element, 'WebkitBoxSizing') || null;
};


/**
 * Retrieves the computed value of the position CSS attribute.
 * @param {Element} element The element to get the position of.
 * @return {string} Position value.
 */
goog.style.getComputedPosition = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'position');
};


/**
 * Retrieves the computed background color string for a given element. The
 * string returned is suitable for assigning to another element's
 * background-color, but is not guaranteed to be in any particular string
 * format. Accessing the color in a numeric form may not be possible in all
 * browsers or with all input.
 *
 * If the background color for the element is defined as a hexadecimal value,
 * the resulting string can be parsed by goog.color.parse in all supported
 * browsers.
 *
 * Whether named colors like "red" or "lightblue" get translated into a
 * format which can be parsed is browser dependent. Calling this function on
 * transparent elements will return "transparent" in most browsers or
 * "rgba(0, 0, 0, 0)" in WebKit.
 * @param {Element} element The element to get the background color of.
 * @return {string} The computed string value of the background color.
 */
goog.style.getBackgroundColor = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'backgroundColor');
};


/**
 * Retrieves the computed value of the overflow-x CSS attribute.
 * @param {Element} element The element to get the overflow-x of.
 * @return {string} The computed string value of the overflow-x attribute.
 */
goog.style.getComputedOverflowX = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'overflowX');
};


/**
 * Retrieves the computed value of the overflow-y CSS attribute.
 * @param {Element} element The element to get the overflow-y of.
 * @return {string} The computed string value of the overflow-y attribute.
 */
goog.style.getComputedOverflowY = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'overflowY');
};


/**
 * Retrieves the computed value of the z-index CSS attribute.
 * @param {Element} element The element to get the z-index of.
 * @return {string|number} The computed value of the z-index attribute.
 */
goog.style.getComputedZIndex = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'zIndex');
};


/**
 * Retrieves the computed value of the text-align CSS attribute.
 * @param {Element} element The element to get the text-align of.
 * @return {string} The computed string value of the text-align attribute.
 */
goog.style.getComputedTextAlign = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'textAlign');
};


/**
 * Retrieves the computed value of the cursor CSS attribute.
 * @param {Element} element The element to get the cursor of.
 * @return {string} The computed string value of the cursor attribute.
 */
goog.style.getComputedCursor = function(element) {
  'use strict';
  return goog.style.getStyle_(element, 'cursor');
};


/**
 * Retrieves the computed value of the CSS transform attribute.
 * @param {Element} element The element to get the transform of.
 * @return {string} The computed string representation of the transform matrix.
 */
goog.style.getComputedTransform = function(element) {
  'use strict';
  var property = goog.style.getVendorStyleName_(element, 'transform');
  return goog.style.getStyle_(element, property) ||
      goog.style.getStyle_(element, 'transform');
};


/**
 * Sets the top/left values of an element.  If no unit is specified in the
 * argument then it will add px. The second argument is required if the first
 * argument is a string or number and is ignored if the first argument
 * is a coordinate.
 * @param {Element} el Element to move.
 * @param {string|number|goog.math.Coordinate} arg1 Left position or coordinate.
 * @param {string|number=} opt_arg2 Top position.
 * @return {void}
 */
goog.style.setPosition = function(el, arg1, opt_arg2) {
  'use strict';
  var x, y;

  if (arg1 instanceof goog.math.Coordinate) {
    x = arg1.x;
    y = arg1.y;
  } else {
    x = arg1;
    y = opt_arg2;
  }

  el.style.left = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (x), false);
  el.style.top = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (y), false);
};


/**
 * Gets the offsetLeft and offsetTop properties of an element and returns them
 * in a Coordinate object
 * @param {Element} element Element.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getPosition = function(element) {
  'use strict';
  return new goog.math.Coordinate(
      /** @type {!HTMLElement} */ (element).offsetLeft,
      /** @type {!HTMLElement} */ (element).offsetTop);
};


/**
 * Returns the viewport element for a particular document
 * @param {Node=} opt_node DOM node (Document is OK) to get the viewport element
 *     of.
 * @return {Element} document.documentElement or document.body.
 */
goog.style.getClientViewportElement = function(opt_node) {
  'use strict';
  var doc;
  if (opt_node) {
    doc = goog.dom.getOwnerDocument(opt_node);
  } else {
    doc = goog.dom.getDocument();
  }

  // In old IE versions the document.body represented the viewport
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
      !goog.dom.getDomHelper(doc).isCss1CompatMode()) {
    return doc.body;
  }
  return doc.documentElement;
};


/**
 * Calculates the viewport coordinates relative to the page/document
 * containing the node. The viewport may be the browser viewport for
 * non-iframe document, or the iframe container for iframe'd document.
 * @param {!Document} doc The document to use as the reference point.
 * @return {!goog.math.Coordinate} The page offset of the viewport.
 */
goog.style.getViewportPageOffset = function(doc) {
  'use strict';
  var body = doc.body;
  var documentElement = doc.documentElement;
  var scrollLeft = body.scrollLeft || documentElement.scrollLeft;
  var scrollTop = body.scrollTop || documentElement.scrollTop;
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Gets the client rectangle of the DOM element.
 *
 * getBoundingClientRect is part of a new CSS object model draft (with a
 * long-time presence in IE), replacing the error-prone parent offset
 * computation and the now-deprecated Gecko getBoxObjectFor.
 *
 * This utility patches common browser bugs in getBoundingClientRect. It
 * will fail if getBoundingClientRect is unsupported.
 *
 * If the element is not in the DOM, the result is undefined, and an error may
 * be thrown depending on user agent.
 *
 * @param {!Element} el The element whose bounding rectangle is being queried.
 * @return {!Object} A native bounding rectangle with numerical left, top,
 *     right, and bottom.  Reported by Firefox to be of object type ClientRect.
 * @private
 */
goog.style.getBoundingClientRect_ = function(el) {
  'use strict';
  try {
    return el.getBoundingClientRect();
  } catch (e) {
    // In IE, calling getBoundingClientRect on an orphan element raises an
    // "Unspecified Error". All other browsers return zeros.
    return {'left': 0, 'top': 0, 'right': 0, 'bottom': 0};
  }
};


/**
 * Returns the first parent that could affect the position of a given element.
 * @param {Element} element The element to get the offset parent for.
 * @return {Element} The first offset parent or null if one cannot be found.
 */
goog.style.getOffsetParent = function(element) {
  'use strict';
  // element.offsetParent does the right thing in IE7 and below.  In other
  // browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8)) {
    goog.asserts.assert(element && 'offsetParent' in element);
    return element.offsetParent;
  }

  var doc = goog.dom.getOwnerDocument(element);
  var positionStyle = goog.style.getStyle_(element, 'position');
  var skipStatic = positionStyle == 'fixed' || positionStyle == 'absolute';
  for (var parent = element.parentNode; parent && parent != doc;
       parent = parent.parentNode) {
    // Skip shadowDOM roots.
    if (parent.nodeType == goog.dom.NodeType.DOCUMENT_FRAGMENT && parent.host) {
      // Cast because the assignment is not type safe, and without a cast we
      // start typing parent loosely and get bad disambiguation.
      parent = /** @type {!Element} */ (parent.host);
    }
    positionStyle =
        goog.style.getStyle_(/** @type {!Element} */ (parent), 'position');
    skipStatic = skipStatic && positionStyle == 'static' &&
        parent != doc.documentElement && parent != doc.body;
    if (!skipStatic &&
        (parent.scrollWidth > parent.clientWidth ||
         parent.scrollHeight > parent.clientHeight ||
         positionStyle == 'fixed' || positionStyle == 'absolute' ||
         positionStyle == 'relative')) {
      return /** @type {!Element} */ (parent);
    }
  }
  return null;
};


/**
 * Calculates and returns the visible rectangle for a given element. Returns a
 * box describing the visible portion of the nearest scrollable offset ancestor.
 * Coordinates are given relative to the document.
 *
 * @param {Element} element Element to get the visible rect for.
 * @return {goog.math.Box} Bounding elementBox describing the visible rect or
 *     null if scrollable ancestor isn't inside the visible viewport.
 */
goog.style.getVisibleRectForElement = function(element) {
  'use strict';
  var visibleRect = new goog.math.Box(0, Infinity, Infinity, 0);
  var dom = goog.dom.getDomHelper(element);
  var body = dom.getDocument().body;
  var documentElement = dom.getDocument().documentElement;
  var scrollEl = dom.getDocumentScrollElement();

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  for (var el = element; el = goog.style.getOffsetParent(el);) {
    // clientWidth is zero for inline block elements in IE.
    // on WEBKIT, body element can have clientHeight = 0 and scrollHeight > 0
    if ((!goog.userAgent.IE || el.clientWidth != 0) &&
        (!goog.userAgent.WEBKIT || el.clientHeight != 0 || el != body) &&
        // body may have overflow set on it, yet we still get the entire
        // viewport. In some browsers, el.offsetParent may be
        // document.documentElement, so check for that too.
        (el != body && el != documentElement &&
         goog.style.getStyle_(el, 'overflow') != 'visible')) {
      var pos = goog.style.getPageOffset(el);
      var client = goog.style.getClientLeftTop(el);
      pos.x += client.x;
      pos.y += client.y;

      visibleRect.top = Math.max(visibleRect.top, pos.y);
      visibleRect.right = Math.min(visibleRect.right, pos.x + el.clientWidth);
      visibleRect.bottom =
          Math.min(visibleRect.bottom, pos.y + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.x);
    }
  }

  // Clip by window's viewport.
  var scrollX = scrollEl.scrollLeft, scrollY = scrollEl.scrollTop;
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  var winSize = dom.getViewportSize();
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 &&
          visibleRect.bottom > visibleRect.top &&
          visibleRect.right > visibleRect.left ?
      visibleRect :
      null;
};


/**
 * Calculate the scroll position of `container` with the minimum amount so
 * that the content and the borders of the given `element` become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element=} opt_container The container to scroll. If not set, then the
 *     document scroll element will be used.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 * @return {!goog.math.Coordinate} The new scroll position of the container,
 *     in form of goog.math.Coordinate(scrollLeft, scrollTop).
 */
goog.style.getContainerOffsetToScrollInto = function(
    element, opt_container, opt_center) {
  'use strict';
  var container = opt_container || goog.dom.getDocumentScrollElement();
  // Absolute position of the element's border's top left corner.
  var elementPos = goog.style.getPageOffset(element);
  // Absolute position of the container's border's top left corner.
  var containerPos = goog.style.getPageOffset(container);
  var containerBorder = goog.style.getBorderBox(container);
  if (container == goog.dom.getDocumentScrollElement()) {
    // The element position is calculated based on the page offset, and the
    // document scroll element holds the scroll position within the page. We can
    // use the scroll position to calculate the relative position from the
    // element.
    var relX = elementPos.x - container.scrollLeft;
    var relY = elementPos.y - container.scrollTop;
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(10)) {
      // In older versions of IE getPageOffset(element) does not include the
      // container border so it has to be added to accommodate.
      relX += containerBorder.left;
      relY += containerBorder.top;
    }
  } else {
    // Relative pos. of the element's border box to the container's content box.
    var relX = elementPos.x - containerPos.x - containerBorder.left;
    var relY = elementPos.y - containerPos.y - containerBorder.top;
  }
  // How much the element can move in the container, i.e. the difference between
  // the element's bottom-right-most and top-left-most position where it's
  // fully visible.
  var elementSize = goog.style.getSizeWithDisplay_(element);
  var spaceX = container.clientWidth - elementSize.width;
  var spaceY = container.clientHeight - elementSize.height;
  var scrollLeft = container.scrollLeft;
  var scrollTop = container.scrollTop;
  if (opt_center) {
    // All browsers round non-integer scroll positions down.
    scrollLeft += relX - spaceX / 2;
    scrollTop += relY - spaceY / 2;
  } else {
    // This formula was designed to give the correct scroll values in the
    // following cases:
    // - element is higher than container (spaceY < 0) => scroll down by relY
    // - element is not higher that container (spaceY >= 0):
    //   - it is above container (relY < 0) => scroll up by abs(relY)
    //   - it is below container (relY > spaceY) => scroll down by relY - spaceY
    //   - it is in the container => don't scroll
    scrollLeft += Math.min(relX, Math.max(relX - spaceX, 0));
    scrollTop += Math.min(relY, Math.max(relY - spaceY, 0));
  }
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Changes the scroll position of `container` with the minimum amount so
 * that the content and the borders of the given `element` become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element=} opt_container The container to scroll. If not set, then the
 *     document scroll element will be used.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 */
goog.style.scrollIntoContainerView = function(
    element, opt_container, opt_center) {
  'use strict';
  var container = opt_container || goog.dom.getDocumentScrollElement();
  var offset =
      goog.style.getContainerOffsetToScrollInto(element, container, opt_center);
  container.scrollLeft = offset.x;
  container.scrollTop = offset.y;
};


/**
 * Returns clientLeft (width of the left border and, if the directionality is
 * right to left, the vertical scrollbar) and clientTop as a coordinate object.
 *
 * @param {Element} el Element to get clientLeft for.
 * @return {!goog.math.Coordinate} Client left and top.
 */
goog.style.getClientLeftTop = function(el) {
  'use strict';
  return new goog.math.Coordinate(el.clientLeft, el.clientTop);
};


/**
 * Returns a Coordinate object relative to the top-left of the HTML document.
 * Implemented as a single function to save having to do two recursive loops in
 * opera and safari just to get both coordinates.  If you just want one value do
 * use goog.style.getPageOffsetLeft() and goog.style.getPageOffsetTop(), but
 * note if you call both those methods the tree will be analysed twice.
 *
 * @param {Element} el Element to get the page offset for.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getPageOffset = function(el) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(el);
  // TODO(gboyer): Update the jsdoc in a way that doesn't break the universe.
  goog.asserts.assertObject(el, 'Parameter is required');

  // NOTE(arv): If element is hidden (display none or disconnected or any the
  // ancestors are hidden) we get (0,0) by default but we still do the
  // accumulation of scroll position.

  // TODO(arv): Should we check if the node is disconnected and in that case
  //            return (0,0)?

  var pos = new goog.math.Coordinate(0, 0);
  var viewportElement = goog.style.getClientViewportElement(doc);
  if (el == viewportElement) {
    // viewport is always at 0,0 as that defined the coordinate system for this
    // function - this avoids special case checks in the code below
    return pos;
  }

  var box = goog.style.getBoundingClientRect_(el);
  // Must add the scroll coordinates in to get the absolute page offset
  // of element since getBoundingClientRect returns relative coordinates to
  // the viewport.
  var scrollCoord = goog.dom.getDomHelper(doc).getDocumentScroll();
  pos.x = box.left + scrollCoord.x;
  pos.y = box.top + scrollCoord.y;

  return pos;
};


/**
 * Returns the left coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The left coordinate.
 */
goog.style.getPageOffsetLeft = function(el) {
  'use strict';
  return goog.style.getPageOffset(el).x;
};


/**
 * Returns the top coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The top coordinate.
 */
goog.style.getPageOffsetTop = function(el) {
  'use strict';
  return goog.style.getPageOffset(el).y;
};


/**
 * Returns a Coordinate object relative to the top-left of an HTML document
 * in an ancestor frame of this element. Used for measuring the position of
 * an element inside a frame relative to a containing frame.
 *
 * @param {Element} el Element to get the page offset for.
 * @param {Window} relativeWin The window to measure relative to. If relativeWin
 *     is not in the ancestor frame chain of the element, we measure relative to
 *     the top-most window.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getFramedPageOffset = function(el, relativeWin) {
  'use strict';
  var position = new goog.math.Coordinate(0, 0);

  // Iterate up the ancestor frame chain, keeping track of the current window
  // and the current element in that window.
  var currentWin = goog.dom.getWindow(goog.dom.getOwnerDocument(el));

  // MS Edge throws when accessing "parent" if el's containing iframe has been
  // deleted.
  if (!goog.reflect.canAccessProperty(currentWin, 'parent')) {
    return position;
  }

  var currentEl = el;
  do {
    // if we're at the top window, we want to get the page offset.
    // if we're at an inner frame, we only want to get the window position
    // so that we can determine the actual page offset in the context of
    // the outer window.
    var offset = currentWin == relativeWin ?
        goog.style.getPageOffset(currentEl) :
        goog.style.getClientPositionForElement_(goog.asserts.assert(currentEl));

    position.x += offset.x;
    position.y += offset.y;
  } while (currentWin && currentWin != relativeWin &&
           currentWin != currentWin.parent &&
           (currentEl = currentWin.frameElement) &&
           (currentWin = currentWin.parent));

  return position;
};


/**
 * Translates the specified rect relative to origBase page, for newBase page.
 * If origBase and newBase are the same, this function does nothing.
 *
 * @param {goog.math.Rect} rect The source rectangle relative to origBase page,
 *     and it will have the translated result.
 * @param {goog.dom.DomHelper} origBase The DomHelper for the input rectangle.
 * @param {goog.dom.DomHelper} newBase The DomHelper for the resultant
 *     coordinate.  This must be a DOM for an ancestor frame of origBase
 *     or the same as origBase.
 */
goog.style.translateRectForAnotherFrame = function(rect, origBase, newBase) {
  'use strict';
  if (origBase.getDocument() != newBase.getDocument()) {
    var body = origBase.getDocument().body;
    var pos = goog.style.getFramedPageOffset(body, newBase.getWindow());

    // Adjust Body's margin.
    pos = goog.math.Coordinate.difference(pos, goog.style.getPageOffset(body));

    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
        !origBase.isCss1CompatMode()) {
      pos = goog.math.Coordinate.difference(pos, origBase.getDocumentScroll());
    }

    rect.left += pos.x;
    rect.top += pos.y;
  }
};


/**
 * Returns the position of an element relative to another element in the
 * document.  A relative to B
 * @param {Element|Event|goog.events.Event} a Element or mouse event whose
 *     position we're calculating.
 * @param {Element|Event|goog.events.Event} b Element or mouse event position
 *     is relative to.
 * @return {!goog.math.Coordinate} The relative position.
 */
goog.style.getRelativePosition = function(a, b) {
  'use strict';
  var ap = goog.style.getClientPosition(a);
  var bp = goog.style.getClientPosition(b);
  return new goog.math.Coordinate(ap.x - bp.x, ap.y - bp.y);
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport.
 * @param {!Element} el Element whose position to get.
 * @return {!goog.math.Coordinate} The position.
 * @private
 */
goog.style.getClientPositionForElement_ = function(el) {
  'use strict';
  var box = goog.style.getBoundingClientRect_(el);
  return new goog.math.Coordinate(box.left, box.top);
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport. If an event is passed, and if this event is a "touch"
 * event, then the position of the first changedTouches will be returned.
 * @param {Element|Event|goog.events.Event} el Element or a mouse / touch event.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getClientPosition = function(el) {
  'use strict';
  goog.asserts.assert(el);
  if (el.nodeType == goog.dom.NodeType.ELEMENT) {
    return goog.style.getClientPositionForElement_(
        /** @type {!Element} */ (el));
  } else {
    var targetEvent = el.changedTouches ? el.changedTouches[0] : el;
    return new goog.math.Coordinate(targetEvent.clientX, targetEvent.clientY);
  }
};


/**
 * Moves an element to the given coordinates relative to the client viewport.
 * @param {Element} el Absolutely positioned element to set page offset for.
 *     It must be in the document.
 * @param {number|goog.math.Coordinate} x Left position of the element's margin
 *     box or a coordinate object.
 * @param {number=} opt_y Top position of the element's margin box.
 * @return {void}
 */
goog.style.setPageOffset = function(el, x, opt_y) {
  'use strict';
  // Get current pageoffset
  var cur = goog.style.getPageOffset(el);

  if (x instanceof goog.math.Coordinate) {
    opt_y = x.y;
    x = x.x;
  }

  // NOTE(arv): We cannot allow strings for x and y. We could but that would
  // require us to manually transform between different units

  // Work out deltas
  var dx = goog.asserts.assertNumber(x) - cur.x;
  var dy = Number(opt_y) - cur.y;

  // Set position to current left/top + delta
  goog.style.setPosition(
      el, /** @type {!HTMLElement} */ (el).offsetLeft + dx,
      /** @type {!HTMLElement} */ (el).offsetTop + dy);
};


/**
 * Sets the width/height values of an element.  If an argument is numeric,
 * or a goog.math.Size is passed, it is assumed to be pixels and will add
 * 'px' after converting it to an integer in string form. (This just sets the
 * CSS width and height properties so it might set content-box or border-box
 * size depending on the box model the browser is using.)
 *
 * @param {Element} element Element to set the size of.
 * @param {string|number|goog.math.Size} w Width of the element, or a
 *     size object.
 * @param {string|number=} opt_h Height of the element. Required if w is not a
 *     size object.
 * @return {void}
 */
goog.style.setSize = function(element, w, opt_h) {
  'use strict';
  var h;
  if (w instanceof goog.math.Size) {
    h = w.height;
    w = w.width;
  } else {
    if (opt_h == undefined) {
      throw new Error('missing height argument');
    }
    h = opt_h;
  }

  goog.style.setWidth(element, /** @type {string|number} */ (w));
  goog.style.setHeight(element, h);
};


/**
 * Helper function to create a string to be set into a pixel-value style
 * property of an element. Can round to the nearest integer value.
 *
 * @param {string|number} value The style value to be used. If a number,
 *     'px' will be appended, otherwise the value will be applied directly.
 * @param {boolean} round Whether to round the nearest integer (if property
 *     is a number).
 * @return {string} The string value for the property.
 * @private
 */
goog.style.getPixelStyleValue_ = function(value, round) {
  'use strict';
  if (typeof value == 'number') {
    value = (round ? Math.round(value) : value) + 'px';
  }

  return value;
};


/**
 * Set the height of an element.  Sets the element's style property.
 * @param {Element} element Element to set the height of.
 * @param {string|number} height The height value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setHeight = function(element, height) {
  'use strict';
  element.style.height = goog.style.getPixelStyleValue_(height, true);
};


/**
 * Set the width of an element.  Sets the element's style property.
 * @param {Element} element Element to set the width of.
 * @param {string|number} width The width value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setWidth = function(element, width) {
  'use strict';
  element.style.width = goog.style.getPixelStyleValue_(width, true);
};


/**
 * Gets the height and width of an element, even if its display is none.
 *
 * Specifically, this returns the height and width of the border box,
 * irrespective of the box model in effect.
 *
 * Note that this function does not take CSS transforms into account. Please see
 * `goog.style.getTransformedSize`.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 */
goog.style.getSize = function(element) {
  'use strict';
  return goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getSizeWithDisplay_, /** @type {!Element} */ (element));
};


/**
 * Call `fn` on `element` such that `element`'s dimensions are
 * accurate when it's passed to `fn`.
 * @param {function(!Element): T} fn Function to call with `element` as
 *     an argument after temporarily changing `element`'s display such
 *     that its dimensions are accurate.
 * @param {!Element} element Element (which may have display none) to use as
 *     argument to `fn`.
 * @return {T} Value returned by calling `fn` with `element`.
 * @template T
 * @private
 */
goog.style.evaluateWithTemporaryDisplay_ = function(fn, element) {
  'use strict';
  if (goog.style.getStyle_(element, 'display') != 'none') {
    return fn(element);
  }

  var style = element.style;
  var originalDisplay = style.display;
  var originalVisibility = style.visibility;
  var originalPosition = style.position;

  style.visibility = 'hidden';
  style.position = 'absolute';
  style.display = 'inline';

  var retVal = fn(element);

  style.display = originalDisplay;
  style.position = originalPosition;
  style.visibility = originalVisibility;

  return retVal;
};


/**
 * Gets the height and width of an element when the display is not none.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 * @private
 */
goog.style.getSizeWithDisplay_ = function(element) {
  'use strict';
  var offsetWidth = /** @type {!HTMLElement} */ (element).offsetWidth;
  var offsetHeight = /** @type {!HTMLElement} */ (element).offsetHeight;
  var webkitOffsetsZero =
      goog.userAgent.WEBKIT && !offsetWidth && !offsetHeight;
  if ((offsetWidth === undefined || webkitOffsetsZero) &&
      element.getBoundingClientRect) {
    // Fall back to calling getBoundingClientRect when offsetWidth or
    // offsetHeight are not defined, or when they are zero in WebKit browsers.
    // This makes sure that we return for the correct size for SVG elements, but
    // will still return 0 on Webkit prior to 534.8, see
    // http://trac.webkit.org/changeset/67252.
    var clientRect = goog.style.getBoundingClientRect_(element);
    return new goog.math.Size(
        clientRect.right - clientRect.left, clientRect.bottom - clientRect.top);
  }
  return new goog.math.Size(offsetWidth, offsetHeight);
};


/**
 * Gets the height and width of an element, post transform, even if its display
 * is none.
 *
 * This is like `goog.style.getSize`, except:
 * <ol>
 * <li>Takes webkitTransforms such as rotate and scale into account.
 * <li>Will return null if `element` doesn't respond to
 *     `getBoundingClientRect`.
 * <li>Currently doesn't make sense on non-WebKit browsers which don't support
 *    webkitTransforms.
 * </ol>
 * @param {!Element} element Element to get size of.
 * @return {goog.math.Size} Object with width/height properties.
 */
goog.style.getTransformedSize = function(element) {
  'use strict';
  if (!element.getBoundingClientRect) {
    return null;
  }

  var clientRect = goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getBoundingClientRect_, element);
  return new goog.math.Size(
      clientRect.right - clientRect.left, clientRect.bottom - clientRect.top);
};


/**
 * Returns a bounding rectangle for a given element in page space.
 * @param {Element} element Element to get bounds of. Must not be display none.
 * @return {!goog.math.Rect} Bounding rectangle for the element.
 */
goog.style.getBounds = function(element) {
  'use strict';
  var o = goog.style.getPageOffset(element);
  var s = goog.style.getSize(element);
  return new goog.math.Rect(o.x, o.y, s.width, s.height);
};


/**
 * Converts a CSS selector in the form style-property to styleProperty.
 * @param {*} selector CSS Selector.
 * @return {string} Camel case selector.
 * @deprecated Use goog.string.toCamelCase instead.
 */
goog.style.toCamelCase = function(selector) {
  'use strict';
  return goog.string.toCamelCase(String(selector));
};


/**
 * Converts a CSS selector in the form styleProperty to style-property.
 * @param {string} selector Camel case selector.
 * @return {string} Selector cased.
 * @deprecated Use goog.string.toSelectorCase instead.
 */
goog.style.toSelectorCase = function(selector) {
  'use strict';
  return goog.string.toSelectorCase(selector);
};


/**
 * Gets the opacity of a node (x-browser). This gets the inline style opacity
 * of the node, and does not take into account the cascaded or the computed
 * style for this node.
 * @param {Element} el Element whose opacity has to be found.
 * @return {number|string} Opacity between 0 and 1 or an empty string {@code ''}
 *     if the opacity is not set.
 */
goog.style.getOpacity = function(el) {
  'use strict';
  goog.asserts.assert(el);
  var style = el.style;
  var result = '';
  if ('opacity' in style) {
    result = style.opacity;
  } else if ('MozOpacity' in style) {
    result = style.MozOpacity;
  } else if ('filter' in style) {
    var match = style.filter.match(/alpha\(opacity=([\d.]+)\)/);
    if (match) {
      result = String(match[1] / 100);
    }
  }
  return result == '' ? result : Number(result);
};


/**
 * Sets the opacity of a node (x-browser).
 * @param {Element} el Elements whose opacity has to be set.
 * @param {number|string} alpha Opacity between 0 and 1 or an empty string
 *     {@code ''} to clear the opacity.
 * @return {void}
 */
goog.style.setOpacity = function(el, alpha) {
  'use strict';
  goog.asserts.assert(el);
  var style = el.style;
  if ('opacity' in style) {
    style.opacity = alpha;
  } else if ('MozOpacity' in style) {
    style.MozOpacity = alpha;
  } else if ('filter' in style) {
    // TODO(arv): Overwriting the filter might have undesired side effects.
    if (alpha === '') {
      style.filter = '';
    } else {
      style.filter = 'alpha(opacity=' + (Number(alpha) * 100) + ')';
    }
  }
};


/**
 * Sets the background of an element to a transparent image in a browser-
 * independent manner.
 *
 * This function does not support repeating backgrounds or alternate background
 * positions to match the behavior of Internet Explorer. It also does not
 * support sizingMethods other than crop since they cannot be replicated in
 * browsers other than Internet Explorer.
 *
 * @param {Element} el The element to set background on.
 * @param {string} src The image source URL.
 * @return {void}
 */
goog.style.setTransparentBackgroundImage = function(el, src) {
  'use strict';
  var style = el.style;
  // It is safe to use the style.filter in IE only. In Safari 'filter' is in
  // style object but access to style.filter causes it to throw an exception.
  // Note: IE8 supports images with an alpha channel.

  // Set style properties individually instead of using background shorthand
  // to prevent overwriting a pre-existing background color.
  style.backgroundImage = 'url(' + src + ')';
  style.backgroundPosition = 'top left';
  style.backgroundRepeat = 'no-repeat';
};


/**
 * Clears the background image of an element in a browser independent manner.
 * @param {Element} el The element to clear background image for.
 */
goog.style.clearTransparentBackgroundImage = function(el) {
  'use strict';
  var style = el.style;
  if ('filter' in style) {
    // See TODO in setOpacity.
    style.filter = '';
  } else {
    // Set style properties individually instead of using background shorthand
    // to prevent overwriting a pre-existing background color.
    style.backgroundImage = 'none';
  }
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules.)
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * showElement(), effectively toggling the display between "none" and "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * showElement will clear that setting and defer to the inherited style in the
 * stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} display True to render the element in its default style,
 *     false to disable rendering the element.
 * @return {void}
 * @deprecated Use goog.style.setElementShown instead.
 */
goog.style.showElement = function(el, display) {
  'use strict';
  goog.style.setElementShown(el, display);
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules).
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * setElementShown(), effectively toggling the display between "none" and
 * "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * setElementShown will clear that setting and defer to the inherited style in
 * the stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} isShown True to render the element in its default style,
 *     false to disable rendering the element.
 * @return {void}
 */
goog.style.setElementShown = function(el, isShown) {
  'use strict';
  el.style.display = isShown ? '' : 'none';
};


/**
 * Test whether the given element has been shown or hidden via a call to
 * {@link #setElementShown}.
 *
 * Note this is strictly a companion method for a call
 * to {@link #setElementShown} and the same caveats apply; in particular, this
 * method does not guarantee that the return value will be consistent with
 * whether or not the element is actually visible.
 *
 * @param {Element} el The element to test.
 * @return {boolean} Whether the element has been shown.
 * @see #setElementShown
 */
goog.style.isElementShown = function(el) {
  'use strict';
  return el.style.display != 'none';
};


/**
 * Installs the style sheet into the window that contains opt_node.  If
 * opt_node is null, the main window is used.
 * @param {!goog.html.SafeStyleSheet} safeStyleSheet The style sheet to install.
 * @param {?Node=} opt_node Node whose parent document should have the
 *     styles installed.
 * @return {!HTMLStyleElement|!StyleSheet} In IE<11, a StyleSheet object with no
 *     owning &lt;style&gt; tag (this is how IE creates style sheets).  In every
 *     other browser, a &lt;style&gt; element with an attached style.  This
 *     doesn't return a StyleSheet object so that setSafeStyleSheet can replace
 *     it (otherwise, if you pass a StyleSheet to setSafeStyleSheet, it will
 *     make a new StyleSheet and leave the original StyleSheet orphaned).
 */
goog.style.installSafeStyleSheet = function(safeStyleSheet, opt_node) {
  'use strict';
  var dh = goog.dom.getDomHelper(opt_node);

  // IE < 11 requires createStyleSheet. Note that doc.createStyleSheet will be
  // undefined as of IE 11.
  var doc = dh.getDocument();
  if (goog.userAgent.IE && doc.createStyleSheet) {
    /** @type {(!HTMLStyleElement|!StyleSheet)} */
    var styleSheet = doc.createStyleSheet();
    goog.style.setSafeStyleSheet(styleSheet, safeStyleSheet);
    return styleSheet;
  } else {
    var head = dh.getElementsByTagNameAndClass(goog.dom.TagName.HEAD)[0];

    // In opera documents are not guaranteed to have a head element, thus we
    // have to make sure one exists before using it.
    if (!head) {
      var body = dh.getElementsByTagNameAndClass(goog.dom.TagName.BODY)[0];
      head = dh.createDom(goog.dom.TagName.HEAD);
      body.parentNode.insertBefore(head, body);
    }
    var el = dh.createDom(goog.dom.TagName.STYLE);
    const nonce = goog.dom.safe.getStyleNonce();
    if (nonce) {
      el.setAttribute('nonce', nonce);
    }

    // NOTE(vkarun): Setting styles after the style element has been appended
    // to the head results in a nasty Webkit bug in certain scenarios. Please
    // refer to https://bugs.webkit.org/show_bug.cgi?id=26307 for additional
    // details.
    goog.style.setSafeStyleSheet(el, safeStyleSheet);
    dh.appendChild(head, el);
    return el;
  }
};


/**
 * Removes the styles added by {@link #installSafeStyleSheet}.
 * @param {Element|StyleSheet} styleSheet The value returned by
 *     {@link #installSafeStyleSheet}.
 */
goog.style.uninstallStyles = function(styleSheet) {
  'use strict';
  var node = styleSheet.ownerNode || styleSheet.owningElement ||
      /** @type {Element} */ (styleSheet);
  goog.dom.removeNode(node);
};


/**
 * Sets the content of a style element.  The style element can be any valid
 * style element.  This element will have its content completely replaced by
 * the safeStyleSheet.
 * @param {!Element|!StyleSheet} element A stylesheet element as returned by
 *     installSafeStyleSheet.
 * @param {!goog.html.SafeStyleSheet} safeStyleSheet The new content of the
 *     stylesheet.
 * @return {void}
 */
goog.style.setSafeStyleSheet = function(element, safeStyleSheet) {
  'use strict';
  var stylesString = goog.html.SafeStyleSheet.unwrap(safeStyleSheet);
  if (goog.userAgent.IE && element.cssText !== undefined) {
    // Adding the selectors individually caused the browser to hang if the
    // selector was invalid or there were CSS comments.  Setting the cssText of
    // the style node works fine and ignores CSS that IE doesn't understand.
    // However IE >= 11 doesn't support cssText any more, so we make sure that
    // cssText is a defined property and otherwise fall back to innerHTML.
    element.cssText = stylesString;
  } else if (goog.global.trustedTypes) {
    goog.dom.setTextContent(/** @type {!Element} */ (element), stylesString);
  } else {
    // Setting textContent doesn't work in Safari, see b/29340337.
    element.innerHTML = stylesString;
  }
};


/**
 * Sets 'white-space: pre-wrap' for a node (x-browser).
 *
 * There are as many ways of specifying pre-wrap as there are browsers.
 *
 * CSS3/IE8: white-space: pre-wrap;
 * Mozilla:  white-space: -moz-pre-wrap;
 * Opera:    white-space: -o-pre-wrap;
 * IE6/7:    white-space: pre; word-wrap: break-word;
 *
 * @param {Element} el Element to enable pre-wrap for.
 */
goog.style.setPreWrap = function(el) {
  'use strict';
  var style = el.style;
  if (goog.userAgent.GECKO) {
    style.whiteSpace = '-moz-pre-wrap';
  } else {
    style.whiteSpace = 'pre-wrap';
  }
};


/**
 * Sets 'display: inline-block' for an element (cross-browser).
 * @param {Element} el Element to which the inline-block display style is to be
 *    applied.
 * @return {void}
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 */
goog.style.setInlineBlock = function(el) {
  'use strict';
  var style = el.style;
  // Without position:relative, weirdness ensues.  Just accept it and move on.
  style.position = 'relative';
  style.display = 'inline-block';
};


/**
 * Returns true if the element is using right to left (rtl) direction.
 * @param {Element} el  The element to test.
 * @return {boolean} True for right to left, false for left to right.
 */
goog.style.isRightToLeft = function(el) {
  'use strict';
  return 'rtl' == goog.style.getStyle_(el, 'direction');
};


/**
 * The CSS style property corresponding to an element being
 * unselectable on the current browser platform (null if none).
 * Opera and IE instead use a DOM attribute 'unselectable'. MS Edge uses
 * the Webkit prefix.
 * @type {?string}
 * @private
 */
goog.style.unselectableStyle_ = goog.userAgent.GECKO ?
    'MozUserSelect' :
    goog.userAgent.WEBKIT || goog.userAgent.EDGE ? 'WebkitUserSelect' : null;


/**
 * Returns true if the element is set to be unselectable, false otherwise.
 * Note that on some platforms (e.g. Mozilla), even if an element isn't set
 * to be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  Element to check.
 * @return {boolean}  Whether the element is set to be unselectable.
 */
goog.style.isUnselectable = function(el) {
  'use strict';
  if (goog.style.unselectableStyle_) {
    return el.style[goog.style.unselectableStyle_].toLowerCase() == 'none';
  } else if (goog.userAgent.IE) {
    return el.getAttribute('unselectable') == 'on';
  }
  return false;
};


/**
 * Makes the element and its descendants selectable or unselectable.  Note
 * that on some platforms (e.g. Mozilla), even if an element isn't set to
 * be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  The element to alter.
 * @param {boolean} unselectable  Whether the element and its descendants
 *     should be made unselectable.
 * @param {boolean=} opt_noRecurse  Whether to only alter the element's own
 *     selectable state, and leave its descendants alone; defaults to false.
 */
goog.style.setUnselectable = function(el, unselectable, opt_noRecurse) {
  'use strict';
  // TODO(attila): Do we need all of TR_DomUtil.makeUnselectable() in Closure?
  var descendants = !opt_noRecurse ? el.getElementsByTagName('*') : null;
  var name = goog.style.unselectableStyle_;
  if (name) {
    // Add/remove the appropriate CSS style to/from the element and its
    // descendants.
    var value = unselectable ? 'none' : '';
    // MathML elements do not have a style property. Verify before setting.
    if (el.style) {
      el.style[name] = value;
    }
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        if (descendant.style) {
          descendant.style[name] = value;
        }
      }
    }
  } else if (goog.userAgent.IE) {
    // Toggle the 'unselectable' attribute on the element and its descendants.
    var value = unselectable ? 'on' : '';
    el.setAttribute('unselectable', value);
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        descendant.setAttribute('unselectable', value);
      }
    }
  }
};


/**
 * Gets the border box size for an element.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The border box size.
 */
goog.style.getBorderBoxSize = function(element) {
  'use strict';
  return new goog.math.Size(
      /** @type {!HTMLElement} */ (element).offsetWidth,
      /** @type {!HTMLElement} */ (element).offsetHeight);
};


/**
 * Sets the border box size of an element. This is potentially expensive in IE
 * if the document is CSS1Compat mode
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setBorderBoxSize = function(element, size) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();

  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('10') &&
      !isCss1CompatMode) {
    var style = element.style;
    if (isCss1CompatMode) {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width - borderBox.left - paddingBox.left -
          paddingBox.right - borderBox.right;
      style.pixelHeight = size.height - borderBox.top - paddingBox.top -
          paddingBox.bottom - borderBox.bottom;
    } else {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'border-box');
  }
};


/**
 * Gets the content box size for an element.  This is potentially expensive in
 * all browsers.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The content box size.
 */
goog.style.getContentBoxSize = function(element) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(element);
  var ieCurrentStyle = goog.userAgent.IE && element.currentStyle;
  if (ieCurrentStyle && goog.dom.getDomHelper(doc).isCss1CompatMode() &&
      ieCurrentStyle.width != 'auto' && ieCurrentStyle.height != 'auto' &&
      !ieCurrentStyle.boxSizing) {
    // If IE in CSS1Compat mode than just use the width and height.
    // If we have a boxSizing then fall back on measuring the borders etc.
    var width = goog.style.getIePixelValue_(
        element, /** @type {string} */ (ieCurrentStyle.width), 'width',
        'pixelWidth');
    var height = goog.style.getIePixelValue_(
        element, /** @type {string} */ (ieCurrentStyle.height), 'height',
        'pixelHeight');
    return new goog.math.Size(width, height);
  } else {
    var borderBoxSize = goog.style.getBorderBoxSize(element);
    var paddingBox = goog.style.getPaddingBox(element);
    var borderBox = goog.style.getBorderBox(element);
    return new goog.math.Size(
        borderBoxSize.width - borderBox.left - paddingBox.left -
            paddingBox.right - borderBox.right,
        borderBoxSize.height - borderBox.top - paddingBox.top -
            paddingBox.bottom - borderBox.bottom);
  }
};


/**
 * Sets the content box size of an element. This is potentially expensive in IE
 * if the document is BackCompat mode.
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setContentBoxSize = function(element, size) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('10') &&
      !isCss1CompatMode) {
    var style = element.style;
    if (isCss1CompatMode) {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    } else {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width + borderBox.left + paddingBox.left +
          paddingBox.right + borderBox.right;
      style.pixelHeight = size.height + borderBox.top + paddingBox.top +
          paddingBox.bottom + borderBox.bottom;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'content-box');
  }
};


/**
 * Helper function that sets the box sizing as well as the width and height
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size to set.
 * @param {string} boxSizing  The box-sizing value.
 * @private
 */
goog.style.setBoxSizingSize_ = function(element, size, boxSizing) {
  'use strict';
  var style = element.style;
  if (goog.userAgent.GECKO) {
    style.MozBoxSizing = boxSizing;
  } else if (goog.userAgent.WEBKIT) {
    style.WebkitBoxSizing = boxSizing;
  } else {
    // Includes IE8 and Opera 9.50+
    style.boxSizing = boxSizing;
  }

  // Setting this to a negative value will throw an exception on IE
  // (and doesn't do anything different than setting it to 0).
  style.width = Math.max(size.width, 0) + 'px';
  style.height = Math.max(size.height, 0) + 'px';
};


/**
 * IE specific function that converts a non pixel unit to pixels.
 * @param {Element} element  The element to convert the value for.
 * @param {string} value  The current value as a string. The value must not be
 *     ''.
 * @param {string} name  The CSS property name to use for the converstion. This
 *     should be 'left', 'top', 'width' or 'height'.
 * @param {string} pixelName  The CSS pixel property name to use to get the
 *     value in pixels.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelValue_ = function(element, value, name, pixelName) {
  'use strict';
  // Try if we already have a pixel value. IE does not do half pixels so we
  // only check if it matches a number followed by 'px'.
  if (/^\d+px?$/.test(value)) {
    return parseInt(value, 10);
  } else {
    var oldStyleValue = element.style[name];
    var oldRuntimeValue = element.runtimeStyle[name];
    // set runtime style to prevent changes
    element.runtimeStyle[name] = element.currentStyle[name];
    element.style[name] = value;
    var pixelValue = element.style[pixelName];
    // restore
    element.style[name] = oldStyleValue;
    element.runtimeStyle[name] = oldRuntimeValue;
    return +pixelValue;
  }
};


/**
 * Helper function for getting the pixel padding or margin for IE.
 * @param {Element} element  The element to get the padding for.
 * @param {string} propName  The property name.
 * @return {number} The pixel padding.
 * @private
 */
goog.style.getIePixelDistance_ = function(element, propName) {
  'use strict';
  var value = goog.style.getCascadedStyle(element, propName);
  return value ?
      goog.style.getIePixelValue_(element, value, 'left', 'pixelLeft') :
      0;
};


/**
 * Gets the computed paddings or margins (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @param {string} stylePrefix  Pass 'padding' to retrieve the padding box,
 *     or 'margin' to retrieve the margin box.
 * @return {!goog.math.Box} The computed paddings or margins.
 * @private
 */
goog.style.getBox_ = function(element, stylePrefix) {
  'use strict';
  if (goog.userAgent.IE) {
    var left = goog.style.getIePixelDistance_(element, stylePrefix + 'Left');
    var right = goog.style.getIePixelDistance_(element, stylePrefix + 'Right');
    var top = goog.style.getIePixelDistance_(element, stylePrefix + 'Top');
    var bottom =
        goog.style.getIePixelDistance_(element, stylePrefix + 'Bottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = goog.style.getComputedStyle(element, stylePrefix + 'Left');
    var right = goog.style.getComputedStyle(element, stylePrefix + 'Right');
    var top = goog.style.getComputedStyle(element, stylePrefix + 'Top');
    var bottom = goog.style.getComputedStyle(element, stylePrefix + 'Bottom');

    // NOTE(arv): Gecko can return floating point numbers for the computed
    // style values.
    return new goog.math.Box(
        parseFloat(top), parseFloat(right), parseFloat(bottom),
        parseFloat(left));
  }
};


/**
 * Gets the computed paddings (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @return {!goog.math.Box} The computed paddings.
 */
goog.style.getPaddingBox = function(element) {
  'use strict';
  return goog.style.getBox_(element, 'padding');
};


/**
 * Gets the computed margins (on all sides) in pixels.
 * @param {Element} element  The element to get the margins for.
 * @return {!goog.math.Box} The computed margins.
 */
goog.style.getMarginBox = function(element) {
  'use strict';
  return goog.style.getBox_(element, 'margin');
};


/**
 * A map used to map the border width keywords to a pixel width.
 * @type {!Object}
 * @private
 */
goog.style.ieBorderWidthKeywords_ = {
  'thin': 2,
  'medium': 4,
  'thick': 6
};


/**
 * Helper function for IE to get the pixel border.
 * @param {Element} element  The element to get the pixel border for.
 * @param {string} prop  The part of the property name.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelBorder_ = function(element, prop) {
  'use strict';
  if (goog.style.getCascadedStyle(element, prop + 'Style') == 'none') {
    return 0;
  }
  var width = goog.style.getCascadedStyle(element, prop + 'Width');
  if (width in goog.style.ieBorderWidthKeywords_) {
    return goog.style.ieBorderWidthKeywords_[width];
  }
  return goog.style.getIePixelValue_(element, width, 'left', 'pixelLeft');
};


/**
 * Gets the computed border widths (on all sides) in pixels
 * @param {Element} element  The element to get the border widths for.
 * @return {!goog.math.Box} The computed border widths.
 */
goog.style.getBorderBox = function(element) {
  'use strict';
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    var left = goog.style.getIePixelBorder_(element, 'borderLeft');
    var right = goog.style.getIePixelBorder_(element, 'borderRight');
    var top = goog.style.getIePixelBorder_(element, 'borderTop');
    var bottom = goog.style.getIePixelBorder_(element, 'borderBottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = goog.style.getComputedStyle(element, 'borderLeftWidth');
    var right = goog.style.getComputedStyle(element, 'borderRightWidth');
    var top = goog.style.getComputedStyle(element, 'borderTopWidth');
    var bottom = goog.style.getComputedStyle(element, 'borderBottomWidth');

    return new goog.math.Box(
        parseFloat(top), parseFloat(right), parseFloat(bottom),
        parseFloat(left));
  }
};


/**
 * Returns the font face applied to a given node. Opera and IE should return
 * the font actually displayed. Firefox returns the author's most-preferred
 * font (whether the browser is capable of displaying it or not.)
 * @param {Element} el  The element whose font family is returned.
 * @return {string} The font family applied to el.
 */
goog.style.getFontFamily = function(el) {
  'use strict';
  var doc = goog.dom.getOwnerDocument(el);
  var font = '';
  // The moveToElementText method from the TextRange only works if the element
  // is attached to the owner document.
  if (doc.body.createTextRange && goog.dom.contains(doc, el)) {
    var range = doc.body.createTextRange();
    range.moveToElementText(el);

    try {
      font = range.queryCommandValue('FontName');
    } catch (e) {
      // This is a workaround for a awkward exception.
      // On some IE, there is an exception coming from it.
      // The error description from this exception is:
      // This window has already been registered as a drop target
      // This is bogus description, likely due to a bug in ie.
      font = '';
    }
  }
  if (!font) {
    // Note if for some reason IE can't derive FontName with a TextRange, we
    // fallback to using currentStyle
    font = goog.style.getStyle_(el, 'fontFamily');
  }

  // Firefox returns the applied font-family string (author's list of
  // preferred fonts.) We want to return the most-preferred font, in lieu of
  // the *actually* applied font.
  var fontsArray = font.split(',');
  if (fontsArray.length > 1) font = fontsArray[0];

  // Sanitize for x-browser consistency:
  // Strip quotes because browsers aren't consistent with how they're
  // applied; Opera always encloses, Firefox sometimes, and IE never.
  return goog.string.stripQuotes(font, '"\'');
};


/**
 * Regular expression used for getLengthUnits.
 * @type {RegExp}
 * @private
 */
goog.style.lengthUnitRegex_ = /[^\d]+$/;


/**
 * Returns the units used for a CSS length measurement.
 * @param {string} value  A CSS length quantity.
 * @return {?string} The units of measurement.
 */
goog.style.getLengthUnits = function(value) {
  'use strict';
  var units = value.match(goog.style.lengthUnitRegex_);
  return units && units[0] || null;
};


/**
 * Map of absolute CSS length units
 * @type {!Object}
 * @private
 */
goog.style.ABSOLUTE_CSS_LENGTH_UNITS_ = {
  'cm': 1,
  'in': 1,
  'mm': 1,
  'pc': 1,
  'pt': 1
};


/**
 * Map of relative CSS length units that can be accurately converted to px
 * font-size values using getIePixelValue_. Only units that are defined in
 * relation to a font size are convertible (%, small, etc. are not).
 * @type {!Object}
 * @private
 */
goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_ = {
  'em': 1,
  'ex': 1
};


/**
 * Returns the font size, in pixels, of text in an element.
 * @param {Element} el  The element whose font size is returned.
 * @return {number} The font size (in pixels).
 */
goog.style.getFontSize = function(el) {
  'use strict';
  var fontSize = goog.style.getStyle_(el, 'fontSize');
  var sizeUnits = goog.style.getLengthUnits(fontSize);
  if (fontSize && 'px' == sizeUnits) {
    // NOTE(nathanl): This could be parseFloat instead, but IE doesn't return
    // decimal fractions in getStyle_ and Firefox reports the fractions, but
    // ignores them when rendering. Interestingly enough, when we force the
    // issue and size something to e.g., 50% of 25px, the browsers round in
    // opposite directions with Firefox reporting 12px and IE 13px. I punt.
    return parseInt(fontSize, 10);
  }

  // In IE, we can convert absolute length units to a px value using
  // goog.style.getIePixelValue_. Units defined in relation to a font size
  // (em, ex) are applied relative to the element's parentNode and can also
  // be converted.
  if (goog.userAgent.IE) {
    if (String(sizeUnits) in goog.style.ABSOLUTE_CSS_LENGTH_UNITS_) {
      return goog.style.getIePixelValue_(el, fontSize, 'left', 'pixelLeft');
    } else if (
        el.parentNode && el.parentNode.nodeType == goog.dom.NodeType.ELEMENT &&
        String(sizeUnits) in goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_) {
      // Check the parent size - if it is the same it means the relative size
      // value is inherited and we therefore don't want to count it twice.  If
      // it is different, this element either has explicit style or has a CSS
      // rule applying to it.
      var parentElement = /** @type {!Element} */ (el.parentNode);
      var parentSize = goog.style.getStyle_(parentElement, 'fontSize');
      return goog.style.getIePixelValue_(
          parentElement, fontSize == parentSize ? '1em' : fontSize, 'left',
          'pixelLeft');
    }
  }

  // Sometimes we can't cleanly find the font size (some units relative to a
  // node's parent's font size are difficult: %, smaller et al), so we create
  // an invisible, absolutely-positioned span sized to be the height of an 'M'
  // rendered in its parent's (i.e., our target element's) font size. This is
  // the definition of CSS's font size attribute.
  var sizeElement = goog.dom.createDom(goog.dom.TagName.SPAN, {
    'style': 'visibility:hidden;position:absolute;' +
        'line-height:0;padding:0;margin:0;border:0;height:1em;'
  });
  goog.dom.appendChild(el, sizeElement);
  fontSize = sizeElement.offsetHeight;
  goog.dom.removeNode(sizeElement);

  return fontSize;
};


/**
 * Parses a style attribute value.  Converts CSS property names to camel case.
 * @param {string} value The style attribute value.
 * @return {!Object} Map of CSS properties to string values.
 */
goog.style.parseStyleAttribute = function(value) {
  'use strict';
  var result = {};
  value.split(/\s*;\s*/).forEach(function(pair) {
    'use strict';
    var keyValue = pair.match(/\s*([\w-]+)\s*:(.+)/);
    if (keyValue) {
      var styleName = keyValue[1];
      var styleValue = goog.string.trim(keyValue[2]);
      result[goog.string.toCamelCase(styleName.toLowerCase())] = styleValue;
    }
  });
  return result;
};


/**
 * Reverse of parseStyleAttribute; that is, takes a style object and returns the
 * corresponding attribute value.  Converts camel case property names to proper
 * CSS selector names.
 * @param {Object} obj Map of CSS properties to values.
 * @return {string} The style attribute value.
 */
goog.style.toStyleAttribute = function(obj) {
  'use strict';
  var buffer = [];
  goog.object.forEach(obj, function(value, key) {
    'use strict';
    buffer.push(goog.string.toSelectorCase(key), ':', value, ';');
  });
  return buffer.join('');
};


/**
 * Sets CSS float property on an element.
 * @param {Element} el The element to set float property on.
 * @param {string} value The value of float CSS property to set on this element.
 */
goog.style.setFloat = function(el, value) {
  'use strict';
  el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] = value;
};


/**
 * Gets value of explicitly-set float CSS property on an element.
 * @param {Element} el The element to get float property of.
 * @return {string} The value of explicitly-set float CSS property on this
 *     element.
 */
goog.style.getFloat = function(el) {
  'use strict';
  return el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] || '';
};


/**
 * Returns the scroll bar width (represents the width of both horizontal
 * and vertical scroll).
 *
 * @param {string=} opt_className An optional class name (or names) to apply
 *     to the invisible div created to measure the scrollbar. This is necessary
 *     if some scrollbars are styled differently than others.
 * @return {number} The scroll bar width in px.
 */
goog.style.getScrollbarWidth = function(opt_className) {
  'use strict';
  // Add two hidden divs.  The child div is larger than the parent and
  // forces scrollbars to appear on it.
  // Using overflow:scroll does not work consistently with scrollbars that
  // are styled with ::-webkit-scrollbar.
  var outerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
  if (opt_className) {
    outerDiv.className = opt_className;
  }
  outerDiv.style.cssText = 'overflow:auto;' +
      'position:absolute;top:0;width:100px;height:100px';
  var innerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
  goog.style.setSize(innerDiv, '200px', '200px');
  outerDiv.appendChild(innerDiv);
  goog.dom.appendChild(goog.dom.getDocument().body, outerDiv);
  var width = outerDiv.offsetWidth - outerDiv.clientWidth;
  goog.dom.removeNode(outerDiv);
  return width;
};


/**
 * Regular expression to extract x and y translation components from a CSS
 * transform Matrix representation.
 *
 * @type {!RegExp}
 * @const
 * @private
 */
goog.style.MATRIX_TRANSLATION_REGEX_ = new RegExp(
    'matrix\\([0-9\\.\\-]+, [0-9\\.\\-]+, ' +
    '[0-9\\.\\-]+, [0-9\\.\\-]+, ' +
    '([0-9\\.\\-]+)p?x?, ([0-9\\.\\-]+)p?x?\\)');


/**
 * Returns the x,y translation component of any CSS transforms applied to the
 * element, in pixels.
 *
 * @param {!Element} element The element to get the translation of.
 * @return {!goog.math.Coordinate} The CSS translation of the element in px.
 */
goog.style.getCssTranslation = function(element) {
  'use strict';
  var transform = goog.style.getComputedTransform(element);
  if (!transform) {
    return new goog.math.Coordinate(0, 0);
  }
  var matches = transform.match(goog.style.MATRIX_TRANSLATION_REGEX_);
  if (!matches) {
    return new goog.math.Coordinate(0, 0);
  }
  return new goog.math.Coordinate(
      parseFloat(matches[1]), parseFloat(matches[2]));
};

//third_party/javascript/closure/ui/idgenerator.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Generator for unique element IDs.
 */

goog.provide('goog.ui.IdGenerator');



/**
 * Creates a new id generator.
 * @constructor
 * @final
 */
goog.ui.IdGenerator = function() {};
goog.addSingletonGetter(goog.ui.IdGenerator);


/**
 * Next unique ID to use
 * @type {number}
 * @private
 */
goog.ui.IdGenerator.prototype.nextId_ = 0;


/**
 * Random ID prefix to help avoid collisions with other closure JavaScript on
 * the same page that may initialize its own IdGenerator singleton.
 * @type {string}
 * @private
 */
goog.ui.IdGenerator.prototype.idPrefix_ = '';


/**
 * Sets the ID prefix for this singleton. This is a temporary workaround to be
 * backwards compatible with code relying on the undocumented, but consistent,
 * behavior. In the future this will be removed and the prefix will be set to
 * a randomly generated string.
 * @param {string} idPrefix
 */
goog.ui.IdGenerator.prototype.setIdPrefix = function(idPrefix) {
  'use strict';
  this.idPrefix_ = idPrefix;
};


/**
 * Gets the next unique ID.
 * @return {string} The next unique identifier.
 */
goog.ui.IdGenerator.prototype.getNextUniqueId = function() {
  'use strict';
  return this.idPrefix_ + ':' + (this.nextId_++).toString(36);
};

//third_party/javascript/closure/ui/component.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Abstract class for all UI components. This defines the standard
 * design pattern that all UI components should follow.
 *
 * @see ../demos/samplecomponent.html
 * @see http://code.google.com/p/closure-library/wiki/IntroToComponents
 */

goog.provide('goog.ui.Component');
goog.provide('goog.ui.Component.Error');
goog.provide('goog.ui.Component.EventType');
goog.provide('goog.ui.Component.State');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.object');
goog.require('goog.style');
goog.require('goog.ui.IdGenerator');



/**
 * Default implementation of UI component.
 *
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 * @constructor
 * @extends {goog.events.EventTarget}
 * @suppress {underscore}
 */
goog.ui.Component = function(opt_domHelper) {
  'use strict';
  goog.events.EventTarget.call(this);
  /**
   * DomHelper used to interact with the document, allowing components to be
   * created in a different window.
   * @protected {!goog.dom.DomHelper}
   * @suppress {underscore|visibility}
   */
  this.dom_ = opt_domHelper || goog.dom.getDomHelper();

  /**
   * Whether the component is rendered right-to-left.  Right-to-left is set
   * lazily when {@link #isRightToLeft} is called the first time, unless it has
   * been set by calling {@link #setRightToLeft} explicitly.
   * @private {?boolean}
   */
  this.rightToLeft_ = goog.ui.Component.defaultRightToLeft_;

  /**
   * Unique ID of the component, lazily initialized in {@link
   * goog.ui.Component#getId} if needed.  This property is strictly private and
   * must not be accessed directly outside of this class!
   * @private {?string}
   */
  this.id_ = null;

  /**
   * Whether the component is in the document.
   * @private {boolean}
   */
  this.inDocument_ = false;

  // TODO(attila): Stop referring to this private field in subclasses.
  /**
   * The DOM element for the component.
   * @private {?Element}
   */
  this.element_ = null;

  /**
   * Event handler.
   * Code search: http://go/component_code_search
   * @private {goog.events.EventHandler|undefined}
   */
  this.googUiComponentHandler_ = void 0;

  /**
   * Arbitrary data object associated with the component.  Such as meta-data.
   * @private {*}
   */
  this.model_ = null;

  /**
   * Parent component to which events will be propagated.  This property is
   * strictly private and must not be accessed directly outside of this class!
   * @private {goog.ui.Component?}
   */
  this.parent_ = null;

  /**
   * Array of child components.  Lazily initialized on first use.  Must be kept
   * in sync with `childIndex_`.  This property is strictly private and
   * must not be accessed directly outside of this class!
   * @private {?Array<?goog.ui.Component>}
   */
  this.children_ = null;

  /**
   * Map of child component IDs to child components.  Used for constant-time
   * random access to child components by ID.  Lazily initialized on first use.
   * Must be kept in sync with `children_`.  This property is strictly
   * private and must not be accessed directly outside of this class!
   *
   * We use a plain Object, not a {@link goog.structs.Map}, for simplicity.
   * This means components can't have children with IDs such as 'constructor' or
   * 'valueOf', but this shouldn't really be an issue in practice, and if it is,
   * we can always fix it later without changing the API.
   *
   * @private {?Object}
   */
  this.childIndex_ = null;

  /**
   * Flag used to keep track of whether a component decorated an already
   * existing element or whether it created the DOM itself.
   *
   * If an element is decorated, dispose will leave the node in the document.
   * It is up to the app to remove the node.
   *
   * If an element was rendered, dispose will remove the node automatically.
   *
   * @private {boolean}
   */
  this.wasDecorated_ = false;

  /**
   * If true, listen for PointerEvent types rather than MouseEvent types. This
   * allows supporting drag gestures for touch/stylus input.
   * @private {boolean}
   */
  this.pointerEventsEnabled_ = false;
};
goog.inherits(goog.ui.Component, goog.events.EventTarget);


/**
 * @define {boolean} Whether to support calling decorate with an element that is
 *     not yet in the document. If true, we check if the element is in the
 *     document, and avoid calling enterDocument if it isn't. If false, we
 *     maintain legacy behavior (always call enterDocument from decorate).
 */
goog.ui.Component.ALLOW_DETACHED_DECORATION =
    goog.define('goog.ui.Component.ALLOW_DETACHED_DECORATION', false);


/**
 * Generator for unique IDs.
 * @type {goog.ui.IdGenerator}
 * @private
 */
goog.ui.Component.prototype.idGenerator_ = goog.ui.IdGenerator.getInstance();


// TODO(gboyer): See if we can remove this and just check goog.i18n.bidi.IS_RTL.
/**
 * @define {number} Defines the default BIDI directionality.
 *     0: Unknown.
 *     1: Left-to-right.
 *     -1: Right-to-left.
 */
goog.ui.Component.DEFAULT_BIDI_DIR =
    goog.define('goog.ui.Component.DEFAULT_BIDI_DIR', 0);


/**
 * The default right to left value.
 * @type {?boolean}
 * @private
 */
goog.ui.Component.defaultRightToLeft_ =
    (goog.ui.Component.DEFAULT_BIDI_DIR == 1) ?
    false :
    (goog.ui.Component.DEFAULT_BIDI_DIR == -1) ? true : null;


/**
 * Common events fired by components so that event propagation is useful.  Not
 * all components are expected to dispatch or listen for all event types.
 * Events dispatched before a state transition should be cancelable to prevent
 * the corresponding state change.
 * @enum {string}
 */
goog.ui.Component.EventType = {
  /** Dispatched before the component becomes visible. */
  BEFORE_SHOW: 'beforeshow',

  /**
   * Dispatched after the component becomes visible.
   * NOTE(bloom): For goog.ui.Container, this actually fires before containers
   * are shown.  Use goog.ui.Container.EventType.AFTER_SHOW if you want an event
   * that fires after a goog.ui.Container is shown.
   */
  SHOW: 'show',

  /** Dispatched before the component becomes hidden. */
  HIDE: 'hide',

  /** Dispatched before the component becomes disabled. */
  DISABLE: 'disable',

  /** Dispatched before the component becomes enabled. */
  ENABLE: 'enable',

  /** Dispatched before the component becomes highlighted. */
  HIGHLIGHT: 'highlight',

  /** Dispatched before the component becomes un-highlighted. */
  UNHIGHLIGHT: 'unhighlight',

  /** Dispatched before the component becomes activated. */
  ACTIVATE: 'activate',

  /** Dispatched before the component becomes deactivated. */
  DEACTIVATE: 'deactivate',

  /** Dispatched before the component becomes selected. */
  SELECT: 'select',

  /** Dispatched before the component becomes un-selected. */
  UNSELECT: 'unselect',

  /** Dispatched before a component becomes checked. */
  CHECK: 'check',

  /** Dispatched before a component becomes un-checked. */
  UNCHECK: 'uncheck',

  /** Dispatched before a component becomes focused. */
  FOCUS: 'focus',

  /** Dispatched before a component becomes blurred. */
  BLUR: 'blur',

  /** Dispatched before a component is opened (expanded). */
  OPEN: 'open',

  /** Dispatched before a component is closed (collapsed). */
  CLOSE: 'close',

  /** Dispatched after a component is moused over. */
  ENTER: 'enter',

  /** Dispatched after a component is moused out of. */
  LEAVE: 'leave',

  /** Dispatched after the user activates the component. */
  ACTION: 'action',

  /** Dispatched after the external-facing state of a component is changed. */
  CHANGE: 'change'
};


/**
 * Errors thrown by the component.
 * @enum {string}
 */
goog.ui.Component.Error = {
  /**
   * Error when a method is not supported.
   */
  NOT_SUPPORTED: 'Method not supported',

  /**
   * Error when the given element can not be decorated.
   */
  DECORATE_INVALID: 'Invalid element to decorate',

  /**
   * Error when the component is already rendered and another render attempt is
   * made.
   */
  ALREADY_RENDERED: 'Component already rendered',

  /**
   * Error when an attempt is made to set the parent of a component in a way
   * that would result in an inconsistent object graph.
   */
  PARENT_UNABLE_TO_BE_SET: 'Unable to set parent component',

  /**
   * Error when an attempt is made to add a child component at an out-of-bounds
   * index.  We don't support sparse child arrays.
   */
  CHILD_INDEX_OUT_OF_BOUNDS: 'Child component index out of bounds',

  /**
   * Error when an attempt is made to remove a child component from a component
   * other than its parent.
   */
  NOT_OUR_CHILD: 'Child is not in parent component',

  /**
   * Error when an operation requiring DOM interaction is made when the
   * component is not in the document
   */
  NOT_IN_DOCUMENT: 'Operation not supported while component is not in document',

  /**
   * Error when an invalid component state is encountered.
   */
  STATE_INVALID: 'Invalid component state'
};


/**
 * Common component states.  Components may have distinct appearance depending
 * on what state(s) apply to them.  Not all components are expected to support
 * all states.
 * @enum {number}
 */
goog.ui.Component.State = {
  /**
   * Union of all supported component states.
   */
  ALL: 0xFF,

  /**
   * Component is disabled.
   * @see goog.ui.Component.EventType.DISABLE
   * @see goog.ui.Component.EventType.ENABLE
   */
  DISABLED: 0x01,

  /**
   * Component is highlighted.
   * @see goog.ui.Component.EventType.HIGHLIGHT
   * @see goog.ui.Component.EventType.UNHIGHLIGHT
   */
  HOVER: 0x02,

  /**
   * Component is active (or "pressed").
   * @see goog.ui.Component.EventType.ACTIVATE
   * @see goog.ui.Component.EventType.DEACTIVATE
   */
  ACTIVE: 0x04,

  /**
   * Component is selected.
   * @see goog.ui.Component.EventType.SELECT
   * @see goog.ui.Component.EventType.UNSELECT
   */
  SELECTED: 0x08,

  /**
   * Component is checked.
   * @see goog.ui.Component.EventType.CHECK
   * @see goog.ui.Component.EventType.UNCHECK
   */
  CHECKED: 0x10,

  /**
   * Component has focus.
   * @see goog.ui.Component.EventType.FOCUS
   * @see goog.ui.Component.EventType.BLUR
   */
  FOCUSED: 0x20,

  /**
   * Component is opened (expanded).  Applies to tree nodes, menu buttons,
   * submenus, zippys (zippies?), etc.
   * @see goog.ui.Component.EventType.OPEN
   * @see goog.ui.Component.EventType.CLOSE
   */
  OPENED: 0x40
};


/**
 * Static helper method; returns the type of event components are expected to
 * dispatch when transitioning to or from the given state.
 * @param {goog.ui.Component.State} state State to/from which the component
 *     is transitioning.
 * @param {boolean} isEntering Whether the component is entering or leaving the
 *     state.
 * @return {goog.ui.Component.EventType} Event type to dispatch.
 */
goog.ui.Component.getStateTransitionEvent = function(state, isEntering) {
  'use strict';
  switch (state) {
    case goog.ui.Component.State.DISABLED:
      return isEntering ? goog.ui.Component.EventType.DISABLE :
                          goog.ui.Component.EventType.ENABLE;
    case goog.ui.Component.State.HOVER:
      return isEntering ? goog.ui.Component.EventType.HIGHLIGHT :
                          goog.ui.Component.EventType.UNHIGHLIGHT;
    case goog.ui.Component.State.ACTIVE:
      return isEntering ? goog.ui.Component.EventType.ACTIVATE :
                          goog.ui.Component.EventType.DEACTIVATE;
    case goog.ui.Component.State.SELECTED:
      return isEntering ? goog.ui.Component.EventType.SELECT :
                          goog.ui.Component.EventType.UNSELECT;
    case goog.ui.Component.State.CHECKED:
      return isEntering ? goog.ui.Component.EventType.CHECK :
                          goog.ui.Component.EventType.UNCHECK;
    case goog.ui.Component.State.FOCUSED:
      return isEntering ? goog.ui.Component.EventType.FOCUS :
                          goog.ui.Component.EventType.BLUR;
    case goog.ui.Component.State.OPENED:
      return isEntering ? goog.ui.Component.EventType.OPEN :
                          goog.ui.Component.EventType.CLOSE;
    default:
      // Fall through.
  }

  // Invalid state.
  throw new Error(goog.ui.Component.Error.STATE_INVALID);
};


/**
 * Set the default right-to-left value. This causes all component's created from
 * this point forward to have the given value. This is useful for cases where
 * a given page is always in one directionality, avoiding unnecessary
 * right to left determinations.
 * @param {?boolean} rightToLeft Whether the components should be rendered
 *     right-to-left. Null iff components should determine their directionality.
 */
goog.ui.Component.setDefaultRightToLeft = function(rightToLeft) {
  'use strict';
  goog.ui.Component.defaultRightToLeft_ = rightToLeft;
};


/**
 * Gets the unique ID for the instance of this component.  If the instance
 * doesn't already have an ID, generates one on the fly.
 * @return {string} Unique component ID.
 */
goog.ui.Component.prototype.getId = function() {
  'use strict';
  return this.id_ || (this.id_ = this.idGenerator_.getNextUniqueId());
};


/**
 * Assigns an ID to this component instance.  It is the caller's responsibility
 * to guarantee that the ID is unique.  If the component is a child of a parent
 * component, then the parent component's child index is updated to reflect the
 * new ID; this may throw an error if the parent already has a child with an ID
 * that conflicts with the new ID.
 * @param {string} id Unique component ID.
 */
goog.ui.Component.prototype.setId = function(id) {
  'use strict';
  if (this.parent_ && this.parent_.childIndex_) {
    // Update the parent's child index.
    goog.object.remove(this.parent_.childIndex_, this.id_);
    goog.object.add(this.parent_.childIndex_, id, this);
  }

  // Update the component ID.
  this.id_ = id;
};


/**
 * Gets the component's element.
 * @return {Element} The element for the component.
 */
goog.ui.Component.prototype.getElement = function() {
  'use strict';
  return this.element_;
};


/**
 * Gets the component's element. This differs from getElement in that
 * it assumes that the element exists (i.e. the component has been
 * rendered/decorated) and will cause an assertion error otherwise (if
 * assertion is enabled).
 * @return {!Element} The element for the component.
 */
goog.ui.Component.prototype.getElementStrict = function() {
  'use strict';
  var el = this.element_;
  goog.asserts.assert(
      el, 'Can not call getElementStrict before rendering/decorating.');
  return el;
};


/**
 * Sets the component's root element to the given element.  Considered
 * protected and final.
 *
 * This should generally only be called during createDom. Setting the element
 * does not actually change which element is rendered, only the element that is
 * associated with this UI component.
 *
 * This should only be used by subclasses and its associated renderers.
 *
 * @param {Element} element Root element for the component.
 */
goog.ui.Component.prototype.setElementInternal = function(element) {
  'use strict';
  this.element_ = element;
};


/**
 * Returns an array of all the elements in this component's DOM with the
 * provided className.
 * @param {string} className The name of the class to look for.
 * @return {!IArrayLike<!Element>} The items found with the class name provided.
 */
goog.ui.Component.prototype.getElementsByClass = function(className) {
  'use strict';
  return this.element_ ?
      this.dom_.getElementsByClass(className, this.element_) :
      [];
};


/**
 * Returns the first element in this component's DOM with the provided
 * className.
 * @param {string} className The name of the class to look for.
 * @return {Element} The first item with the class name provided.
 */
goog.ui.Component.prototype.getElementByClass = function(className) {
  'use strict';
  return this.element_ ? this.dom_.getElementByClass(className, this.element_) :
                         null;
};


/**
 * Similar to `getElementByClass` except that it expects the
 * element to be present in the dom thus returning a required value. Otherwise,
 * will assert.
 * @param {string} className The name of the class to look for.
 * @return {!Element} The first item with the class name provided.
 */
goog.ui.Component.prototype.getRequiredElementByClass = function(className) {
  'use strict';
  var el = this.getElementByClass(className);
  goog.asserts.assert(
      el, 'Expected element in component with class: %s', className);
  return el;
};


/**
 * Returns the event handler for this component, lazily created the first time
 * this method is called.
 * @return {!goog.events.EventHandler<T>} Event handler for this component.
 * @protected
 * @this {T}
 * @template T
 */
goog.ui.Component.prototype.getHandler = function() {
  'use strict';
  // TODO(17988911): templated "this" values currently result in "this" being
  // "unknown" in the body of the function.
  var self = /** @type {goog.ui.Component} */ (this);
  if (!self.googUiComponentHandler_) {
    self.googUiComponentHandler_ = new goog.events.EventHandler(self);
  }
  return goog.asserts.assert(self.googUiComponentHandler_);
};


/**
 * Sets the parent of this component to use for event bubbling.  Throws an error
 * if the component already has a parent or if an attempt is made to add a
 * component to itself as a child.  Callers must use `removeChild`
 * or `removeChildAt` to remove components from their containers before
 * calling this method.
 * @see goog.ui.Component#removeChild
 * @see goog.ui.Component#removeChildAt
 * @param {goog.ui.Component} parent The parent component.
 */
goog.ui.Component.prototype.setParent = function(parent) {
  'use strict';
  if (this == parent) {
    // Attempting to add a child to itself is an error.
    throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
  }

  if (parent && this.parent_ && this.id_ && this.parent_.getChild(this.id_) &&
      this.parent_ != parent) {
    // This component is already the child of some parent, so it should be
    // removed using removeChild/removeChildAt first.
    throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
  }

  this.parent_ = parent;
  goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
};


/**
 * Returns the component's parent, if any.
 * @return {goog.ui.Component?} The parent component.
 */
goog.ui.Component.prototype.getParent = function() {
  'use strict';
  return this.parent_;
};


/**
 * Overrides {@link goog.events.EventTarget#setParentEventTarget} to throw an
 * error if the parent component is set, and the argument is not the parent.
 * @override
 */
goog.ui.Component.prototype.setParentEventTarget = function(parent) {
  'use strict';
  if (this.parent_ && this.parent_ != parent) {
    throw new Error(goog.ui.Component.Error.NOT_SUPPORTED);
  }
  goog.ui.Component.superClass_.setParentEventTarget.call(this, parent);
};


/**
 * Returns the dom helper that is being used on this component.
 * @return {!goog.dom.DomHelper} The dom helper used on this component.
 */
goog.ui.Component.prototype.getDomHelper = function() {
  'use strict';
  return this.dom_;
};


/**
 * Determines whether the component has been added to the document.
 * @return {boolean} TRUE if rendered. Otherwise, FALSE.
 */
goog.ui.Component.prototype.isInDocument = function() {
  'use strict';
  return this.inDocument_;
};


/**
 * Creates the initial DOM representation for the component.  The default
 * implementation is to set this.element_ = div.
 */
goog.ui.Component.prototype.createDom = function() {
  'use strict';
  this.element_ = this.dom_.createElement(goog.dom.TagName.DIV);
};


/**
 * Renders the component.  If a parent element is supplied, the component's
 * element will be appended to it.  If there is no optional parent element and
 * the element doesn't have a parentNode then it will be appended to the
 * document body.
 *
 * If this component has a parent component, and the parent component is
 * not in the document already, then this will not call `enterDocument`
 * on this component.
 *
 * Throws an Error if the component is already rendered.
 *
 * @param {Element=} opt_parentElement Optional parent element to render the
 *    component into.
 */
goog.ui.Component.prototype.render = function(opt_parentElement) {
  'use strict';
  this.render_(opt_parentElement);
};


/**
 * Renders the component before another element. The other element should be in
 * the document already.
 *
 * Throws an Error if the component is already rendered.
 *
 * @param {Node} sibling Node to render the component before.
 */
goog.ui.Component.prototype.renderBefore = function(sibling) {
  'use strict';
  this.render_(/** @type {Element} */ (sibling.parentNode), sibling);
};


/**
 * Renders the component.  If a parent element is supplied, the component's
 * element will be appended to it.  If there is no optional parent element and
 * the element doesn't have a parentNode then it will be appended to the
 * document body.
 *
 * If this component has a parent component, and the parent component is
 * not in the document already, then this will not call `enterDocument`
 * on this component.
 *
 * Throws an Error if the component is already rendered.
 *
 * @param {Element=} opt_parentElement Optional parent element to render the
 *    component into.
 * @param {Node=} opt_beforeNode Node before which the component is to
 *    be rendered.  If left out the node is appended to the parent element.
 * @private
 */
goog.ui.Component.prototype.render_ = function(
    opt_parentElement, opt_beforeNode) {
  'use strict';
  if (this.inDocument_) {
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  if (!this.element_) {
    this.createDom();
  }

  if (opt_parentElement) {
    opt_parentElement.insertBefore(
        /** @type {!Node} */ (this.element_), opt_beforeNode || null);
  } else {
    this.dom_.getDocument().body.appendChild(
        /** @type {!Node} */ (this.element_));
  }

  // If this component has a parent component that isn't in the document yet,
  // we don't call enterDocument() here.  Instead, when the parent component
  // enters the document, the enterDocument() call will propagate to its
  // children, including this one.  If the component doesn't have a parent
  // or if the parent is already in the document, we call enterDocument().
  if (!this.parent_ || this.parent_.isInDocument()) {
    this.enterDocument();
  }
};


/**
 * Decorates the element for the UI component. If the element is in the
 * document, the enterDocument method will be called.
 *
 * If goog.ui.Component.ALLOW_DETACHED_DECORATION is false, the caller must
 * pass an element that is in the document.
 *
 * @param {Element} element Element to decorate.
 */
goog.ui.Component.prototype.decorate = function(element) {
  'use strict';
  if (this.inDocument_) {
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  } else if (element && this.canDecorate(element)) {
    this.wasDecorated_ = true;

    // Set the DOM helper of the component to match the decorated element.
    var doc = goog.dom.getOwnerDocument(element);
    if (!this.dom_ || this.dom_.getDocument() != doc) {
      this.dom_ = goog.dom.getDomHelper(element);
    }

    // Call specific component decorate logic.
    this.decorateInternal(element);

    // If supporting detached decoration, check that element is in doc.
    if (!goog.ui.Component.ALLOW_DETACHED_DECORATION ||
        goog.dom.contains(doc, element)) {
      this.enterDocument();
    }
  } else {
    throw new Error(goog.ui.Component.Error.DECORATE_INVALID);
  }
};


/**
 * Determines if a given element can be decorated by this type of component.
 * This method should be overridden by inheriting objects.
 * @param {Element} element Element to decorate.
 * @return {boolean} True if the element can be decorated, false otherwise.
 */
goog.ui.Component.prototype.canDecorate = function(element) {
  'use strict';
  return true;
};


/**
 * @return {boolean} Whether the component was decorated.
 */
goog.ui.Component.prototype.wasDecorated = function() {
  'use strict';
  return this.wasDecorated_;
};


/**
 * Actually decorates the element. Should be overridden by inheriting objects.
 * This method can assume there are checks to ensure the component has not
 * already been rendered have occurred and that enter document will be called
 * afterwards. This method is considered protected.
 * @param {Element} element Element to decorate.
 * @protected
 */
goog.ui.Component.prototype.decorateInternal = function(element) {
  'use strict';
  this.element_ = element;
};


/**
 * Called when the component's element is known to be in the document. Anything
 * using document.getElementById etc. should be done at this stage.
 *
 * If the component contains child components, this call is propagated to its
 * children.
 */
goog.ui.Component.prototype.enterDocument = function() {
  'use strict';
  this.inDocument_ = true;

  // Propagate enterDocument to child components that have a DOM, if any.
  // If a child was decorated before entering the document (permitted when
  // goog.ui.Component.ALLOW_DETACHED_DECORATION is true), its enterDocument
  // will be called here.
  this.forEachChild(function(child) {
    'use strict';
    if (!child.isInDocument() && child.getElement()) {
      child.enterDocument();
    }
  });
};


/**
 * Called by dispose to clean up the elements and listeners created by a
 * component, or by a parent component/application who has removed the
 * component from the document but wants to reuse it later.
 *
 * If the component contains child components, this call is propagated to its
 * children.
 *
 * It should be possible for the component to be rendered again once this method
 * has been called.
 */
goog.ui.Component.prototype.exitDocument = function() {
  'use strict';
  // Propagate exitDocument to child components that have been rendered, if any.
  this.forEachChild(function(child) {
    'use strict';
    if (child.isInDocument()) {
      child.exitDocument();
    }
  });

  if (this.googUiComponentHandler_) {
    this.googUiComponentHandler_.removeAll();
  }

  this.inDocument_ = false;
};


/**
 * Disposes of the component.  Calls `exitDocument`, which is expected to
 * remove event handlers and clean up the component.  Propagates the call to
 * the component's children, if any. Removes the component's DOM from the
 * document unless it was decorated.
 * @override
 * @protected
 */
goog.ui.Component.prototype.disposeInternal = function() {
  'use strict';
  if (this.inDocument_) {
    this.exitDocument();
  }

  if (this.googUiComponentHandler_) {
    this.googUiComponentHandler_.dispose();
    delete this.googUiComponentHandler_;
  }

  // Disposes of the component's children, if any.
  this.forEachChild(function(child) {
    'use strict';
    child.dispose();
  });

  // Detach the component's element from the DOM, unless it was decorated.
  if (!this.wasDecorated_ && this.element_) {
    goog.dom.removeNode(this.element_);
  }

  this.children_ = null;
  this.childIndex_ = null;
  this.element_ = null;
  this.model_ = null;
  this.parent_ = null;

  goog.ui.Component.superClass_.disposeInternal.call(this);
};


/**
 * Helper function for subclasses that gets a unique id for a given fragment,
 * this can be used by components to generate unique string ids for DOM
 * elements.
 * @param {string} idFragment A partial id.
 * @return {string} Unique element id.
 */
goog.ui.Component.prototype.makeId = function(idFragment) {
  'use strict';
  return this.getId() + '.' + idFragment;
};


/**
 * Makes a collection of ids.  This is a convenience method for makeId.  The
 * object's values are the id fragments and the new values are the generated
 * ids.  The key will remain the same.
 * @param {Object} object The object that will be used to create the ids.
 * @return {!Object<string, string>} An object of id keys to generated ids.
 */
goog.ui.Component.prototype.makeIds = function(object) {
  'use strict';
  var ids = {};
  for (var key in object) {
    ids[key] = this.makeId(object[key]);
  }
  return ids;
};


/**
 * Returns the model associated with the UI component.
 * @return {*} The model.
 */
goog.ui.Component.prototype.getModel = function() {
  'use strict';
  return this.model_;
};


/**
 * Sets the model associated with the UI component.
 * @param {*} obj The model.
 */
goog.ui.Component.prototype.setModel = function(obj) {
  'use strict';
  this.model_ = obj;
};


/**
 * Helper function for returning the fragment portion of an id generated using
 * makeId().
 * @param {string} id Id generated with makeId().
 * @return {string} Fragment.
 */
goog.ui.Component.prototype.getFragmentFromId = function(id) {
  'use strict';
  return id.substring(this.getId().length + 1);
};


/**
 * Helper function for returning an element in the document with a unique id
 * generated using makeId().
 * @param {string} idFragment The partial id.
 * @return {Element} The element with the unique id, or null if it cannot be
 *     found.
 */
goog.ui.Component.prototype.getElementByFragment = function(idFragment) {
  'use strict';
  if (!this.inDocument_) {
    throw new Error(goog.ui.Component.Error.NOT_IN_DOCUMENT);
  }
  return this.dom_.getElement(this.makeId(idFragment));
};


/**
 * Adds the specified component as the last child of this component.  See
 * {@link goog.ui.Component#addChildAt} for detailed semantics.
 *
 * @see goog.ui.Component#addChildAt
 * @param {goog.ui.Component} child The new child component.
 * @param {boolean=} opt_render If true, the child component will be rendered
 *    into the parent.
 */
goog.ui.Component.prototype.addChild = function(child, opt_render) {
  'use strict';
  // TODO(gboyer): addChildAt(child, this.getChildCount(), false) will
  // reposition any already-rendered child to the end.  Instead, perhaps
  // addChild(child, false) should never reposition the child; instead, clients
  // that need the repositioning will use addChildAt explicitly.  Right now,
  // clients can get around this by calling addChild before calling decorate.
  this.addChildAt(child, this.getChildCount(), opt_render);
};


/**
 * Adds the specified component as a child of this component at the given
 * 0-based index.
 *
 * Both `addChild` and `addChildAt` assume the following contract
 * between parent and child components:
 *  <ul>
 *    <li>the child component's element must be a descendant of the parent
 *        component's element, and
 *    <li>the DOM state of the child component must be consistent with the DOM
 *        state of the parent component (see `isInDocument`) in the
 *        steady state -- the exception is to addChildAt(child, i, false) and
 *        then immediately decorate/render the child.
 *  </ul>
 *
 * In particular, `parent.addChild(child)` will throw an error if the
 * child component is already in the document, but the parent isn't.
 *
 * Clients of this API may call `addChild` and `addChildAt` with
 * `opt_render` set to true.  If `opt_render` is true, calling these
 * methods will automatically render the child component's element into the
 * parent component's element. If the parent does not yet have an element, then
 * `createDom` will automatically be invoked on the parent before
 * rendering the child.
 *
 * Invoking {@code parent.addChild(child, true)} will throw an error if the
 * child component is already in the document, regardless of the parent's DOM
 * state.
 *
 * If `opt_render` is true and the parent component is not already
 * in the document, `enterDocument` will not be called on this component
 * at this point.
 *
 * Finally, this method also throws an error if the new child already has a
 * different parent, or the given index is out of bounds.
 *
 * @see goog.ui.Component#addChild
 * @param {goog.ui.Component} child The new child component.
 * @param {number} index 0-based index at which the new child component is to be
 *    added; must be between 0 and the current child count (inclusive).
 * @param {boolean=} opt_render If true, the child component will be rendered
 *    into the parent.
 * @return {void} Nada.
 */
goog.ui.Component.prototype.addChildAt = function(child, index, opt_render) {
  'use strict';
  goog.asserts.assert(!!child, 'Provided element must not be null.');

  if (child.inDocument_ && (opt_render || !this.inDocument_)) {
    // Adding a child that's already in the document is an error, except if the
    // parent is also in the document and opt_render is false (e.g. decorate()).
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  if (index < 0 || index > this.getChildCount()) {
    // Allowing sparse child arrays would lead to strange behavior, so we don't.
    throw new Error(goog.ui.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);
  }

  // Create the index and the child array on first use.
  if (!this.childIndex_ || !this.children_) {
    this.childIndex_ = {};
    this.children_ = [];
  }

  // Moving child within component, remove old reference.
  if (child.getParent() == this) {
    goog.object.set(this.childIndex_, child.getId(), child);
    goog.array.remove(this.children_, child);

    // Add the child to this component.  goog.object.add() throws an error if
    // a child with the same ID already exists.
  } else {
    goog.object.add(this.childIndex_, child.getId(), child);
  }

  // Set the parent of the child to this component.  This throws an error if
  // the child is already contained by another component.
  child.setParent(this);
  goog.array.insertAt(this.children_, child, index);

  if (child.inDocument_ && this.inDocument_ && child.getParent() == this) {
    // Changing the position of an existing child, move the DOM node (if
    // necessary).
    var contentElement = this.getContentElement();
    var elementAtDestinationIndex = contentElement.childNodes[index] || null;
    // Don't move the node if it's already in the destination index.
    if (elementAtDestinationIndex != child.getElement()) {
      // We remove the node before calculating the new index, otherwise we get
      // an off-by-one error when we move it to the right of its current index.
      if (child.getElement().parentElement == contentElement) {
        contentElement.removeChild(child.getElement());
      }
      var insertBeforeElement = contentElement.childNodes[index] || null;
      contentElement.insertBefore(
          /** @type {!Node} */ (child.getElement()), insertBeforeElement);
    }
  } else if (opt_render) {
    // If this (parent) component doesn't have a DOM yet, call createDom now
    // to make sure we render the child component's element into the correct
    // parent element (otherwise render_ with a null first argument would
    // render the child into the document body, which is almost certainly not
    // what we want).
    if (!this.element_) {
      this.createDom();
    }
    // Render the child into the parent at the appropriate location.  Note that
    // getChildAt(index + 1) returns undefined if inserting at the end.
    // TODO(attila): We should have a renderer with a renderChildAt API.
    var sibling = this.getChildAt(index + 1);
    // render_() calls enterDocument() if the parent is already in the document.
    child.render_(this.getContentElement(), sibling ? sibling.element_ : null);
  } else if (
      this.inDocument_ && !child.inDocument_ && child.element_ &&
      child.element_.parentNode &&
      // Under some circumstances, IE8 implicitly creates a Document Fragment
      // for detached nodes, so ensure the parent is an Element as it should be.
      child.element_.parentNode.nodeType == goog.dom.NodeType.ELEMENT) {
    // We don't touch the DOM, but if the parent is in the document, and the
    // child element is in the document but not marked as such, then we call
    // enterDocument on the child.
    // TODO(gboyer): It would be nice to move this condition entirely, but
    // there's a large risk of breaking existing applications that manually
    // append the child to the DOM and then call addChild.
    child.enterDocument();
  }
};


/**
 * Returns the DOM element into which child components are to be rendered,
 * or null if the component itself hasn't been rendered yet.  This default
 * implementation returns the component's root element.  Subclasses with
 * complex DOM structures must override this method.
 * @return {Element} Element to contain child elements (null if none).
 */
goog.ui.Component.prototype.getContentElement = function() {
  'use strict';
  return this.element_;
};


/**
 * Returns true if the component is rendered right-to-left, false otherwise.
 * The first time this function is invoked, the right-to-left rendering property
 * is set if it has not been already.
 * @return {boolean} Whether the control is rendered right-to-left.
 */
goog.ui.Component.prototype.isRightToLeft = function() {
  'use strict';
  if (this.rightToLeft_ == null) {
    this.rightToLeft_ = goog.style.isRightToLeft(
        this.inDocument_ ? this.element_ : this.dom_.getDocument().body);
  }
  return this.rightToLeft_;
};


/**
 * Set is right-to-left. This function should be used if the component needs
 * to know the rendering direction during dom creation (i.e. before
 * {@link #enterDocument} is called and is right-to-left is set).
 * @param {boolean} rightToLeft Whether the component is rendered
 *     right-to-left.
 */
goog.ui.Component.prototype.setRightToLeft = function(rightToLeft) {
  'use strict';
  if (this.inDocument_) {
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.rightToLeft_ = rightToLeft;
};


/**
 * Returns true if the component has children.
 * @return {boolean} True if the component has children.
 */
goog.ui.Component.prototype.hasChildren = function() {
  'use strict';
  return !!this.children_ && this.children_.length != 0;
};


/**
 * Returns the number of children of this component.
 * @return {number} The number of children.
 */
goog.ui.Component.prototype.getChildCount = function() {
  'use strict';
  return this.children_ ? this.children_.length : 0;
};


/**
 * Returns an array containing the IDs of the children of this component, or an
 * empty array if the component has no children.
 * @return {!Array<string>} Child component IDs.
 */
goog.ui.Component.prototype.getChildIds = function() {
  'use strict';
  var ids = [];

  // We don't use goog.object.getKeys(this.childIndex_) because we want to
  // return the IDs in the correct order as determined by this.children_.
  this.forEachChild(function(child) {
    'use strict';
    // addChild()/addChildAt() guarantee that the child array isn't sparse.
    ids.push(child.getId());
  });

  return ids;
};


/**
 * Returns the child with the given ID, or null if no such child exists.
 * @param {string} id Child component ID.
 * @return {goog.ui.Component?} The child with the given ID; null if none.
 */
goog.ui.Component.prototype.getChild = function(id) {
  'use strict';
  // Use childIndex_ for O(1) access by ID.
  return (this.childIndex_ && id) ?
      /** @type {goog.ui.Component} */ (
          goog.object.get(this.childIndex_, id)) ||
          null :
      null;
};


/**
 * Returns the child at the given index, or null if the index is out of bounds.
 * @param {number} index 0-based index.
 * @return {goog.ui.Component?} The child at the given index; null if none.
 */
goog.ui.Component.prototype.getChildAt = function(index) {
  'use strict';
  // Use children_ for access by index.
  return this.children_ ? this.children_[index] || null : null;
};


/**
 * Calls the given function on each of this component's children in order.  If
 * `opt_obj` is provided, it will be used as the 'this' object in the
 * function when called.  The function should take two arguments:  the child
 * component and its 0-based index.  The return value is ignored.
 * @param {function(this:T,?,number):?} f The function to call for every
 * child component; should take 2 arguments (the child and its index).
 * @param {T=} opt_obj Used as the 'this' object in f when called.
 * @template T
 */
goog.ui.Component.prototype.forEachChild = function(f, opt_obj) {
  'use strict';
  if (this.children_) {
    this.children_.forEach(f, opt_obj);
  }
};


/**
 * Returns the 0-based index of the given child component, or -1 if no such
 * child is found.
 * @param {goog.ui.Component?} child The child component.
 * @return {number} 0-based index of the child component; -1 if not found.
 */
goog.ui.Component.prototype.indexOfChild = function(child) {
  'use strict';
  return (this.children_ && child) ? this.children_.indexOf(child) : -1;
};


/**
 * Removes the given child from this component, and returns it.  Throws an error
 * if the argument is invalid or if the specified child isn't found in the
 * parent component.  The argument can either be a string (interpreted as the
 * ID of the child component to remove) or the child component itself.
 *
 * If `opt_unrender` is true, calls {@link goog.ui.component#exitDocument}
 * on the removed child, and subsequently detaches the child's DOM from the
 * document.  Otherwise it is the caller's responsibility to clean up the child
 * component's DOM.
 *
 * @see goog.ui.Component#removeChildAt
 * @param {string|goog.ui.Component|null} child The ID of the child to remove,
 *    or the child component itself.
 * @param {boolean=} opt_unrender If true, calls `exitDocument` on the
 *    removed child component, and detaches its DOM from the document.
 * @return {?goog.ui.Component} The removed component, if any.
 */
goog.ui.Component.prototype.removeChild = function(child, opt_unrender) {
  'use strict';
  if (child) {
    // Normalize child to be the object and id to be the ID string.  This also
    // ensures that the child is really ours.
    var id = (typeof child === 'string') ? child : child.getId();
    child = this.getChild(id);

    if (id && child) {
      goog.object.remove(this.childIndex_, id);
      goog.array.remove(this.children_, child);

      if (opt_unrender) {
        // Remove the child component's DOM from the document.  We have to call
        // exitDocument first (see documentation).
        child.exitDocument();
        if (child.element_) {
          goog.dom.removeNode(child.element_);
        }
      }

      // Child's parent must be set to null after exitDocument is called
      // so that the child can unlisten to its parent if required.
      child.setParent(null);
    }
  }

  if (!child) {
    throw new Error(goog.ui.Component.Error.NOT_OUR_CHILD);
  }

  return /** @type {!goog.ui.Component} */ (child);
};


/**
 * Removes the child at the given index from this component, and returns it.
 * Throws an error if the argument is out of bounds, or if the specified child
 * isn't found in the parent.  See {@link goog.ui.Component#removeChild} for
 * detailed semantics.
 *
 * @see goog.ui.Component#removeChild
 * @param {number} index 0-based index of the child to remove.
 * @param {boolean=} opt_unrender If true, calls `exitDocument` on the
 *    removed child component, and detaches its DOM from the document.
 * @return {goog.ui.Component} The removed component, if any.
 */
goog.ui.Component.prototype.removeChildAt = function(index, opt_unrender) {
  'use strict';
  // removeChild(null) will throw error.
  return this.removeChild(this.getChildAt(index), opt_unrender);
};


/**
 * Removes every child component attached to this one and returns them.
 *
 * @see goog.ui.Component#removeChild
 * @param {boolean=} opt_unrender If true, calls {@link #exitDocument} on the
 *    removed child components, and detaches their DOM from the document.
 * @return {!Array<goog.ui.Component>} The removed components if any.
 */
goog.ui.Component.prototype.removeChildren = function(opt_unrender) {
  'use strict';
  var removedChildren = [];
  while (this.hasChildren()) {
    removedChildren.push(this.removeChildAt(0, opt_unrender));
  }
  return removedChildren;
};


/**
 * Returns whether this component should listen for PointerEvent types rather
 * than MouseEvent types. This allows supporting drag gestures for touch/stylus
 * input.
 * @return {boolean}
 */
goog.ui.Component.prototype.pointerEventsEnabled = function() {
  'use strict';
  return this.pointerEventsEnabled_;
};


/**
 * Indicates whether this component should listen for PointerEvent types rather
 * than MouseEvent types. This allows supporting drag gestures for touch/stylus
 * input. Must be called before enterDocument to listen for the correct event
 * types.
 * @param {boolean} enable
 */
goog.ui.Component.prototype.setPointerEventsEnabled = function(enable) {
  'use strict';
  if (this.inDocument_) {
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }
  this.pointerEventsEnabled_ = enable;
};

//third_party/javascript/closure/ui/rangemodel.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Implementation of a range model. This is an implementation of
 * the BoundedRangeModel as described by Java at
 * http://java.sun.com/javase/6/docs/api/javax/swing/BoundedRangeModel.html.
 *
 * One good way to understand the range model is to think of a scroll bar for
 * a scrollable element. In that case minimum is 0, maximum is scrollHeight,
 * value is scrollTop and extent is clientHeight.
 *
 * Based on http://webfx.eae.net/dhtml/slider/js/range.js
 */

goog.provide('goog.ui.RangeModel');

goog.require('goog.events.EventTarget');
goog.require('goog.ui.Component');



/**
 * Creates a range model
 * @extends {goog.events.EventTarget}
 * @constructor
 */
goog.ui.RangeModel = function() {
  'use strict';
  goog.events.EventTarget.call(this);
};
goog.inherits(goog.ui.RangeModel, goog.events.EventTarget);


/**
 * @type {number}
 * @private
 */
goog.ui.RangeModel.prototype.value_ = 0;


/**
 * @type {number}
 * @private
 */
goog.ui.RangeModel.prototype.minimum_ = 0;


/**
 * @type {number}
 * @private
 */
goog.ui.RangeModel.prototype.maximum_ = 100;


/**
 * @type {number}
 * @private
 */
goog.ui.RangeModel.prototype.extent_ = 0;


/**
 * @type {?number}
 * @private
 */
goog.ui.RangeModel.prototype.step_ = 1;


/**
 * This is true if something is changed as a side effect. This happens when for
 * example we set the maximum below the current value.
 * @type {boolean}
 * @private
 */
goog.ui.RangeModel.prototype.isChanging_ = false;


/**
 * If set to true, we do not fire any change events.
 * @type {boolean}
 * @private
 */
goog.ui.RangeModel.prototype.mute_ = false;


/**
 * Sets the model to mute / unmute.
 * @param {boolean} muteValue Whether or not to mute the range, i.e.,
 *     suppress any CHANGE events.
 */
goog.ui.RangeModel.prototype.setMute = function(muteValue) {
  'use strict';
  this.mute_ = muteValue;
};


/**
 * Sets the value.
 * @param {number} value The new value.
 */
goog.ui.RangeModel.prototype.setValue = function(value) {
  'use strict';
  value = this.roundToStepWithMin(value);
  if (this.value_ != value) {
    if (value + this.extent_ > this.maximum_) {
      this.value_ = this.maximum_ - this.extent_;
    } else if (value < this.minimum_) {
      this.value_ = this.minimum_;
    } else {
      this.value_ = value;
    }
    if (!this.isChanging_ && !this.mute_) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * @return {number} the current value.
 */
goog.ui.RangeModel.prototype.getValue = function() {
  'use strict';
  return this.roundToStepWithMin(this.value_);
};


/**
 * Sets the extent. The extent is the 'size' of the value.
 * @param {number} extent The new extent.
 */
goog.ui.RangeModel.prototype.setExtent = function(extent) {
  'use strict';
  extent = this.roundToStepWithMin(extent);
  if (this.extent_ != extent) {
    if (extent < 0) {
      this.extent_ = 0;
    } else if (this.value_ + extent > this.maximum_) {
      this.extent_ = this.maximum_ - this.value_;
    } else {
      this.extent_ = extent;
    }
    if (!this.isChanging_ && !this.mute_) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * @return {number} The extent for the range model.
 */
goog.ui.RangeModel.prototype.getExtent = function() {
  'use strict';
  return this.roundToStep(this.extent_);
};


/**
 * Sets the minimum
 * @param {number} minimum The new minimum.
 */
goog.ui.RangeModel.prototype.setMinimum = function(minimum) {
  'use strict';
  // Don't round minimum because it is the base
  if (this.minimum_ != minimum) {
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = true;

    this.minimum_ = minimum;

    if (minimum + this.extent_ > this.maximum_) {
      this.extent_ = this.maximum_ - this.minimum_;
    }
    if (minimum > this.value_) {
      this.setValue(minimum);
    }
    if (minimum > this.maximum_) {
      this.extent_ = 0;
      this.setMaximum(minimum);
      this.setValue(minimum);
    }


    this.isChanging_ = oldIsChanging;
    if (!this.isChanging_ && !this.mute_) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * @return {number} The minimum value for the range model.
 */
goog.ui.RangeModel.prototype.getMinimum = function() {
  'use strict';
  return this.roundToStepWithMin(this.minimum_);
};


/**
 * Sets the maximum
 * @param {number} maximum The new maximum.
 */
goog.ui.RangeModel.prototype.setMaximum = function(maximum) {
  'use strict';
  maximum = this.roundToStepWithMin(maximum);
  if (this.maximum_ != maximum) {
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = true;

    this.maximum_ = maximum;

    if (maximum < this.value_ + this.extent_) {
      this.setValue(maximum - this.extent_);
    }
    if (maximum < this.minimum_) {
      this.extent_ = 0;
      this.setMinimum(maximum);
      this.setValue(this.maximum_);
    }
    if (maximum < this.minimum_ + this.extent_) {
      this.extent_ = this.maximum_ - this.minimum_;
    }

    this.isChanging_ = oldIsChanging;
    if (!this.isChanging_ && !this.mute_) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * @return {number} The maximimum value for the range model.
 */
goog.ui.RangeModel.prototype.getMaximum = function() {
  'use strict';
  return this.roundToStepWithMin(this.maximum_);
};


/**
 * Returns the step value. The step value is used to determine how to round the
 * value.
 * @return {?number} The maximimum value for the range model.
 */
goog.ui.RangeModel.prototype.getStep = function() {
  'use strict';
  return this.step_;
};


/**
 * Sets the step. The step value is used to determine how to round the value.
 * @param {?number} step  The step size.
 */
goog.ui.RangeModel.prototype.setStep = function(step) {
  'use strict';
  if (this.step_ != step) {
    this.step_ = step;

    // adjust value, extent and maximum
    var oldIsChanging = this.isChanging_;
    this.isChanging_ = true;

    this.setMaximum(this.getMaximum());
    this.setExtent(this.getExtent());
    this.setValue(this.getValue());

    this.isChanging_ = oldIsChanging;
    if (!this.isChanging_ && !this.mute_) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * Rounds to the closest step using the minimum value as the base.
 * @param {number} value  The number to round.
 * @return {number} The number rounded to the closest step.
 */
goog.ui.RangeModel.prototype.roundToStepWithMin = function(value) {
  'use strict';
  if (this.step_ == null) return value;
  return this.minimum_ +
      Math.round((value - this.minimum_) / this.step_) * this.step_;
};


/**
 * Rounds to the closest step.
 * @param {number} value  The number to round.
 * @return {number} The number rounded to the closest step.
 */
goog.ui.RangeModel.prototype.roundToStep = function(value) {
  'use strict';
  if (this.step_ == null) return value;
  return Math.round(value / this.step_) * this.step_;
};

//third_party/javascript/closure/ui/progressbar.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Implementation of a progress bar.
 *
 * @see ../demos/progressbar.html
 */


goog.provide('goog.ui.ProgressBar');
goog.provide('goog.ui.ProgressBar.Orientation');

goog.require('goog.a11y.aria');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.ui.Component');
goog.require('goog.ui.RangeModel');
goog.require('goog.userAgent');
goog.requireType('goog.events.Event');



/**
 * This creates a progress bar object.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 * @constructor
 * @extends {goog.ui.Component}
 */
goog.ui.ProgressBar = function(opt_domHelper) {
  'use strict';
  goog.ui.Component.call(this, opt_domHelper);

  /** @type {?HTMLDivElement} */
  this.thumbElement_;

  /**
   * The underlying data model for the progress bar.
   * @type {goog.ui.RangeModel}
   * @private
   */
  this.rangeModel_ = new goog.ui.RangeModel;
  goog.events.listen(
      this.rangeModel_, goog.ui.Component.EventType.CHANGE, this.handleChange_,
      false, this);
};
goog.inherits(goog.ui.ProgressBar, goog.ui.Component);


/**
 * Enum for representing the orientation of the progress bar.
 *
 * @enum {string}
 */
goog.ui.ProgressBar.Orientation = {
  VERTICAL: 'vertical',
  HORIZONTAL: 'horizontal'
};


/**
 * Map from progress bar orientation to CSS class names.
 * @type {!Object<string, string>}
 * @private
 */
goog.ui.ProgressBar.ORIENTATION_TO_CSS_NAME_ = {};
goog.ui.ProgressBar
    .ORIENTATION_TO_CSS_NAME_[goog.ui.ProgressBar.Orientation.VERTICAL] =
    goog.getCssName('progress-bar-vertical');
goog.ui.ProgressBar
    .ORIENTATION_TO_CSS_NAME_[goog.ui.ProgressBar.Orientation.HORIZONTAL] =
    goog.getCssName('progress-bar-horizontal');


/**
 * Creates the DOM nodes needed for the progress bar
 * @override
 */
goog.ui.ProgressBar.prototype.createDom = function() {
  'use strict';
  this.thumbElement_ = this.createThumb_();
  this.setElementInternal(this.getDomHelper().createDom(
      goog.dom.TagName.DIV,
      goog.ui.ProgressBar.ORIENTATION_TO_CSS_NAME_[this.orientation_],
      this.thumbElement_));
  this.setValueState_();
  this.setMinimumState_();
  this.setMaximumState_();
};


/** @override */
goog.ui.ProgressBar.prototype.enterDocument = function() {
  'use strict';
  goog.ui.ProgressBar.superClass_.enterDocument.call(this);
  this.attachEvents_();
  this.updateUi_();

  var element = this.getElement();
  goog.asserts.assert(element, 'The progress bar DOM element cannot be null.');
  // state live = polite will notify the user of updates,
  // but will not interrupt ongoing feedback
  goog.a11y.aria.setRole(element, 'progressbar');
  goog.a11y.aria.setState(element, 'live', 'polite');
};


/** @override */
goog.ui.ProgressBar.prototype.exitDocument = function() {
  'use strict';
  goog.ui.ProgressBar.superClass_.exitDocument.call(this);
  this.detachEvents_();
};


/**
 * This creates the thumb element.
 * @private
 * @return {!HTMLDivElement} The created thumb element.
 */
goog.ui.ProgressBar.prototype.createThumb_ = function() {
  'use strict';
  return this.getDomHelper().createDom(
      goog.dom.TagName.DIV, goog.getCssName('progress-bar-thumb'));
};


/**
 * Adds the initial event listeners to the element.
 * @private
 * @suppress {strictPrimitiveOperators} Part of the go/strict_warnings_migration
 */
goog.ui.ProgressBar.prototype.attachEvents_ = function() {
  'use strict';
  if (goog.userAgent.IE && goog.userAgent.VERSION < 7) {
    goog.events.listen(
        this.getElement(), goog.events.EventType.RESIZE, this.updateUi_, false,
        this);
  }
};


/**
 * Removes the event listeners added by attachEvents_.
 * @private
 * @suppress {strictPrimitiveOperators} Part of the go/strict_warnings_migration
 */
goog.ui.ProgressBar.prototype.detachEvents_ = function() {
  'use strict';
  if (goog.userAgent.IE && goog.userAgent.VERSION < 7) {
    goog.events.unlisten(
        this.getElement(), goog.events.EventType.RESIZE, this.updateUi_, false,
        this);
  }
};


/**
 * Decorates an existing HTML DIV element as a progress bar input. If the
 * element contains a child with a class name of 'progress-bar-thumb' that will
 * be used as the thumb.
 * @param {Element} element  The HTML element to decorate.
 * @override
 */
goog.ui.ProgressBar.prototype.decorateInternal = function(element) {
  'use strict';
  goog.ui.ProgressBar.superClass_.decorateInternal.call(this, element);
  goog.dom.classlist.add(
      goog.asserts.assert(this.getElement()),
      goog.ui.ProgressBar.ORIENTATION_TO_CSS_NAME_[this.orientation_]);

  // find thumb
  var thumb = goog.dom.getElementsByTagNameAndClass(
      null, goog.getCssName('progress-bar-thumb'), this.getElement())[0];
  if (!thumb) {
    thumb = this.createThumb_();
    this.getElement().appendChild(/** @type {!Node} */ (thumb));
  }
  this.thumbElement_ = /** @type {!HTMLDivElement} */ (thumb);
};


/**
 * @return {number} The value.
 */
goog.ui.ProgressBar.prototype.getValue = function() {
  'use strict';
  return this.rangeModel_.getValue();
};


/**
 * Sets the value
 * @param {number} v The value.
 */
goog.ui.ProgressBar.prototype.setValue = function(v) {
  'use strict';
  this.rangeModel_.setValue(v);
  if (this.getElement()) {
    this.setValueState_();
  }
};


/**
 * Sets the state for a11y of the current value.
 * @private
 */
goog.ui.ProgressBar.prototype.setValueState_ = function() {
  'use strict';
  var element = this.getElement();
  goog.asserts.assert(element, 'The progress bar DOM element cannot be null.');
  goog.a11y.aria.setState(element, 'valuenow', this.getValue());
};


/**
 * @return {number} The minimum value.
 */
goog.ui.ProgressBar.prototype.getMinimum = function() {
  'use strict';
  return this.rangeModel_.getMinimum();
};


/**
 * Sets the minimum number
 * @param {number} v The minimum value.
 */
goog.ui.ProgressBar.prototype.setMinimum = function(v) {
  'use strict';
  this.rangeModel_.setMinimum(v);
  if (this.getElement()) {
    this.setMinimumState_();
  }
};


/**
 * Sets the state for a11y of the minimum value.
 * @private
 */
goog.ui.ProgressBar.prototype.setMinimumState_ = function() {
  'use strict';
  var element = this.getElement();
  goog.asserts.assert(element, 'The progress bar DOM element cannot be null.');
  goog.a11y.aria.setState(element, 'valuemin', this.getMinimum());
};


/**
 * @return {number} The maximum value.
 */
goog.ui.ProgressBar.prototype.getMaximum = function() {
  'use strict';
  return this.rangeModel_.getMaximum();
};


/**
 * Sets the maximum number
 * @param {number} v The maximum value.
 */
goog.ui.ProgressBar.prototype.setMaximum = function(v) {
  'use strict';
  this.rangeModel_.setMaximum(v);
  if (this.getElement()) {
    this.setMaximumState_();
  }
};


/**
 * Sets the state for a11y of the maximum valiue.
 * @private
 */
goog.ui.ProgressBar.prototype.setMaximumState_ = function() {
  'use strict';
  var element = this.getElement();
  goog.asserts.assert(element, 'The progress bar DOM element cannot be null.');
  goog.a11y.aria.setState(element, 'valuemax', this.getMaximum());
};


/**
 *
 * @type {goog.ui.ProgressBar.Orientation}
 * @private
 */
goog.ui.ProgressBar.prototype.orientation_ =
    goog.ui.ProgressBar.Orientation.HORIZONTAL;


/**
 * Call back when the internal range model changes
 * @param {goog.events.Event} e The event object.
 * @private
 */
goog.ui.ProgressBar.prototype.handleChange_ = function(e) {
  'use strict';
  this.updateUi_();
  this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
};


/**
 * This is called when we need to update the size of the thumb. This happens
 * when first created as well as when the value and the orientation changes.
 * @private
 * @suppress {strictPrimitiveOperators} Part of the go/strict_warnings_migration
 */
goog.ui.ProgressBar.prototype.updateUi_ = function() {
  'use strict';
  if (this.thumbElement_) {
    var min = this.getMinimum();
    var max = this.getMaximum();
    var val = this.getValue();
    var ratio = (val - min) / (max - min);
    var size = Math.round(ratio * 100);
    if (this.orientation_ == goog.ui.ProgressBar.Orientation.VERTICAL) {
      // Note(arv): IE up to version 6 has some serious computation bugs when
      // using percentages or bottom. We therefore first set the height to
      // 100% and measure that and base the top and height on that size instead.
      if (goog.userAgent.IE && goog.userAgent.VERSION < 7) {
        this.thumbElement_.style.top = '0';
        this.thumbElement_.style.height = '100%';
        var h = this.thumbElement_.offsetHeight;
        var bottom = Math.round(ratio * h);
        this.thumbElement_.style.top = h - bottom + 'px';
        this.thumbElement_.style.height = bottom + 'px';
      } else {
        this.thumbElement_.style.top = (100 - size) + '%';
        this.thumbElement_.style.height = size + '%';
      }
    } else {
      this.thumbElement_.style.width = size + '%';
    }
  }
};


/**
 * This is called when we need to setup the UI sizes and positions. This
 * happens when we create the element and when we change the orientation.
 * @private
 */
goog.ui.ProgressBar.prototype.initializeUi_ = function() {
  'use strict';
  var tStyle = this.thumbElement_.style;
  if (this.orientation_ == goog.ui.ProgressBar.Orientation.VERTICAL) {
    tStyle.left = '0';
    tStyle.width = '100%';
  } else {
    tStyle.top = tStyle.left = '0';
    tStyle.height = '100%';
  }
};


/**
 * Changes the orientation
 * @param {goog.ui.ProgressBar.Orientation} orient The orientation.
 */
goog.ui.ProgressBar.prototype.setOrientation = function(orient) {
  'use strict';
  if (this.orientation_ != orient) {
    var oldCss =
        goog.ui.ProgressBar.ORIENTATION_TO_CSS_NAME_[this.orientation_];
    var newCss = goog.ui.ProgressBar.ORIENTATION_TO_CSS_NAME_[orient];
    this.orientation_ = orient;

    // Update the DOM
    var element = this.getElement();
    if (element) {
      goog.dom.classlist.swap(element, oldCss, newCss);
      this.initializeUi_();
      this.updateUi_();
    }
  }
};


/**
 * @return {goog.ui.ProgressBar.Orientation} The orientation of the
 *     progress bar.
 */
goog.ui.ProgressBar.prototype.getOrientation = function() {
  'use strict';
  return this.orientation_;
};


/** @override */
goog.ui.ProgressBar.prototype.disposeInternal = function() {
  'use strict';
  this.detachEvents_();
  goog.ui.ProgressBar.superClass_.disposeInternal.call(this);
  this.thumbElement_ = null;
  this.rangeModel_.dispose();
};


/**
 * @return {?number} The step value used to determine how to round the value.
 */
goog.ui.ProgressBar.prototype.getStep = function() {
  'use strict';
  return this.rangeModel_.getStep();
};


/**
 * Sets the step value. The step value is used to determine how to round the
 * value.
 * @param {?number} step  The step size.
 */
goog.ui.ProgressBar.prototype.setStep = function(step) {
  'use strict';
  this.rangeModel_.setStep(step);
};

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/writeimagecontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.WriteImageController');
goog.module.declareLegacyNamespace();

const ListenerCollection = goog.require('recovery.ListenerCollection');
const ProgressBar = goog.require('goog.ui.ProgressBar');
const RateEstimator = goog.require('recovery.RateEstimator');
const Stage = goog.require('recovery.Stage');
const dom = goog.require('goog.dom');
const recovery = goog.require('recovery');

/**
 * The controller to manage the write operation.
 *
 * @unrestricted
 */
const WriteImageController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.writeImageController = this;

    /** @type {recovery.controllers.AppController} */
    this.app = $scope.app;
    /** @type {function()} */
    this.applyScope = goog.bind($scope.$apply, $scope);

    /** @type {boolean} */
    this.canCancel = true;
    /** @type {?string} */
    this.stage = null;
    /** @type {number} */
    this.startTime = 0;
    /** @type {number} */
    this.percentComplete = 0;
    /** @type {?number} */
    this.hours = null;
    /** @type {?number} */
    this.minutes = null;
    /** @type {?number} */
    this.seconds = null;
    /** @type {!RateEstimator} */
    this.estimator =
        new RateEstimator(WriteImageController.NUM_PROGRESS_SAMPLES);
    /** @private {!ListenerCollection} */
    this.listeners_ = new ListenerCollection();

    if (!this.app.writeParams.device) {
      this.app.selectDevice();
      return;
    }

    if (!this.app.writeParams.target) {
      this.app.selectTarget();
      return;
    }

    // All paths that end a write should call listeners.removeAll(). That
    // currently includes completion, error and cancellation. All are covered
    // below.
    this.listeners_.add(
        chrome.imageWriterPrivate.onWriteComplete,
        goog.bind(this.onComplete, this));

    this.listeners_.add(
        chrome.imageWriterPrivate.onWriteError, goog.bind(this.onError, this));

    this.app.writeError = null;
    this.app.writeCancelled = false;

    this.start();
  }

  /** Starts the operation. */
  start() {
    if (this.app.writeParams.device.local) {
      chrome.imageWriterPrivate.writeFromFile(
          this.app.writeParams.target.storageUnitId,
          this.app.writeParams.device.file, function() {});
    } else if (this.app.writeParams.device.url) {
      chrome.imageWriterPrivate.writeFromUrl(
          this.app.writeParams.target.storageUnitId,
          this.app.writeParams.device.url, {
            imageHash: this.app.writeParams.device.md5,
            saveAsDownload: this.app.writeParams.saveAsDownload
          },
          function() {});
    }
    this.startTime = Date.now();
  }

  /** Starts the operation. */
  back() {
    this.app.writeConfirm();
  }

  /** Starts the operation. */
  forward() {
    this.app.writeComplete();
  }

  /** Configures the progress bar. */
  setupProgressBar() {
    this.progressBar = new ProgressBar();
    this.progressBar.setOrientation(ProgressBar.Orientation.HORIZONTAL);
    this.progressBar.render(dom.getElement('progress'));

    this.listeners_.add(
        chrome.imageWriterPrivate.onWriteProgress,
        goog.bind(this.onProgress, this));
  }

  /**
   * Gets the current stage enum.
   * @return {string} The translated stage name.
   */
  getStageKey() {
    return this.stage ? 'STAGE_' + this.stage.toUpperCase() : '';
  }

  /**
   * Cancels the current write.
   */
  cancel() {
    this.listeners_.removeAll();
    this.canCancel = false;
    chrome.imageWriterPrivate.cancelWrite(goog.bind(function() {
      this.app.writeCancelled = true;
      this.back();
      this.applyScope();
    }, this));
  }

  /**
   * Configures the scope when the write completes.
   * @param {!chrome.imageWriterPrivate.ProgressInfo} writeState The current
   *     progress of the write.
   */
  onProgress(writeState) {
    if (this.stage != writeState.stage) {
      this.sendTimeForStage_();
      this.stage = writeState.stage;
      this.estimator.reset();
    }
    this.percentComplete = writeState.percentComplete;

    this.estimator.addSample(writeState.percentComplete);
    this.seconds =
        Math.floor((100 - this.percentComplete) / this.estimator.getRate());
    this.minutes = Math.floor(this.seconds / 60);
    this.hours = Math.floor(this.minutes / 60);

    this.progressBar.setValue(this.percentComplete);
    this.applyScope();
  }

  /** Configures the scope when the write completes. */
  onComplete() {
    this.sendTimeForStage_();
    this.listeners_.removeAll();
    this.forward();
    this.applyScope();
  }

  /**
   * Send time spent on different stages to Google Analytics.
   * @private
   */
  sendTimeForStage_() {
    if (this.stage) {
      var endTime = Date.now();
      if (this.stage == Stage.DOWNLOAD) {
        this.app.ga.sendTiming(
            recovery.GoogleAnalytics.timingVar.DOWNLOAD_IMAGE,
            endTime - this.startTime);
      } else if (this.stage == Stage.VERIFY_DOWNLOAD) {
        this.app.ga.sendTiming(
            recovery.GoogleAnalytics.timingVar.VERIFY_DOWNLOADED_IMAGE,
            endTime - this.startTime);
      } else if (this.stage == Stage.UNZIP) {
        this.app.ga.sendTiming(
            recovery.GoogleAnalytics.timingVar.UNPACK_IMAGE,
            endTime - this.startTime);
      } else if (this.stage == Stage.WRITE) {
        this.app.ga.sendTiming(
            recovery.GoogleAnalytics.timingVar.BURN_IMAGE,
            endTime - this.startTime);
      } else if (this.stage == Stage.VERIFY_WRITE) {
        this.app.ga.sendTiming(
            recovery.GoogleAnalytics.timingVar.VERIFY_BURNED_IMAGE,
            endTime - this.startTime);
      }
      this.startTime = endTime;
    }
  }

  /**
   * Configures the scope when the write fails.
   * @param {!chrome.imageWriterPrivate.ProgressInfo} writeState The current
   *     progress of the write.
   * @param {string} errorCode The error message from the API.
   */
  onError(writeState, errorCode) {
    this.app.ga.setDimensionErrorReason(errorCode);
    this.app.ga.sendImageWriterErrorEvent();
    this.listeners_.removeAll();
    this.app.writeErrorCode = errorCode;
    this.app.writeConfirm();
    this.applyScope();
  }
};
goog.exportSymbol(
    'recovery.controllers.WriteImageController', WriteImageController);

/** @type {number} The number of samples to keep for estimating progress. */
WriteImageController.NUM_PROGRESS_SAMPLES = 5;

exports = WriteImageController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/erasedevicecontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.EraseDeviceController');
const WriteImageController = goog.require('recovery.controllers.WriteImageController');

/**
 * A controller for the erase progress screen
 *
 */
const EraseDeviceController = class extends WriteImageController {
  /**
   * @param {!angular.Scope} $scope
   * @param {!Function} $controller The angular controller service.
   */
  constructor($scope, $controller) {
    super($scope);
    $scope.eraseDeviceController = this;
  }

  /** Starts the operation. */
  start() {
    chrome.imageWriterPrivate.destroyPartitions(
        this.app.writeParams.target.storageUnitId, function() {});
  }

  /** Starts the operation. */
  back() {
    this.app.eraseConfirm();
  }

  /** Starts the operation. */
  forward() {
    this.app.eraseComplete();
  }
};
goog.exportSymbol(
    'recovery.controllers.EraseDeviceController', EraseDeviceController);

exports = EraseDeviceController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/drivelistupdater.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.DriveListUpdater');
goog.module.declareLegacyNamespace();

const googArray = goog.require('goog.array');

/**
 * Keeps track of the attached USB devices by polling periodically.  The
 * callback will be called whenever the list of devices changes.
 *
 * @unrestricted
 */
const DriveListUpdater = class {
  /**
   * @param {function(!chrome.imageWriterPrivate.DriveList)} callback The
   *     callback to call with the list of devices.
   * @param {number=} opt_interval The polling interval in milliseconds,
   *     defaulting to POLL_INTERVAL.
   */
  constructor(callback, opt_interval) {
    /** @private {?chrome.imageWriterPrivate.DriveList} */
    this.devices_ = null;
    /** @private {function(!chrome.imageWriterPrivate.DriveList)} */
    this.callback_ = callback;
    /** @private {number} */
    this.pollInterval_ = opt_interval || DriveListUpdater.POLL_INTERVAL;
    /** @private {number} */
    this.interval_ =
        setInterval(goog.bind(this.poll_, this), this.pollInterval_);

    this.poll_();
  }

  /** Stops the polling. */
  stop() {
    clearInterval(this.interval_);
  }

  /**
   * Triggers a poll.
   * @private
   */
  poll_() {
    chrome.imageWriterPrivate.listRemovableStorageDevices(
        goog.bind(this.update_, this));
  }

  /**
   * Calls the callback if the device list has changed.
   * @param {chrome.imageWriterPrivate.DriveList} devices The device list as
   *     returned from the API.
   * @private
   */
  update_(devices) {
    devices = devices.filter(function(dev) {
      return dev.capacity > 0;
    });
    var isSame = googArray.equals(devices, this.devices_, function(dev1, dev2) {
      return dev1.storageUnitId == dev2.storageUnitId;
    });

    if (!isSame) {
      this.devices_ = devices;
      this.callback_(devices);
    }
  }
};
goog.exportSymbol('recovery.DriveListUpdater', DriveListUpdater);

/**
 * A default polling interval in milliseconds.
 * @type {number}
 */
DriveListUpdater.POLL_INTERVAL = 2000;

exports = DriveListUpdater;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/selecttargetcontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.SelectTargetController');
goog.module.declareLegacyNamespace();

const DriveListUpdater = goog.require('recovery.DriveListUpdater');
const recovery = goog.require('recovery');

/**
 * USB-target selection controller.
 *
 * @unrestricted
 */
const SelectTargetController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.selectTargetController = this;

    /**
     * A reference to the parent controller.
     * @type {!recovery.controllers.AppController}
     */
    this.app = $scope.app;
    /**
     * A function to trigger scope application.
     * @private {function()}
     */
    this.applyScope_ = goog.bind($scope.$apply, $scope);
    /**
     * The currently selected device.
     * @type {?chrome.imageWriterPrivate.DriveInfo}
     */
    this.selectedUsb = this.app.writeParams.target;
    /**
     * Tracker for whether the user can currently continue.
     * @type {boolean}
     */
    this.canContinue = false;
    /**
     * Tracker for whether device detection is complete.
     * @type {boolean}
     */
    this.isDetectionCompleted = false;
    /**
     * The list of currently detected devices.
     * @type {chrome.imageWriterPrivate.DriveList}
     */
    this.usbDevices = [];
    /**
     * Whether to display the low-capacity error.
     * @type {boolean}
     */
    this.showLowCapacityError = false;

    var updater = new DriveListUpdater(goog.bind(this.onDevicesChanged_, this));
    $scope.$on('$destroy', function() {
      updater.stop();
    });

    $scope.$watch(
        'selectTargetController.selectedUsb',
        goog.bind(this.onDeviceSelected_, this));
  }

  /**
   * Helper function to focus a jfk select element.
   * @param {HTMLElement} jfkSelectElement The jfk-select element to focus.
   * @private
   */
  focusJfkSelect_(jfkSelectElement) {
    if (jfkSelectElement) {
      // Unclear why, but above null-check appears to be needed for testing.
      jfkSelectElement.getElementsByClassName('jfk-select')[0].focus();
    }
  }

  /**
   * Updates the scope when the device list changes.
   * @param {!chrome.imageWriterPrivate.DriveList} devices The list of removable
   *     devices.
   * @private
   */
  onDevicesChanged_(devices) {
    this.usbDevices = devices;
    this.isDetectionCompleted = true;

    // The objects returned by the API are always new objects, which makes the
    // widget think that the selected element is no longer in the list.  We need
    // to fix this by finding the right one.
    if (this.selectedUsb) {
      this.selectedUsb = devices.filter(function(dev) {
        return dev.storageUnitId == this.selectedUsb.storageUnitId;
      }, this)[0];
    }

    this.applyScope_();

    this.focusJfkSelect_(document.getElementById('select-usb-device'));
  }

  /**
   * Updates the scope when the user selects a device.
   * @private
   */
  onDeviceSelected_() {
    if (this.selectedUsb) {
      this.app.ga.setDimensionDriveModel(
          this.selectedUsb.vendor + ' ' + this.selectedUsb.model);
      this.app.ga.setDimensionDriveCapacity(
          this.convertCapacity_(this.selectedUsb.capacity));
      this.app.ga.setDimensionDriveIsRemovable(this.selectedUsb.removable);

      if (this.app.writeParams.device.local) {
        this.canContinue = true;
        this.showLowCapacityError = false;
        this.app.writeParams.target = this.selectedUsb;
      } else {
        var hasEnoughCapacity =
            this.selectedUsb.capacity >= this.app.writeParams.device.filesize;
        if (hasEnoughCapacity) {
          this.canContinue = true;
          this.showLowCapacityError = false;
          this.app.writeParams.target = this.selectedUsb;
        } else {
          this.canContinue = false;
          this.showLowCapacityError = true;
          this.app.writeParams.target = null;
        }
      }
    } else {
      this.canContinue = false;
      this.showLowCapacityError = false;
      this.app.writeParams.target = null;
    }
  }

  /**
   * Convert the actual capacity to readable capacity string like 4GB,
   * the number is rounded to nearest integer.
   *
   * @param {number} capacity The capacity of the drive.
   * @return {string} The readable capacity of drive.
   * @private
   */
  convertCapacity_(capacity) {
    if (capacity > 1000000000) {
      return (capacity / 1000000000).toFixed(0) + 'GB';
    } else {
      return (capacity / 1000000).toFixed(0) + 'MB';
    }
  }
};
goog.exportSymbol(
    'recovery.controllers.SelectTargetController', SelectTargetController);

exports = SelectTargetController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/eraseselecttargetcontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.EraseSelectTargetController');
const SelectTargetController = goog.require('recovery.controllers.SelectTargetController');

/**
 * A controller for the erase: select target screen
 *
 */
const EraseSelectTargetController = class extends SelectTargetController {
  /**
   * @param {!angular.Scope} $scope
   * @param {!Function} $controller The angular controller service.
   */
  constructor($scope, $controller) {
    super($scope);
    $scope.eraseSelectTargetController = this;

    $scope.app.writeParams.device = {local: true};
    $scope.app.step = null;
  }
};
goog.exportSymbol(
    'recovery.controllers.EraseSelectTargetController',
    EraseSelectTargetController);

exports = EraseSelectTargetController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/hwid_def.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.HwidDef');
goog.module.declareLegacyNamespace();

/**
 * Represents the definition of a given version of HWID w.r.t. the string
 * pattern HWIDs based on the definition must conform to and how the checksum
 * is generated.
 *  @final
 */
const HwidDef = class {
  /**
   * @param {boolean} removeDashes True if normalization should remove dashes.
   * @param {!RegExp} pattern Pattern that matches a valid HWID.
   * @param {!RegExp} prefixPattern Pattern that matches a valid HWID prefix.
   * @param {number} checksumCharsLen Number of chars in the checksum.
   * @param {function(string): string} generateChecksum Function that generates
   *     the checksum for a HWID.
   */
  constructor(
      removeDashes, pattern, prefixPattern, checksumCharsLen,
      generateChecksum) {
    /** @const @private {boolean} */
    this.removeDashes_ = removeDashes;

    /** @const @private {!RegExp} */
    this.pattern_ = pattern;

    /** @const @private {!RegExp} */
    this.prefixPattern_ = prefixPattern;

    /** @const @private {number} */
    this.checksumCharsLen_ = checksumCharsLen;

    /** @const @private {function(string): string} */
    this.generateChecksum_ = generateChecksum;
  }

  /**
   * Validates the checksum of the HWID.
   * @param {string} hwid The partial or complete HWID to validate.
   * @return {boolean} True if input HWID passes a checksum validation.
   */
  hasValidChecksum(hwid) {
    if (!hwid) {
      return false;
    }

    hwid = HwidDef.normalize_(hwid, this.removeDashes_);

    // Verify that checksum matches expected value.
    var actual = hwid.slice(hwid.length - this.checksumCharsLen_, hwid.length);
    var expected = this.generateChecksum_(
        hwid.slice(0, hwid.length - this.checksumCharsLen_).trim());

    return expected == actual;
  }

  /**
   * Returns true if the input is a valid HWID.
   * @param {string} hwid HWID to check.
   * @return {boolean} True if the input is a valid HWID.
   */
  isValidPattern(hwid) {
    hwid = HwidDef.normalize_(hwid, false);
    return this.pattern_.test(hwid);
  }

  /**
   * Returns true if the input is a valid HWID prefix including an empty string.
   * @param {string} hwidPrefix Prefix to check.
   * @return {boolean} True if the input is a valid prefix.
   */
  isValidPrefix(hwidPrefix) {
    if (hwidPrefix) {
      hwidPrefix = HwidDef.normalize_(hwidPrefix, false);
      return this.prefixPattern_.test(hwidPrefix);
    }
    return true;
  }

  /**
   * Normalizes the input:
   * - Uppercase the string.
   * - Trim off leading and trailing whitespace.
   * - Compress multiple spaces into a single space.
   * - Removes dashes if removeDashes is set to true.
   * @param {string} str String to normalize.
   * @param {boolean} removeDashes Set to true if dashes should be removed.
   * @return {string} Normalized string.
   * @private
   */
  static normalize_(str, removeDashes) {
    str = str.toUpperCase().trim().replace(/\s+/g, ' ');
    if (removeDashes) {
      str = str.replace(/-/g, '');
    }
    return str;
  }

  /**
   * Converts an ascii string to Uint8Array.
   * @param {string} str Input string assumed to be ascii.
   * @return {!Uint8Array} Byte array.
   */
  static stringToUint8Array(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return bufView;
  }
};
goog.exportSymbol('recovery.HwidDef', HwidDef);

exports = HwidDef;

;return exports;});

//third_party/javascript/zlib_js/util.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview 雑多な関数群をまとめたモジュール実装.
 */
goog.provide('Zlib.Util');

goog.scope(function() {

/**
 * Byte String から Byte Array に変換.
 * @param {!string} str byte string.
 * @return {!Array.<number>} byte array.
 */
Zlib.Util.stringToByteArray = function(str) {
  /** @type {!Array.<(string|number)>} */
  var tmp = str.split('');
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = tmp.length; i < il; i++) {
    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
  }

  return tmp;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/adler32.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Adler32 checksum 実装.
 */
goog.provide('Zlib.Adler32');

goog.require('Zlib.Util');

goog.scope(function() {

/**
 * Adler32 ハッシュ値の作成
 * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32 = function(array) {
  if (typeof(array) === 'string') {
    array = Zlib.Util.stringToByteArray(array);
  }
  return Zlib.Adler32.update(1, array);
};

/**
 * Adler32 ハッシュ値の更新
 * @param {number} adler 現在のハッシュ値.
 * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
 * @return {number} Adler32 ハッシュ値.
 */
Zlib.Adler32.update = function(adler, array) {
  /** @type {number} */
  var s1 = adler & 0xffff;
  /** @type {number} */
  var s2 = (adler >>> 16) & 0xffff;
  /** @type {number} array length */
  var len = array.length;
  /** @type {number} loop length (don't overflow) */
  var tlen;
  /** @type {number} array index */
  var i = 0;

  while (len > 0) {
    tlen = len > Zlib.Adler32.OptimizationParameter ?
      Zlib.Adler32.OptimizationParameter : len;
    len -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);

    s1 %= 65521;
    s2 %= 65521;
  }

  return ((s2 << 16) | s1) >>> 0;
};

/**
 * Adler32 最適化パラメータ
 * 現状では 1024 程度が最適.
 * @see http://jsperf.com/adler-32-simple-vs-optimized/3
 * @define {number}
 */
Zlib.Adler32.OptimizationParameter = 1024;

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/hybrid.js
/**
 * defines
 */

goog.provide('Zlib.USE_TYPEDARRAY');

// Safari が typeof Uint8Array === 'object' になるため、
// 未定義か否かで Typed Array の使用を決定する

/** @const {boolean} use typed array flag. */
Zlib.USE_TYPEDARRAY =
  (typeof Uint8Array !== 'undefined') &&
  (typeof Uint16Array !== 'undefined') &&
  (typeof Uint32Array !== 'undefined');

//third_party/javascript/zlib_js/bitstream.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview bit 単位での書き込み実装.
 */
goog.provide('Zlib.BitStream');

goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * ビットストリーム
 * @constructor
 * @param {!(Array|Uint8Array)=} buffer output buffer.
 * @param {number=} bufferPosition start buffer pointer.
 */
Zlib.BitStream = function(buffer, bufferPosition) {
  /** @type {number} buffer index. */
  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
  /** @type {number} bit index. */
  this.bitindex = 0;
  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */
  this.buffer = buffer instanceof (Zlib.USE_TYPEDARRAY ? Uint8Array : Array) ?
    buffer :
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.BitStream.DefaultBlockSize);

  // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする
  if (this.buffer.length * 2 <= this.index) {
    throw new Error("invalid index");
  } else if (this.buffer.length <= this.index) {
    this.expandBuffer();
  }
};

/**
 * デフォルトブロックサイズ.
 * @const
 * @type {number}
 */
Zlib.BitStream.DefaultBlockSize = 0x8000;

/**
 * expand buffer.
 * @return {!(Array|Uint8Array)} new buffer.
 */
Zlib.BitStream.prototype.expandBuffer = function() {
  /** @type {!(Array|Uint8Array)} old buffer. */
  var oldbuf = this.buffer;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il = oldbuf.length;
  /** @type {!(Array|Uint8Array)} new buffer. */
  var buffer =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);

  // copy buffer
  if (Zlib.USE_TYPEDARRAY) {
    buffer.set(oldbuf);
  } else {
    // XXX: loop unrolling
    for (i = 0; i < il; ++i) {
      buffer[i] = oldbuf[i];
    }
  }

  return (this.buffer = buffer);
};


/**
 * 数値をビットで指定した数だけ書き込む.
 * @param {number} number 書き込む数値.
 * @param {number} n 書き込むビット数.
 * @param {boolean=} reverse 逆順に書き込むならば true.
 */
Zlib.BitStream.prototype.writeBits = function(number, n, reverse) {
  var buffer = this.buffer;
  var index = this.index;
  var bitindex = this.bitindex;

  /** @type {number} current octet. */
  var current = buffer[index];
  /** @type {number} loop counter. */
  var i;

  /**
   * 32-bit 整数のビット順を逆にする
   * @param {number} n 32-bit integer.
   * @return {number} reversed 32-bit integer.
   * @private
   */
  function rev32_(n) {
    return (Zlib.BitStream.ReverseTable[n & 0xFF] << 24) |
      (Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |
      (Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |
      Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];
  }

  if (reverse && n > 1) {
    number = n > 8 ?
      rev32_(number) >> (32 - n) :
      Zlib.BitStream.ReverseTable[number] >> (8 - n);
  }

  // Byte 境界を超えないとき
  if (n + bitindex < 8) {
    current = (current << n) | number;
    bitindex += n;
  // Byte 境界を超えるとき
  } else {
    for (i = 0; i < n; ++i) {
      current = (current << 1) | ((number >> n - i - 1) & 1);

      // next byte
      if (++bitindex === 8) {
        bitindex = 0;
        buffer[index++] = Zlib.BitStream.ReverseTable[current];
        current = 0;

        // expand
        if (index === buffer.length) {
          buffer = this.expandBuffer();
        }
      }
    }
  }
  buffer[index] = current;

  this.buffer = buffer;
  this.bitindex = bitindex;
  this.index = index;
};


/**
 * ストリームの終端処理を行う
 * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
 */
Zlib.BitStream.prototype.finish = function() {
  var buffer = this.buffer;
  var index = this.index;

  /** @type {!(Array|Uint8Array)} output buffer. */
  var output;

  // bitindex が 0 の時は余分に index が進んでいる状態
  if (this.bitindex > 0) {
    buffer[index] <<= 8 - this.bitindex;
    buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];
    index++;
  }

  // array truncation
  if (Zlib.USE_TYPEDARRAY) {
    output = buffer.subarray(0, index);
  } else {
    buffer.length = index;
    output = buffer;
  }

  return output;
};

/**
 * 0-255 のビット順を反転したテーブル
 * @const
 * @type {!(Uint8Array|Array<number>)}
 */
Zlib.BitStream.ReverseTable = (function(table) {
  return table;
})((function() {
  /** @type {!(Array|Uint8Array)} reverse table. */
  var table = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(256);
  /** @type {number} loop counter. */
  var i;

  // generate
  for (i = 0; i < 256; ++i) {
    table[i] = (function(n) {
      var r = n;
      var s = 7;

      for (n >>>= 1; n; n >>>= 1) {
        r <<= 1;
        r |= n & 1;
        --s;
      }

      return (r << s & 0xff) >>> 0;
    })(i);
  }

  return table;
})());


// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/compression_method.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.CompressionMethod');

goog.scope(function() {
/**
 * Compression Method
 * @enum {number}
 */
Zlib.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};

// end of scope
});

//third_party/javascript/zlib_js/crc32.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview CRC32 実装.
 */
goog.provide('Zlib.CRC32');

goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/** @define {boolean} */
var ZLIB_CRC32_COMPACT = false;

/**
 * CRC32 ハッシュ値を取得
 * @param {!(Array<number>|Uint8Array)} data data byte array.
 * @param {number=} pos data position.
 * @param {number=} length data length.
 * @return {number} CRC32.
 */
Zlib.CRC32.calc = function(data, pos, length) {
  return Zlib.CRC32.update(data, 0, pos, length);
};

/**
 * CRC32ハッシュ値を更新
 * @param {!(Array<number>|Uint8Array)} data data byte array.
 * @param {number} crc CRC32.
 * @param {number=} pos data position.
 * @param {number=} length data length.
 * @return {number} CRC32.
 */
Zlib.CRC32.update = function(data, crc, pos, length) {
  var table = Zlib.CRC32.Table;
  var i = (typeof pos === 'number') ? pos : (pos = 0);
  var il = (typeof length === 'number') ? length : data.length;

  crc ^= 0xffffffff;

  // loop unrolling for performance
  for (i = il & 7; i--; ++pos) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];
  }
  for (i = il >> 3; i--; pos += 8) {
    crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];
    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];
  }

  return (crc ^ 0xffffffff) >>> 0;
};

/**
 * @param {number} num
 * @param {number} crc
 * @returns {number}
 */
Zlib.CRC32.single = function(num, crc) {
  return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;
};

/**
 * @type {Array<number>}
 * @const
 * @private
 */
Zlib.CRC32.Table_ = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

/**
 * @type {!(Array<number>|Uint32Array)} CRC-32 Table.
 * @const
 */
Zlib.CRC32.Table = ZLIB_CRC32_COMPACT ? (function() {
  /** @type {!(Array<number>|Uint32Array)} */
  var table = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(256);
  /** @type {number} */
  var c;
  /** @type {number} */
  var i;
  /** @type {number} */
  var j;

  for (i = 0; i < 256; ++i) {
    c = i;
    for (j = 0; j < 8; ++j) {
      c = (c & 1) ? (0xedB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[i] = c >>> 0;
  }

  return table;
})() : Zlib.USE_TYPEDARRAY ? new Uint32Array(Zlib.CRC32.Table_) : Zlib.CRC32.Table_;

});

//third_party/javascript/zlib_js/heap.js
/**
 * @license
 *
 * zlib.heap.js
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
 */

goog.provide('Zlib.Heap');

goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * カスタムハフマン符号で使用するヒープ実装
 * @param {number} length ヒープサイズ.
 * @constructor
 */
Zlib.Heap = function(length) {
  /** @type {!Uint16Array|!Array} */
  this.buffer = new (Zlib.USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);
  /** @type {number} */
  this.length = 0;
};

/**
 * 親ノードの index 取得
 * @param {number} index 子ノードの index.
 * @return {number} 親ノードの index.
 *
 */
Zlib.Heap.prototype.getParent = function(index) {
  return ((index - 2) / 4 | 0) * 2;
};

/**
 * 子ノードの index 取得
 * @param {number} index 親ノードの index.
 * @return {number} 子ノードの index.
 */
Zlib.Heap.prototype.getChild = function(index) {
  return 2 * index + 2;
};

/**
 * Heap に値を追加する
 * @param {number} index キー index.
 * @param {number} value 値.
 * @return {number} 現在のヒープ長.
 */
Zlib.Heap.prototype.push = function(index, value) {
  var current, parent,
      heap = this.buffer,
      swap;

  current = this.length;
  heap[this.length++] = value;
  heap[this.length++] = index;

  // ルートノードにたどり着くまで入れ替えを試みる
  while (current > 0) {
    parent = this.getParent(current);

    // 親ノードと比較して親の方が小さければ入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[current];
      heap[current] = heap[parent];
      heap[parent] = swap;

      swap = heap[current + 1];
      heap[current + 1] = heap[parent + 1];
      heap[parent + 1] = swap;

      current = parent;
    // 入れ替えが必要なくなったらそこで抜ける
    } else {
      break;
    }
  }

  return this.length;
};

/**
 * Heapから一番大きい値を返す
 * @return {{index: number, value: number, length: number}} {index: キーindex,
 *     value: 値, length: ヒープ長} の Object.
 */
Zlib.Heap.prototype.pop = function() {
  var index, value,
      heap = this.buffer, swap,
      current, parent;

  value = heap[0];
  index = heap[1];

  // 後ろから値を取る
  this.length -= 2;
  heap[0] = heap[this.length];
  heap[1] = heap[this.length + 1];

  parent = 0;
  // ルートノードから下がっていく
  while (true) {
    current = this.getChild(parent);

    // 範囲チェック
    if (current >= this.length) {
      break;
    }

    // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択
    if (current + 2 < this.length && heap[current + 2] > heap[current]) {
      current += 2;
    }

    // 親ノードと比較して親の方が小さい場合は入れ替える
    if (heap[current] > heap[parent]) {
      swap = heap[parent];
      heap[parent] = heap[current];
      heap[current] = swap;

      swap = heap[parent + 1];
      heap[parent + 1] = heap[current + 1];
      heap[current + 1] = swap;
    } else {
      break;
    }

    parent = current;
  }

  return {index: index, value: value, length: this.length};
};


// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/rawdeflate.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
 */

goog.provide('Zlib.RawDeflate');

goog.require('Zlib.BitStream');
goog.require('Zlib.Heap');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * Raw Deflate 実装
 *
 * @constructor
 * @param {!(Array<number>|Uint8Array)} input 符号化する対象のバッファ.
 * @param {Object=} opt_params option parameters.
 *
 * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
 * 変換されます.
 * 別のオブジェクトになるため出力バッファを参照している変数などは
 * 更新する必要があります.
 */
Zlib.RawDeflate = function(input, opt_params) {
  /** @type {Zlib.RawDeflate.CompressionType} */
  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;
  /** @type {number} */
  this.lazy = 0;
  /** @type {!(Array<number>|Uint32Array)} */
  this.freqsLitLen;
  /** @type {!(Array<number>|Uint32Array)} */
  this.freqsDist;
  /** @type {!(Array<number>|Uint8Array)} */
  this.input =
    (Zlib.USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;
  /** @type {!(Array<number>|Uint8Array)} output output buffer. */
  this.output;
  /** @type {number} pos output buffer position. */
  this.op = 0;

  // option parameters
  if (opt_params) {
    if (opt_params['lazy']) {
      this.lazy = opt_params['lazy'];
    }
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
    if (opt_params['outputBuffer']) {
      this.output =
        (Zlib.USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?
        new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
    }
    if (typeof opt_params['outputIndex'] === 'number') {
      this.op = opt_params['outputIndex'];
    }
  }

  if (!this.output) {
    this.output = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);
  }
};

/**
 * @enum {number}
 */
Zlib.RawDeflate.CompressionType = {
  NONE: 0,
  FIXED: 1,
  DYNAMIC: 2,
  RESERVED: 3
};


/**
 * LZ77 の最小マッチ長
 * @const
 * @type {number}
 */
Zlib.RawDeflate.Lz77MinLength = 3;

/**
 * LZ77 の最大マッチ長
 * @const
 * @type {number}
 */
Zlib.RawDeflate.Lz77MaxLength = 258;

/**
 * LZ77 のウィンドウサイズ
 * @const
 * @type {number}
 */
Zlib.RawDeflate.WindowSize = 0x8000;

/**
 * 最長の符号長
 * @const
 * @type {number}
 */
Zlib.RawDeflate.MaxCodeLength = 16;

/**
 * ハフマン符号の最大数値
 * @const
 * @type {number}
 */
Zlib.RawDeflate.HUFMAX = 286;

/**
 * 固定ハフマン符号の符号化テーブル
 * @const
 * @type {!Array<!Array<number>>}
 */
Zlib.RawDeflate.FixedHuffmanTable = (function() {
  var table = [], i;

  for (i = 0; i < 288; i++) {
    switch (true) {
      case (i <= 143): table.push([i       + 0x030, 8]); break;
      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;
      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;
      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;
      default:
        throw new Error('invalid literal: ' + i);
    }
  }

  return table;
})();

/**
 * DEFLATE ブロックの作成
 * @return {!(Array<number>|Uint8Array)} 圧縮済み byte array.
 */
Zlib.RawDeflate.prototype.compress = function() {
  /** @type {!(Array<number>|Uint8Array)} */
  var blockArray;
  /** @type {number} */
  var position;
  /** @type {number} */
  var length;

  var input = this.input;

  // compression
  switch (this.compressionType) {
    case Zlib.RawDeflate.CompressionType.NONE:
      // each 65535-Byte (length header: 16-bit)
      for (position = 0, length = input.length; position < length;) {
        blockArray = Zlib.USE_TYPEDARRAY ?
          input.subarray(position, position + 0xffff) :
          input.slice(position, position + 0xffff);
        position += blockArray.length;
        this.makeNocompressBlock(blockArray, (position === length));
      }
      break;
    case Zlib.RawDeflate.CompressionType.FIXED:
      this.output = this.makeFixedHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    case Zlib.RawDeflate.CompressionType.DYNAMIC:
      this.output = this.makeDynamicHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    default:
      throw new Error('invalid compression type');
  }

  return this.output;
};

/**
 * 非圧縮ブロックの作成
 * @param {!(Array<number>|Uint8Array)} blockArray ブロックデータ byte array.
 * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
 * @return {!(Array<number>|Uint8Array)} 非圧縮ブロック byte array.
 */
Zlib.RawDeflate.prototype.makeNocompressBlock =
function(blockArray, isFinalBlock) {
  /** @type {number} */
  var bfinal;
  /** @type {Zlib.RawDeflate.CompressionType} */
  var btype;
  /** @type {number} */
  var len;
  /** @type {number} */
  var nlen;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  var output = this.output;
  var op = this.op;

  // expand buffer
  if (Zlib.USE_TYPEDARRAY) {
    output = new Uint8Array(this.output.buffer);
    while (output.length <= op + blockArray.length + 5) {
      output = new Uint8Array(output.length << 1);
    }
    output.set(this.output);
  }

  // header
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.NONE;
  output[op++] = (bfinal) | (btype << 1);

  // length
  len = blockArray.length;
  nlen = (~len + 0x10000) & 0xffff;
  output[op++] =          len & 0xff;
  output[op++] =  (len >>> 8) & 0xff;
  output[op++] =         nlen & 0xff;
  output[op++] = (nlen >>> 8) & 0xff;

  // copy buffer
  if (Zlib.USE_TYPEDARRAY) {
     output.set(blockArray, op);
     op += blockArray.length;
     output = output.subarray(0, op);
  } else {
    for (i = 0, il = blockArray.length; i < il; ++i) {
      output[op++] = blockArray[i];
    }
    output.length = op;
  }

  this.op = op;
  this.output = output;

  return output;
};

/**
 * 固定ハフマンブロックの作成
 * @param {!(Array<number>|Uint8Array)} blockArray ブロックデータ byte array.
 * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
 * @return {!(Array<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
 */
Zlib.RawDeflate.prototype.makeFixedHuffmanBlock =
function(blockArray, isFinalBlock) {
  /** @type {Zlib.BitStream} */
  var stream = new Zlib.BitStream(Zlib.USE_TYPEDARRAY ?
    new Uint8Array(this.output.buffer) : this.output, this.op);
  /** @type {number} */
  var bfinal;
  /** @type {Zlib.RawDeflate.CompressionType} */
  var btype;
  /** @type {!(Array<number>|Uint16Array)} */
  var data;

  // header
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.FIXED;

  stream.writeBits(bfinal, 1, true);
  stream.writeBits(btype, 2, true);

  data = this.lz77(blockArray);
  this.fixedHuffman(data, stream);

  return stream.finish();
};

/**
 * 動的ハフマンブロックの作成
 * @param {!(Array<number>|Uint8Array)} blockArray ブロックデータ byte array.
 * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
 * @return {!(Array<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
 */
Zlib.RawDeflate.prototype.makeDynamicHuffmanBlock =
function(blockArray, isFinalBlock) {
  /** @type {Zlib.BitStream} */
  var stream = new Zlib.BitStream(Zlib.USE_TYPEDARRAY ?
    new Uint8Array(this.output.buffer) : this.output, this.op);
  /** @type {number} */
  var bfinal;
  /** @type {Zlib.RawDeflate.CompressionType} */
  var btype;
  /** @type {!(Array<number>|Uint16Array)} */
  var data;
  /** @type {number} */
  var hlit;
  /** @type {number} */
  var hdist;
  /** @type {number} */
  var hclen;
  /** @const {Array<number>} */
  var hclenOrder =
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  /** @type {!(Array<number>|Uint8Array)} */
  var litLenLengths;
  /** @type {!(Array<number>|Uint16Array)} */
  var litLenCodes;
  /** @type {!(Array<number>|Uint8Array)} */
  var distLengths;
  /** @type {!(Array<number>|Uint16Array)} */
  var distCodes;
  /** @type {{
   *   codes: !(Array<number>|Uint32Array),
   *   freqs: !(Array<number>|Uint32Array)
   * }} */
  var treeSymbols;
  /** @type {!(Array<number>|Uint8Array)} */
  var treeLengths;
  /** @type {Array} */
  var transLengths = new Array(19);
  /** @type {!(Array<number>|Uint16Array)} */
  var treeCodes;
  /** @type {number} */
  var code;
  /** @type {number} */
  var bitlen;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  // header
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.DYNAMIC;

  stream.writeBits(bfinal, 1, true);
  stream.writeBits(btype, 2, true);

  data = this.lz77(blockArray);

  // リテラル・長さ, 距離のハフマン符号と符号長の算出
  litLenLengths = this.getLengths_(this.freqsLitLen, 15);
  litLenCodes = this.getCodesFromLengths_(litLenLengths);
  distLengths = this.getLengths_(this.freqsDist, 7);
  distCodes = this.getCodesFromLengths_(distLengths);

  // HLIT, HDIST の決定
  for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}
  for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}

  // HCLEN
  treeSymbols =
    this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
  treeLengths = this.getLengths_(treeSymbols.freqs, 7);
  for (i = 0; i < 19; i++) {
    transLengths[i] = treeLengths[hclenOrder[i]];
  }
  for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}

  treeCodes = this.getCodesFromLengths_(treeLengths);

  // 出力
  stream.writeBits(hlit - 257, 5, true);
  stream.writeBits(hdist - 1, 5, true);
  stream.writeBits(hclen - 4, 4, true);
  for (i = 0; i < hclen; i++) {
    stream.writeBits(transLengths[i], 3, true);
  }

  // ツリーの出力
  for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
    code = treeSymbols.codes[i];

    stream.writeBits(treeCodes[code], treeLengths[code], true);

    // extra bits
    if (code >= 16) {
      i++;
      switch (code) {
        case 16: bitlen = 2; break;
        case 17: bitlen = 3; break;
        case 18: bitlen = 7; break;
        default:
          throw new Error('invalid code: ' + code);
      }

      stream.writeBits(treeSymbols.codes[i], bitlen, true);
    }
  }

  this.dynamicHuffman(
    data,
    [litLenCodes, litLenLengths],
    [distCodes, distLengths],
    stream
  );

  return stream.finish();
};


/**
 * 動的ハフマン符号化(カスタムハフマンテーブル)
 * @param {!(Array<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
 * @param {!Array<!(Array<number>|Uint16Array)>} litLen
 * @param {!Array<!(Array<number>|Uint16Array)>} dist
 * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
 * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
 */
Zlib.RawDeflate.prototype.dynamicHuffman =
function(dataArray, litLen, dist, stream) {
  /** @type {number} */
  var index;
  /** @type {number} */
  var length;
  /** @type {number} */
  var literal;
  /** @type {number} */
  var code;
  /** @type {!(Array<number>|Uint16Array)} */
  var litLenCodes;
  /** @type {!(Array<number>|Uint16Array)} */
  var litLenLengths;
  /** @type {!(Array<number>|Uint16Array)} */
  var distCodes;
  /** @type {!(Array<number>|Uint16Array)} */
  var distLengths;

  litLenCodes = litLen[0];
  litLenLengths = litLen[1];
  distCodes = dist[0];
  distLengths = dist[1];

  // 符号を BitStream に書き込んでいく
  for (index = 0, length = dataArray.length; index < length; ++index) {
    literal = dataArray[index];

    // literal or length
    stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);

    // 長さ・距離符号
    if (literal > 256) {
      // length extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // distance
      code = dataArray[++index];
      stream.writeBits(distCodes[code], distLengths[code], true);
      // distance extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
    // 終端
    } else if (literal === 256) {
      break;
    }
  }

  return stream;
};

/**
 * 固定ハフマン符号化
 * @param {!(Array<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
 * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
 * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
 */
Zlib.RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {
  /** @type {number} */
  var index;
  /** @type {number} */
  var length;
  /** @type {number} */
  var literal;

  // 符号を BitStream に書き込んでいく
  for (index = 0, length = dataArray.length; index < length; index++) {
    literal = dataArray[index];

    // 符号の書き込み
    Zlib.BitStream.prototype.writeBits.apply(
      stream,
      Zlib.RawDeflate.FixedHuffmanTable[literal]
    );

    // 長さ・距離符号
    if (literal > 0x100) {
      // length extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
      // distance
      stream.writeBits(dataArray[++index], 5);
      // distance extra
      stream.writeBits(dataArray[++index], dataArray[++index], true);
    // 終端
    } else if (literal === 0x100) {
      break;
    }
  }

  return stream;
};

/**
 * マッチ情報
 * @param {!number} length マッチした長さ.
 * @param {!number} backwardDistance マッチ位置との距離.
 * @constructor
 */
Zlib.RawDeflate.Lz77Match = function(length, backwardDistance) {
  /** @type {number} match length. */
  this.length = length;
  /** @type {number} backward distance. */
  this.backwardDistance = backwardDistance;
};

/**
 * 長さ符号テーブル.
 * [コード, 拡張ビット, 拡張ビット長] の配列となっている.
 * @const
 * @type {!(Array<number>|Uint32Array)}
 */
Zlib.RawDeflate.Lz77Match.LengthCodeTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint32Array(table) : table;
})((function() {
  /** @type {!Array} */
  var table = [];
  /** @type {number} */
  var i;
  /** @type {!Array<number>} */
  var c;

  for (i = 3; i <= 258; i++) {
    c = code(i);
    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];
  }

  /**
   * @param {number} length lz77 length.
   * @return {!Array<number>} lz77 codes.
   */
  function code(length) {
    switch (true) {
      case (length === 3): return [257, length - 3, 0]; break;
      case (length === 4): return [258, length - 4, 0]; break;
      case (length === 5): return [259, length - 5, 0]; break;
      case (length === 6): return [260, length - 6, 0]; break;
      case (length === 7): return [261, length - 7, 0]; break;
      case (length === 8): return [262, length - 8, 0]; break;
      case (length === 9): return [263, length - 9, 0]; break;
      case (length === 10): return [264, length - 10, 0]; break;
      case (length <= 12): return [265, length - 11, 1]; break;
      case (length <= 14): return [266, length - 13, 1]; break;
      case (length <= 16): return [267, length - 15, 1]; break;
      case (length <= 18): return [268, length - 17, 1]; break;
      case (length <= 22): return [269, length - 19, 2]; break;
      case (length <= 26): return [270, length - 23, 2]; break;
      case (length <= 30): return [271, length - 27, 2]; break;
      case (length <= 34): return [272, length - 31, 2]; break;
      case (length <= 42): return [273, length - 35, 3]; break;
      case (length <= 50): return [274, length - 43, 3]; break;
      case (length <= 58): return [275, length - 51, 3]; break;
      case (length <= 66): return [276, length - 59, 3]; break;
      case (length <= 82): return [277, length - 67, 4]; break;
      case (length <= 98): return [278, length - 83, 4]; break;
      case (length <= 114): return [279, length - 99, 4]; break;
      case (length <= 130): return [280, length - 115, 4]; break;
      case (length <= 162): return [281, length - 131, 5]; break;
      case (length <= 194): return [282, length - 163, 5]; break;
      case (length <= 226): return [283, length - 195, 5]; break;
      case (length <= 257): return [284, length - 227, 5]; break;
      case (length === 258): return [285, length - 258, 0]; break;
      default: throw new Error('invalid length: ' + length);
    }
  }

  return table;
})());

/**
 * 距離符号テーブル
 * @param {!number} dist 距離.
 * @return {!Array<number>} コード、拡張ビット、拡張ビット長の配列.
 * @private
 */
Zlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {
  /** @type {!Array<number>} distance code table. */
  var r;

  switch (true) {
    case (dist === 1): r = [0, dist - 1, 0]; break;
    case (dist === 2): r = [1, dist - 2, 0]; break;
    case (dist === 3): r = [2, dist - 3, 0]; break;
    case (dist === 4): r = [3, dist - 4, 0]; break;
    case (dist <= 6): r = [4, dist - 5, 1]; break;
    case (dist <= 8): r = [5, dist - 7, 1]; break;
    case (dist <= 12): r = [6, dist - 9, 2]; break;
    case (dist <= 16): r = [7, dist - 13, 2]; break;
    case (dist <= 24): r = [8, dist - 17, 3]; break;
    case (dist <= 32): r = [9, dist - 25, 3]; break;
    case (dist <= 48): r = [10, dist - 33, 4]; break;
    case (dist <= 64): r = [11, dist - 49, 4]; break;
    case (dist <= 96): r = [12, dist - 65, 5]; break;
    case (dist <= 128): r = [13, dist - 97, 5]; break;
    case (dist <= 192): r = [14, dist - 129, 6]; break;
    case (dist <= 256): r = [15, dist - 193, 6]; break;
    case (dist <= 384): r = [16, dist - 257, 7]; break;
    case (dist <= 512): r = [17, dist - 385, 7]; break;
    case (dist <= 768): r = [18, dist - 513, 8]; break;
    case (dist <= 1024): r = [19, dist - 769, 8]; break;
    case (dist <= 1536): r = [20, dist - 1025, 9]; break;
    case (dist <= 2048): r = [21, dist - 1537, 9]; break;
    case (dist <= 3072): r = [22, dist - 2049, 10]; break;
    case (dist <= 4096): r = [23, dist - 3073, 10]; break;
    case (dist <= 6144): r = [24, dist - 4097, 11]; break;
    case (dist <= 8192): r = [25, dist - 6145, 11]; break;
    case (dist <= 12288): r = [26, dist - 8193, 12]; break;
    case (dist <= 16384): r = [27, dist - 12289, 12]; break;
    case (dist <= 24576): r = [28, dist - 16385, 13]; break;
    case (dist <= 32768): r = [29, dist - 24577, 13]; break;
    default: throw new Error('invalid distance');
  }

  return r;
};

/**
 * マッチ情報を LZ77 符号化配列で返す.
 * なお、ここでは以下の内部仕様で符号化している
 * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
 * @return {!Array<number>} LZ77 符号化 byte array.
 */
Zlib.RawDeflate.Lz77Match.prototype.toLz77Array = function() {
  /** @type {number} */
  var length = this.length;
  /** @type {number} */
  var dist = this.backwardDistance;
  /** @type {Array} */
  var codeArray = [];
  /** @type {number} */
  var pos = 0;
  /** @type {!Array<number>} */
  var code;

  // length
  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];
  codeArray[pos++] = code & 0xffff;
  codeArray[pos++] = (code >> 16) & 0xff;
  codeArray[pos++] = code >> 24;

  // distance
  code = this.getDistanceCode_(dist);
  codeArray[pos++] = code[0];
  codeArray[pos++] = code[1];
  codeArray[pos++] = code[2];

  return codeArray;
};

/**
 * LZ77 実装
 * @param {!(Array<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
 * @return {!(Array<number>|Uint16Array)} LZ77 符号化した配列.
 */
Zlib.RawDeflate.prototype.lz77 = function(dataArray) {
  /** @type {number} input position */
  var position;
  /** @type {number} input length */
  var length;
  /** @type {number} loop counter */
  var i;
  /** @type {number} loop limiter */
  var il;
  /** @type {number} chained-hash-table key */
  var matchKey;
  /** @type {Object.<number, Array<number>>} chained-hash-table */
  var table = {};
  /** @const {number} */
  var windowSize = Zlib.RawDeflate.WindowSize;
  /** @type {Array<number>} match list */
  var matchList;
  /** @type {Zlib.RawDeflate.Lz77Match} longest match */
  var longestMatch;
  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */
  var prevMatch;
  /** @type {!(Array<number>|Uint16Array)} lz77 buffer */
  var lz77buf = Zlib.USE_TYPEDARRAY ?
    new Uint16Array(dataArray.length * 2) : [];
  /** @type {number} lz77 output buffer pointer */
  var pos = 0;
  /** @type {number} lz77 skip length */
  var skipLength = 0;
  /** @type {!(Array<number>|Uint32Array)} */
  var freqsLitLen = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(286);
  /** @type {!(Array<number>|Uint32Array)} */
  var freqsDist = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(30);
  /** @type {number} */
  var lazy = this.lazy;
  /** @type {*} temporary variable */
  var tmp;

  // 初期化
  if (!Zlib.USE_TYPEDARRAY) {
    for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }
    for (i = 0; i <= 29;) { freqsDist[i++] = 0; }
  }
  freqsLitLen[256] = 1; // EOB の最低出現回数は 1

  /**
   * マッチデータの書き込み
   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
   * @param {!number} offset スキップ開始位置(相対指定).
   * @private
   */
  function writeMatch(match, offset) {
    /** @type {Array<number>} */
    var lz77Array = match.toLz77Array();
    /** @type {number} */
    var i;
    /** @type {number} */
    var il;

    for (i = 0, il = lz77Array.length; i < il; ++i) {
      lz77buf[pos++] = lz77Array[i];
    }
    freqsLitLen[lz77Array[0]]++;
    freqsDist[lz77Array[3]]++;
    skipLength = match.length + offset - 1;
    prevMatch = null;
  }

  // LZ77 符号化
  for (position = 0, length = dataArray.length; position < length; ++position) {
    // ハッシュキーの作成
    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {
      if (position + i === length) {
        break;
      }
      matchKey = (matchKey << 8) | dataArray[position + i];
    }

    // テーブルが未定義だったら作成する
    if (table[matchKey] === void 0) { table[matchKey] = []; }
    matchList = table[matchKey];

    // skip
    if (skipLength-- > 0) {
      matchList.push(position);
      continue;
    }

    // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)
    while (matchList.length > 0 && position - matchList[0] > windowSize) {
      matchList.shift();
    }

    // データ末尾でマッチしようがない場合はそのまま流しこむ
    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {
      if (prevMatch) {
        writeMatch(prevMatch, -1);
      }

      for (i = 0, il = length - position; i < il; ++i) {
        tmp = dataArray[position + i];
        lz77buf[pos++] = tmp;
        ++freqsLitLen[tmp];
      }
      break;
    }

    // マッチ候補から最長のものを探す
    if (matchList.length > 0) {
      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

      if (prevMatch) {
        // 現在のマッチの方が前回のマッチよりも長い
        if (/** @type {!Zlib.RawDeflate.Lz77Match} */(prevMatch).length <
            longestMatch.length) {
          // write previous literal
          tmp = dataArray[position - 1];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];

          // write current match
          writeMatch(longestMatch, 0);
        } else {
          // write previous match
          writeMatch(prevMatch, -1);
        }
      } else if (longestMatch.length < lazy) {
        prevMatch = longestMatch;
      } else {
        writeMatch(longestMatch, 0);
      }
    // 前回マッチしていて今回マッチがなかったら前回のを採用
    } else if (prevMatch) {
      writeMatch(prevMatch, -1);
    } else {
      tmp = dataArray[position];
      lz77buf[pos++] = tmp;
      ++freqsLitLen[tmp];
    }

    matchList.push(position); // マッチテーブルに現在の位置を保存
  }

  // 終端処理
  lz77buf[pos++] = 256;
  freqsLitLen[256]++;
  this.freqsLitLen = freqsLitLen;
  this.freqsDist = freqsDist;

  return /** @type {!(Uint16Array|Array<number>)} */ (
    Zlib.USE_TYPEDARRAY ?  lz77buf.subarray(0, pos) : lz77buf
  );
};

/**
 * マッチした候補の中から最長一致を探す
 * @param {!Object} data plain data byte array.
 * @param {!number} position plain data byte array position.
 * @param {!Array<number>} matchList 候補となる位置の配列.
 * @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
 * @private
 */
Zlib.RawDeflate.prototype.searchLongestMatch_ =
function(data, position, matchList) {
  var match,
      currentMatch,
      matchMax = 0, matchLength,
      i, j, l, dl = data.length;

  // 候補を後ろから 1 つずつ絞り込んでゆく
  permatch:
  for (i = 0, l = matchList.length; i < l; i++) {
    match = matchList[l - i - 1];
    matchLength = Zlib.RawDeflate.Lz77MinLength;

    // 前回までの最長一致を末尾から一致検索する
    if (matchMax > Zlib.RawDeflate.Lz77MinLength) {
      for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {
        if (data[match + j - 1] !== data[position + j - 1]) {
          continue permatch;
        }
      }
      matchLength = matchMax;
    }

    // 最長一致探索
    while (matchLength < Zlib.RawDeflate.Lz77MaxLength &&
           position + matchLength < dl &&
           data[match + matchLength] === data[position + matchLength]) {
      ++matchLength;
    }

    // マッチ長が同じ場合は後方を優先
    if (matchLength > matchMax) {
      currentMatch = match;
      matchMax = matchLength;
    }

    // 最長が確定したら後の処理は省略
    if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {
      break;
    }
  }

  return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);
};

/**
 * Tree-Transmit Symbols の算出
 * reference: PuTTY Deflate implementation
 * @param {number} hlit HLIT.
 * @param {!(Array<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
 * @param {number} hdist HDIST.
 * @param {!(Array<number>|Uint8Array)} distLengths 距離符号の符号長配列.
 * @return {{
 *   codes: !(Array<number>|Uint32Array),
 *   freqs: !(Array<number>|Uint32Array)
 * }} Tree-Transmit Symbols.
 * @private
 */
Zlib.RawDeflate.prototype.getTreeSymbols_ =
function(hlit, litlenLengths, hdist, distLengths) {
  var src = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),
      i, j, runLength, l,
      result = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),
      nResult,
      rpt,
      freqs = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(19);

  j = 0;
  for (i = 0; i < hlit; i++) {
    src[j++] = litlenLengths[i];
  }
  for (i = 0; i < hdist; i++) {
    src[j++] = distLengths[i];
  }

  // 初期化
  if (!Zlib.USE_TYPEDARRAY) {
    for (i = 0, l = freqs.length; i < l; ++i) {
      freqs[i] = 0;
    }
  }

  // 符号化
  nResult = 0;
  for (i = 0, l = src.length; i < l; i += j) {
    // Run Length Encoding
    for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}

    runLength = j;

    if (src[i] === 0) {
      // 0 の繰り返しが 3 回未満ならばそのまま
      if (runLength < 3) {
        while (runLength-- > 0) {
          result[nResult++] = 0;
          freqs[0]++;
        }
      } else {
        while (runLength > 0) {
          // 繰り返しは最大 138 までなので切り詰める
          rpt = (runLength < 138 ? runLength : 138);

          if (rpt > runLength - 3 && rpt < runLength) {
            rpt = runLength - 3;
          }

          // 3-10 回 -> 17
          if (rpt <= 10) {
            result[nResult++] = 17;
            result[nResult++] = rpt - 3;
            freqs[17]++;
          // 11-138 回 -> 18
          } else {
            result[nResult++] = 18;
            result[nResult++] = rpt - 11;
            freqs[18]++;
          }

          runLength -= rpt;
        }
      }
    } else {
      result[nResult++] = src[i];
      freqs[src[i]]++;
      runLength--;

      // 繰り返し回数が3回未満ならばランレングス符号は要らない
      if (runLength < 3) {
        while (runLength-- > 0) {
          result[nResult++] = src[i];
          freqs[src[i]]++;
        }
      // 3 回以上ならばランレングス符号化
      } else {
        while (runLength > 0) {
          // runLengthを 3-6 で分割
          rpt = (runLength < 6 ? runLength : 6);

          if (rpt > runLength - 3 && rpt < runLength) {
            rpt = runLength - 3;
          }

          result[nResult++] = 16;
          result[nResult++] = rpt - 3;
          freqs[16]++;

          runLength -= rpt;
        }
      }
    }
  }

  return {
    codes:
      Zlib.USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult),
    freqs: freqs
  };
};

/**
 * ハフマン符号の長さを取得する
 * @param {!(Array<number>|Uint32Array)} freqs 出現カウント.
 * @param {number} limit 符号長の制限.
 * @return {!(Array<number>|Uint8Array)} 符号長配列.
 * @private
 */
Zlib.RawDeflate.prototype.getLengths_ = function(freqs, limit) {
  /** @type {number} */
  var nSymbols = freqs.length;
  /** @type {Zlib.Heap} */
  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);
  /** @type {!(Array<number>|Uint8Array)} */
  var length = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);
  /** @type {Array} */
  var nodes;
  /** @type {!(Array<number>|Uint8Array)} */
  var values;
  /** @type {!(Array<number>|Uint8Array)} */
  var codeLength;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  // 配列の初期化
  if (!Zlib.USE_TYPEDARRAY) {
    for (i = 0; i < nSymbols; i++) {
      length[i] = 0;
    }
  }

  // ヒープの構築
  for (i = 0; i < nSymbols; ++i) {
    if (freqs[i] > 0) {
      heap.push(i, freqs[i]);
    }
  }
  nodes = new Array(heap.length / 2);
  values = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);

  // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了
  if (nodes.length === 1) {
    length[heap.pop().index] = 1;
    return length;
  }

  // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定
  for (i = 0, il = heap.length / 2; i < il; ++i) {
    nodes[i] = heap.pop();
    values[i] = nodes[i].value;
  }
  codeLength = this.reversePackageMerge_(values, values.length, limit);

  for (i = 0, il = nodes.length; i < il; ++i) {
    length[nodes[i].index] = codeLength[i];
  }

  return length;
};

/**
 * Reverse Package Merge Algorithm.
 * @param {!(Array<number>|Uint32Array)} freqs sorted probability.
 * @param {number} symbols number of symbols.
 * @param {number} limit code length limit.
 * @return {!(Array<number>|Uint8Array)} code lengths.
 * @private
 */
Zlib.RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {
  /** @type {!(Array<number>|Uint16Array)} */
  var minimumCost = new (Zlib.USE_TYPEDARRAY ? Uint16Array : Array)(limit);
  /** @type {!(Array<number>|Uint8Array)} */
  var flag = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(limit);
  /** @type {!(Array<number>|Uint8Array)} */
  var codeLength = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(symbols);
  /** @type {Array} */
  var value = new Array(limit);
  /** @type {Array} */
  var type  = new Array(limit);
  /** @type {Array<number>} */
  var currentPosition = new Array(limit);
  /** @type {number} */
  var excess = (1 << limit) - symbols;
  /** @type {number} */
  var half = (1 << (limit - 1));
  /** @type {number} */
  var i;
  /** @type {number} */
  var j;
  /** @type {number} */
  var t;
  /** @type {number} */
  var weight;
  /** @type {number} */
  var next;

  /**
   * @param {number} j
   */
  function takePackage(j) {
    /** @type {number} */
    var x = type[j][currentPosition[j]];

    if (x === symbols) {
      takePackage(j+1);
      takePackage(j+1);
    } else {
      --codeLength[x];
    }

    ++currentPosition[j];
  }

  minimumCost[limit-1] = symbols;

  for (j = 0; j < limit; ++j) {
    if (excess < half) {
      flag[j] = 0;
    } else {
      flag[j] = 1;
      excess -= half;
    }
    excess <<= 1;
    minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;
  }
  minimumCost[0] = flag[0];

  value[0] = new Array(minimumCost[0]);
  type[0]  = new Array(minimumCost[0]);
  for (j = 1; j < limit; ++j) {
    if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {
      minimumCost[j] = 2 * minimumCost[j-1] + flag[j];
    }
    value[j] = new Array(minimumCost[j]);
    type[j]  = new Array(minimumCost[j]);
  }

  for (i = 0; i < symbols; ++i) {
    codeLength[i] = limit;
  }

  for (t = 0; t < minimumCost[limit-1]; ++t) {
    value[limit-1][t] = freqs[t];
    type[limit-1][t]  = t;
  }

  for (i = 0; i < limit; ++i) {
    currentPosition[i] = 0;
  }
  if (flag[limit-1] === 1) {
    --codeLength[0];
    ++currentPosition[limit-1];
  }

  for (j = limit-2; j >= 0; --j) {
    i = 0;
    weight = 0;
    next = currentPosition[j+1];

    for (t = 0; t < minimumCost[j]; t++) {
      weight = value[j+1][next] + value[j+1][next+1];

      if (weight > freqs[i]) {
        value[j][t] = weight;
        type[j][t] = symbols;
        next += 2;
      } else {
        value[j][t] = freqs[i];
        type[j][t] = i;
        ++i;
      }
    }

    currentPosition[j] = 0;
    if (flag[j] === 1) {
      takePackage(j);
    }
  }

  return codeLength;
};

/**
 * 符号長配列からハフマン符号を取得する
 * reference: PuTTY Deflate implementation
 * @param {!(Array<number>|Uint8Array)} lengths 符号長配列.
 * @return {!(Array<number>|Uint16Array)} ハフマン符号配列.
 * @private
 */
Zlib.RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {
  var codes = new (Zlib.USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),
      count = [],
      startCode = [],
      code = 0, i, il, j, m;

  // Count the codes of each length.
  for (i = 0, il = lengths.length; i < il; i++) {
    count[lengths[i]] = (count[lengths[i]] | 0) + 1;
  }

  // Determine the starting code for each length block.
  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {
    startCode[i] = code;
    code += count[i] | 0;
    code <<= 1;
  }

  // Determine the code for each symbol. Mirrored, of course.
  for (i = 0, il = lengths.length; i < il; i++) {
    code = startCode[lengths[i]];
    startCode[lengths[i]] += 1;
    codes[i] = 0;

    for (j = 0, m = lengths[i]; j < m; j++) {
      codes[i] = (codes[i] << 1) | (code & 1);
      code >>>= 1;
    }
  }

  return codes;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/deflate.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Deflate (RFC1951) 実装.
 * Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
 */
goog.provide('Zlib.Deflate');

goog.require('Zlib.Adler32');
goog.require('Zlib.CompressionMethod');
goog.require('Zlib.RawDeflate');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * Zlib Deflate
 * @constructor
 * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
 * @param {Object=} opt_params option parameters.
 */
Zlib.Deflate = function(input, opt_params) {
  /** @type {!(Array|Uint8Array)} */
  this.input = input;
  /** @type {!(Array|Uint8Array)} */
  this.output =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.Deflate.DefaultBufferSize);
  /** @type {Zlib.Deflate.CompressionType} */
  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;
  /** @type {Zlib.RawDeflate} */
  this.rawDeflate;
  /** @type {Object} */
  var rawDeflateOption = {};
  /** @type {string} */
  var prop;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (typeof opt_params['compressionType'] === 'number') {
      this.compressionType = opt_params['compressionType'];
    }
  }

  // copy options
  for (prop in opt_params) {
    rawDeflateOption[prop] = opt_params[prop];
  }

  // set raw-deflate output buffer
  rawDeflateOption['outputBuffer'] = this.output;

  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);
};

/**
 * @const
 * @type {number} デフォルトバッファサイズ.
 */
Zlib.Deflate.DefaultBufferSize = 0x8000;

/**
 * @enum {number}
 */
Zlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;

/**
 * 直接圧縮に掛ける.
 * @param {!(Array|Uint8Array)} input target buffer.
 * @param {Object=} opt_params option parameters.
 * @return {!(Array|Uint8Array)} compressed data byte array.
 */
Zlib.Deflate.compress = function(input, opt_params) {
  return (new Zlib.Deflate(input, opt_params)).compress();
};

/**
 * Deflate Compression.
 * @return {!(Array|Uint8Array)} compressed data byte array.
 */
Zlib.Deflate.prototype.compress = function() {
  /** @type {Zlib.CompressionMethod} */
  var cm;
  /** @type {number} */
  var cinfo;
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;
  /** @type {number} */
  var fcheck;
  /** @type {number} */
  var fdict;
  /** @type {number} */
  var flevel;
  /** @type {number} */
  var clevel;
  /** @type {number} */
  var adler;
  /** @type {boolean} */
  var error = false;
  /** @type {!(Array|Uint8Array)} */
  var output;
  /** @type {number} */
  var pos = 0;

  output = this.output;

  // Compression Method and Flags
  cm = Zlib.CompressionMethod.DEFLATE;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;
      break;
    default:
      throw new Error('invalid compression method');
  }
  cmf = (cinfo << 4) | cm;
  output[pos++] = cmf;

  // Flags
  fdict = 0;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      switch (this.compressionType) {
        case Zlib.Deflate.CompressionType.NONE: flevel = 0; break;
        case Zlib.Deflate.CompressionType.FIXED: flevel = 1; break;
        case Zlib.Deflate.CompressionType.DYNAMIC: flevel = 2; break;
        default: throw new Error('unsupported compression type');
      }
      break;
    default:
      throw new Error('invalid compression method');
  }
  flg = (flevel << 6) | (fdict << 5);
  fcheck = 31 - (cmf * 256 + flg) % 31;
  flg |= fcheck;
  output[pos++] = flg;

  // Adler-32 checksum
  adler = Zlib.Adler32(this.input);

  this.rawDeflate.op = pos;
  output = this.rawDeflate.compress();
  pos = output.length;

  if (Zlib.USE_TYPEDARRAY) {
    // subarray 分を元にもどす
    output = new Uint8Array(output.buffer);
    // expand buffer
    if (output.length <= pos + 4) {
      this.output = new Uint8Array(output.length + 4);
      this.output.set(output);
      output = this.output;
    }
    output = output.subarray(0, pos + 4);
  }

  // adler32
  output[pos++] = (adler >> 24) & 0xff;
  output[pos++] = (adler >> 16) & 0xff;
  output[pos++] = (adler >>  8) & 0xff;
  output[pos++] = (adler      ) & 0xff;

  return output;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/export_object.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.exportObject');

goog.scope(function() {

Zlib.exportObject = function(enumString, exportKeyValue) {
  /** @type {Array.<string>} */
  var keys;
  /** @type {string} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (Object.keys) {
    keys = Object.keys(exportKeyValue);
  } else {
    keys = [];
    i = 0;
    for (key in exportKeyValue) {
      keys[i++] = key;
    }
  }

  for (i = 0, il = keys.length; i < il; ++i) {
    key = keys[i];
    goog.exportSymbol(enumString + '.' + key, exportKeyValue[key])
  }
};

});
//third_party/javascript/zlib_js/gunzip_member.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.GunzipMember');

goog.scope(function() {

/**
 * @constructor
 */
Zlib.GunzipMember = function() {
  /** @type {number} signature first byte. */
  this.id1;
  /** @type {number} signature second byte. */
  this.id2;
  /** @type {number} compression method. */
  this.cm;
  /** @type {number} flags. */
  this.flg;
  /** @type {Date} modification time. */
  this.mtime;
  /** @type {number} extra flags. */
  this.xfl;
  /** @type {number} operating system number. */
  this.os;
  /** @type {number} CRC-16 value for FHCRC flag. */
  this.crc16;
  /** @type {number} extra length. */
  this.xlen;
  /** @type {number} CRC-32 value for verification. */
  this.crc32;
  /** @type {number} input size modulo 32 value. */
  this.isize;
  /** @type {string} filename. */
  this.name;
  /** @type {string} comment. */
  this.comment;
  /** @type {!(Uint8Array|Array.<number>)} */
  this.data;
};

Zlib.GunzipMember.prototype.getName = function() {
  return this.name;
};

Zlib.GunzipMember.prototype.getData = function() {
  return this.data;
};

Zlib.GunzipMember.prototype.getMtime = function() {
  return this.mtime;
}

});
//third_party/javascript/zlib_js/gzip.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview GZIP (RFC1952) 実装.
 */
goog.provide('Zlib.Gzip');

goog.require('Zlib.CRC32');
goog.require('Zlib.RawDeflate');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * @constructor
 * @param {!(Array|Uint8Array)} input input buffer.
 * @param {Object=} opt_params option parameters.
 */
Zlib.Gzip = function(input, opt_params) {
  /** @type {!(Array.<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {!(Array.<number>|Uint8Array)} output buffer. */
  this.output;
  /** @type {number} output buffer. */
  this.op = 0;
  /** @type {!Object} flags option flags. */
  this.flags = {};
  /** @type {!string} filename. */
  this.filename;
  /** @type {!string} comment. */
  this.comment;
  /** @type {!Object} deflate options. */
  this.deflateOptions;

  // option parameters
  if (opt_params) {
    if (opt_params['flags']) {
      this.flags = opt_params['flags'];
    }
    if (typeof opt_params['filename'] === 'string') {
      this.filename = opt_params['filename'];
    }
    if (typeof opt_params['comment'] === 'string') {
      this.comment = opt_params['comment'];
    }
    if (opt_params['deflateOptions']) {
      this.deflateOptions = opt_params['deflateOptions'];
    }
  }

  if (!this.deflateOptions) {
    this.deflateOptions = {};
  }
};

/**
 * @type {number}
 * @const
 */
Zlib.Gzip.DefaultBufferSize = 0x8000;

/**
 * encode gzip members.
 * @return {!(Array|Uint8Array)} gzip binary array.
 */
Zlib.Gzip.prototype.compress = function() {
  /** @type {number} flags. */
  var flg;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} CRC-16 value for FHCRC flag. */
  var crc16;
  /** @type {number} CRC-32 value for verification. */
  var crc32;
  /** @type {!Zlib.RawDeflate} raw deflate object. */
  var rawdeflate;
  /** @type {number} character code */
  var c;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {!(Array|Uint8Array)} output buffer. */
  var output =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.Gzip.DefaultBufferSize);
  /** @type {number} output buffer pointer. */
  var op = 0;

  var input = this.input;
  var ip = this.ip;
  var filename = this.filename;
  var comment = this.comment;

  // check signature
  output[op++] = 0x1f;
  output[op++] = 0x8b;

  // check compression method
  output[op++] = 8; /* XXX: use Zlib const */

  // flags
  flg = 0;
  if (this.flags['fname'])    flg |= Zlib.Gzip.FlagsMask.FNAME;
  if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;
  if (this.flags['fhcrc'])    flg |= Zlib.Gzip.FlagsMask.FHCRC;
  // XXX: FTEXT
  // XXX: FEXTRA
  output[op++] = flg;

  // modification time
  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
  output[op++] = mtime        & 0xff;
  output[op++] = mtime >>>  8 & 0xff;
  output[op++] = mtime >>> 16 & 0xff;
  output[op++] = mtime >>> 24 & 0xff;

  // extra flags
  output[op++] = 0;

  // operating system
  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;

  // extra
  /* NOP */

  // fname
  if (this.flags['fname'] !== void 0) {
    for (i = 0, il = filename.length; i < il; ++i) {
      c = filename.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fcomment
  if (this.flags['comment']) {
    for (i = 0, il = comment.length; i < il; ++i) {
      c = comment.charCodeAt(i);
      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }
      output[op++] = c & 0xff;
    }
    output[op++] = 0; // null termination
  }

  // fhcrc
  if (this.flags['fhcrc']) {
    crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;
    output[op++] = (crc16      ) & 0xff;
    output[op++] = (crc16 >>> 8) & 0xff;
  }

  // add compress option
  this.deflateOptions['outputBuffer'] = output;
  this.deflateOptions['outputIndex'] = op;

  // compress
  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);
  output = rawdeflate.compress();
  op = rawdeflate.op;

  // expand buffer
  if (Zlib.USE_TYPEDARRAY) {
    if (op + 8 > output.buffer.byteLength) {
      this.output = new Uint8Array(op + 8);
      this.output.set(new Uint8Array(output.buffer));
      output = this.output;
    } else {
      output = new Uint8Array(output.buffer);
    }
  }

  // crc32
  crc32 = Zlib.CRC32.calc(input);
  output[op++] = (crc32       ) & 0xff;
  output[op++] = (crc32 >>>  8) & 0xff;
  output[op++] = (crc32 >>> 16) & 0xff;
  output[op++] = (crc32 >>> 24) & 0xff;

  // input size
  il = input.length;
  output[op++] = (il       ) & 0xff;
  output[op++] = (il >>>  8) & 0xff;
  output[op++] = (il >>> 16) & 0xff;
  output[op++] = (il >>> 24) & 0xff;

  this.ip = ip;

  if (Zlib.USE_TYPEDARRAY && op < output.length) {
    this.output = output = output.subarray(0, op);
  }

  return output;
};

/** @enum {number} */
Zlib.Gzip.OperatingSystem = {
  FAT: 0,
  AMIGA: 1,
  VMS: 2,
  UNIX: 3,
  VM_CMS: 4,
  ATARI_TOS: 5,
  HPFS: 6,
  MACINTOSH: 7,
  Z_SYSTEM: 8,
  CP_M: 9,
  TOPS_20: 10,
  NTFS: 11,
  QDOS: 12,
  ACORN_RISCOS: 13,
  UNKNOWN: 255
};

/** @enum {number} */
Zlib.Gzip.FlagsMask = {
  FTEXT: 0x01,
  FHCRC: 0x02,
  FEXTRA: 0x04,
  FNAME: 0x08,
  FCOMMENT: 0x10
};

});
/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/huffman.js
/**
 * @license
 *
 * JavaScript Inflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2012 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
goog.provide('Zlib.Huffman');

goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * build huffman table from length list.
 * @param {!(Array<number>|Uint8Array)} lengths length list.
 * @return {!Array} huffman table.
 */
Zlib.Huffman.buildHuffmanTable = function(lengths) {
  /** @type {number} length list size. */
  var listSize = lengths.length;
  /** @type {number} max code length for table size. */
  var maxCodeLength = 0;
  /** @type {number} min code length for table size. */
  var minCodeLength = Number.POSITIVE_INFINITY;
  /** @type {number} table size. */
  var size;
  /** @type {!(Array|Uint8Array)} huffman code table. */
  var table;
  /** @type {number} bit length. */
  var bitLength;
  /** @type {number} huffman code. */
  var code;
  /**
   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
   * @type {number} skip length for table filling.
   */
  var skip;
  /** @type {number} reversed code. */
  var reversed;
  /** @type {number} reverse temp. */
  var rtemp;
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limit. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} table value. */
  var value;

  // Math.max は遅いので最長の値は for-loop で取得する
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }

  size = 1 << maxCodeLength;
  table = new (Zlib.USE_TYPEDARRAY ? Uint32Array : Array)(size);

  // ビット長の短い順からハフマン符号を割り当てる
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        // ビットオーダーが逆になるためビット長分並びを反転する
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = (reversed << 1) | (rtemp & 1);
          rtemp >>= 1;
        }

        // 最大ビット長をもとにテーブルを作るため、
        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
        // そのどちらでも良い場所は同じ値で埋めることで
        // 本来のビット長以上のビット数取得しても問題が起こらないようにする
        value = (bitLength << 16) | i;
        for (j = reversed; j < size; j += skip) {
          table[j] = value;
        }

        ++code;
      }
    }

    // 次のビット長へ
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }

  return [table, maxCodeLength, minCodeLength];
};


// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/rawinflate.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.RawInflate');

goog.require('Zlib.Huffman');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

//-----------------------------------------------------------------------------

/** @define {number} buffer block size. */
var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]

//-----------------------------------------------------------------------------

var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
 * @constructor
 * @param {!(Uint8Array|Array<number>)} input input buffer.
 * @param {Object} opt_params option parameter.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
 *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
 */
Zlib.RawInflate = function(input, opt_params) {
  /** @type {!(Array<number>|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array<(Array<number>|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = 0;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array<number>|Uint8Array)} input buffer. */
  this.input = Zlib.USE_TYPEDARRAY ? new Uint8Array(input) : input;
  /** @type {!(Uint8Array|Array<number>)} output buffer. */
  this.output;
  /** @type {!number} output buffer pointer. */
  this.op;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {Zlib.RawInflate.BufferType} buffer management. */
  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;
  /** @type {Array} */
  this.currentLitlenTable;
  /** @type {number} previous RLE value */
  this.prev;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['bufferSize']) {
      this.bufferSize = opt_params['bufferSize'];
    }
    if (opt_params['bufferType']) {
      this.bufferType = opt_params['bufferType'];
    }
    if (opt_params['resize']) {
      this.resize = opt_params['resize'];
    }
  }

  // initialize
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      this.op = Zlib.RawInflate.MaxBackwardLength;
      this.output =
        new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(
          Zlib.RawInflate.MaxBackwardLength +
          this.bufferSize +
          Zlib.RawInflate.MaxCopyLength
        );
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
      this.expandBuffer = this.expandBufferAdaptive;
      this.concatBuffer = this.concatBufferDynamic;
      this.decodeHuffman = this.decodeHuffmanAdaptive;
      break;
    default:
      throw new Error('invalid inflate mode');
  }
};

/**
 * @enum {number}
 */
Zlib.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};

/**
 * decompress.
 * @return {!(Uint8Array|Array<number>)} inflated buffer.
 */
Zlib.RawInflate.prototype.decompress = function() {
  while (!this.bfinal) {
    this.parseBlock();
  }

  return this.concatBuffer();
};

/**
 * @const
 * @type {number} max backward length for LZ77.
 */
Zlib.RawInflate.MaxBackwardLength = 32768;

/**
 * @const
 * @type {number} max copy length for LZ77.
 */
Zlib.RawInflate.MaxCopyLength = 258;

/**
 * huffman order
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflate.Order = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
 * huffman length code table.
 * @const
 * @type {!(Array<number>|Uint16Array)}
 */
Zlib.RawInflate.LengthCodeTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
 * huffman length extra-bits table.
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflate.LengthExtraTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
 * huffman dist code table.
 * @const
 * @type {!(Array<number>|Uint16Array)}
 */
Zlib.RawInflate.DistCodeTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
 * huffman dist extra-bits table.
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflate.DistExtraTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
 * fixed huffman length code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedLiteralLengthTable = (function(table) {
  return table;
})((function() {
  var lengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
      (i <= 255) ? 9 :
      (i <= 279) ? 7 :
      8;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * fixed huffman distance code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflate.FixedDistanceTable = (function(table) {
  return table;
})((function() {
  var lengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * parse deflated block.
 */
Zlib.RawInflate.prototype.parseBlock = function() {
  /** @type {number} header */
  var hdr = this.readBits(3);

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error('unknown BTYPE: ' + hdr);
  }
};

/**
 * read inflate bits
 * @param {number} length bits length.
 * @return {number} read bits.
 */
Zlib.RawInflate.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    if (ip >= inputLength) {
      throw new Error('input buffer is broken');
    }

    // concat octet
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
 * read huffman code using table
 * @param {Array} table huffman code table.
 * @return {number} huffman code.
 */
Zlib.RawInflate.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {!(Array<number>|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (ip >= inputLength) {
      break;
    }
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
 * parse uncompressed block.
 */
Zlib.RawInflate.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;

  /** @type {number} */
  var inputLength = input.length;
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;
  /** @type {number} output buffer length */
  var olength = output.length;
  /** @type {number} copy counter */
  var preCopy;

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  // len
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: LEN');
  }
  len = input[ip++] | (input[ip++] << 8);

  // nlen
  if (ip + 1 >= inputLength) {
    throw new Error('invalid uncompressed block header: NLEN');
  }
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // check size
  if (ip + len > input.length) { throw new Error('input buffer is broken'); }

  // expand buffer
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      // pre copy
      while (op + len > output.length) {
        preCopy = olength - op;
        len -= preCopy;
        if (Zlib.USE_TYPEDARRAY) {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        } else {
          while (preCopy--) {
            output[op++] = input[ip++];
          }
        }
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      while (op + len > output.length) {
        output = this.expandBuffer({fixRatio: 2});
      }
      break;
    default:
      throw new Error('invalid inflate mode');
  }

  // copy
  if (Zlib.USE_TYPEDARRAY) {
    output.set(input.subarray(ip, ip + len), op);
    op += len;
    ip += len;
  } else {
    while (len--) {
      output[op++] = input[ip++];
    }
  }

  this.ip = ip;
  this.op = op;
  this.output = output;
};

/**
 * parse fixed huffman block.
 */
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {
  this.decodeHuffman(
    Zlib.RawInflate.FixedLiteralLengthTable,
    Zlib.RawInflate.FixedDistanceTable
  );
};

/**
 * parse dynamic huffman block.
 */
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {
  /** @type {number} number of literal and length codes. */
  var hlit = this.readBits(5) + 257;
  /** @type {number} number of distance codes. */
  var hdist = this.readBits(5) + 1;
  /** @type {number} number of code lengths. */
  var hclen = this.readBits(4) + 4;
  /** @type {!(Uint8Array|Array<number>)} code lengths. */
  var codeLengths =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint8Array|Array<number>)} literal and length code lengths. */
  var litlenLengths;
  /** @type {!(Uint8Array|Array<number>)} distance code lengths. */
  var distLengths;
  /** @type {number} loop counter. */
  var i;

  // decode code lengths
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
  }
  if (!Zlib.USE_TYPEDARRAY) {
    for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {
      codeLengths[Zlib.RawInflate.Order[i]] = 0;
    }
  }
  codeLengthsTable = buildHuffmanTable(codeLengths);

  /**
   * decode function
   * @param {number} num number of lengths.
   * @param {!Array} table code lengths table.
   * @param {!(Uint8Array|Array<number>)} lengths code lengths buffer.
   * @return {!(Uint8Array|Array<number>)} code lengths buffer.
   * @this {!Zlib.RawInflate}
   */
  function decode(num, table, lengths) {
    /** @type {number} */
    var code;
    /** @type {number} */
    var prev = this.prev;
    /** @type {number} */
    var repeat;
    /** @type {number} */
    var i;

    for (i = 0; i < num;) {
      code = this.readCodeByTable(table);
      switch (code) {
        case 16:
          repeat = 3 + this.readBits(2);
          while (repeat--) { lengths[i++] = prev; }
          break;
        case 17:
          repeat = 3 + this.readBits(3);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        case 18:
          repeat = 11 + this.readBits(7);
          while (repeat--) { lengths[i++] = 0; }
          prev = 0;
          break;
        default:
          lengths[i++] = code;
          prev = code;
          break;
      }
    }

    this.prev = prev;

    return lengths;
  }

  // literal and length code
  litlenLengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(hlit);

  // distance code
  distLengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(hdist);

  this.prev = 0;
  this.decodeHuffman(
    buildHuffmanTable(decode.call(this, hlit, codeLengthsTable, litlenLengths)),
    buildHuffmanTable(decode.call(this, hdist, codeLengthsTable, distLengths))
  );
};

/**
 * decode huffman code
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffman = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length - Zlib.RawInflate.MaxCopyLength;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBuffer();
        op = this.op;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op >= olength) {
      this.op = op;
      output = this.expandBuffer();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * decode huffman code (adaptive)
 * @param {!Array} litlen literal and length code table.
 * @param {!Array} dist distination code table.
 */
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {
  var output = this.output;
  var op = this.op;

  this.currentLitlenTable = litlen;

  /** @type {number} output position limit. */
  var olength = output.length;
  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  while ((code = this.readCodeByTable(litlen)) !== 256) {
    // literal
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflate.LengthCodeTable[ti];
    if (Zlib.RawInflate.LengthExtraTable[ti] > 0) {
      codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti]);
    }

    // dist code
    code = this.readCodeByTable(dist);
    codeDist = Zlib.RawInflate.DistCodeTable[code];
    if (Zlib.RawInflate.DistExtraTable[code] > 0) {
      codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code]);
    }

    // lz77 decode
    if (op + codeLength > olength) {
      output = this.expandBuffer();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};

/**
 * expand output buffer.
 * @param {Object=} opt_param option parameters.
 * @return {!(Array<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.expandBuffer = function(opt_param) {
  /** @type {!(Array<number>|Uint8Array)} store buffer. */
  var buffer =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(
        this.op - Zlib.RawInflate.MaxBackwardLength
    );
  /** @type {number} backward base point */
  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
  /** @type {number} copy index. */
  var i;
  /** @type {number} copy limit */
  var il;

  var output = this.output;

  // copy to output buffer
  if (Zlib.USE_TYPEDARRAY) {
    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
  } else {
    for (i = 0, il = buffer.length; i < il; ++i) {
      buffer[i] = output[i + Zlib.RawInflate.MaxBackwardLength];
    }
  }

  this.blocks.push(buffer);
  this.totalpos += buffer.length;

  // copy to backward buffer
  if (Zlib.USE_TYPEDARRAY) {
    output.set(
      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)
    );
  } else {
    for (i = 0; i < Zlib.RawInflate.MaxBackwardLength; ++i) {
      output[i] = output[backward + i];
    }
  }

  this.op = Zlib.RawInflate.MaxBackwardLength;

  return output;
};

/**
 * expand output buffer. (adaptive)
 * @param {Object=} opt_param option parameters.
 * @return {!(Array<number>|Uint8Array)} output buffer pointer.
 */
Zlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {
  /** @type {!(Array<number>|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  if (Zlib.USE_TYPEDARRAY) {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  } else {
    buffer = output;
  }

  this.output = buffer;

  return this.output;
};

/**
 * concat output buffer.
 * @return {!(Array<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBuffer = function() {
  /** @type {number} buffer pointer. */
  var pos = 0;
  /** @type {number} buffer pointer. */
  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
  /** @type {!(Array<number>|Uint8Array)} output block array. */
  var output = this.output;
  /** @type {!Array} blocks array. */
  var blocks = this.blocks;
  /** @type {!(Array<number>|Uint8Array)} output block array. */
  var block;
  /** @type {!(Array<number>|Uint8Array)} output buffer. */
  var buffer = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(limit);
  /** @type {number} loop counter. */
  var i;
  /** @type {number} loop limiter. */
  var il;
  /** @type {number} loop counter. */
  var j;
  /** @type {number} loop limiter. */
  var jl;

  // single buffer
  if (blocks.length === 0) {
    return Zlib.USE_TYPEDARRAY ?
      this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) :
      this.output.slice(Zlib.RawInflate.MaxBackwardLength, this.op);
  }

  // copy to buffer
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }

  // current buffer
  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }

  this.blocks = [];
  this.buffer = buffer;

  return this.buffer;
};

/**
 * concat output buffer. (dynamic)
 * @return {!(Array<number>|Uint8Array)} output buffer.
 */
Zlib.RawInflate.prototype.concatBufferDynamic = function() {
  /** @type {Array<number>|Uint8Array} output buffer. */
  var buffer;
  var op = this.op;

  if (Zlib.USE_TYPEDARRAY) {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  } else {
    if (this.output.length > op) {
      this.output.length = op;
    }
    buffer = this.output;
  }

  this.buffer = buffer;

  return this.buffer;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/gunzip.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview GZIP (RFC1952) 展開コンテナ実装.
 */
goog.provide('Zlib.Gunzip');

goog.require('Zlib.CRC32');
goog.require('Zlib.Gzip');
goog.require('Zlib.RawInflate');
goog.require('Zlib.GunzipMember');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * @constructor
 * @param {!(Array|Uint8Array)} input input buffer.
 * @param {Object=} opt_params option parameters.
 */
Zlib.Gunzip = function(input, opt_params) {
  /** @type {!(Array<number>|Uint8Array)} input buffer. */
  this.input = input;
  /** @type {number} input buffer pointer. */
  this.ip = 0;
  /** @type {Array<Zlib.GunzipMember>} */
  this.member = [];
  /** @type {boolean} */
  this.decompressed = false;
};

/**
 * @return {Array<Zlib.GunzipMember>}
 */
Zlib.Gunzip.prototype.getMembers = function() {
  if (!this.decompressed) {
    this.decompress();
  }

  return this.member.slice();
};

/**
 * inflate gzip data.
 * @return {!(Array<number>|Uint8Array)} inflated buffer.
 */
Zlib.Gunzip.prototype.decompress = function() {
  /** @type {number} input length. */
  var il = this.input.length;

  while (this.ip < il) {
    this.decodeMember();
  }

  this.decompressed = true;

  return this.concatMember();
};

/**
 * decode gzip member.
 */
Zlib.Gunzip.prototype.decodeMember = function() {
  /** @type {Zlib.GunzipMember} */
  var member = new Zlib.GunzipMember();
  /** @type {number} */
  var isize;
  /** @type {Zlib.RawInflate} RawInflate implementation. */
  var rawinflate;
  /** @type {!(Array<number>|Uint8Array)} inflated data. */
  var inflated;
  /** @type {number} inflate size */
  var inflen;
  /** @type {number} character code */
  var c;
  /** @type {number} character index in string. */
  var ci;
  /** @type {Array<string>} character array. */
  var str;
  /** @type {number} modification time. */
  var mtime;
  /** @type {number} */
  var crc32;

  var input = this.input;
  var ip = this.ip;

  member.id1 = input[ip++];
  member.id2 = input[ip++];

  // check signature
  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
  }

  // check compression method
  member.cm = input[ip++];
  switch (member.cm) {
    case 8: /* XXX: use Zlib const */
      break;
    default:
      throw new Error('unknown compression method: ' + member.cm);
  }

  // flags
  member.flg = input[ip++];

  // modification time
  mtime = (input[ip++])       |
          (input[ip++] << 8)  |
          (input[ip++] << 16) |
          (input[ip++] << 24);
  member.mtime = new Date(mtime * 1000);

  // extra flags
  member.xfl = input[ip++];

  // operating system
  member.os = input[ip++];

  // extra
  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {
    member.xlen = input[ip++] | (input[ip++] << 8);
    ip = this.decodeSubField(ip, member.xlen);
  }

  // fname
  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {
    for(str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.name = str.join('');
  }

  // fcomment
  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {
    for(str = [], ci = 0; (c = input[ip++]) > 0;) {
      str[ci++] = String.fromCharCode(c);
    }
    member.comment = str.join('');
  }

  // fhcrc
  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {
    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;
    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {
      throw new Error('invalid header crc16');
    }
  }

  // isize を事前に取得すると展開後のサイズが分かるため、
  // inflate処理のバッファサイズが事前に分かり、高速になる
  isize = (input[input.length - 4])       | (input[input.length - 3] << 8) |
          (input[input.length - 2] << 16) | (input[input.length - 1] << 24);

  // isize の妥当性チェック
  // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
  // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
  // 1/128 になるとする
  // ここから入力バッファの残りが isize の 512 倍以上だったら
  // サイズ指定のバッファ確保は行わない事とする
  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {
    inflen = isize;
  }

  // compressed block
  rawinflate = new Zlib.RawInflate(input, {'index': ip, 'bufferSize': inflen});
  member.data = inflated = rawinflate.decompress();
  ip = rawinflate.ip;

  // crc32
  member.crc32 = crc32 =
    ((input[ip++])       | (input[ip++] << 8) |
     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if (Zlib.CRC32.calc(inflated) !== crc32) {
    throw new Error('invalid CRC-32 checksum: 0x' +
        Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
  }

  // input size
  member.isize = isize =
    ((input[ip++])       | (input[ip++] << 8) |
     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;
  if ((inflated.length & 0xffffffff) !== isize) {
    throw new Error('invalid input size: ' +
        (inflated.length & 0xffffffff) + ' / ' + isize);
  }

  this.member.push(member);
  this.ip = ip;
};

/**
 * サブフィールドのデコード
 * XXX: 現在は何もせずスキップする
 */
Zlib.Gunzip.prototype.decodeSubField = function(ip, length) {
  return ip + length;
};

/**
 * @return {!(Array<number>|Uint8Array)}
 */
Zlib.Gunzip.prototype.concatMember = function() {
  /** @type {Array<Zlib.GunzipMember>} */
  var member = this.member;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var p = 0;
  /** @type {number} */
  var size = 0;
  /** @type {!(Array<number>|Uint8Array)} */
  var buffer;

  for (i = 0, il = member.length; i < il; ++i) {
    size += member[i].data.length;
  }

  if (Zlib.USE_TYPEDARRAY) {
    buffer = new Uint8Array(size);
    for (i = 0; i < il; ++i) {
      buffer.set(member[i].data, p);
      p += member[i].data.length;
    }
  } else {
    buffer = [];
    for (i = 0; i < il; ++i) {
      buffer[i] = member[i].data;
    }
    buffer = Array.prototype.concat.apply([], buffer);
  }

  return buffer;
};

});
/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/inflate.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.Inflate');

goog.require('Zlib.Adler32');
goog.require('Zlib.CompressionMethod');
goog.require('Zlib.RawInflate');

goog.scope(function() {

/**
 * @constructor
 * @param {!(Uint8Array|Array)} input deflated buffer.
 * @param {Object=} opt_params option parameters.
 *
 * opt_params は以下のプロパティを指定する事ができます。
 *   - index: input buffer の deflate コンテナの開始位置.
 *   - blockSize: バッファのブロックサイズ.
 *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
 *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
 *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
 */
Zlib.Inflate = function(input, opt_params) {
  /** @type {number} */
  var cmf;
  /** @type {number} */
  var flg;

  /** @type {!(Uint8Array|Array)} */
  this.input = input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflate} */
  this.rawinflate;
  /** @type {(boolean|undefined)} verify flag. */
  this.verify;

  // option parameters
  if (opt_params || !(opt_params = {})) {
    if (opt_params['index']) {
      this.ip = opt_params['index'];
    }
    if (opt_params['verify']) {
      this.verify = opt_params['verify'];
    }
  }

  // Compression Method and Flags
  cmf = input[this.ip++];
  flg = input[this.ip++];

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  // RawInflate
  this.rawinflate = new Zlib.RawInflate(input, {
    'index': this.ip,
    'bufferSize': opt_params['bufferSize'],
    'bufferType': opt_params['bufferType'],
    'resize': opt_params['resize']
  });
};

/**
 * @enum {number}
 */
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;

/**
 * decompress.
 * @return {!(Uint8Array|Array)} inflated buffer.
 */
Zlib.Inflate.prototype.decompress = function() {
  /** @type {!(Array|Uint8Array)} input buffer. */
  var input = this.input;
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;

  // verify adler-32
  if (this.verify) {
    adler32 = (
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++]
    ) >>> 0;

    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }

  return buffer;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/rawinflate_stream.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.RawInflateStream');

goog.require('Zlib.Huffman');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

//-----------------------------------------------------------------------------

/** @define {number} buffer block size. */
var ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 0x8000;

//-----------------------------------------------------------------------------

var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;

/**
 * @param {!(Uint8Array|Array<number>)} input input buffer.
 * @param {number} ip input buffer pointer.
 * @param {number=} opt_buffersize buffer block size.
 * @constructor
 */
Zlib.RawInflateStream = function(input, ip, opt_buffersize) {
  /** @type {!(Array|Uint8Array)} inflated buffer */
  this.buffer;
  /** @type {!Array<(Array|Uint8Array)>} */
  this.blocks = [];
  /** @type {number} block size. */
  this.bufferSize =
    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;
  /** @type {!number} total output buffer pointer. */
  this.totalpos = 0;
  /** @type {!number} input buffer pointer. */
  this.ip = ip === void 0 ? 0 : ip;
  /** @type {!number} bit stream reader buffer. */
  this.bitsbuf = 0;
  /** @type {!number} bit stream reader buffer size. */
  this.bitsbuflen = 0;
  /** @type {!(Array|Uint8Array)} input buffer. */
  this.input = Zlib.USE_TYPEDARRAY ? new Uint8Array(input) : input;
  /** @type {!(Uint8Array|Array)} output buffer. */
  this.output = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
  /** @type {!number} output buffer pointer. */
  this.op = 0;
  /** @type {boolean} is final block flag. */
  this.bfinal = false;
  /** @type {number} uncompressed block length. */
  this.blockLength;
  /** @type {boolean} resize flag for memory size optimization. */
  this.resize = false;
  /** @type {Array} */
  this.litlenTable;
  /** @type {Array} */
  this.distTable;
  /** @type {number} */
  this.sp = 0; // stream pointer
  /** @type {Zlib.RawInflateStream.Status} */
  this.status = Zlib.RawInflateStream.Status.INITIALIZED;
  /** @type {Zlib.RawInflateStream.BlockType} */
  this.currentBlockType;
  /** @type {number} previous RLE value */
  this.prev;

  //
  // backup
  //
  /** @type {!number} */
  this.ip_;
  /** @type {!number} */
  this.bitsbuflen_;
  /** @type {!number} */
  this.bitsbuf_;
};

/**
 * @enum {number}
 */
Zlib.RawInflateStream.BlockType = {
  UNCOMPRESSED: 0,
  FIXED: 1,
  DYNAMIC: 2
};

/**
 * @enum {number}
 */
Zlib.RawInflateStream.Status = {
  INITIALIZED: 0,
  BLOCK_HEADER_START: 1,
  BLOCK_HEADER_END: 2,
  BLOCK_BODY_START: 3,
  BLOCK_BODY_END: 4,
  DECODE_BLOCK_START: 5,
  DECODE_BLOCK_END: 6
};

/**
 * decompress.
 * @return {!(Uint8Array|Array)} inflated buffer.
 */
Zlib.RawInflateStream.prototype.decompress = function(newInput, ip) {
  /** @type {boolean} */
  var stop = false;

  if (newInput !== void 0) {
    this.input = newInput;
  }

  if (ip !== void 0) {
    this.ip = ip;
  }

  // decompress
  while (!stop) {
    switch (this.status) {
      // block header
      case Zlib.RawInflateStream.Status.INITIALIZED:
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:
        if (this.readBlockHeader() < 0) {
          stop = true;
        }
        break;
      // block body
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */
      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:
        switch(this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.readUncompressedBlockHeader() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED:
            if (this.parseFixedHuffmanBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.parseDynamicHuffmanBlock() < 0) {
              stop = true;
            }
            break;
        }
        break;
      // decode data
      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:
        switch(this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.parseUncompressedBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.decodeHuffman() < 0) {
              stop = true;
            }
            break;
        }
        break;
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:
        if (this.bfinal) {
          stop = true;
        } else {
          this.status = Zlib.RawInflateStream.Status.INITIALIZED;
        }
        break;
    }
  }

  return this.concatBuffer();
};

/**
 * @const
 * @type {number} max backward length for LZ77.
 */
Zlib.RawInflateStream.MaxBackwardLength = 32768;

/**
 * @const
 * @type {number} max copy length for LZ77.
 */
Zlib.RawInflateStream.MaxCopyLength = 258;

/**
 * huffman order
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflateStream.Order = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/**
 * huffman length code table.
 * @const
 * @type {!(Array<number>|Uint16Array)}
 */
Zlib.RawInflateStream.LengthCodeTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,
  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,
  0x00e3, 0x0102, 0x0102, 0x0102
]);

/**
 * huffman length extra-bits table.
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflateStream.LengthExtraTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0
]);

/**
 * huffman dist code table.
 * @const
 * @type {!(Array<number>|Uint16Array)}
 */
Zlib.RawInflateStream.DistCodeTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint16Array(table) : table;
})([
  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,
  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,
  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,
  0x3001, 0x4001, 0x6001
]);

/**
 * huffman dist extra-bits table.
 * @const
 * @type {!(Array<number>|Uint8Array)}
 */
Zlib.RawInflateStream.DistExtraTable = (function(table) {
  return Zlib.USE_TYPEDARRAY ? new Uint8Array(table) : table;
})([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13
]);

/**
 * fixed huffman length code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflateStream.FixedLiteralLengthTable = (function(table) {
  return table;
})((function() {
  var lengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(288);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] =
      (i <= 143) ? 8 :
      (i <= 255) ? 9 :
      (i <= 279) ? 7 :
      8;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * fixed huffman distance code table
 * @const
 * @type {!Array}
 */
Zlib.RawInflateStream.FixedDistanceTable = (function(table) {
  return table;
})((function() {
  var lengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(30);
  var i, il;

  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }

  return buildHuffmanTable(lengths);
})());

/**
 * parse deflated block.
 */
Zlib.RawInflateStream.prototype.readBlockHeader = function() {
  /** @type {number} header */
  var hdr;

  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;

  this.save_();
  if ((hdr = this.readBits(3)) < 0) {
    this.restore_();
    return -1;
  }

  // BFINAL
  if (hdr & 0x1) {
    this.bfinal = true;
  }

  // BTYPE
  hdr >>>= 1;
  switch (hdr) {
    case 0: // uncompressed
      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;
      break;
    case 1: // fixed huffman
      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;
      break;
    case 2: // dynamic huffman
      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;
      break;
    default: // reserved or other
      throw new Error('unknown BTYPE: ' + hdr);
  }

  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;
};

/**
 * read inflate bits
 * @param {number} length bits length.
 * @return {number} read bits.
 */
Zlib.RawInflateStream.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {number} input and output byte. */
  var octet;

  // not enough buffer
  while (bitsbuflen < length) {
    // input byte
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];

    // concat octet
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // output byte
  octet = bitsbuf & /* MASK */ ((1 << length) - 1);
  bitsbuf >>>= length;
  bitsbuflen -= length;

  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;

  return octet;
};

/**
 * read huffman code using table
 * @param {Array} table huffman code table.
 * @return {number} huffman code.
 */
Zlib.RawInflateStream.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;

  /** @type {!(Array|Uint8Array)} huffman code table */
  var codeTable = table[0];
  /** @type {number} */
  var maxCodeLength = table[1];
  /** @type {number} input byte */
  var octet;
  /** @type {number} code length & code (16bit, 16bit) */
  var codeWithLength;
  /** @type {number} code bits length */
  var codeLength;

  // not enough buffer
  while (bitsbuflen < maxCodeLength) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }

  // read max length
  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];
  codeLength = codeWithLength >>> 16;

  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;

  return codeWithLength & 0xffff;
};

/**
 * read uncompressed block header
 */
Zlib.RawInflateStream.prototype.readUncompressedBlockHeader = function() {
  /** @type {number} block length */
  var len;
  /** @type {number} number for check block length */
  var nlen;

  var input = this.input;
  var ip = this.ip;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  if (ip + 4 >= input.length) {
    return -1;
  }

  len = input[ip++] | (input[ip++] << 8);
  nlen = input[ip++] | (input[ip++] << 8);

  // check len & nlen
  if (len === ~nlen) {
    throw new Error('invalid uncompressed block header: length verify');
  }

  // skip buffered header bits
  this.bitsbuf = 0;
  this.bitsbuflen = 0;

  this.ip = ip;
  this.blockLength = len;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
}

/**
 * parse uncompressed block.
 */
Zlib.RawInflateStream.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var len = this.blockLength;

  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;

  // copy
  // XXX: とりあえず素直にコピー
  while (len--) {
    if (op === output.length) {
      output = this.expandBuffer({fixRatio: 2});
    }

    // not enough input buffer
    if (ip >= input.length) {
      this.ip = ip;
      this.op = op;
      this.blockLength = len + 1; // コピーしてないので戻す
      return -1;
    }

    output[op++] = input[ip++];
  }

  if (len < 0) {
    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
  }

  this.ip = ip;
  this.op = op;

  return 0;
};

/**
 * parse fixed huffman block.
 */
Zlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function() {
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;
  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
 * オブジェクトのコンテキストを別のプロパティに退避する.
 * @private
 */
Zlib.RawInflateStream.prototype.save_ = function() {
  this.ip_ = this.ip;
  this.bitsbuflen_ = this.bitsbuflen;
  this.bitsbuf_ = this.bitsbuf;
};

/**
 * 別のプロパティに退避したコンテキストを復元する.
 * @private
 */
Zlib.RawInflateStream.prototype.restore_ = function() {
  this.ip = this.ip_;
  this.bitsbuflen = this.bitsbuflen_;
  this.bitsbuf = this.bitsbuf_;
};

/**
 * parse dynamic huffman block.
 */
Zlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {
  /** @type {number} number of literal and length codes. */
  var hlit;
  /** @type {number} number of distance codes. */
  var hdist;
  /** @type {number} number of code lengths. */
  var hclen;
  /** @type {!(Uint8Array|Array)} code lengths. */
  var codeLengths =
    new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflateStream.Order.length);
  /** @type {!Array} code lengths table. */
  var codeLengthsTable;
  /** @type {!(Uint32Array|Array)} literal and length code lengths. */
  var litlenLengths;
  /** @type {!(Uint32Array|Array)} distance code lengths. */
  var distLengths;
  /** @type {number} loop counter. */
  var i = 0;

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

  this.save_();
  hlit = this.readBits(5) + 257;
  hdist = this.readBits(5) + 1;
  hclen = this.readBits(4) + 4;
  if (hlit < 0 || hdist < 0 || hclen < 0) {
    this.restore_();
    return -1;
  }

  try {
    parseDynamicHuffmanBlockImpl.call(this);
  } catch(e) {
    this.restore_();
    return -1;
  }

  /** @this {!Zlib.RawInflateStream} */
  function parseDynamicHuffmanBlockImpl() {
    /** @type {number} */
    var bits;

    // decode code lengths
    for (i = 0; i < hclen; ++i) {
      if ((bits = this.readBits(3)) < 0) {
        throw new Error('not enough input');
      }
      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;
    }
    codeLengthsTable = buildHuffmanTable(codeLengths);

    /**
     * decode function
     * @param {number} num number of lengths.
     * @param {!Array} table code lengths table.
     * @param {!(Uint8Array|Array<number>)} lengths code lengths buffer.
     * @return {!(Uint8Array|Array<number>)} code lengths buffer.
     * @this {!Zlib.RawInflateStream}
     */
    function decode(num, table, lengths) {
      var code;
      var prev = this.prev;
      var repeat;
      var i;
      var bits;

      for (i = 0; i < num;) {
        code = this.readCodeByTable(table);
        if (code < 0) {
          throw new Error('not enough input');
        }
        switch (code) {
          case 16:
            if ((bits = this.readBits(2)) < 0) {
              throw new Error('not enough input');
            }
            repeat = 3 + bits;
            while (repeat--) { lengths[i++] = prev; }
            break;
          case 17:
            if ((bits = this.readBits(3)) < 0) {
              throw new Error('not enough input');
            }
            repeat = 3 + bits;
            while (repeat--) { lengths[i++] = 0; }
            prev = 0;
            break;
          case 18:
            if ((bits = this.readBits(7)) < 0) {
              throw new Error('not enough input');
            }
            repeat = 11 + bits;
            while (repeat--) { lengths[i++] = 0; }
            prev = 0;
            break;
          default:
            lengths[i++] = code;
            prev = code;
            break;
        }
      }

      this.prev = prev;

      return lengths;
    }

    // literal and length code
    litlenLengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(hlit);

    // distance code
    distLengths = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(hdist);

    this.prev = 0;
    this.litlenTable = buildHuffmanTable(decode.call(this, hlit, codeLengthsTable, litlenLengths));
    this.distTable = buildHuffmanTable(decode.call(this, hdist, codeLengthsTable, distLengths));
  }

  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;

  return 0;
};

/**
 * decode huffman code (dynamic)
 * @return {(number|undefined)} -1 is error.
 */
Zlib.RawInflateStream.prototype.decodeHuffman = function() {
  var output = this.output;
  var op = this.op;

  /** @type {number} huffman code. */
  var code;
  /** @type {number} table index. */
  var ti;
  /** @type {number} huffman code distination. */
  var codeDist;
  /** @type {number} huffman code length. */
  var codeLength;

  var litlen = this.litlenTable;
  var dist = this.distTable;

  var olength = output.length;
  var bits;

  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;

  while (true) {
    this.save_();

    code = this.readCodeByTable(litlen);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }

    if (code === 256) {
      break;
    }

    // literal
    if (code < 256) {
      if (op === olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;

      continue;
    }

    // length code
    ti = code - 257;
    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];
    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeLength += bits;
    }

    // dist code
    code = this.readCodeByTable(dist);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    codeDist = Zlib.RawInflateStream.DistCodeTable[code];
    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeDist += bits;
    }

    // lz77 decode
    if (op + codeLength >= olength) {
      output = this.expandBuffer();
      olength = output.length;
    }

    while (codeLength--) {
      output[op] = output[(op++) - codeDist];
    }

    // break
    if (this.ip === this.input.length) {
      this.op = op;
      return -1;
    }
  }

  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }

  this.op = op;
  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
};

/**
 * expand output buffer. (dynamic)
 * @param {Object=} opt_param option parameters.
 * @return {!(Array|Uint8Array)} output buffer pointer.
 */
Zlib.RawInflateStream.prototype.expandBuffer = function(opt_param) {
  /** @type {!(Array|Uint8Array)} store buffer. */
  var buffer;
  /** @type {number} expantion ratio. */
  var ratio = (this.input.length / this.ip + 1) | 0;
  /** @type {number} maximum number of huffman code. */
  var maxHuffCode;
  /** @type {number} new output buffer size. */
  var newSize;
  /** @type {number} max inflate size. */
  var maxInflateSize;

  var input = this.input;
  var output = this.output;

  if (opt_param) {
    if (typeof opt_param.fixRatio === 'number') {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === 'number') {
      ratio += opt_param.addRatio;
    }
  }

  // calculate new buffer size
  if (ratio < 2) {
    maxHuffCode =
      (input.length - this.ip) / this.litlenTable[2];
    maxInflateSize = (maxHuffCode / 2 * 258) | 0;
    newSize = maxInflateSize < output.length ?
      output.length + maxInflateSize :
      output.length << 1;
  } else {
    newSize = output.length * ratio;
  }

  // buffer expantion
  if (Zlib.USE_TYPEDARRAY) {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  } else {
    buffer = output;
  }

  this.output = buffer;

  return this.output;
};

/**
 * concat output buffer. (dynamic)
 * @return {!(Array|Uint8Array)} output buffer.
 */
Zlib.RawInflateStream.prototype.concatBuffer = function() {
  /** @type {!(Array|Uint8Array)} output buffer. */
  var buffer;

  var resize = this.resize;

  var op = this.op;

  if (resize) {
    if (Zlib.USE_TYPEDARRAY) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(this.sp, op));
    } else {
      buffer = this.output.slice(this.sp, op);
    }
  } else {
    buffer =
      Zlib.USE_TYPEDARRAY ? this.output.subarray(this.sp, op) : this.output.slice(this.sp, op);
  }


  this.buffer = buffer;
  this.sp = op;

  return this.buffer;
};

/**
 * @return {!(Array|Uint8Array)} current output buffer.
 */
Zlib.RawInflateStream.prototype.getBytes = function() {
  return Zlib.USE_TYPEDARRAY ?
    this.output.subarray(0, this.op) : this.output.slice(0, this.op);
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/inflate_stream.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.InflateStream');

//goog.require('Zlib.Adler32');
goog.require('Zlib.CompressionMethod');
goog.require('Zlib.RawInflateStream');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * @param {!(Uint8Array|Array)} input deflated buffer.
 * @constructor
 */
Zlib.InflateStream = function(input) {
  /** @type {!(Uint8Array|Array)} */
  this.input = input === void 0 ? new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)() : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {Zlib.RawInflateStream} */
  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);
  /** @type {Zlib.CompressionMethod} */
  this.method;
  /** @type {!(Array|Uint8Array)} */
  this.output = this.rawinflate.output;
};

/**
 * decompress.
 * @return {!(Uint8Array|Array)} inflated buffer.
 */
Zlib.InflateStream.prototype.decompress = function(input) {
  /** @type {!(Uint8Array|Array)} inflated buffer. */
  var buffer;
  /** @type {number} adler-32 checksum */
  var adler32;

  // 新しい入力を入力バッファに結合する
  // XXX Array, Uint8Array のチェックを行うか確認する
  if (input !== void 0) {
    if (Zlib.USE_TYPEDARRAY) {
      var tmp = new Uint8Array(this.input.length + input.length);
      tmp.set(this.input, 0);
      tmp.set(input, this.input.length);
      this.input = tmp;
    } else {
      this.input = this.input.concat(input);
    }
  }

  if (this.method === void 0) {
    if(this.readHeader() < 0) {
      return new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)();
    }
  }

  buffer = this.rawinflate.decompress(this.input, this.ip);
  if (this.rawinflate.ip !== 0) {
    this.input = Zlib.USE_TYPEDARRAY ?
      this.input.subarray(this.rawinflate.ip) :
      this.input.slice(this.rawinflate.ip);
    this.ip = 0;
  }

  // verify adler-32
  /*
  if (this.verify) {
    adler32 =
      input[this.ip++] << 24 | input[this.ip++] << 16 |
      input[this.ip++] << 8 | input[this.ip++];
    if (adler32 !== Zlib.Adler32(buffer)) {
      throw new Error('invalid adler-32 checksum');
    }
  }
  */

  return buffer;
};

/**
 * @return {!(Uint8Array|Array)} current output buffer.
 */
Zlib.InflateStream.prototype.getBytes = function() {
  return this.rawinflate.getBytes();
};

Zlib.InflateStream.prototype.readHeader = function() {
  var ip = this.ip;
  var input = this.input;

  // Compression Method and Flags
  var cmf = input[ip++];
  var flg = input[ip++];

  if (cmf === void 0 || flg === void 0) {
    return -1;
  }

  // compression method
  switch (cmf & 0x0f) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error('unsupported compression method');
  }

  // fcheck
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
  }

  // fdict (not supported)
  if (flg & 0x20) {
    throw new Error('fdict flag is not supported');
  }

  this.ip = ip;
};

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//third_party/javascript/zlib_js/zip.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.Zip');

goog.require('Zlib.RawDeflate');
goog.require('Zlib.CRC32');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * @param {Object=} opt_params options.
 * @constructor
 */
Zlib.Zip = function(opt_params) {
  opt_params = opt_params || {};
  /** @type {Array<{
   *   buffer: !(Array<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  this.files = [];
  /** @type {(Array<number>|Uint8Array)} */
  this.comment = opt_params['comment'];
  /** @type {(Array<number>|Uint8Array)} */
  this.password;
};


/**
 * @enum {number}
 */
Zlib.Zip.CompressionMethod = {
  STORE: 0,
  DEFLATE: 8
};

/**
 * @enum {number}
 */
Zlib.Zip.OperatingSystem = {
  MSDOS: 0,
  UNIX: 3,
  MACINTOSH: 7
};

/**
 * @enum {number}
 */
Zlib.Zip.Flags = {
  ENCRYPT:    0x0001,
  DESCRIPTOR: 0x0008,
  UTF8:       0x0800
};

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];

/**
 * @param {Array<number>|Uint8Array} input
 * @param {Object=} opt_params options.
 */
Zlib.Zip.prototype.addFile = function(input, opt_params) {
  opt_params = opt_params || {};
  /** @type {string} */
  var filename = opt_params['filename']; // github.com/imaya/zlib.js/issues/75
  /** @type {boolean} */
  var compressed;
  /** @type {number} */
  var size = input.length;
  /** @type {number} */
  var crc32 = 0;

  if (Zlib.USE_TYPEDARRAY && input instanceof Array) {
    input = new Uint8Array(input);
  }

  // default
  if (typeof opt_params['compressionMethod'] !== 'number') {
    opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;
  }

  // その場で圧縮する場合
  if (opt_params['compress']) {
    switch (opt_params['compressionMethod']) {
      case Zlib.Zip.CompressionMethod.STORE:
        break;
      case Zlib.Zip.CompressionMethod.DEFLATE:
        crc32 = Zlib.CRC32.calc(input);
        input = this.deflateWithOption(input, opt_params);
        compressed = true;
        break;
      default:
        throw new Error('unknown compression method:' + opt_params['compressionMethod']);
    }
  }

  this.files.push({
    buffer: input,
    option: opt_params,
    compressed: compressed,
    encrypted: false,
    size: size,
    crc32: crc32
  });
};

/**
 * @param {(Array<number>|Uint8Array)} password
 */
Zlib.Zip.prototype.setPassword = function(password) {
  this.password = password;
};

Zlib.Zip.prototype.compress = function() {
  /** @type {Array<{
   *   buffer: !(Array<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }>} */
  var files = this.files;
  /** @type {{
   *   buffer: !(Array<number>|Uint8Array),
   *   option: Object,
   *   compressed: boolean,
   *   encrypted: boolean,
   *   size: number,
   *   crc32: number
   * }} */
  var file;
  /** @type {!(Array<number>|Uint8Array)} */
  var output;
  /** @type {number} */
  var op1;
  /** @type {number} */
  var op2;
  /** @type {number} */
  var op3;
  /** @type {number} */
  var localFileSize = 0;
  /** @type {number} */
  var centralDirectorySize = 0;
  /** @type {number} */
  var endOfCentralDirectorySize;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var needVersion;
  /** @type {number} */
  var flags;
  /** @type {Zlib.Zip.CompressionMethod} */
  var compressionMethod;
  /** @type {Date} */
  var date;
  /** @type {number} */
  var crc32;
  /** @type {number} */
  var size;
  /** @type {number} */
  var plainSize;
  /** @type {number} */
  var filenameLength;
  /** @type {number} */
  var extraFieldLength;
  /** @type {number} */
  var commentLength;
  /** @type {(Array<number>|Uint8Array)} */
  var filename;
  /** @type {(Array<number>|Uint8Array)} */
  var extraField;
  /** @type {(Array<number>|Uint8Array)} */
  var comment;
  /** @type {(Array<number>|Uint8Array)} */
  var buffer;
  /** @type {*} */
  var tmp;
  /** @type {Array<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {number} */
  var j;
  /** @type {number} */
  var jl;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      (file.option['filename']) ? file.option['filename'].length : 0;
    extraFieldLength =
      (file.option['extraField']) ? file.option['extraField'].length : 0;
    commentLength =
      (file.option['comment']) ? file.option['comment'].length : 0;

    // 圧縮されていなかったら圧縮
    if (!file.compressed) {
      // 圧縮前に CRC32 の計算をしておく
      file.crc32 = Zlib.CRC32.calc(file.buffer);

      switch (file.option['compressionMethod']) {
        case Zlib.Zip.CompressionMethod.STORE:
          break;
        case Zlib.Zip.CompressionMethod.DEFLATE:
          file.buffer = this.deflateWithOption(file.buffer, file.option);
          file.compressed = true;
          break;
        default:
          throw new Error('unknown compression method:' + file.option['compressionMethod']);
      }
    }

    // encryption
    if (file.option['password'] !== void 0|| this.password !== void 0) {
      // init encryption
      key = this.createEncryptionKey(file.option['password'] || this.password);

      // add header
      buffer = file.buffer;
      if (Zlib.USE_TYPEDARRAY) {
        tmp = new Uint8Array(buffer.length + 12);
        tmp.set(buffer, 12);
        buffer = tmp;
      } else {
        buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }

      for (j = 0; j < 12; ++j) {
        buffer[j] = this.encode(
          key,
          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)
        );
      }

      // data encryption
      for (jl = buffer.length; j < jl; ++j) {
        buffer[j] = this.encode(key, buffer[j]);
      }
      file.buffer = buffer;
    }

    // 必要バッファサイズの計算
    localFileSize +=
      // local file header
      30 + filenameLength +
      // file data
      file.buffer.length;

    centralDirectorySize +=
      // file header
      46 + filenameLength + commentLength;
  }

  // end of central directory
  endOfCentralDirectorySize = 46 + (this.comment ? this.comment.length : 0);
  output = new (Zlib.USE_TYPEDARRAY ? Uint8Array : Array)(
    localFileSize + centralDirectorySize + endOfCentralDirectorySize
  );
  op1 = 0;
  op2 = localFileSize;
  op3 = op2 + centralDirectorySize;

  // ファイルの圧縮
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength =
      file.option['filename'] ? file.option['filename'].length :  0;
    extraFieldLength = 0; // TODO
    commentLength =
      file.option['comment'] ? file.option['comment'].length : 0;

    //-------------------------------------------------------------------------
    // local file header & file header
    //-------------------------------------------------------------------------

    offset = op1;

    // signature
    // local file header
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];
    // file header
    output[op2++] = Zlib.Zip.FileHeaderSignature[0];
    output[op2++] = Zlib.Zip.FileHeaderSignature[1];
    output[op2++] = Zlib.Zip.FileHeaderSignature[2];
    output[op2++] = Zlib.Zip.FileHeaderSignature[3];

    // compressor info
    needVersion = 20;
    output[op2++] = needVersion & 0xff;
    output[op2++] =
      /** @type {Zlib.Zip.OperatingSystem} */
      (file.option['os']) ||
      Zlib.Zip.OperatingSystem.MSDOS;

    // need version
    output[op1++] = output[op2++] =  needVersion       & 0xff;
    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;

    // general purpose bit flag
    flags = 0;
    if (file.option['password'] || this.password) {
      flags |= Zlib.Zip.Flags.ENCRYPT;
    }
    output[op1++] = output[op2++] =  flags       & 0xff;
    output[op1++] = output[op2++] = (flags >> 8) & 0xff;

    // compression method
    compressionMethod =
      /** @type {Zlib.Zip.CompressionMethod} */
      (file.option['compressionMethod']);
    output[op1++] = output[op2++] =  compressionMethod       & 0xff;
    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;

    // date
    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();
    output[op1++] = output[op2++] =
      ((date.getMinutes() & 0x7) << 5) |
      (date.getSeconds() / 2 | 0);
    output[op1++] = output[op2++] =
      (date.getHours()   << 3) |
      (date.getMinutes() >> 3);
    //
    output[op1++] = output[op2++] =
      ((date.getMonth() + 1 & 0x7) << 5) |
      (date.getDate());
    output[op1++] = output[op2++] =
      ((date.getFullYear() - 1980 & 0x7f) << 1) |
      (date.getMonth() + 1 >> 3);

    // CRC-32
    crc32 = file.crc32;
    output[op1++] = output[op2++] =  crc32        & 0xff;
    output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;
    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;

    // compressed size
    size = file.buffer.length;
    output[op1++] = output[op2++] =  size        & 0xff;
    output[op1++] = output[op2++] = (size >>  8) & 0xff;
    output[op1++] = output[op2++] = (size >> 16) & 0xff;
    output[op1++] = output[op2++] = (size >> 24) & 0xff;

    // uncompressed size
    plainSize = file.size;
    output[op1++] = output[op2++] =  plainSize        & 0xff;
    output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;
    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;

    // filename length
    output[op1++] = output[op2++] =  filenameLength       & 0xff;
    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;

    // extra field length
    output[op1++] = output[op2++] =  extraFieldLength       & 0xff;
    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;

    // file comment length
    output[op2++] =  commentLength       & 0xff;
    output[op2++] = (commentLength >> 8) & 0xff;

    // disk number start
    output[op2++] = 0;
    output[op2++] = 0;

    // internal file attributes
    output[op2++] = 0;
    output[op2++] = 0;

    // external file attributes
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;

    // relative offset of local header
    output[op2++] =  offset        & 0xff;
    output[op2++] = (offset >>  8) & 0xff;
    output[op2++] = (offset >> 16) & 0xff;
    output[op2++] = (offset >> 24) & 0xff;

    // filename
    filename = file.option['filename'];
    if (filename) {
      if (Zlib.USE_TYPEDARRAY) {
        output.set(filename, op1);
        output.set(filename, op2);
        op1 += filenameLength;
        op2 += filenameLength;
      } else {
        for (j = 0; j < filenameLength; ++j) {
          output[op1++] = output[op2++] = filename[j];
        }
      }
    }

    // extra field
    extraField = file.option['extraField'];
    if (extraField) {
      if (Zlib.USE_TYPEDARRAY) {
        output.set(extraField, op1);
        output.set(extraField, op2);
        op1 += extraFieldLength;
        op2 += extraFieldLength;
      } else {
        for (j = 0; j < commentLength; ++j) {
          output[op1++] = output[op2++] = extraField[j];
        }
      }
    }

    // comment
    comment = file.option['comment'];
    if (comment) {
      if (Zlib.USE_TYPEDARRAY) {
        output.set(comment, op2);
        op2 += commentLength;
      } else {
        for (j = 0; j < commentLength; ++j) {
          output[op2++] = comment[j];
        }
      }
    }

    //-------------------------------------------------------------------------
    // file data
    //-------------------------------------------------------------------------

    if (Zlib.USE_TYPEDARRAY) {
      output.set(file.buffer, op1);
      op1 += file.buffer.length;
    } else {
      for (j = 0, jl = file.buffer.length; j < jl; ++j) {
        output[op1++] = file.buffer[j];
      }
    }
  }

  //-------------------------------------------------------------------------
  // end of central directory
  //-------------------------------------------------------------------------

  // signature
  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];

  // number of this disk
  output[op3++] = 0;
  output[op3++] = 0;

  // number of the disk with the start of the central directory
  output[op3++] = 0;
  output[op3++] = 0;

  // total number of entries in the central directory on this disk
  output[op3++] =  il       & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // total number of entries in the central directory
  output[op3++] =  il       & 0xff;
  output[op3++] = (il >> 8) & 0xff;

  // size of the central directory
  output[op3++] =  centralDirectorySize        & 0xff;
  output[op3++] = (centralDirectorySize >>  8) & 0xff;
  output[op3++] = (centralDirectorySize >> 16) & 0xff;
  output[op3++] = (centralDirectorySize >> 24) & 0xff;

  // offset of start of central directory with respect to the starting disk number
  output[op3++] =  localFileSize        & 0xff;
  output[op3++] = (localFileSize >>  8) & 0xff;
  output[op3++] = (localFileSize >> 16) & 0xff;
  output[op3++] = (localFileSize >> 24) & 0xff;

  // .ZIP file comment length
  commentLength = this.comment ? this.comment.length : 0;
  output[op3++] =  commentLength       & 0xff;
  output[op3++] = (commentLength >> 8) & 0xff;

  // .ZIP file comment
  if (this.comment) {
    if (Zlib.USE_TYPEDARRAY) {
      output.set(this.comment, op3);
      op3 += commentLength;
    } else {
      for (j = 0, jl = commentLength; j < jl; ++j) {
        output[op3++] = this.comment[j];
      }
    }
  }

  return output;
};

/**
 * @param {!(Array<number>|Uint8Array)} input
 * @param {Object=} opt_params options.
 * @return {!(Array<number>|Uint8Array)}
 */
Zlib.Zip.prototype.deflateWithOption = function(input, opt_params) {
  /** @type {Zlib.RawDeflate} */
  var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);

  return deflator.compress();
};

/**
 * @param {(Array<number>|Uint32Array)} key
 * @return {number}
 */
Zlib.Zip.prototype.getByte = function(key) {
  /** @type {number} */
  var tmp = ((key[2] & 0xffff) | 2);

  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;
};

/**
 * @param {(Array<number>|Uint32Array|Object)} key
 * @param {number} n
 * @return {number}
 */
Zlib.Zip.prototype.encode = function(key, n) {
  /** @type {number} */
  var tmp = this.getByte(/** @type {(Array<number>|Uint32Array)} */(key));

  this.updateKeys(/** @type {(Array<number>|Uint32Array)} */(key), n);

  return tmp ^ n;
};

/**
 * @param {(Array<number>|Uint32Array)} key
 * @param {number} n
 */
Zlib.Zip.prototype.updateKeys = function(key, n) {
  key[0] = Zlib.CRC32.single(key[0], n);
  key[1] =
    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;
  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);
};

/**
 * @param {(Array<number>|Uint8Array)} password
 * @return {!(Array<number>|Uint32Array|Object)}
 */
Zlib.Zip.prototype.createEncryptionKey = function(password) {
  /** @type {!(Array<number>|Uint32Array)} */
  var key = [305419896, 591751049, 878082192];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (Zlib.USE_TYPEDARRAY) {
    key = new Uint32Array(key);
  }

  for (i = 0, il = password.length; i < il; ++i) {
    this.updateKeys(key, password[i] & 0xff);
  }

  return key;
};

});

//third_party/javascript/zlib_js/unzip.js
/**
 * @license
 *
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

goog.provide('Zlib.Unzip');

goog.require('Zlib.RawInflate');
goog.require('Zlib.CRC32');
goog.require('Zlib.Zip');
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

/**
 * @param {!(Array<number>|Uint8Array)} input input buffer.
 * @param {Object=} opt_params options.
 * @constructor
 */
Zlib.Unzip = function(input, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array<number>|Uint8Array)} */
  this.input =
    (Zlib.USE_TYPEDARRAY && (input instanceof Array)) ?
    new Uint8Array(input) : input;
  /** @type {number} */
  this.ip = 0;
  /** @type {number} */
  this.eocdrOffset;
  /** @type {number} */
  this.numberOfThisDisk;
  /** @type {number} */
  this.startDisk;
  /** @type {number} */
  this.totalEntriesThisDisk;
  /** @type {number} */
  this.totalEntries;
  /** @type {number} */
  this.centralDirectorySize;
  /** @type {number} */
  this.centralDirectoryOffset;
  /** @type {number} */
  this.commentLength;
  /** @type {(Array<number>|Uint8Array)} */
  this.comment;
  /** @type {Array<Zlib.Unzip.FileHeader>} */
  this.fileHeaderList;
  /** @type {Object.<string, number>} */
  this.filenameToIndex;
  /** @type {boolean} */
  this.verify = opt_params['verify'] || false;
  /** @type {(Array<number>|Uint8Array)} */
  this.password = opt_params['password'];
};

Zlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;

/**
 * @type {Array<number>}
 * @const
 */
Zlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;

/**
 * @param {!(Array<number>|Uint8Array)} input input buffer.
 * @param {number} ip input position.
 * @constructor
 */
Zlib.Unzip.FileHeader = function(input, ip) {
  /** @type {!(Array<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.version;
  /** @type {number} */
  this.os;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {number} */
  this.fileCommentLength;
  /** @type {number} */
  this.diskNumberStart;
  /** @type {number} */
  this.internalFileAttributes;
  /** @type {number} */
  this.externalFileAttributes;
  /** @type {number} */
  this.relativeOffset;
  /** @type {string} */
  this.filename;
  /** @type {!(Array<number>|Uint8Array)} */
  this.extraField;
  /** @type {!(Array<number>|Uint8Array)} */
  this.comment;
};

Zlib.Unzip.FileHeader.prototype.parse = function() {
  /** @type {!(Array<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // central file header signature
  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] ||
      input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] ||
      input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] ||
      input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {
    throw new Error('invalid file header signature');
  }

  // version made by
  this.version = input[ip++];
  this.os = input[ip++];

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file comment length
  this.fileCommentLength = input[ip++] | (input[ip++] << 8);

  // disk number start
  this.diskNumberStart = input[ip++] | (input[ip++] << 8);

  // internal file attributes
  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);

  // external file attributes
  this.externalFileAttributes =
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24);

  // relative offset of local header
  this.relativeOffset = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name
  this.filename = String.fromCharCode.apply(null, Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip += this.fileNameLength) :
    input.slice(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip += this.extraFieldLength) :
    input.slice(ip, ip += this.extraFieldLength);

  // file comment
  this.comment = Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip + this.fileCommentLength) :
    input.slice(ip, ip + this.fileCommentLength);

  this.length = ip - this.offset;
};

/**
 * @param {!(Array<number>|Uint8Array)} input input buffer.
 * @param {number} ip input position.
 * @constructor
 */
Zlib.Unzip.LocalFileHeader = function(input, ip) {
  /** @type {!(Array<number>|Uint8Array)} */
  this.input = input;
  /** @type {number} */
  this.offset = ip;
  /** @type {number} */
  this.length;
  /** @type {number} */
  this.needVersion;
  /** @type {number} */
  this.flags;
  /** @type {number} */
  this.compression;
  /** @type {number} */
  this.time;
  /** @type {number} */
  this.date;
  /** @type {number} */
  this.crc32;
  /** @type {number} */
  this.compressedSize;
  /** @type {number} */
  this.plainSize;
  /** @type {number} */
  this.fileNameLength;
  /** @type {number} */
  this.extraFieldLength;
  /** @type {string} */
  this.filename;
  /** @type {!(Array<number>|Uint8Array)} */
  this.extraField;
};

Zlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;

Zlib.Unzip.LocalFileHeader.prototype.parse = function() {
  /** @type {!(Array<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip = this.offset;

  // local file header signature
  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] ||
      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] ||
      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] ||
      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {
    throw new Error('invalid local file header signature');
  }

  // version needed to extract
  this.needVersion = input[ip++] | (input[ip++] << 8);

  // general purpose bit flag
  this.flags = input[ip++] | (input[ip++] << 8);

  // compression method
  this.compression = input[ip++] | (input[ip++] << 8);

  // last mod file time
  this.time = input[ip++] | (input[ip++] << 8);

  //last mod file date
  this.date = input[ip++] | (input[ip++] << 8);

  // crc-32
  this.crc32 = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // compressed size
  this.compressedSize = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // uncompressed size
  this.plainSize = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // file name length
  this.fileNameLength = input[ip++] | (input[ip++] << 8);

  // extra field length
  this.extraFieldLength = input[ip++] | (input[ip++] << 8);

  // file name
  this.filename = String.fromCharCode.apply(null, Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip += this.fileNameLength) :
    input.slice(ip, ip += this.fileNameLength)
  );

  // extra field
  this.extraField = Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip += this.extraFieldLength) :
    input.slice(ip, ip += this.extraFieldLength);

  this.length = ip - this.offset;
};


Zlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {
  /** @type {!(Array<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  for (ip = input.length - 12; ip > 0; --ip) {
    if (input[ip  ] === Zlib.Unzip.CentralDirectorySignature[0] &&
        input[ip+1] === Zlib.Unzip.CentralDirectorySignature[1] &&
        input[ip+2] === Zlib.Unzip.CentralDirectorySignature[2] &&
        input[ip+3] === Zlib.Unzip.CentralDirectorySignature[3]) {
      this.eocdrOffset = ip;
      return;
    }
  }

  throw new Error('End of Central Directory Record not found');
};

Zlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {
  /** @type {!(Array<number>|Uint8Array)} */
  var input = this.input;
  /** @type {number} */
  var ip;

  if (!this.eocdrOffset) {
    this.searchEndOfCentralDirectoryRecord();
  }
  ip = this.eocdrOffset;

  // signature
  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] ||
      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] ||
      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] ||
      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {
    throw new Error('invalid signature');
  }

  // number of this disk
  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);

  // number of the disk with the start of the central directory
  this.startDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory on this disk
  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);

  // total number of entries in the central directory
  this.totalEntries = input[ip++] | (input[ip++] << 8);

  // size of the central directory
  this.centralDirectorySize = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // offset of start of central directory with respect to the starting disk number
  this.centralDirectoryOffset = (
    (input[ip++]      ) | (input[ip++] <<  8) |
    (input[ip++] << 16) | (input[ip++] << 24)
  ) >>> 0;

  // .ZIP file comment length
  this.commentLength = input[ip++] | (input[ip++] << 8);

  // .ZIP file comment
  this.comment = Zlib.USE_TYPEDARRAY ?
    input.subarray(ip, ip + this.commentLength) :
    input.slice(ip, ip + this.commentLength);
};

Zlib.Unzip.prototype.parseFileHeader = function() {
  /** @type {Array<Zlib.Unzip.FileHeader>} */
  var filelist = [];
  /** @type {Object.<string, number>} */
  var filetable = {};
  /** @type {number} */
  var ip;
  /** @type {Zlib.Unzip.FileHeader} */
  var fileHeader;
  /*: @type {number} */
  var i;
  /*: @type {number} */
  var il;

  if (this.fileHeaderList) {
    return;
  }

  if (this.centralDirectoryOffset === void 0) {
    this.parseEndOfCentralDirectoryRecord();
  }
  ip = this.centralDirectoryOffset;

  for (i = 0, il = this.totalEntries; i < il; ++i) {
    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);
    fileHeader.parse();
    ip += fileHeader.length;
    filelist[i] = fileHeader;
    filetable[fileHeader.filename] = i;
  }

  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
    throw new Error('invalid file header size');
  }

  this.fileHeaderList = filelist;
  this.filenameToIndex = filetable;
};

/**
 * @param {number} index file header index.
 * @param {Object=} opt_params
 * @return {!(Array<number>|Uint8Array)} file data.
 */
Zlib.Unzip.prototype.getFileData = function(index, opt_params) {
  opt_params = opt_params || {};
  /** @type {!(Array<number>|Uint8Array)} */
  var input = this.input;
  /** @type {Array<Zlib.Unzip.FileHeader>} */
  var fileHeaderList = this.fileHeaderList;
  /** @type {Zlib.Unzip.LocalFileHeader} */
  var localFileHeader;
  /** @type {number} */
  var offset;
  /** @type {number} */
  var length;
  /** @type {!(Array<number>|Uint8Array)} */
  var buffer;
  /** @type {number} */
  var crc32;
  /** @type {Array<number>|Uint32Array|Object} */
  var key;
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  if (!fileHeaderList) {
    this.parseFileHeader();
  }

  if (fileHeaderList[index] === void 0) {
    throw new Error('wrong index');
  }

  offset = fileHeaderList[index].relativeOffset;
  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);
  localFileHeader.parse();
  offset += localFileHeader.length;
  length = localFileHeader.compressedSize;

  // decryption
  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
    if (!(opt_params['password'] || this.password)) {
      throw new Error('please set password');
    }
    key =  this.createDecryptionKey(opt_params['password'] || this.password);

    // encryption header
    for(i = offset, il = offset + 12; i < il; ++i) {
      this.decode(key, input[i]);
    }
    offset += 12;
    length -= 12;

    // decryption
    for (i = offset, il = offset + length; i < il; ++i) {
      input[i] = this.decode(key, input[i]);
    }
  }

  switch (localFileHeader.compression) {
    case Zlib.Unzip.CompressionMethod.STORE:
      buffer = Zlib.USE_TYPEDARRAY ?
        this.input.subarray(offset, offset + length) :
        this.input.slice(offset, offset + length);
      break;
    case Zlib.Unzip.CompressionMethod.DEFLATE:
      buffer = new Zlib.RawInflate(this.input, {
        'index': offset,
        'bufferSize': localFileHeader.plainSize
      }).decompress();
      break;
    default:
      throw new Error('unknown compression type');
  }

  if (this.verify) {
    crc32 = Zlib.CRC32.calc(buffer);
    if (localFileHeader.crc32 !== crc32) {
      throw new Error(
        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +
        ', data=0x' + crc32.toString(16)
      );
    }
  }

  return buffer;
};

/**
 * @return {Array<string>}
 */
Zlib.Unzip.prototype.getFilenames = function() {
  /** @type {Array<string>} */
  var filenameList = [];
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;
  /** @type {Array<Zlib.Unzip.FileHeader>} */
  var fileHeaderList;

  if (!this.fileHeaderList) {
    this.parseFileHeader();
  }
  fileHeaderList = this.fileHeaderList;

  for (i = 0, il = fileHeaderList.length; i < il; ++i) {
    filenameList[i] = fileHeaderList[i].filename;
  }

  return filenameList;
};

/**
 * @param {string} filename extract filename.
 * @param {Object=} opt_params
 * @return {!(Array<number>|Uint8Array)} decompressed data.
 */
Zlib.Unzip.prototype.decompress = function(filename, opt_params) {
  /** @type {number} */
  var index;

  if (!this.filenameToIndex) {
    this.parseFileHeader();
  }
  index = this.filenameToIndex[filename];

  if (index === void 0) {
    throw new Error(filename + ' not found');
  }

  return this.getFileData(index, opt_params);
};

/**
 * @param {(Array<number>|Uint8Array)} password
 */
Zlib.Unzip.prototype.setPassword = function(password) {
  this.password = password;
};

/**
 * @param {(Array<number>|Uint32Array|Object)} key
 * @param {number} n
 * @return {number}
 */
Zlib.Unzip.prototype.decode = function(key, n) {
  n ^= this.getByte(/** @type {(Array<number>|Uint32Array)} */(key));
  this.updateKeys(/** @type {(Array<number>|Uint32Array)} */(key), n);

  return n;
};

// common method
Zlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;
Zlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;
Zlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;

// end of scope
});

//third_party/javascript/zlib_js/zlib.js
/**
 * @license
 *
 * zlib.js
 * JavaScript Zlib and Deflate Library
 *
 * The MIT License
 *
 * Copyright (c) 2011 imaya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
 * されている. これは Inflate との共存を考慮している為.
 */

goog.provide('Zlib');

//-----------------------------------------------------------------------------

/** @suppress {extraRequire} */
goog.require('Zlib.Deflate');
/** @suppress {extraRequire} */
goog.require('Zlib.Inflate');
/** @suppress {extraRequire} */
goog.require('Zlib.USE_TYPEDARRAY');

goog.scope(function() {

// Zlib.CompressionMethod moved to its own file to break cyclic dependency.

// end of scope
});

/* vim:set expandtab ts=2 sw=2 tw=80: */

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/hwid_def_v1v2.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.HwidDefV1V2');
goog.module.declareLegacyNamespace();

const CRC32 = goog.require('Zlib.CRC32');
const HwidDef = goog.require('recovery.HwidDef');
const googString = goog.require('goog.string');

/**
 * The HWID definition pattern.
 * @const @type {!RegExp}
 */
const PATTERN = new RegExp('^(\\w+ ){2,3}(\\w+-?){1,3} \\d{4}$');

/**
 * The HWID definition prefix pattern.
 * @const @type {!RegExp}
 */
const PREFIX_PATTERN = new RegExp(
    '^(' +
    '(\\w+ ?){1,3}|' +
    '(\\w+ ){2,3}(\\w+-?){1,3} ?|' +
    '(\\w+ ){2,3}(\\w+-?){1,3} \\d{0,4}' +
    ')$');

/**
 * Number of characters in the checksum.
 * @const @type {number}
 */
const CHECKSUM_CHARS_LEN = 4;

/**
 * Generates the checksum for a HWID.
 * @param {string} hwid The hwid to generate a checksum for.
 * @return {string} The checksum for the hwid.
 */
function generateChecksum(hwid) {
  // Get the last 4 bytes of the crc32 as the checksum.
  // Zero-fill right-shift to get the unsigned number.
  var numStr = ((CRC32.calc(HwidDef.stringToUint8Array(hwid)) & 0xffffffff) >>>
                0).toString();

  // Pad the number with leading zeros as necessary.
  numStr = googString.padNumber(parseInt(numStr, 10), CHECKSUM_CHARS_LEN);

  // Return the last 4 chars as the checksum.
  return numStr.slice(numStr.length - CHECKSUM_CHARS_LEN, numStr.length);
}

/**
 * Creates HwidDef for the v1/v2 definition.
 *
 * HWID v1/v2 encoding checksum defined here:
 *   https://chromium.googlesource.com/chromiumos/platform/factory_test_tools/+/HEAD/gen_hwid.py
 * example HWID: LINK BOOJUM A-A 3548
 * @return {!HwidDef}
 */
function create() {
  return new HwidDef(
      false /* removeDashes */, PATTERN, PREFIX_PATTERN, CHECKSUM_CHARS_LEN,
      generateChecksum);
}

exports = {
  create,
};

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/hwid_def_v3base32.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.HwidDefV3Base32');
goog.module.declareLegacyNamespace();

const CRC32 = goog.require('Zlib.CRC32');
const HwidDef = goog.require('recovery.HwidDef');

/**
 * Base-32 character set used in V3 Base32 HWID def pattern.
 * @const @type {string}
 */
const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

/**
 * The HWID definition pattern.
 * @const @type {!RegExp}
 */
const PATTERN = new RegExp(
    '^\\w+ (?:[' + BASE32_ALPHABET + ']{4}-?)+' +
    '(?:[' + BASE32_ALPHABET + ']{1,4})?$');

/**
 * The HWID definition prefix pattern.
 * @const @type {!RegExp}
 */
const PREFIX_PATTERN = new RegExp(
    '^\\w+ ?(?:[' + BASE32_ALPHABET + ']{4}-?)*' +
    '(?:[' + BASE32_ALPHABET + ']{1,3})?$');

/**
 * Number of characters in the checksum.
 * @const @type {number}
 */
const CHECKSUM_CHARS_LEN = 2;

/**
 * Generates the checksum for a HWID.
 * @param {string} hwid The hwid to generate a checksum for.
 * @return {string} The checksum for the hwid.
 */
function generateChecksum(hwid) {
  // Get the last 10 bits of the crc32 as the checksum.
  var num = CRC32.calc(HwidDef.stringToUint8Array(hwid)) & ((1 << 10) - 1);

  // Return the numeric checksum in the base32 encoding.
  return BASE32_ALPHABET[num >> 5] + BASE32_ALPHABET[num & ((1 << 5) - 1)];
}

/**
 * Creates HwidDef for the v3 Base32 definition.
 *
 * HWID v3 Base32 encoding defined here:
 *   https://chromium.googlesource.com/chromiumos/platform/factory/+/main/py/hwid/base32.py
 * example HWID: FALCO AAAF-FYFI
 * @return {!HwidDef}
 */
function create() {
  return new HwidDef(
      true /* removeDashes */, PATTERN, PREFIX_PATTERN, CHECKSUM_CHARS_LEN,
      generateChecksum);
}

exports = {
  create,
};

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/hwid_def_v3base8192.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.HwidDefV3Base8192');
goog.module.declareLegacyNamespace();

const CRC32 = goog.require('Zlib.CRC32');
const HwidDef = goog.require('recovery.HwidDef');

/**
 * Base-8 character set used in V3 Base8192 HWID def pattern.
 * @const @type {string}
 */
const BASE8_ALPHABET = '23456789';

/**
 * Base-32 character set used in V3 Base8192 HWID def pattern.
 * @const @type {string}
 */
const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

/**
 * Implementation of HWIDv3 Base8192 validator.
 *  @final
 */
recovery.HwidDefV3Base8192Impl = class {
  constructor() {}

  /**
   * Generates the checksum for a HWID.
   * @param {string} str The string to generate a checksum for.
   * @return {string} The checksum for the hwid.
   * @private
   */
  generateChecksum_(str) {
    // Get the last 8 bits of the crc32 as the checksum.
    var num = CRC32.calc(HwidDef.stringToUint8Array(str)) & ((1 << 8) - 1);

    // Return the numeric checksum in the base8192 encoding.
    return BASE8_ALPHABET[num >> 5] + BASE32_ALPHABET[num & ((1 << 5) - 1)];
  }

  /**
   * Normalizes a hwid string.
   * @param {string} hwid The string to normalize.
   * @return {string} The normalized string.
   * @private
   */
  normalize_(hwid) {
    return hwid.toUpperCase().trim().replace(/\s+/g, ' ');
  }

  /**
   * Check if given part matches "<MODEL>[-<RLZ>]".
   *
   * @param {string} str The part to check.
   * @return {boolean} Whether given part is a valid model and RLZ part or not.
   * @private
   */
  checkModelAndRlzPart_(str) {
    return (
        recovery.HwidDefV3Base8192Impl.MODEL_AND_RLZ_PATTERN_.test(str) ||
        recovery.HwidDefV3Base8192Impl.MODEL_PATTERN_.test(str));
  }

  /**
   * Splits HWID into checksum and not_checksum parts for checking.
   * @param {string} hwid the HWID to split.
   * @return {{success: boolean, checksum: string, not_checksum: string}}
   *     success will be True if parts are split successfully.
   *     checksum is a two letter string.
   *     not_checksum is a string that can be used to compute checksum directly.
   * @private
   */
  splitHwid_(hwid) {
    hwid = this.normalize_(hwid);
    if (!hwid) {
      return {success: false, checksum: '', not_checksum: ''};
    }

    const parts = hwid.split(' ');
    let success = false;

    if (parts.length == 2) {
      // Regular format: <MODEL>[-<RLZ>] <COMPONENT><CHECKSUM>
      success =
          (this.checkModelAndRlzPart_(parts[0]) &&
           recovery.HwidDefV3Base8192Impl.COMPONENT_PATTERN_.test(parts[1]));
    } else if (parts.length == 3) {
      // Extended format: <MODEL>[-<RLZ>] <CONFIGLESS> <COMPONENT><CHECKSUM>
      success =
          (this.checkModelAndRlzPart_(parts[0]) &&
           recovery.HwidDefV3Base8192Impl.CONFIGLESS_PATTERN_.test(parts[1]) &&
           recovery.HwidDefV3Base8192Impl.COMPONENT_PATTERN_.test(parts[2]));
    }

    const component_field_index = parts.length - 1;
    const checksum_length = 2;
    // Last @checksum_length characters are checksum.
    const checksum = parts[component_field_index].slice(
        parts[component_field_index].length - checksum_length,
        parts[component_field_index].length);
    // Remove checksum.
    parts[component_field_index] = parts[component_field_index].slice(
        0, parts[component_field_index].length - checksum_length);
    // When computing checksum, '-' is removed from component field.
    parts[component_field_index] =
        parts[component_field_index].replace(/-/g, '');
    const not_checksum = parts.join(' ').trim();
    return {success, checksum, not_checksum};
  }

  /**
   * Validates the checksum of the HWID.
   * @param {string} hwid the partial or complete HWID to validate.
   * @return {boolean} True if input HWID passes a checksum validation.
   */
  hasValidChecksum(hwid) {
    const {success, checksum, not_checksum} = this.splitHwid_(hwid);
    const expected = this.generateChecksum_(not_checksum);
    return expected == checksum;
  }

  /**
   * Returns true if the input is a valid HWID.
   * @param {string} hwid HWID to check.
   * @return {boolean} True if the input is a valid HWID.
   */
  isValidPattern(hwid) {
    const {success, checksum, not_checksum} = this.splitHwid_(hwid);
    return success;
  }

  /**
   * Returns true if the input is a valid HWID prefix including an empty string.
   * @param {string} hwidPrefix Prefix to check.
   * @return {boolean} True if the input is a valid prefix.
   */
  isValidPrefix(hwidPrefix) {
    if (!hwidPrefix) {  // empty string
      return true;
    }

    hwidPrefix = this.normalize_(hwidPrefix);

    const parts = hwidPrefix.split(' ');

    if (parts.length >= 1) {
      // part[0] must be <MODEL>[-<RLZ>]
      if (!this.checkModelAndRlzPart_(parts[0])) {
        return false;
      }
      if (parts.length == 1) {
        return true;
      }
    }

    if (parts.length == 2) {
      if (!parts[1]) {  // empty string
        return true;
      }
      return (
          recovery.HwidDefV3Base8192Impl.CONFIGLESS_PARTIAL_.test(parts[1]) ||
          recovery.HwidDefV3Base8192Impl.COMPONENT_PARTIAL_.test(parts[1]));
    }

    if (parts.length == 3) {
      // In this case, it must be:
      //   <MODEL>[-<RLZ>] <CONFIGLESS> <COMPONENT+CHECKSUM>
      if (!recovery.HwidDefV3Base8192Impl.CONFIGLESS_PARTIAL_.test(parts[1])) {
        return false;
      }
      if (!parts[2]) {  // empty string
        return true;
      }
      return recovery.HwidDefV3Base8192Impl.COMPONENT_PARTIAL_.test(parts[2]);
    }

    return false;
  }
};
goog.exportSymbol(
    'recovery.HwidDefV3Base8192Impl', recovery.HwidDefV3Base8192Impl);

/**
 * Pattern for <MODEL> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.MODEL_PATTERN_ = /^[A-Z0-9]+$/;

/**
 * Pattern for <MODEL>-<RLZ> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.MODEL_AND_RLZ_PATTERN_ = /^[A-Z0-9]+-\w+$/;

/**
 * Pattern for <CONFIGLESS> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.CONFIGLESS_PATTERN_ =
    /^(?:[A-F0-9]+-)+[A-F0-9]+$/;

/**
 * Matches prefix of <CONFIGLESS> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.CONFIGLESS_PARTIAL_ =
    /^(?:[A-F0-9]+-)*(?:[A-F0-9]+)?$/;

/**
 * Pattern for <COMPONENT><CHECKSUM> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.COMPONENT_PATTERN_ = new RegExp(
    '^(?:[' + BASE32_ALPHABET + ']' +
    '[' + BASE8_ALPHABET + ']' +
    '[' + BASE32_ALPHABET + ']' +
    '-)*' +
    '(?:[' + BASE32_ALPHABET + ']' +
    // Last two digits are checksum.
    '[' + BASE8_ALPHABET + ']' +
    '[' + BASE32_ALPHABET + '])$');

/**
 * Matches prefix of <COMPONENT><CHECKSUM> part.
 * @const @private {!RegExp}
 */
recovery.HwidDefV3Base8192Impl.COMPONENT_PARTIAL_ = new RegExp(
    '^(?:[' + BASE32_ALPHABET + ']' +
    '[' + BASE8_ALPHABET + ']' +
    '[' + BASE32_ALPHABET + ']' +
    '-?)*' +
    '(?:[' + BASE32_ALPHABET + ']|' +
    '[' + BASE32_ALPHABET + ']' +
    '[' + BASE8_ALPHABET + '])?$');

/**
 * Creates HwidDef for the v3 Base8192 definition.
 *
 * HWID v3 Base8192 encoding defined here:
 *   https://chromium.googlesource.com/chromiumos/platform/factory/+/main/py/hwid/base8192.py
 * example HWID: SPRING G2A-A7D-A5A
 * @return {!recovery.HwidDefV3Base8192Impl}
 */
function create() {
  return new recovery.HwidDefV3Base8192Impl();
}

exports = {
  create,
};

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/hwid_validator.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.HwidValidator');
goog.module.declareLegacyNamespace();

const HwidDef = goog.require('recovery.HwidDef');
const HwidDefV1V2 = goog.require('recovery.HwidDefV1V2');
const HwidDefV3Base32 = goog.require('recovery.HwidDefV3Base32');
const HwidDefV3Base8192 = goog.require('recovery.HwidDefV3Base8192');

/**
 * Class to validate the pattern and checksum value of a HWID string.
 *  @final
 */
const HwidValidator = class {
  /**
   * @param {!Array.<!HwidDef>} hwidDefs HWID definitions supported
   *     by the validator.
   */
  constructor(hwidDefs) {
    /**
     * Array of supported HWID definitions.
     * @private {!Array.<!HwidDef>}
     * @const
     */
    this.hwidDefs_ = hwidDefs;
  }

  /**
   * Returns a new HwidValidator that supports HWID v1, v2, and v3 definitions.
   * @return {!HwidValidator}
   */
  static createDefaultValidator() {
    return new HwidValidator([
      HwidDefV1V2.create(), HwidDefV3Base32.create(), HwidDefV3Base8192.create()
    ]);
  }

  /**
   * Returns true if the input represents a valid HWID pattern prefix. Checks
   * all supported HWID definitions.
   * @param {string} hwid HWID to check.
   * @return {boolean} True if the input is a valid HWID pattern prefix.
   */
  isValidPrefix(hwid) {
    return this.hwidDefs_.some(function(hwidDef) {
      return hwidDef.isValidPrefix(hwid);
    });
  }

  /**
   * Returns true if the input represents a valid HWID pattern. Checks all
   * supported HWID definitions.
   * @param {string} hwid HWID to check.
   * @return {boolean} True if the input is a valid HWID pattern.
   */
  isValidPattern(hwid) {
    return this.hwidDefs_.some(function(hwidDef) {
      return hwidDef.isValidPattern(hwid);
    });
  }

  /**
   * Validates the checksum of the HWID against all the supported
   * HWID definitions.
   * @param {string} hwid The partial or complete HWID to validate.
   * @return {boolean} True if the HWID passes checksum validation.
   */
  hasValidChecksum(hwid) {
    return this.hwidDefs_.some(function(hwidDef) {
      return hwidDef.hasValidChecksum(hwid);
    });
  }
};
goog.exportSymbol('recovery.HwidValidator', HwidValidator);

exports = HwidValidator;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/selectdevicebyhwidcontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.SelectDeviceByHwidController');
goog.module.declareLegacyNamespace();

const HwidValidator = goog.require('recovery.HwidValidator');
const appConfig = goog.require('recovery.appConfig');
const devices = goog.require('recovery.devices');
const googString = goog.require('goog.string');
const recovery = goog.require('recovery');

/**
 * The controller for the 'select device by hwid' flow.
 *  @final
 */
const SelectDeviceByHwidController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.selectByHwidController = this;

    /**
     * Angular controller for the app.
     * @const {recovery.controllers.AppController}
     */
    this.app = $scope.app;

    /**
     * Angular controller for selecting a device.
     * @const {recovery.controllers.SelectDeviceController}
     */
    this.selectController = $scope.selectDeviceController;

    /**
     * Angular scope apply() function.
     * @const {function()}
     */
    this.scopeApply = goog.bind($scope.$apply, $scope);

    this.app.writeParams.device = recovery.DUMMY_DEVICE;

    this.app.hwidPlaceholder = 'e.g. ' + appConfig.sampleHwid;

    /**
     * True if the link to populate the HWID input field with the HWID of the
     * Chromebook should be shown to the user.
     * @const {boolean}
     */
    this.showPopulateUsingModelNumber =
        appConfig.allowPopulateUsingModelNumber &&
        !!this.app.currentChromebookHwid;

    $scope.$watch('app.userHwid', goog.bind(this.watchHwid, this));
  }

  /**
   * Updates the page based on changes in the autocomplete value.
   */
  watchHwid() {
    var hwidValidator = HwidValidator.createDefaultValidator();
    var matchingDevice = null;

    if (googString.isEmptyOrWhitespace(
            googString.makeSafe(this.app.userHwid))) {
      this.app.hwidEntryMessageStyle = '';
      this.app.hwidEntryMessageKey = '';
    } else {
      // Normalize the string: uppercase it and trim leading whitespace.
      var normalizedHwid = googString.trimLeft(this.app.userHwid).toUpperCase();
      if (normalizedHwid != this.app.userHwid) {
        this.app.userHwid = normalizedHwid;

        // Return since updating app.userHwid will trigger this method again.
        return;
      }

      matchingDevice = recovery.getMatchingDevice(this.app.userHwid);

      if (matchingDevice) {
        // Single matching device found.
        this.app.hwidEntryMessageStyle =
            SelectDeviceByHwidController.HwidEntryMessageStyles.MATCH;

        if (hwidValidator.isValidPattern(this.app.userHwid) &&
            hwidValidator.hasValidChecksum(this.app.userHwid)) {
          this.app.hwidEntryMessageKey =
              SelectDeviceByHwidController.HwidEntryMessageKeys
                  .HWID_MATCH_FOUND_AND_CHECKSUM_VERIFIED;
        } else {
          this.app.hwidEntryMessageKey =
              SelectDeviceByHwidController.HwidEntryMessageKeys
                  .HWID_MATCH_FOUND;
        }
      } else if (!recovery.isValidModelFamilyPrefix(this.app.userHwid)) {
        // Invalid model prefix.
        this.app.hwidEntryMessageStyle =
            SelectDeviceByHwidController.HwidEntryMessageStyles.ERROR;
        this.app.hwidEntryMessageKey =
            SelectDeviceByHwidController.HwidEntryMessageKeys
                .HWID_INVALID_MODEL;
      } else if (hwidValidator.isValidPrefix(this.app.userHwid)) {
        // Valid prefix.
        this.app.hwidEntryMessageStyle =
            SelectDeviceByHwidController.HwidEntryMessageStyles.MESSAGE;
        this.app.hwidEntryMessageKey =
            SelectDeviceByHwidController.HwidEntryMessageKeys.HWID_KEEP_TYPING;
      } else {
        // Invalid prefix.
        this.app.hwidEntryMessageStyle =
            SelectDeviceByHwidController.HwidEntryMessageStyles.ERROR;
        this.app.hwidEntryMessageKey =
            SelectDeviceByHwidController.HwidEntryMessageKeys
                .HWID_INVALID_MODEL;
      }
    }

    // Set the matching device and let the user continue.
    this.app.writeParams.device = matchingDevice || recovery.DUMMY_DEVICE;
    this.selectController.canContinue = !!matchingDevice;

    // Analytics: set targetChromebookHwid and targetChromebookModel dimensions.
    if (matchingDevice) {
      this.app.ga.setDimensionTargetChromebookHwid(this.app.userHwid);
      var model = this.app.userHwid.split(' ')[0];
      this.app.ga.setDimensionTargetChromebookModel(model);
    }
  }

  /**
   * Populates the HWID field with the model of the current chromebook.
   */
  populateUsingModelNumber() {
    this.app.userHwid = this.app.currentChromebookHwid;
  }
};
goog.exportSymbol(
    'recovery.controllers.SelectDeviceByHwidController',
    SelectDeviceByHwidController);

/**
 * CSS styles for the HWID entry message.
 * @enum {string}
 */
SelectDeviceByHwidController.HwidEntryMessageStyles = {
  ERROR: 'error',
  MATCH: 'match',
  MESSAGE: 'message'
};

/**
 * Message keys for the HWID entry message.
 * @enum {string}
 */
SelectDeviceByHwidController.HwidEntryMessageKeys = {
  HWID_INVALID_MODEL: 'HWID_INVALID_MODEL',
  HWID_KEEP_TYPING: 'HWID_KEEP_TYPING',
  HWID_MATCH_FOUND: 'HWID_MATCH_FOUND',
  HWID_MATCH_FOUND_AND_CHECKSUM_VERIFIED:
      'HWID_MATCH_FOUND_AND_CHECKSUM_VERIFIED'
};

exports = SelectDeviceByHwidController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/selectdevicebymodelcontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.SelectDeviceByModelController');
goog.module.declareLegacyNamespace();

const appConfig = goog.require('recovery.appConfig');
const recovery = goog.require('recovery');

/**
 * Controller for the 'select device by make/model' flow.
 *
 * @unrestricted
 */
const SelectDeviceByModelController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.selectByModelController = this;

    this.app = $scope.app;
    this.selectController = $scope.selectDeviceController;
    this.selectController.canContinue = false;

    // Init
    this.oemList = Object.keys(recovery.oems).sort();
    this.onOemSelected();
    this.app.hasSelectByHwid = appConfig.allowSelectByHwid;

    $scope.$watch('app.selectedOem', goog.bind(this.onOemSelected, this));

    $scope.$watch('app.selectedSku', goog.bind(this.onSkuSelected, this));
  }

  /**
   * Updates the list to of SKUs based on the chosen OEM.
   */
  onOemSelected() {
    var oem = this.app.selectedOem;

    this.skuList = oem ? Object.keys(recovery.oems[oem]).sort() : [];
    this.onSkuSelected();
  }

  /**
   * Updates a app-level variables based on the state of the controller.
   */
  onSkuSelected() {
    var oem = this.app.selectedOem;
    var sku = this.app.selectedSku;

    if (oem && sku && recovery.oems[oem] && recovery.oems[oem][sku]) {
      this.selectController.canContinue = true;
      this.app.writeParams.device = recovery.oems[oem][sku];
      var model = recovery.getDeviceAnalyticsModel(this.app.writeParams.device);
      if (model) {
        this.app.ga.setDimensionTargetChromebookModel(model);
      }
    } else {
      this.selectController.canContinue = false;
      this.app.writeParams.device = recovery.DUMMY_DEVICE;
    }
  }
};
goog.exportSymbol(
    'recovery.controllers.SelectDeviceByModelController',
    SelectDeviceByModelController);

exports = SelectDeviceByModelController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/controllers/selectdevicecontroller.js
goog.loadModule(function(exports) {'use strict';goog.module('recovery.controllers.SelectDeviceController');
goog.module.declareLegacyNamespace();

const GoogleAnalytics = goog.require('recovery.GoogleAnalytics');
const appConfig = goog.require('recovery.appConfig');

/**
 * A common controller for device selection.
 *
 * @unrestricted
 */
const SelectDeviceController = class {
  /**
   * @param {!angular.Scope} $scope
   */
  constructor($scope) {
    $scope.selectDeviceController = this;

    this.app = $scope.app;

    this.app.step = 1;
    this.app.allowErase = true;
    this.app.allowLocalFile = true;

    this.canContinue = false;

    /**
     * Selection modes.
     * @enum {string}
     */
    this.SelectionTypes = {HWID: 'HWID', MAKE_MODEL: 'MAKE_MODEL'};

    if (appConfig.selectByModelFirst) {
      $scope.app.selectionType = this.SelectionTypes.MAKE_MODEL;
    }

    if ($scope.app.selectionType == this.SelectionTypes.MAKE_MODEL) {
      this.selectByModel();
    } else {
      this.selectByHwid();
    }
  }

  /** Changes to the select-by-hwid page. */
  selectByHwid() {
    this.app.ga.setDimensionSelectionMethod(GoogleAnalytics.selection.HWID);
    this.subView = 'html/select_device_by_hwid.html';
    this.app.selectionType = this.SelectionTypes.HWID;
  }

  /** Changes to the select-by-model page. */
  selectByModel() {
    this.app.ga.setDimensionSelectionMethod(GoogleAnalytics.selection.MODEL);
    this.subView = 'html/select_device_by_model.html';
    this.app.selectionType = this.SelectionTypes.MAKE_MODEL;
  }
};
goog.exportSymbol(
    'recovery.controllers.SelectDeviceController', SelectDeviceController);

exports = SelectDeviceController;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/chromeosinfoprivate_stub.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview A stub API to emulate the chromeosInfoPrivate API.
 */
goog.module('recovery.chromeosInfoPrivateStub');


/**
 * HWID of the current machine, set to '' to disable this stub.
 */
const HWID = 'IEC MARIO FISH 2330';  // Pretend we're on a Cr-48.

/**
 * Returns device properties.
 * @param {Array} properties
 * @param {!Function} callback
 */
function get(properties, callback) {
  if (properties.length !== 1 || properties[0] !== 'hwid') {
    callback(null);
  }
  callback({hwid: HWID});
}

exports = {
  HWID,
  get,
};

;return exports;});

//javascript/jfk/activityindicator/activitystatus.js
// Copyright 2011 Google. All Rights Reserved.

/**
 * @fileoverview Status state for Kennedy.
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('jfk.ActivityStatus');
goog.provide('jfk.ActivityStatus.State');

goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');



/**
 * Observable status object.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
jfk.ActivityStatus = function() {
  jfk.ActivityStatus.base(this, 'constructor');

  /**
   * Currently displayed state.
   * @type {jfk.ActivityStatus.State}
   * @private
   */
  this.state_ = jfk.ActivityStatus.State.NONE;
};
goog.inherits(jfk.ActivityStatus, goog.events.EventTarget);


/**
 * Possible states.
 * @enum {string}
 */
jfk.ActivityStatus.State = {
  LOADING: 'loading',
  NONE: 'none',
  OFFLINE: 'offline'
};


/**
 * Set a new state.
 * @param {jfk.ActivityStatus.State} state New state.
 * @return {boolean} If the state changed.
 */
jfk.ActivityStatus.prototype.setState = function(state) {
  var stateChanged = this.state_ != state;
  if (stateChanged) {
    this.state_ = state;
    this.dispatchEvent(goog.events.EventType.CHANGE);
  }

  return stateChanged;
};


/**
 * Get the current state.
 * @return {jfk.ActivityStatus.State} The current state.
 */
jfk.ActivityStatus.prototype.getState = function() {
  return this.state_;
};

//javascript/jfk/activityindicator/activityindicator.js
// Copyright 2011 Google. All Rights Reserved.

/**
 * @fileoverview Activity indicator for Kennedy. Works on all browsers that
 * support CSS3 Animations (all browsers except IE<10).
 * See http://caniuse.com/#feat=css-animation.
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('jfk.ActivityIndicator');

goog.require('goog.Timer');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dispose');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.object');
goog.require('goog.style');
goog.require('goog.ui.Component');
goog.require('goog.userAgent');
goog.require('jfk.ActivityStatus');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.Event');



/**
 * Component to show activity status: loading, offline, etc.
 * @param {!jfk.ActivityStatus} status Status object.
 * @param {!goog.dom.DomHelper=} domHelper Optional DOM helper.
 * @param {boolean=} retainLastTransition Whether to retain the object with the
 *     transition once a transition ends.
 * @constructor
 * @extends {goog.ui.Component}
 */
jfk.ActivityIndicator = function(
    status, domHelper = undefined, retainLastTransition = false) {
  jfk.ActivityIndicator.base(this, 'constructor', domHelper);

  /** @private @const {boolean} */
  this.retainLastTransition_ = retainLastTransition;

  /**
   * The background color of the activity indicator.
   * @type {string}
   * @private
   */
  this.backgroundColor_ = '#fff';

  /**
   * The size of the activity indicator.
   * @type {jfk.ActivityIndicator.Size}
   * @private
   */
  this.size_ = jfk.ActivityIndicator.Size.NORMAL;

  /**
   * Status object.
   * @type {!jfk.ActivityStatus}
   * @private
   */
  this.status_ = status;
};
goog.inherits(jfk.ActivityIndicator, goog.ui.Component);


/**
 * Lightweight object representing `jfk.ActivityIndicator.CircleTransition_`
 * properties.
 * @typedef {{
 *   complete: boolean,
 *   endColor: string,
 *   endShadowColor: string,
 *   direction: !jfk.ActivityIndicator.Direction_,
 * }}
 */
jfk.ActivityIndicator.TransitionProperties_;


/**
 * Direction of the folding animation.
 * @enum {number}
 * @private
 */
jfk.ActivityIndicator.Direction_ = {
  UP: 0,
  RIGHT: 1,
  DOWN: 2,
  LEFT: 3
};


/**
 * The size of the activity indicator.
 * @enum {number}
 */
jfk.ActivityIndicator.Size = {
  NORMAL: 0,
  SMALL: 1
};


/**
 * @param {jfk.ActivityIndicator.Size} size The size.
 */
jfk.ActivityIndicator.prototype.setSize = function(size) {
  goog.asserts.assert(!this.getElement(),
      'Cannot setSize after activity indicator is rendered.');
  this.size_ = size;
};


/**
 * Sets the background color.
 * @param {string} color Background color.
 */
jfk.ActivityIndicator.prototype.setBackgroundColor = function(color) {
  this.backgroundColor_ = color;
};


/** @override */
jfk.ActivityIndicator.prototype.createDom = function() {
  jfk.ActivityIndicator.base(this, 'createDom');

  var domHelper = this.getDomHelper();

  // The activity indicator needs to display the offline image above
  // the transition circles.  The iconLayer_ div is placed after
  // the contentElement_ so that transition circles are rendered
  // first in document order (and the icon appears above).

  this.contentElement_ = domHelper.createDom(goog.dom.TagName.DIV);

  this.iconLayer_ = domHelper.createDom(goog.dom.TagName.DIV,
      goog.getCssName(jfk.ActivityIndicator.CSS_NAME_, 'icon'));

  var classNames = [jfk.ActivityIndicator.CSS_NAME_];
  if (this.size_ == jfk.ActivityIndicator.Size.SMALL) {
    classNames.push(goog.getCssName(jfk.ActivityIndicator.CSS_NAME_, 'small'));
  }
  this.setElementInternal(domHelper.createDom(goog.dom.TagName.DIV,
                                              classNames,
                                              this.contentElement_,
                                              this.iconLayer_));
};


/** @override */
jfk.ActivityIndicator.prototype.getContentElement = function() {
  return this.contentElement_;
};


/** @override */
jfk.ActivityIndicator.prototype.enterDocument = function() {
  jfk.ActivityIndicator.base(this, 'enterDocument');
  // TODO(obelomestnykh): See the indicator to the initial status state as well.
  // Remove the hacky state resetting in the demo.
  this.getHandler().listen(this.status_,
                           goog.events.EventType.CHANGE,
                           this.runAnimationLoop_);
};


/**
 * Starts off the animation loop.  Plays the next transition in sequence.
 * Called on state change or at the end of a previous transition if it's
 * a state that plays continuously (loading). No-op if a transition is already
 * playing.
 * @private
 */
jfk.ActivityIndicator.prototype.runAnimationLoop_ = function() {

  // There is an outstanding loop playing.  It will be responsible for
  // starting the next run.
  if (this.lastTransitionProperties_ &&
      !this.lastTransitionProperties_.complete) {
    return;
  }

  this.removeChildren(true);

  var transition = this.createNextTransition_();
  this.lastTransitionProperties_ = {
    complete: false,
    endColor: transition.endColor,
    endShadowColor: transition.endShadowColor,
    direction: transition.direction,
  };
  this.playTransition_(transition);

  this.setOfflineOpacity_();
};


/**
 * Play given transition.
 * @param {jfk.ActivityIndicator.CircleTransition_} transition Transition
 *     to play.
 * @private
 */
jfk.ActivityIndicator.prototype.playTransition_ = function(transition) {
  this.addChild(transition, true);
  this.getHandler().listenOnce(transition,
      jfk.ActivityIndicator.CircleTransition_.EventType.COMPLETE,
      this.handleTransitionEnd_);

  // Call after a delay to trigger the CSS3 animation (the style changes
  // happen after the execution thread).
  goog.Timer.callOnce(
      goog.partial(this.cleanupTransition_, transition), 0, this);

  // TODO(nnaze): Translations and a11y.
};


/**
 * Called after a delay to trigger the CSS3 animation (the style changes
 * happen after the execution thread).
 * @param {?jfk.ActivityIndicator.CircleTransition_} transition
 * @private
 */
jfk.ActivityIndicator.prototype.cleanupTransition_ = function(transition) {
  if (this.isInDocument()) {
    transition.play();
    // Cleanup in case transitionend event doesn't fire.
    goog.Timer.callOnce(function() {
      if (!this.isDisposed() && this.isInDocument() && this.started &&
          !this.complete) {
        this.handleTransitionEnd_();
      }
    }, 500, transition);
  }
};


/**
 * At the end of a transition, possibly continue the animation.
 * @param {!goog.events.Event} e Transition complete event, with
 *     transition as the target.
 * @private
 */
jfk.ActivityIndicator.prototype.handleTransitionEnd_ = function(e) {
  this.lastTransitionProperties_.complete = true;

  var objectWithTransition = e.target;

  var state = this.status_.getState();

  // Continue with the animation if the indicator doesn't match the
  // current state, or if we're loading (that animation runs
  // continuously).
  if (state != objectWithTransition.state ||
      state == jfk.ActivityStatus.State.LOADING) {
    this.runAnimationLoop_();
  }

  this.setOfflineOpacity_();
  if (!this.retainLastTransition_) {
    goog.dispose(objectWithTransition);
  }
};


/**
 * Set the opacity of the offline icon based on current status.
 * @private
 */
jfk.ActivityIndicator.prototype.setOfflineOpacity_ = function() {
  this.iconLayer_.style.opacity =
      this.status_.getState() == jfk.ActivityStatus.State.OFFLINE ? 1 : 0;
};


/**
 * Create the next transition.
 * @return {!jfk.ActivityIndicator.CircleTransition_} New transition.
 * @private
 */
jfk.ActivityIndicator.prototype.createNextTransition_ = function() {

  // TODO(nnaze): Consider moving color definitions into GSS (if possible).

  // Default values if we don't have a previous transition.
  var lastColor = this.backgroundColor_;
  var lastShadowColor = this.backgroundColor_;
  var newDirection = jfk.ActivityIndicator.Direction_.DOWN;

  var previousTransition = this.lastTransitionProperties_;
  if (previousTransition) {
    lastColor = previousTransition.endColor;
    lastShadowColor = previousTransition.endShadowColor;
    newDirection = jfk.ActivityIndicator.getNextDirection_(
        previousTransition.direction);
  }

  var state = this.status_.getState();

  // nextColor is the color of the next circle.
  // nextShadowColor is the color of the circle midway through the tranision
  var nextColor;
  var nextShadowColor;

  switch (state) {
    case jfk.ActivityStatus.State.LOADING:
      var newColors = jfk.ActivityIndicator.LOADING_COLOR_MAP_[newDirection];
      nextColor = newColors[0];
      nextShadowColor = newColors[1];
      break;
    case jfk.ActivityStatus.State.NONE:
      nextColor = this.backgroundColor_;
      nextShadowColor = this.backgroundColor_;
      break;
    case jfk.ActivityStatus.State.OFFLINE:
      nextColor = '#999';
      nextShadowColor = '#777';
      break;
    default:
      goog.asserts.fail('should not reach default case');
  }

  goog.asserts.assert(nextColor);
  goog.asserts.assert(nextShadowColor);

  return new jfk.ActivityIndicator.CircleTransition_(
      state, newDirection,
      nextColor, lastColor,
      lastColor, lastShadowColor,
      nextColor, nextShadowColor,
      this.size_, this.getDomHelper());
};


/**
 * Give the next direction.
 * @param {jfk.ActivityIndicator.Direction_} direction Current direction.
 * @return {jfk.ActivityIndicator.Direction_} New direction.
 * @private
 */
jfk.ActivityIndicator.getNextDirection_ = function(direction) {
  goog.asserts.assert(goog.array.contains(
      goog.object.getValues(jfk.ActivityIndicator.Direction_),
      direction));

  var newDirection = (direction + 1) % 4;

  goog.asserts.assert(goog.array.contains(
      goog.object.getValues(jfk.ActivityIndicator.Direction_),
      newDirection));

  return /** @type {jfk.ActivityIndicator.Direction_} */ (newDirection);
};


/**
 * Map of loading transition direction to pairs of colors (regular and shadow).
 * @type {!Object.<jfk.ActivityIndicator.Direction_,string>}
 * @private
 */
jfk.ActivityIndicator.LOADING_COLOR_MAP_ = goog.object.create(
    jfk.ActivityIndicator.Direction_.UP, ['#00B15F', '#008948'],  // green
    jfk.ActivityIndicator.Direction_.RIGHT, ['#3C78F8', '#2159bd'], // blue
    jfk.ActivityIndicator.Direction_.DOWN, ['#FA2424', '#9e1212'],  // red
    jfk.ActivityIndicator.Direction_.LEFT, ['#FFD34B', '#dea11a'] // yellow
    );


/**
 * CSS class name for activity indicator.
 * @type {string}
 * @private
 */
jfk.ActivityIndicator.CSS_NAME_ = goog.getCssName('jfk-activityIndicator');


/**
 * The properties of last played transition used to create new transition.
 * @type {?jfk.ActivityIndicator.TransitionProperties_}
 * @private
 */
jfk.ActivityIndicator.prototype.lastTransitionProperties_;


/**
 * Offline icon layer.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.prototype.iconLayer_;


/**
 * Content element.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.prototype.contentElement_;



/**
 * Component animating a folding circle.
 *
 * The transition is done with two CSS3 animations.  See notes in createDom().
 * @constructor
 * @extends {goog.ui.Component}
 * @private
 * @param {jfk.ActivityStatus.State} state State for this transition.
 * @param {jfk.ActivityIndicator.Direction_} direction Direction of animation.
 * @param {string} startBackgroundColor Background color for first circle.
 * @param {string} endBackgroundColor Background color for second circle.
 * @param {string} startColor Start color of first circle.
 * @param {string} startShadowColor Start shadow color of first circle.
 * @param {string} endColor End color of second circle.
 * @param {string} endShadowColor End shadow color of second circle.
 * @param {jfk.ActivityIndicator.Size} size The size that dictates the circle
 *     diameter.
 * @param {goog.dom.DomHelper=} opt_domHelper Dom helper for this component.
 */
jfk.ActivityIndicator.CircleTransition_ = function(state,
                                                   direction,
                                                   startBackgroundColor,
                                                   endBackgroundColor,
                                                   startColor,
                                                   startShadowColor,
                                                   endColor,
                                                   endShadowColor,
                                                   size,
                                                   opt_domHelper) {
  jfk.ActivityIndicator.CircleTransition_.base(this,
      'constructor', opt_domHelper);

  /**
   * The state represented by this transition.
   * @type {jfk.ActivityStatus.State}
   */

  this.state = state;

  /**
   * Whether the transition has completed.
   * @type {boolean}
   */
  this.complete = false;

  /**
   * Direction of the fold.
   * @type {jfk.ActivityIndicator.Direction_}
   */
  this.direction = direction;

  /**
   * The color of the first background circle.
   * @type {string}
   */
  this.startBackgroundColor = startBackgroundColor;

  /**
   * The color of the second background circle.
   * @type {string}
   */
  this.endBackgroundColor = endBackgroundColor;

  /**
   * @type {string}
   */
  this.startColor = startColor;

  /**
   * @type {string}
   */
  this.startShadowColor = startShadowColor;

  /**
   * @type {string}
   */
  this.endColor = endColor;

  /**
   * @type {string}
   */
  this.endShadowColor = endShadowColor;

  /**
   * @type {number}
   * @private
   */
  this.circleDiameter_ = size == jfk.ActivityIndicator.Size.SMALL ?
      jfk.ActivityIndicator.CircleTransition_.CIRCLE_DIAMETER_SMALL_ :
      jfk.ActivityIndicator.CircleTransition_.CIRCLE_DIAMETER_;
};
goog.inherits(jfk.ActivityIndicator.CircleTransition_, goog.ui.Component);


/**
 * Transition events.
 * @enum {string}
 */
jfk.ActivityIndicator.CircleTransition_.EventType = {
  COMPLETE: goog.events.getUniqueId('complete')
};


/**
 * Diameter of a normal circle.
 * Note that this must match the value in activityindicator.gss.
 * @type {number}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.CIRCLE_DIAMETER_ = 19;


/**
 * Diameter of a small circle.
 * Note that this must match the value in activityindicator.gss.
 * @type {number}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.CIRCLE_DIAMETER_SMALL_ = 16;


/**
 * @param {jfk.ActivityIndicator.Direction_} direction
 *     Direction of animation.
 * @return {boolean} Whether the animation is in the vertical direction.
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.isVertical_ = function(direction) {
  return direction == jfk.ActivityIndicator.Direction_.UP ||
         direction == jfk.ActivityIndicator.Direction_.DOWN;
};


/** @override */
jfk.ActivityIndicator.CircleTransition_.prototype.createDom = function() {
  jfk.ActivityIndicator.CircleTransition_.base(this, 'createDom');
  var elem = this.getElement();
  var domHelper = this.getDomHelper();

  goog.dom.classlist.add(elem, goog.getCssName(jfk.ActivityIndicator.CSS_NAME_,
      'circle-transition'));

  // The animation of a circle folding over is produced by two semi-circles
  // and two separate animations.

  // The semicircle is accomplished by putting a full circle (created with
  // border-width: %50) inside a cropping mask.

  // In the animation, the first semicircle goes from full width to zero
  // width, and then the second goes from zero to full.  The CSS transition
  // rules animate the transition.

  var maskClassName = goog.getCssName(jfk.ActivityIndicator.CSS_NAME_, 'mask');
  var firstMask = domHelper.createDom(goog.dom.TagName.DIV, maskClassName);
  var secondMask = domHelper.createDom(goog.dom.TagName.DIV, maskClassName);

  goog.asserts.assert(elem);
  domHelper.append(elem, firstMask, secondMask);

  var circleClassName = goog.getCssName(jfk.ActivityIndicator.CSS_NAME_,
                                        'circle');

  var firstBackgroundCircle =
      domHelper.createDom(goog.dom.TagName.DIV, circleClassName);
  domHelper.appendChild(firstMask, firstBackgroundCircle);
  goog.style.setStyle(firstBackgroundCircle, 'backgroundColor',
                      this.startBackgroundColor);

  var secondBackgroundCircle =
      domHelper.createDom(goog.dom.TagName.DIV, circleClassName);
  domHelper.appendChild(secondMask, secondBackgroundCircle);
  goog.style.setStyle(secondBackgroundCircle, 'backgroundColor',
                      this.endBackgroundColor);

  var firstCircle = domHelper.createDom(goog.dom.TagName.DIV, circleClassName);
  var secondCircle = domHelper.createDom(goog.dom.TagName.DIV, circleClassName);
  domHelper.appendChild(firstMask, firstCircle);
  domHelper.appendChild(secondMask, secondCircle);
  goog.style.setStyle(firstCircle, 'backgroundColor', this.startColor);
  goog.style.setStyle(secondCircle, 'backgroundColor', this.endShadowColor);

  this.firstCircle_ = firstCircle;
  this.secondCircle_ = secondCircle;
  this.firstBackgroundCircle_ = firstBackgroundCircle;
  this.secondBackgroundCircle_ = secondBackgroundCircle;

  this.firstMask_ = firstMask;
  this.secondMask_ = secondMask;

  this.setStartPositions_(this.direction);

  goog.dom.classlist.add(firstCircle,
      goog.getCssName(jfk.ActivityIndicator.CSS_NAME_, 'transition'));
  goog.dom.classlist.add(secondCircle,
      goog.getCssName(jfk.ActivityIndicator.CSS_NAME_, 'transition-second'));
};


/**
 * Set the starting positions for the animation.
 * @param {jfk.ActivityIndicator.Direction_} direction Animation direction.
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.setStartPositions_ =
    function(direction) {

  // Precalculate styles so they needn't be inlined multiple times below.

  // Full circle diameter.
  var full = this.circleDiameter_ + 'px';

  // Half circle diameter.
  var half = Math.ceil(this.circleDiameter_ / 2) + 'px';

  // Negative half circle diameter.
  var minusHalf = '-' + half;

  switch (direction) {
    case jfk.ActivityIndicator.Direction_.RIGHT:
      goog.style.setStyle(this.firstMask_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondMask_, {'left': half, 'top': 0});
      goog.style.setStyle(this.firstCircle_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondCircle_, {'width': 0, 'left': 0});
      goog.style.setStyle(this.firstBackgroundCircle_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondBackgroundCircle_, {'left': minusHalf});
      break;
    case jfk.ActivityIndicator.Direction_.LEFT:
      goog.style.setStyle(this.firstMask_, {'left': half, 'top': 0});
      goog.style.setStyle(this.secondMask_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.firstCircle_, {'left': minusHalf, 'top': 0});
      goog.style.setStyle(this.secondCircle_, {'width': 0, 'left': half});
      goog.style.setStyle(this.firstBackgroundCircle_,
                          {'left': minusHalf, 'top': 0});
      break;
    case jfk.ActivityIndicator.Direction_.UP:
      goog.style.setStyle(this.firstMask_, {'left': 0, 'top': half});
      goog.style.setStyle(this.secondMask_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.firstCircle_, {'left': 0, 'top': minusHalf});
      goog.style.setStyle(this.secondCircle_, {'top': half, 'height': 0});
      goog.style.setStyle(this.firstBackgroundCircle_,
                          {'left': 0, 'top': minusHalf});
      break;
    case jfk.ActivityIndicator.Direction_.DOWN:
      goog.style.setStyle(this.firstMask_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondMask_, {'left': 0, 'top': half});
      goog.style.setStyle(this.firstCircle_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondCircle_, {'left': 0, 'height': 0});
      goog.style.setStyle(this.firstBackgroundCircle_, {'left': 0, 'top': 0});
      goog.style.setStyle(this.secondBackgroundCircle_, {'top': minusHalf});
      break;
    default:
      goog.asserts.fail('should not reach default case');
  }

  // Correctly size the masks.
  var maskStyles = jfk.ActivityIndicator.CircleTransition_.isVertical_(
      this.direction) ? {'width': full, 'height': half} :
                        {'width': half, 'height': full};
  goog.style.setStyle(this.firstMask_, maskStyles);
  goog.style.setStyle(this.secondMask_, maskStyles);
};


/**
 * Set the ending positions for the animation.
 * @param {jfk.ActivityIndicator.Direction_} direction Animation direction.
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.setEndPositions_ =
    function(direction) {
  // See notes on styles in createDom().
  var full = this.circleDiameter_ + 'px';
  var half = Math.ceil(this.circleDiameter_ / 2) + 'px';
  var minusHalf = '-' + half;

  switch (direction) {
    case jfk.ActivityIndicator.Direction_.RIGHT:
      goog.style.setStyle(this.firstCircle_, {'width': 0, 'left': half});
      goog.style.setStyle(this.secondCircle_,
                          {'left': minusHalf, 'width': full});
      break;
    case jfk.ActivityIndicator.Direction_.LEFT:
      goog.style.setStyle(this.firstCircle_, {'width': 0, 'left': 0});
      goog.style.setStyle(this.secondCircle_, {'width': full, 'left': 0});
      break;
    case jfk.ActivityIndicator.Direction_.UP:
      goog.style.setStyle(this.firstCircle_, {'top': 0, 'height': 0});
      goog.style.setStyle(this.secondCircle_, {'top': 0, 'height': full});
      break;
    case jfk.ActivityIndicator.Direction_.DOWN:
      goog.style.setStyle(this.firstCircle_, {'top': half, 'height': 0});
      goog.style.setStyle(this.secondCircle_,
                          {'top': minusHalf, 'height': full});
      break;
    default:
      goog.asserts.fail('should not reach default case');
  }
};


/**
 * Play the animation.
 */
jfk.ActivityIndicator.CircleTransition_.prototype.play = function() {
  goog.asserts.assert(this.isInDocument(),
                      'Must be in document at this point.');

  // Gecko has a bug where the styles might not have been calculated
  // yet at this point, meaning that the transition may not occur when
  // new values are set. Calculating size forces Gecko to calculate styles
  // and ensures the transition occurs.
  if (goog.userAgent.GECKO) {
    goog.style.getSize(this.getElement());
  }

  /**
   * @type {boolean}
   */
  this.started = true;

  var transitionEvents = ['webkitTransitionEnd', 'transitionend'];

  // It's safer to add listener first before style change happens.
  this.listenEventsOnce_(
      this.secondCircle_, transitionEvents, this.handleTransitionEnd_);

  goog.style.setStyle(this.firstCircle_, 'backgroundColor',
                      this.startShadowColor);
  goog.style.setStyle(this.secondCircle_, 'backgroundColor',
                      this.endColor);

  this.setEndPositions_(this.direction);
};


/**
 * Add multiple event listeners, but only call the handler for the first
 * that fires.
 * @param {EventTarget} target Event target.
 * @param {!Array.<string>} events Events to listen for.
 * @param {!Function} handler Handler function.
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.listenEventsOnce_ = function(
    target, events, handler) {
  var fired = false;
  var self = this;
  this.getHandler().listenOnce(target, events, function() {

    if (fired) {
      return;
    }

    fired = true;
    handler.call(self);
  });

};


/**
 * Called when the CSS transition ends.  Mark transition as complete,
 * dispatch COMPLETE event, and hide the hidden background circle (can bleed
 * through otherwise).
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.handleTransitionEnd_ =
    function() {
  this.complete = true;
  this.dispatchEvent(
      jfk.ActivityIndicator.CircleTransition_.EventType.COMPLETE);
  goog.style.setElementShown(this.secondBackgroundCircle_, false);
};


/**
 * First circle of the animation.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.firstCircle_;


/**
 * Second circle of the animation.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.secondCircle_;


/**
 * Element that masks the first circle.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.firstMask_;


/**
 * Element that masks the second circle.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.secondMask_;


/**
 * First background circle.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.firstBackgroundCircle_;


/**
 * Second background circle.
 * @type {Element}
 * @private
 */
jfk.ActivityIndicator.CircleTransition_.prototype.secondBackgroundCircle_;

//javascript/angular/components/activityindicator/activityindicator_directive.js
goog.loadModule(function(exports) {'use strict';goog.module('ng.g.activityIndicator.directive');
const ActivityIndicator = goog.require('jfk.ActivityIndicator');
const ActivityStatus = goog.require('jfk.ActivityStatus');
const GoogAdapter = goog.requireType('ng.g.GoogAdapter');
const googString = goog.require('goog.string');

/**
 * Angular directive which displays an activity indicator that can signal
 * loading, offline, or inactive.
 *
 * Attributes:
 * size: 'small', defualts to 'normal'
 * loading: boolean expression, defaults to true
 * offline: boolean expression, defaults to false
 *
 * If 'offline' is true, then the indicator will display the offline state.
 * Otherwise 'loading' determines whether the indicator shows progress or not.
 *
 * Usage example:
 * <span g-activity-indicator offline="isOffline"></span>
 *
 * @param {!GoogAdapter} gGoogAdapter The gGoogAdapter service.
 * @return {!angular.Directive} The directive configuration.
 */
function directive(gGoogAdapter) {
  // Determine if the component is being used from Angular Components (and not
  // from JFK Wrappers).
  var libraryNgComp = gGoogAdapter.prefixed('') === 'g';

  // Return full attribute name for Angular Components, and the original name
  // for JFK Wrappers.
  // TODO(idos): Remove once the jfkActivityIndicator is deprecated.
  var getAttributeName = function(attr) {
    return libraryNgComp ? 'gActivityIndicator' + googString.toTitleCase(attr) :
                           attr;
  };

  return {
    replace: true,
    restrict: 'EAM',
    scope: {
      loading: '&' + getAttributeName('loading'),
      offline: '&' + getAttributeName('offline'),
      size: '@' + getAttributeName('size'),
      backgroundColor: '@' + getAttributeName('backgroundColor')
    },
    template: '<span></span>',

    link: function($scope, $element, $attrs) {
      var status = new ActivityStatus();
      var indicator = new ActivityIndicator(status);
      var updateBackgroundColor = function(color) {
        indicator.setBackgroundColor(color || '#fff');
      };
      indicator.setSize(
          $scope.size === 'small' ? ActivityIndicator.Size.SMALL :
                                    ActivityIndicator.Size.NORMAL);
      updateBackgroundColor($scope.backgroundColor);
      indicator.render($element[0]);

      // Since the component uses an isolate scope, the parent scope must be
      // used to evaluate event, ng-disabled, and ng-value expressions.
      gGoogAdapter.componentLink($scope.$parent, $attrs, indicator);

      // The status isn't a component, and will be disposed by the indicator.
      // However, the interesting event (change) is on the status.
      gGoogAdapter.forwardEvents($scope.$parent, $attrs, status);

      // Watch for changes in the loading and offline scope properties and
      // update the state accordingly.
      $scope.$watch(function(scope) {
        if (scope.offline()) {
          return ActivityStatus.State.OFFLINE;
        } else {
          var loading = scope.loading();
          return loading === undefined || loading ?
              ActivityStatus.State.LOADING :
              ActivityStatus.State.NONE;
        }
      }, function(state) {
        status.setState(state);
      });

      // Watch for changes in the background color.
      $scope.$watch(function(scope) {
        return scope.backgroundColor;
      }, updateBackgroundColor);
    }
  };
}

exports = directive;

;return exports;});

//javascript/angular/components/googadapter/googadapter.js
/**
 * @fileoverview Service with helper functions for Angular components wrapping
 * Closure components.
 */
goog.provide('ng.g.GoogAdapter');
goog.provide('ng.g.googAdapter.module');

goog.require('goog.events');
goog.require('goog.object');
goog.require('goog.string');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.EventTarget');
goog.requireType('goog.ui.Control');

goog.scope(function() {
/**
 * A service providing common functionality for linking Closure widgets to
 * corresponding angular directives.
 */
ng.g.GoogAdapter = class {
  /**
   * @ngInject
   * @param {!angular.$parse} $parse
   * @param {string} prefix The prefix to use for attribute names, 'g' or 'jfk'.
   */
  constructor($parse, prefix) {
    /** @private {!angular.$parse} */ this.$parse_ = $parse;
    /** @private {string} */ this.prefix_ = prefix;
  }

  /**
   * Returns an prefixed attribute name for the given attribute name.
   * @param {string} attrName
   * @return {string}
   */
  prefixed(attrName) {
    return this.prefix_ + attrName;
  }

  /**
   * Converts a regular value into a value usable for
   * {@link goog.ui.Component#setModel}.
   * @param {*} value The plain JavaScript value.
   * @return {*} A value adapted for Closure models, see comment above.
   */
  valueToModel(value) {
    return value != null ? value : GoogAdapter.SENTINEL_NULL_MODEL_VALUE_;
  }

  /**
   * Converts a value that has been sent through valueToModel back.
   * @param {*} model The Closure model compatible value.
   * @return {*} The regular JavaScript value.
   */
  modelToValue(model) {
    return model == GoogAdapter.SENTINEL_NULL_MODEL_VALUE_ ? null : model;
  }

  /**
   * Parse a named attribute from an Angular Attributes object.
   * @param {!angular.Attributes} $attrs Angular's attributes object.
   * @param {string} attrName Attribute name.
   * @return {angular.parse.Expression}
   * @private
   */
  parseAttribute_($attrs, attrName) {
    return this.$parse_($attrs[attrName]);
  }

  /**
   * Shared functionality for linking components. This checks for event handling
   * attributes and supports setEnabled/ng-disabled.
   *
   * @param {!angular.Scope} $scope Angular's scope object.
   * @param {!angular.Attributes} $attrs Angular's attributes object.
   * @param {!goog.events.EventTarget|goog.ui.Control} target The component
   *     being linked. Note that this is not always a `goog.ui.Component`!
   *
   * NB: If the line above gives you a compile error, you need a forward
   * declaration for goog.ui.Control. See http://go/forwarddeclarations
   */
  componentLink($scope, $attrs, target) {
    var self = this;
    // Support ng-disabled for components that can be enabled.
    if (/** @type {?} */ (target.setEnabled) &&
        $attrs.hasOwnProperty('ngDisabled')) {
      $scope.$watch($attrs['ngDisabled'], function(newValue) {
        /** @type {?} */ (target.setEnabled)(
            newValue === undefined || !newValue);
      });
    }

    if (/** @type {?} */ (target.setModel) &&
        $attrs.hasOwnProperty(self.prefixed('ModelValue'))) {
      $scope.$watch($attrs[self.prefixed('ModelValue')], function(newValue) {
        /** @type {?} */ (target.setModel)(self.valueToModel(newValue));
      });
    }

    // Some JFK widgets (e.g. jfk-button) set tabindex="0". This makes it
    // possible to override it.
    if (/** @type {?} */ (target.getElement) &&
        $attrs.hasOwnProperty('tabindex')) {
      $attrs.$observe('tabindex', function(/** ? */ newTabIndex) {
        /** @type {?} */ (target.getElement)().setAttribute(
            'tabindex', newTabIndex);
      });
    }

    // If specified, this attribute publishes the underlying Closure widget onto
    // the containing scope.
    if ($attrs.hasOwnProperty(self.prefixed('ComponentAs'))) {
      self.register($scope, $attrs[self.prefixed('ComponentAs')], target);
    }

    self.forwardEvents($scope, $attrs, target);

    // Dispose the component when its scope is destroyed.
    $scope.$on('$destroy', function() {
      // Removes the Angular data attached to the component.
      //
      // The Angular cleanup system works by invoking jQuery/jqLite remove on
      // the root element being disposed of. This triggers a recursive descent
      // of the tree rooted on the element where at each step all the jQuery
      // data for the element is cleaned up.
      //
      // This mechanism of course does not work if the nodes were moved out
      // from the subtree or if the nodes were detached. Note that the latter
      // is particularly hard to discover as some Closure components remove
      // nodes from the DOM on dispose.
      if (typeof /** @type {?} */ (target.getElement) === 'function') {
        var element = /** @type {?} */ (target.getElement)();
        if (element) GoogAdapter.cleanup_(element);
      }
      target.dispose();
    });
  }

  /**
   * Cleans up the JQuery cache associated with the element and its children
   * without triggering Angular $destroy events. This is necessary to avoid
   * infinite loops due to the fact that we already are in a $destroy handler.
   *
   * @param {!Element} element
   * @private
   */
  static cleanup_(element) {
    var wrap = angular.element(element);
    // We distinguish between jqLite and jQuery by checking the existence
    // of the original, unpatched version of remove in jQuery
    if (typeof wrap.remove['$original'] === 'function') {
      // using jQuery
      //
      // remove is the remove function patched by Angular.
      // remove.$original is the original jQuery remove function.
      // The only change in the Angular version is that the $destroy handler, if
      // any, is invoked. As we don't want the $destroy handler to be called we
      // invoke the original function.
      wrap.remove['$original'].apply(wrap);
    } else {
      // using JQLite
      GoogAdapter.cleanupJQLite_(element);
    }
  }

  /**
   * Cleanup implemenation for JQLite.
   *
   * @param {!Element} element
   * @private
   */
  static cleanupJQLite_(element) {
    var wrap = angular.element(element);
    wrap.unbind();
    wrap.removeData();
    for (var i = 0, children = element.childNodes || []; i < children.length;
         i++) {
      GoogAdapter.cleanupJQLite_(/** @type {!Element} */ (children[i]));
    }
  }

  /**
   * Look for jfk-on-* attributes in $attrs, and evaluate them in $scope when
   * the corresponding event occurs. This enables attributes like
   * g-on-action="doFoo()". The closure event is available as $event.
   *
   * @param {!angular.Scope} $scope Angular's scope object.
   * @param {!angular.Attributes} $attrs Angular's attributes object.
   * @param {!goog.events.EventTarget} eventTarget The event source to listen
   *     on.
   */
  forwardEvents($scope, $attrs, eventTarget) {
    var self = this;
    goog.object.forEach($attrs, function(value, attributeName) {
      if (!goog.string.startsWith(attributeName, self.prefixed('On'))) {
        return;
      }
      var eventName = attributeName.slice(self.prefixed('On').length);
      eventName = eventName[0].toLowerCase() + eventName.slice(1);
      var handler = self.parseAttribute_($attrs, attributeName);
      self.listenUntilDestroy($scope, eventTarget, eventName, function(event) {
        self.runEventHandler_($scope, handler, event);
      });
    });
  }

  /**
   * Immediately evaluate expression declared as attr-name="doFoo()" as a
   *response to a raised closure event. The closure event object is available as
   *$event.
   * @param {!angular.Scope} $scope Angular's scope object.
   * @param {!angular.Attributes} $attrs Angular's attributes object.
   * @param {string} attrName Attribute name.
   * @param {!goog.events.Event} event The event to forward.
   **/
  forwardSingleEvent($scope, $attrs, attrName, event) {
    var handler = this.parseAttribute_($attrs, attrName);
    this.runEventHandler_($scope, handler, event);
  }

  /**
   * Execute an angular event handler with the event exposed to the $scope as
   * $event.
   * @param {!angular.Scope} $scope Angular's scope object.
   * @param {!angular.parse.Expression} handler Event handler function.
   * @param {!goog.events.Event} event The event to forward to the handler as
   *     $event.
   * @private
   */
  runEventHandler_($scope, handler, event) {
    this.evalInDigest($scope, function() {
      handler($scope, {'$event': event});
    });
  }

  /**
   * $eval's the given expression in the current $digest cycle if one is
   * running, starts a new cycle through $apply otherwise. This should only be
   * used when it's impossible to distinguish user triggered from
   * programatically triggered events in Closure components.
   * @param {!angular.Scope} $scope The Angular scope to listen in.
   * @param {string|function(): ?} expr The expression to $eval/$apply.
   */
  evalInDigest($scope, expr) {
    return $scope.$root['$$phase'] ? $scope.$eval(expr) : $scope.$apply(expr);
  }

  /**
   * Listens to `event` on `src` until `$scope` gets
   * destroyed.
   * @param {!angular.Scope} $scope The Angular scope.
   * @param {(!goog.events.EventTarget|!EventTarget)} src
   *     The UI component or native event target to listen on.
   * @param {string|!Array.<string>} event The event type to listen to.
   * @param {function(?)} handler The event handler.
   */
  listenUntilDestroy($scope, src, event, handler) {
    var key = goog.events.listen(src, event, handler);
    $scope.$on('$destroy', function() {
      goog.events.unlistenByKey(key);
    });
  }

  /**
   * Registers `value` on the angular scope based on the result of the
   * angular expression `expr`.
   * @param {!angular.Scope} $scope The Angular scope to assign to.
   * @param {string} expr The Angular expression defining where on the scope we
   *     should assign to.
   * @param {*} value The value or object to register on the scope.
   */
  register($scope, expr, value) {
    var setter = this.$parse_(expr).assign;
    if (!setter) {
      throw new Error('Angular scope expression non-assignable.');
    }
    setter($scope, value);
  }
};
var GoogAdapter = ng.g.GoogAdapter;



/**
 * Some Closure components (e.g. {@link goog.ui.SelectModel}) use
 * {@link goog.ui.Component#getValue} instead of
 * {@link goog.ui.Component#getModel}, which returns the caption of a component
 * if the model value is null. This value is used as a sentinel model value to
 * replace null model values. As it's compared using '==' it will never equal
 * any other model value.
 * @const
 * @private
 */
GoogAdapter.SENTINEL_NULL_MODEL_VALUE_ = {};



/**
 * In Angular < 1.2:
 * Lower priority than inputDirective (priority 0), so we can replace its
 * ngModel.$render assignment.
 *
 * In Angular 1.2+:
 * Link functions run in reverse order, so to run last it needs a positive
 * priority.
 *
 * @const
 */
GoogAdapter.PRIORITY_BEFORE_NG_MODEL =
    angular.version.major > 1 || angular.version.minor >= 2 ? 1 : -1;
});  // goog.scope


/**
 * AngularJS module providing the gGoogAdapter service.
 * @const {!angular.Module}
 */
ng.g.googAdapter.module = angular.module('ng.g.GoogAdapter', []);


/** Define the gGoogAdapter service. */
ng.g.googAdapter.module.factory('gGoogAdapter', [
  '$parse',
  function($parse) {
    return new ng.g.GoogAdapter($parse, 'g');
  }
]);

//javascript/angular/jfkwrappers/ngjfkcommon.js
goog.provide('ng.jfk.Common');
goog.provide('ng.jfk.CommonService');

goog.require('ng.g.GoogAdapter');

/**
 * Module containing the JFK Common service bound to 'jfkCommon'.
 * @type {!angular.Module}
 */
ng.jfk.Common = angular.module('jfkCommon', []);
ng.jfk.Common.factory('jfkCommon', ['$parse', function($parse) {
  return new ng.g.GoogAdapter($parse, 'jfk');
}]);

/**
 * Typedef for legacy code to be used during migration to
 * //javascript/angular/components.
 * @typedef {!ng.g.GoogAdapter}
 */
ng.jfk.CommonService;

/**
 * Aliases ng.g.GoogAdapter.PRIORITY_BEFORE_NG_MODEL during migration.
 * @const {number}
 */
ng.jfk.Common.PRIORITY_BEFORE_NG_MODEL =
    ng.g.GoogAdapter.PRIORITY_BEFORE_NG_MODEL;

//javascript/angular/jfkwrappers/activityindicator/activityindicator.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Implements the jfk-activity-indicator directive. This displays
 * an activity indicator which can signal loading, offline, or no state.
 *
 * <p>Attributes:<ul>
 * <li>size: 'small' or 'normal'
 * <li>loading: boolean expression, defaults to true
 * <li>offline: boolean expression, defaults to false</ul>
 *
 * <p>If 'offline' is true, then the indicator will display the offline state.
 * Otherwise 'loading' determines whether the indicator shows progress or not.
 *
 * Usage example:
 * <pre>&lt;span jfk-activity-indicator offline="isOffline">&lt;/span></pre>
 */

goog.module('ng.jfk.ActivityIndicator');
goog.module.declareLegacyNamespace();

const Common = goog.require('ng.jfk.Common');
const directive = goog.require('ng.g.activityIndicator.directive');

/** @type {!angular.Module} */
const ActivityIndicator = angular.module('jfkActivityIndicator', [Common.name]);

ActivityIndicator.directive('jfkActivityIndicator', ['jfkCommon', directive]);

exports = ActivityIndicator;

;return exports;});

//third_party/javascript/closure/ui/ac/arraymatcher.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Basic class for matching words in an array.
 */


goog.provide('goog.ui.ac.ArrayMatcher');

goog.require('goog.string');



/**
 * Basic class for matching words in an array
 * @constructor
 * @param {Array<?>} rows Dictionary of items to match.  Can be objects if they
 *     have a toString method that returns the value to match against.
 * @param {boolean=} opt_noSimilar if true, do not do similarity matches for the
 *     input token against the dictionary.
 */
goog.ui.ac.ArrayMatcher = function(rows, opt_noSimilar) {
  'use strict';
  /** @type {!Array<?>} */
  this.rows_ = rows || [];
  this.useSimilar_ = !opt_noSimilar;
};


/**
 * Replaces the rows that this object searches over.
 * @param {Array<?>} rows Dictionary of items to match.
 */
goog.ui.ac.ArrayMatcher.prototype.setRows = function(rows) {
  'use strict';
  this.rows_ = rows || [];
};


/**
 * Function used to pass matches to the autocomplete
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @param {Function} matchHandler callback to execute after matching.
 * @param {string=} opt_fullString The full string from the input box.
 */
goog.ui.ac.ArrayMatcher.prototype.requestMatchingRows = function(
    token, maxMatches, matchHandler, opt_fullString) {
  'use strict';
  var matches = this.useSimilar_ ?
      goog.ui.ac.ArrayMatcher.getMatchesForRows(token, maxMatches, this.rows_) :
      this.getPrefixMatches(token, maxMatches);

  matchHandler(token, matches);
};


/**
 * Matches the token against the specified rows, first looking for prefix
 * matches and if that fails, then looking for similar matches.
 *
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @param {!Array<?>} rows Rows to search for matches. Can be objects if they
 *     have a toString method that returns the value to match against.
 * @return {!Array<?>} Rows that match.
 */
goog.ui.ac.ArrayMatcher.getMatchesForRows = function(token, maxMatches, rows) {
  'use strict';
  var matches =
      goog.ui.ac.ArrayMatcher.getPrefixMatchesForRows(token, maxMatches, rows);

  if (matches.length == 0) {
    matches = goog.ui.ac.ArrayMatcher.getSimilarMatchesForRows(
        token, maxMatches, rows);
  }
  return matches;
};


/**
 * Matches the token against the start of words in the row.
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @return {!Array<?>} Rows that match.
 */
goog.ui.ac.ArrayMatcher.prototype.getPrefixMatches = function(
    token, maxMatches) {
  'use strict';
  return goog.ui.ac.ArrayMatcher.getPrefixMatchesForRows(
      token, maxMatches, this.rows_);
};


/**
 * Matches the token against the start of words in the row.
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @param {!Array<?>} rows Rows to search for matches. Can be objects if they
 * have
 *     a toString method that returns the value to match against.
 * @return {!Array<?>} Rows that match.
 */
goog.ui.ac.ArrayMatcher.getPrefixMatchesForRows = function(
    token, maxMatches, rows) {
  'use strict';
  var matches = [];

  if (token != '') {
    var escapedToken = goog.string.regExpEscape(token);
    var matcher = new RegExp('(^|\\W+)' + escapedToken, 'i');

    for (var i = 0; i < rows.length && matches.length < maxMatches; i++) {
      var row = rows[i];
      if (String(row).match(matcher)) {
        matches.push(row);
      }
    }
  }
  return matches;
};


/**
 * Matches the token against similar rows, by calculating "distance" between the
 * terms.
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @return {!Array<?>} The best maxMatches rows.
 */
goog.ui.ac.ArrayMatcher.prototype.getSimilarRows = function(token, maxMatches) {
  'use strict';
  return goog.ui.ac.ArrayMatcher.getSimilarMatchesForRows(
      token, maxMatches, this.rows_);
};


/**
 * Matches the token against similar rows, by calculating "distance" between the
 * terms.
 * @param {string} token Token to match.
 * @param {number} maxMatches Max number of matches to return.
 * @param {!Array<?>} rows Rows to search for matches. Can be objects
 *     if they have a toString method that returns the value to
 *     match against.
 * @return {!Array<?>} The best maxMatches rows.
 */
goog.ui.ac.ArrayMatcher.getSimilarMatchesForRows = function(
    token, maxMatches, rows) {
  'use strict';
  var results = [];

  for (var index = 0; index < rows.length; index++) {
    var row = rows[index];
    var str = token.toLowerCase();
    var txt = String(row).toLowerCase();
    var score = 0;

    if (txt.indexOf(str) != -1) {
      score = parseInt((txt.indexOf(str) / 4).toString(), 10);

    } else {
      var arr = str.split('');

      var lastPos = -1;
      var penalty = 10;

      for (var i = 0, c; c = arr[i]; i++) {
        var pos = txt.indexOf(c);

        if (pos > lastPos) {
          var diff = pos - lastPos - 1;

          if (diff > penalty - 5) {
            diff = penalty - 5;
          }

          score += diff;

          lastPos = pos;
        } else {
          score += penalty;
          penalty += 5;
        }
      }
    }

    if (score < str.length * 6) {
      results.push({str: row, score: score, index: index});
    }
  }

  results.sort(function(a, b) {
    'use strict';
    var diff = a.score - b.score;
    if (diff != 0) {
      return diff;
    }
    return a.index - b.index;
  });

  var matches = [];
  for (var i = 0; i < maxMatches && i < results.length; i++) {
    matches.push(results[i].str);
  }

  return matches;
};

//third_party/javascript/closure/ui/ac/renderoptions.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Options for rendering matches.
 */

goog.provide('goog.ui.ac.RenderOptions');



/**
 * A simple class that contains options for rendering a set of autocomplete
 * matches.  Used as an optional argument in the callback from the matcher.
 * @constructor
 */
goog.ui.ac.RenderOptions = function() {};


/**
 * Whether the current highlighting is to be preserved when displaying the new
 * set of matches.
 * @type {boolean}
 * @private
 */
goog.ui.ac.RenderOptions.prototype.preserveHilited_ = false;


/**
 * Whether the first match is to be highlighted.  When undefined the autoHilite
 * flag of the autocomplete is used.
 * @type {boolean|undefined}
 * @private
 */
goog.ui.ac.RenderOptions.prototype.autoHilite_;


/**
 * @param {boolean} flag The new value for the preserveHilited_ flag.
 */
goog.ui.ac.RenderOptions.prototype.setPreserveHilited = function(flag) {
  'use strict';
  this.preserveHilited_ = flag;
};


/**
 * @return {boolean} The value of the preserveHilited_ flag.
 */
goog.ui.ac.RenderOptions.prototype.getPreserveHilited = function() {
  'use strict';
  return this.preserveHilited_;
};


/**
 * @param {boolean} flag The new value for the autoHilite_ flag.
 */
goog.ui.ac.RenderOptions.prototype.setAutoHilite = function(flag) {
  'use strict';
  this.autoHilite_ = flag;
};


/**
 * @return {boolean|undefined} The value of the autoHilite_ flag.
 */
goog.ui.ac.RenderOptions.prototype.getAutoHilite = function() {
  'use strict';
  return this.autoHilite_;
};

//third_party/javascript/closure/ui/ac/autocomplete.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Gmail-like AutoComplete logic.
 *
 * @see ../../demos/autocomplete-basic.html
 */

goog.provide('goog.ui.ac.AutoComplete');
goog.provide('goog.ui.ac.AutoComplete.EventType');

goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventTarget');
goog.require('goog.object');
goog.require('goog.ui.ac.RenderOptions');
goog.requireType('goog.events.Event');
goog.requireType('goog.ui.ac.InputHandler');


/**
 * This is the central manager class for an AutoComplete instance. The matcher
 * can specify disabled rows that should not be hilited or selected by
 * implementing <code>isRowDisabled(row):boolean</code> for each autocomplete
 * row. No row will be considered disabled if this method is not implemented.
 *
 * @param {Object} matcher A data source and row matcher, implements
 *        <code>requestMatchingRows(token, maxMatches, matchCallback)</code>.
 * @param {goog.events.EventTarget} renderer An object that implements
 *        <code>
 *          isVisible():boolean<br>
 *          renderRows(rows:Array, token:string, target:Element);<br>
 *          hiliteId(row-id:number);<br>
 *          dismiss();<br>
 *          dispose():
 *        </code>.
 * @param {Object} selectionHandler An object that implements
 *        <code>
 *          selectRow(row);<br>
 *          update(opt_force);
 *        </code>.
 *
 * @constructor
 * @extends {goog.events.EventTarget}
 * @suppress {underscore}
 */
goog.ui.ac.AutoComplete = function(matcher, renderer, selectionHandler) {
  'use strict';
  goog.events.EventTarget.call(this);

  /**
   * A data-source which provides autocomplete suggestions.
   *
   * TODO(chrishenry): Tighten the type to !goog.ui.ac.AutoComplete.Matcher.
   *
   * @type {Object}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.matcher_ = matcher;

  /**
   * A handler which interacts with the input DOM element (textfield, textarea,
   * or richedit).
   *
   * TODO(chrishenry): Tighten the type to !Object.
   *
   * @type {Object}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * A renderer to render/show/highlight/hide the autocomplete menu.
   * @type {goog.events.EventTarget}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.renderer_ = renderer;
  goog.events.listen(
      renderer,
      [
        goog.ui.ac.AutoComplete.EventType.HILITE,
        goog.ui.ac.AutoComplete.EventType.SELECT,
        goog.ui.ac.AutoComplete.EventType.CANCEL_DISMISS,
        goog.ui.ac.AutoComplete.EventType.DISMISS
      ],
      this.handleEvent, false, this);

  /**
   * Currently typed token which will be used for completion.
   * @type {?string}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.token_ = null;

  /**
   * Autocomplete suggestion items.
   * @type {Array<?>}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.rows_ = [];

  /**
   * Id of the currently highlighted row.
   * @type {number}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.hiliteId_ = -1;

  /**
   * Id of the first row in autocomplete menu. Note that new ids are assigned
   * every time new suggestions are fetched.
   *
   * TODO(chrishenry): Figure out what subclass does with this value
   * and whether we should expose a more proper API.
   *
   * @type {number}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.firstRowId_ = 0;

  /**
   * The target HTML node for displaying.
   * @type {?Element}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.target_ = null;

  /**
   * The timer id for dismissing autocomplete menu with a delay.
   * @type {?number}
   * @private
   */
  this.dismissTimer_ = null;

  /**
   * Mapping from text input element to the anchor element. If the
   * mapping does not exist, the input element will act as the anchor
   * element.
   * @type {Object<Element>}
   * @private
   */
  this.inputToAnchorMap_ = {};
};
goog.inherits(goog.ui.ac.AutoComplete, goog.events.EventTarget);


/**
 * The maximum number of matches that should be returned
 * @type {number}
 * @private
 */
goog.ui.ac.AutoComplete.prototype.maxMatches_ = 10;


/**
 * True iff the first row should automatically be highlighted
 * @type {boolean}
 * @private
 */
goog.ui.ac.AutoComplete.prototype.autoHilite_ = true;


/**
 * True iff the user can unhilight all rows by pressing the up arrow.
 * @type {boolean}
 * @private
 */
goog.ui.ac.AutoComplete.prototype.allowFreeSelect_ = false;


/**
 * True iff item selection should wrap around from last to first. If
 *     allowFreeSelect_ is on in conjunction, there is a step of free selection
 *     before wrapping.
 * @type {boolean}
 * @private
 */
goog.ui.ac.AutoComplete.prototype.wrap_ = false;


/**
 * Whether completion from suggestion triggers fetching new suggestion.
 * @type {boolean}
 * @private
 */
goog.ui.ac.AutoComplete.prototype.triggerSuggestionsOnUpdate_ = false;


/**
 * Events associated with the autocomplete
 * @enum {string}
 */
goog.ui.ac.AutoComplete.EventType = {

  /** A row has been highlighted by the renderer */
  ROW_HILITE: 'rowhilite',

  // Note: The events below are used for internal autocomplete events only and
  // should not be used in non-autocomplete code.

  /** A row has been mouseovered and should be highlighted by the renderer. */
  HILITE: 'hilite',

  /** A row has been selected by the renderer */
  SELECT: 'select',

  /** A dismiss event has occurred */
  DISMISS: 'dismiss',

  /** Event that cancels a dismiss event */
  CANCEL_DISMISS: 'canceldismiss',

  /**
   * Field value was updated.  A row field is included and is non-null when a
   * row has been selected.  The value of the row typically includes fields:
   * contactData and formattedValue as well as a toString function (though none
   * of these fields are guaranteed to exist).  The row field may be used to
   * return custom-type row data.
   */
  UPDATE: 'update',

  /**
   * The list of suggestions has been updated, usually because either the list
   * has opened, or because the user has typed another character and the
   * suggestions have been updated, or the user has dismissed the autocomplete.
   */
  SUGGESTIONS_UPDATE: 'suggestionsupdate'
};


/**
 * @typedef {{
 *   requestMatchingRows:(!Function|undefined),
 *   isRowDisabled:(!Function|undefined)
 * }}
 */
goog.ui.ac.AutoComplete.Matcher;


/**
 * @return {!Object} The data source providing the `autocomplete
 *     suggestions.
 */
goog.ui.ac.AutoComplete.prototype.getMatcher = function() {
  'use strict';
  return goog.asserts.assert(this.matcher_);
};


/**
 * Sets the data source providing the autocomplete suggestions.
 *
 * See constructor documentation for the interface.
 *
 * @param {!Object} matcher The matcher.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.setMatcher = function(matcher) {
  'use strict';
  this.matcher_ = matcher;
};


/**
 * @return {!Object} The handler used to interact with the input DOM
 *     element (textfield, textarea, or richedit), e.g. to update the
 *     input DOM element with selected value.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.getSelectionHandler = function() {
  'use strict';
  return goog.asserts.assert(this.selectionHandler_);
};


/**
 * @return {goog.events.EventTarget} The renderer that
 *     renders/shows/highlights/hides the autocomplete menu.
 *     See constructor documentation for the expected renderer API.
 */
goog.ui.ac.AutoComplete.prototype.getRenderer = function() {
  'use strict';
  return this.renderer_;
};


/**
 * Sets the renderer that renders/shows/highlights/hides the autocomplete
 * menu.
 *
 * See constructor documentation for the expected renderer API.
 *
 * @param {goog.events.EventTarget} renderer The renderer.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.setRenderer = function(renderer) {
  'use strict';
  this.renderer_ = renderer;
};


/**
 * @return {?string} The currently typed token used for completion.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.getToken = function() {
  'use strict';
  return this.token_;
};


/**
 * Sets the current token (without changing the rendered autocompletion).
 *
 * NOTE(chrishenry): This method will likely go away when we figure
 * out a better API.
 *
 * @param {?string} token The new token.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.setTokenInternal = function(token) {
  'use strict';
  this.token_ = token;
};


/**
 * @param {number} index The suggestion index, must be within the
 *     interval [0, this.getSuggestionCount()).
 * @return {Object} The currently suggested item at the given index
 *     (or null if there is none).
 */
goog.ui.ac.AutoComplete.prototype.getSuggestion = function(index) {
  'use strict';
  return this.rows_[index];
};


/**
 * @return {!Array<?>} The current autocomplete suggestion items.
 */
goog.ui.ac.AutoComplete.prototype.getAllSuggestions = function() {
  'use strict';
  return goog.asserts.assert(this.rows_);
};


/**
 * @return {number} The number of currently suggested items.
 */
goog.ui.ac.AutoComplete.prototype.getSuggestionCount = function() {
  'use strict';
  return this.rows_.length;
};


/**
 * @return {number} The id (not index!) of the currently highlighted row.
 */
goog.ui.ac.AutoComplete.prototype.getHighlightedId = function() {
  'use strict';
  return this.hiliteId_;
};


/**
 * Generic event handler that handles any events this object is listening to.
 * @param {goog.events.Event} e Event Object.
 * @suppress {missingProperties} e.row
 */
goog.ui.ac.AutoComplete.prototype.handleEvent = function(e) {
  'use strict';
  var matcher = /** @type {?goog.ui.ac.AutoComplete.Matcher} */ (this.matcher_);

  if (e.target == this.renderer_) {
    switch (e.type) {
      case goog.ui.ac.AutoComplete.EventType.HILITE:
        this.hiliteId(/** @type {number} */ (e.row));
        break;

      case goog.ui.ac.AutoComplete.EventType.SELECT:
        var rowDisabled = false;

        // e.row can be either a valid row id or empty.
        if (typeof e.row === 'number') {
          var rowId = e.row;
          var index = this.getIndexOfId(rowId);
          var row = this.rows_[index];

          // Make sure the row selected is not a disabled row.
          rowDisabled =
              !!row && matcher.isRowDisabled && matcher.isRowDisabled(row);
          if (row && !rowDisabled && this.hiliteId_ != rowId) {
            // Event target row not currently highlighted - fix the mismatch.
            this.hiliteId(rowId);
          }
        }
        if (!rowDisabled) {
          // Note that rowDisabled can be false even if e.row does not
          // contain a valid row ID; at least one client depends on us
          // proceeding anyway.
          this.selectHilited();
        }
        break;

      case goog.ui.ac.AutoComplete.EventType.CANCEL_DISMISS:
        this.cancelDelayedDismiss();
        break;

      case goog.ui.ac.AutoComplete.EventType.DISMISS:
        this.dismissOnDelay();
        break;
    }
  }
};


/**
 * Sets the max number of matches to fetch from the Matcher.
 *
 * @param {number} max Max number of matches.
 */
goog.ui.ac.AutoComplete.prototype.setMaxMatches = function(max) {
  'use strict';
  this.maxMatches_ = max;
};


/**
 * Sets whether or not the first row should be highlighted by default.
 *
 * @param {boolean} autoHilite true iff the first row should be
 *      highlighted by default.
 */
goog.ui.ac.AutoComplete.prototype.setAutoHilite = function(autoHilite) {
  'use strict';
  this.autoHilite_ = autoHilite;
};


/**
 * Sets whether or not the up/down arrow can unhilite all rows.
 *
 * @param {boolean} allowFreeSelect true iff the up arrow can unhilite all rows.
 */
goog.ui.ac.AutoComplete.prototype.setAllowFreeSelect = function(
    allowFreeSelect) {
  'use strict';
  this.allowFreeSelect_ = allowFreeSelect;
};


/**
 * Sets whether or not selections can wrap around the edges.
 *
 * @param {boolean} wrap true iff sections should wrap around the edges.
 */
goog.ui.ac.AutoComplete.prototype.setWrap = function(wrap) {
  'use strict';
  this.wrap_ = wrap;
};


/**
 * Sets whether or not to request new suggestions immediately after completion
 * of a suggestion.
 *
 * @param {boolean} triggerSuggestionsOnUpdate true iff completion should fetch
 *     new suggestions.
 */
goog.ui.ac.AutoComplete.prototype.setTriggerSuggestionsOnUpdate = function(
    triggerSuggestionsOnUpdate) {
  'use strict';
  this.triggerSuggestionsOnUpdate_ = triggerSuggestionsOnUpdate;
};


/**
 * Sets the token to match against.  This triggers calls to the Matcher to
 * fetch the matches (up to maxMatches), and then it triggers a call to
 * <code>renderer.renderRows()</code>.
 *
 * @param {string} token The string for which to search in the Matcher.
 * @param {string=} opt_fullString Optionally, the full string in the input
 *     field.
 */
goog.ui.ac.AutoComplete.prototype.setToken = function(token, opt_fullString) {
  'use strict';
  if (this.token_ == token) {
    return;
  }
  this.token_ = token;
  this.matcher_.requestMatchingRows(
      this.token_, this.maxMatches_, goog.bind(this.matchListener_, this),
      opt_fullString);
  this.cancelDelayedDismiss();
};


/**
 * Gets the current target HTML node for displaying autocomplete UI.
 * @return {Element} The current target HTML node for displaying autocomplete
 *     UI.
 */
goog.ui.ac.AutoComplete.prototype.getTarget = function() {
  'use strict';
  return this.target_;
};


/**
 * Sets the current target HTML node for displaying autocomplete UI.
 * Can be an implementation specific definition of how to display UI in relation
 * to the target node.
 * This target will be passed into  <code>renderer.renderRows()</code>
 *
 * @param {Element} target The current target HTML node for displaying
 *     autocomplete UI.
 */
goog.ui.ac.AutoComplete.prototype.setTarget = function(target) {
  'use strict';
  this.target_ = target;
};


/**
 * @return {boolean} Whether the autocomplete's renderer is open.
 * @suppress {missingProperties}
 */
goog.ui.ac.AutoComplete.prototype.isOpen = function() {
  'use strict';
  return this.renderer_.isVisible();
};


/**
 * @return {number} Number of rows in the autocomplete.
 * @deprecated Use this.getSuggestionCount().
 */
goog.ui.ac.AutoComplete.prototype.getRowCount = function() {
  'use strict';
  return this.getSuggestionCount();
};


/**
 * Moves the hilite to the next non-disabled row.
 * Calls renderer.hiliteId() when there's something to do.
 * @return {boolean} Returns true on a successful hilite.
 */
goog.ui.ac.AutoComplete.prototype.hiliteNext = function() {
  'use strict';
  var lastId = this.firstRowId_ + this.rows_.length - 1;
  var toHilite = this.hiliteId_;
  // Hilite the next row, skipping any disabled rows.
  for (var i = 0; i < this.rows_.length; i++) {
    // Increment to the next row.
    if (toHilite >= this.firstRowId_ && toHilite < lastId) {
      toHilite++;
    } else if (toHilite == -1) {
      toHilite = this.firstRowId_;
    } else if (this.allowFreeSelect_ && toHilite == lastId) {
      this.hiliteId(-1);
      return false;
    } else if (this.wrap_ && toHilite == lastId) {
      toHilite = this.firstRowId_;
    } else {
      return false;
    }

    if (this.hiliteId(toHilite)) {
      return true;
    }
  }
  return false;
};


/**
 * Moves the hilite to the previous non-disabled row.  Calls
 * renderer.hiliteId() when there's something to do.
 * @return {boolean} Returns true on a successful hilite.
 */
goog.ui.ac.AutoComplete.prototype.hilitePrev = function() {
  'use strict';
  var lastId = this.firstRowId_ + this.rows_.length - 1;
  var toHilite = this.hiliteId_;
  // Hilite the previous row, skipping any disabled rows.
  for (var i = 0; i < this.rows_.length; i++) {
    // Decrement to the previous row.
    if (toHilite > this.firstRowId_) {
      toHilite--;
    } else if (this.allowFreeSelect_ && toHilite == this.firstRowId_) {
      this.hiliteId(-1);
      return false;
    } else if (this.wrap_ && (toHilite == -1 || toHilite == this.firstRowId_)) {
      toHilite = lastId;
    } else {
      return false;
    }

    if (this.hiliteId(toHilite)) {
      return true;
    }
  }
  return false;
};


/**
 * Hilites the id if it's valid and the row is not disabled, otherwise does
 * nothing.
 * @param {number} id A row id (not index).
 * @return {boolean} Whether the id was hilited. Returns false if the row is
 *     disabled.
 */
goog.ui.ac.AutoComplete.prototype.hiliteId = function(id) {
  'use strict';
  var index = this.getIndexOfId(id);
  var row = this.rows_[index];
  var rowDisabled =
      !!row && this.matcher_.isRowDisabled && this.matcher_.isRowDisabled(row);
  if (!rowDisabled) {
    this.hiliteId_ = id;
    this.renderer_.hiliteId(id);
    return index != -1;
  }
  return false;
};


/**
 * Hilites the index, if it's valid and the row is not disabled, otherwise does
 * nothing.
 * @param {number} index The row's index.
 * @return {boolean} Whether the index was hilited.
 */
goog.ui.ac.AutoComplete.prototype.hiliteIndex = function(index) {
  'use strict';
  return this.hiliteId(this.getIdOfIndex_(index));
};


/**
 * If there are any current matches, this passes the hilited row data to
 * <code>selectionHandler.selectRow()</code>
 * @return {boolean} Whether there are any current matches.
 */
goog.ui.ac.AutoComplete.prototype.selectHilited = function() {
  'use strict';
  var index = this.getIndexOfId(this.hiliteId_);
  if (index != -1) {
    var selectedRow = this.rows_[index];
    var suppressUpdate =
        /** @type {!goog.ui.ac.InputHandler} */ (this.selectionHandler_)
            .selectRow(selectedRow);
    if (this.triggerSuggestionsOnUpdate_) {
      this.token_ = null;
      this.dismissOnDelay();
    } else {
      this.dismiss();
    }
    if (!suppressUpdate) {
      this.dispatchEvent({
        type: goog.ui.ac.AutoComplete.EventType.UPDATE,
        row: selectedRow,
        index: index
      });
      if (this.triggerSuggestionsOnUpdate_) {
        this.selectionHandler_.update(true);
      }
    }
    return true;
  } else {
    this.dismiss();
    this.dispatchEvent({
      type: goog.ui.ac.AutoComplete.EventType.UPDATE,
      row: null,
      index: null
    });
    return false;
  }
};


/**
 * Returns whether or not the autocomplete is open and has a highlighted row.
 * @return {boolean} Whether an autocomplete row is highlighted.
 */
goog.ui.ac.AutoComplete.prototype.hasHighlight = function() {
  'use strict';
  return this.isOpen() && this.getIndexOfId(this.hiliteId_) != -1;
};


/**
 * Clears out the token, rows, and hilite, and calls
 * <code>renderer.dismiss()</code>
 */
goog.ui.ac.AutoComplete.prototype.dismiss = function() {
  'use strict';
  this.hiliteId_ = -1;
  this.token_ = null;
  this.firstRowId_ += this.rows_.length;
  this.rows_ = [];
  window.clearTimeout(this.dismissTimer_);
  this.dismissTimer_ = null;
  this.renderer_.dismiss();
  this.dispatchEvent(goog.ui.ac.AutoComplete.EventType.SUGGESTIONS_UPDATE);
  this.dispatchEvent(goog.ui.ac.AutoComplete.EventType.DISMISS);
};


/**
 * Call a dismiss after a delay, if there's already a dismiss active, ignore.
 */
goog.ui.ac.AutoComplete.prototype.dismissOnDelay = function() {
  'use strict';
  if (!this.dismissTimer_) {
    this.dismissTimer_ = window.setTimeout(goog.bind(this.dismiss, this), 100);
  }
};


/**
 * Cancels any delayed dismiss events immediately.
 * @return {boolean} Whether a delayed dismiss was cancelled.
 * @private
 */
goog.ui.ac.AutoComplete.prototype.immediatelyCancelDelayedDismiss_ =
    function() {
  'use strict';
  if (this.dismissTimer_) {
    window.clearTimeout(this.dismissTimer_);
    this.dismissTimer_ = null;
    return true;
  }
  return false;
};


/**
 * Cancel the active delayed dismiss if there is one.
 */
goog.ui.ac.AutoComplete.prototype.cancelDelayedDismiss = function() {
  'use strict';
  // Under certain circumstances a cancel event occurs immediately prior to a
  // delayedDismiss event that it should be cancelling. To handle this situation
  // properly, a timer is used to stop that event.
  // Using only the timer creates undesirable behavior when the cancel occurs
  // less than 10ms before the delayed dismiss timout ends. If that happens the
  // clearTimeout() will occur too late and have no effect.
  if (!this.immediatelyCancelDelayedDismiss_()) {
    window.setTimeout(
        goog.bind(this.immediatelyCancelDelayedDismiss_, this), 10);
  }
};


/** @override */
goog.ui.ac.AutoComplete.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.ac.AutoComplete.superClass_.disposeInternal.call(this);
  delete this.inputToAnchorMap_;
  this.renderer_.dispose();
  this.selectionHandler_.dispose();
  this.matcher_ = null;
};


/**
 * Callback passed to Matcher when requesting matches for a token.
 * This might be called synchronously, or asynchronously, or both, for
 * any implementation of a Matcher.
 * If the Matcher calls this back, with the same token this AutoComplete
 * has set currently, then this will package the matching rows in object
 * of the form
 * <pre>
 * {
 *   id: an integer ID unique to this result set and AutoComplete instance,
 *   data: the raw row data from Matcher
 * }
 * </pre>
 *
 * @param {string} matchedToken Token that corresponds with the rows.
 * @param {!Array<?>} rows Set of data that match the given token.
 * @param {(boolean|goog.ui.ac.RenderOptions)=} opt_options If true,
 *     keeps the currently hilited (by index) element hilited. If false not.
 *     Otherwise a RenderOptions object.
 * @private
 */
goog.ui.ac.AutoComplete.prototype.matchListener_ = function(
    matchedToken, rows, opt_options) {
  'use strict';
  if (this.token_ != matchedToken) {
    // Matcher's response token doesn't match current token.
    // This is probably an async response that came in after
    // the token was changed, so don't do anything.
    return;
  }

  this.renderRows(rows, opt_options);
};


/**
 * Renders the rows and adds highlighting.
 * @param {!Array<?>} rows Set of data that match the given token.
 * @param {(boolean|goog.ui.ac.RenderOptions)=} opt_options If true,
 *     keeps the currently hilited (by index) element hilited. If false not.
 *     Otherwise a RenderOptions object.
 * @suppress {missingProperties}
 */
goog.ui.ac.AutoComplete.prototype.renderRows = function(rows, opt_options) {
  'use strict';
  // The optional argument should be a RenderOptions object.  It can be a
  // boolean for backwards compatibility, defaulting to false.
  var optionsObj = goog.typeOf(opt_options) == 'object' && opt_options;

  var preserveHilited =
      optionsObj ? optionsObj.getPreserveHilited() : opt_options;
  var indexToHilite = preserveHilited ? this.getIndexOfId(this.hiliteId_) : -1;

  // Current token matches the matcher's response token.
  this.firstRowId_ += this.rows_.length;
  this.rows_ = rows;
  var rendRows = [];
  for (var i = 0; i < rows.length; ++i) {
    rendRows.push({id: this.getIdOfIndex_(i), data: rows[i]});
  }

  var anchor = null;
  if (this.target_) {
    anchor = this.inputToAnchorMap_[goog.getUid(this.target_)] || this.target_;
  }
  this.renderer_.setAnchorElement(anchor);
  this.renderer_.renderRows(rendRows, this.token_, this.target_);

  var autoHilite = this.autoHilite_;
  if (optionsObj && optionsObj.getAutoHilite() !== undefined) {
    autoHilite = optionsObj.getAutoHilite();
  }
  this.hiliteId_ = -1;
  if ((autoHilite || indexToHilite >= 0) && rendRows.length != 0 &&
      this.token_) {
    if (indexToHilite >= 0) {
      this.hiliteId(this.getIdOfIndex_(indexToHilite));
    } else {
      // Hilite the first non-disabled row.
      this.hiliteNext();
    }
  }
  this.dispatchEvent(goog.ui.ac.AutoComplete.EventType.SUGGESTIONS_UPDATE);
};


/**
 * Gets the index corresponding to a particular id.
 * @param {number} id A unique id for the row.
 * @return {number} A valid index into rows_, or -1 if the id is invalid.
 * @protected
 */
goog.ui.ac.AutoComplete.prototype.getIndexOfId = function(id) {
  'use strict';
  var index = id - this.firstRowId_;
  if (index < 0 || index >= this.rows_.length) {
    return -1;
  }
  return index;
};


/**
 * Gets the id corresponding to a particular index.  (Does no checking.)
 * @param {number} index The index of a row in the result set.
 * @return {number} The id that currently corresponds to that index.
 * @private
 */
goog.ui.ac.AutoComplete.prototype.getIdOfIndex_ = function(index) {
  'use strict';
  return this.firstRowId_ + index;
};


/**
 * Attach text areas or input boxes to the autocomplete by DOM reference.  After
 * elements are attached to the autocomplete, when a user types they will see
 * the autocomplete drop down.
 * @param {...Element} var_args Variable args: Input or text area elements to
 *     attach the autocomplete too.
 */
goog.ui.ac.AutoComplete.prototype.attachInputs = function(var_args) {
  'use strict';
  // Delegate to the input handler
  var inputHandler = /** @type {goog.ui.ac.InputHandler} */
      (this.selectionHandler_);
  inputHandler.attachInputs.apply(inputHandler, arguments);
};


/**
 * Detach text areas or input boxes to the autocomplete by DOM reference.
 * @param {...Element} var_args Variable args: Input or text area elements to
 *     detach from the autocomplete.
 */
goog.ui.ac.AutoComplete.prototype.detachInputs = function(var_args) {
  'use strict';
  // Delegate to the input handler
  var inputHandler = /** @type {goog.ui.ac.InputHandler} */
      (this.selectionHandler_);
  inputHandler.detachInputs.apply(inputHandler, arguments);

  // Remove mapping from input to anchor if one exists.
  Array.prototype.forEach.call(arguments, function(input) {
    'use strict';
    goog.object.remove(this.inputToAnchorMap_, goog.getUid(input));
  }, this);
};


/**
 * Attaches the autocompleter to a text area or text input element
 * with an anchor element. The anchor element is the element the
 * autocomplete box will be positioned against.
 * @param {Element} inputElement The input element. May be 'textarea',
 *     text 'input' element, or any other element that exposes similar
 *     interface.
 * @param {Element} anchorElement The anchor element.
 */
goog.ui.ac.AutoComplete.prototype.attachInputWithAnchor = function(
    inputElement, anchorElement) {
  'use strict';
  this.inputToAnchorMap_[goog.getUid(inputElement)] = anchorElement;
  this.attachInputs(inputElement);
};


/**
 * Forces an update of the display.
 * @param {boolean=} opt_force Whether to force an update.
 */
goog.ui.ac.AutoComplete.prototype.update = function(opt_force) {
  'use strict';
  var inputHandler = /** @type {goog.ui.ac.InputHandler} */
      (this.selectionHandler_);
  inputHandler.update(opt_force);
};

//third_party/javascript/closure/dom/inputtype.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines the goog.dom.InputType enum.  This enumerates all
 * input element types (for INPUT, BUTTON, SELECT and TEXTAREA elements) in
 * either the W3C HTML 4.01 index of elements or the HTML5 draft specification.
 *
 * References:
 * http://www.w3.org/TR/html401/sgml/dtd.html#InputType
 * http://www.w3.org/TR/html-markup/input.html#input
 * https://html.spec.whatwg.org/multipage/forms.html#dom-input-type
 * https://html.spec.whatwg.org/multipage/forms.html#dom-button-type
 * https://html.spec.whatwg.org/multipage/forms.html#dom-select-type
 * https://html.spec.whatwg.org/multipage/forms.html#dom-textarea-type
 */
goog.provide('goog.dom.InputType');


/**
 * Enum of all input types (for INPUT, BUTTON, SELECT and TEXTAREA elements)
 * specified by the W3C HTML4.01 and HTML5 specifications.
 * @enum {string}
 */
goog.dom.InputType = {
  BUTTON: 'button',
  CHECKBOX: 'checkbox',
  COLOR: 'color',
  DATE: 'date',
  DATETIME: 'datetime',
  DATETIME_LOCAL: 'datetime-local',
  EMAIL: 'email',
  FILE: 'file',
  HIDDEN: 'hidden',
  IMAGE: 'image',
  MENU: 'menu',
  MONTH: 'month',
  NUMBER: 'number',
  PASSWORD: 'password',
  RADIO: 'radio',
  RANGE: 'range',
  RESET: 'reset',
  SEARCH: 'search',
  SELECT_MULTIPLE: 'select-multiple',
  SELECT_ONE: 'select-one',
  SUBMIT: 'submit',
  TEL: 'tel',
  TEXT: 'text',
  TEXTAREA: 'textarea',
  TIME: 'time',
  URL: 'url',
  WEEK: 'week'
};

//third_party/javascript/closure/dom/selection.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for working with selections in input boxes and text
 * areas.
 *
 * @see ../demos/dom_selection.html
 */


goog.provide('goog.dom.selection');

goog.require('goog.dom.InputType');
goog.require('goog.string');


/**
 * Sets the place where the selection should start inside a textarea or a text
 * input
 * @param {Element} textfield A textarea or text input.
 * @param {number} pos The position to set the start of the selection at.
 */
goog.dom.selection.setStart = function(textfield, pos) {
  'use strict';
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    textfield.selectionStart = pos;
  }
};


/**
 * Return the place where the selection starts inside a textarea or a text
 * input
 * @param {Element} textfield A textarea or text input.
 * @return {number} The position where the selection starts or 0 if it was
 *     unable to find the position or no selection exists. Note that we can't
 *     reliably tell the difference between an element that has no selection and
 *     one where it starts at 0.
 */
goog.dom.selection.getStart = function(textfield) {
  'use strict';
  return goog.dom.selection.getEndPoints_(textfield, true)[0];
};


/**
 * Returns the start and end points of the selection within a textarea in IE.
 * IE treats newline characters as \r\n characters, and we need to check for
 * these characters at the edge of our selection, to ensure that we return the
 * right cursor position.
 * @param {TextRange} range Complete range object, e.g., "Hello\r\n".
 * @param {TextRange} selRange Selected range object.
 * @param {boolean} getOnlyStart Value indicating if only start
 *     cursor position is to be returned. In IE, obtaining the end position
 *     involves extra work, hence we have this parameter for calls which need
 *     only start position.
 * @return {!Array<number>} An array with the start and end positions where the
 *     selection starts and ends or [0,0] if it was unable to find the
 *     positions or no selection exists. Note that we can't reliably tell the
 *     difference between an element that has no selection and one where
 *     it starts and ends at 0. If getOnlyStart was true, we return
 *     -1 as end offset.
 * @private
 */
goog.dom.selection.getEndPointsTextareaIe_ = function(
    range, selRange, getOnlyStart) {
  'use strict';
  // Create a duplicate of the selected range object to perform our actions
  // against. Example of selectionRange = "" (assuming that the cursor is
  // just after the \r\n combination)
  var selectionRange = selRange.duplicate();

  // Text before the selection start, e.g.,"Hello" (notice how range.text
  // excludes the \r\n sequence)
  var beforeSelectionText = range.text;
  // Text before the selection start, e.g., "Hello" (this will later include
  // the \r\n sequences also)
  var untrimmedBeforeSelectionText = beforeSelectionText;
  // Text within the selection , e.g. "" assuming that the cursor is just after
  // the \r\n combination.
  var selectionText = selectionRange.text;
  // Text within the selection, e.g.,  "" (this will later include the \r\n
  // sequences also)
  var untrimmedSelectionText = selectionText;

  // Boolean indicating whether we are done dealing with the text before the
  // selection's beginning.
  var isRangeEndTrimmed = false;
  // Go over the range until it becomes a 0-lengthed range or until the range
  // text starts changing when we move the end back by one character.
  // If after moving the end back by one character, the text remains the same,
  // then we need to add a "\r\n" at the end to get the actual text.
  while (!isRangeEndTrimmed) {
    if (range.compareEndPoints('StartToEnd', range) == 0) {
      isRangeEndTrimmed = true;
    } else {
      range.moveEnd('character', -1);
      if (range.text == beforeSelectionText) {
        // If the start position of the cursor was after a \r\n string,
        // we would skip over it in one go with the moveEnd call, but
        // range.text will still show "Hello" (because of the IE range.text
        // bug) - this implies that we should add a \r\n to our
        // untrimmedBeforeSelectionText string.
        untrimmedBeforeSelectionText += '\r\n';
      } else {
        isRangeEndTrimmed = true;
      }
    }
  }

  if (getOnlyStart) {
    // We return -1 as end, since the caller is only interested in the start
    // value.
    return [untrimmedBeforeSelectionText.length, -1];
  }
  // Boolean indicating whether we are done dealing with the text inside the
  // selection.
  var isSelectionRangeEndTrimmed = false;
  // Go over the selected range until it becomes a 0-lengthed range or until
  // the range text starts changing when we move the end back by one character.
  // If after moving the end back by one character, the text remains the same,
  // then we need to add a "\r\n" at the end to get the actual text.
  while (!isSelectionRangeEndTrimmed) {
    if (selectionRange.compareEndPoints('StartToEnd', selectionRange) == 0) {
      isSelectionRangeEndTrimmed = true;
    } else {
      selectionRange.moveEnd('character', -1);
      if (selectionRange.text == selectionText) {
        // If the selection was not empty, and the end point of the selection
        // was just after a \r\n, we would have skipped it in one go with the
        // moveEnd call, and this implies that we should add a \r\n to the
        // untrimmedSelectionText string.
        untrimmedSelectionText += '\r\n';
      } else {
        isSelectionRangeEndTrimmed = true;
      }
    }
  }
  return [
    untrimmedBeforeSelectionText.length,
    untrimmedBeforeSelectionText.length + untrimmedSelectionText.length
  ];
};


/**
 * Returns the start and end points of the selection inside a textarea or a
 * text input.
 * @param {Element} textfield A textarea or text input.
 * @return {!Array<number>} An array with the start and end positions where the
 *     selection starts and ends or [0,0] if it was unable to find the
 *     positions or no selection exists. Note that we can't reliably tell the
 *     difference between an element that has no selection and one where
 *     it starts and ends at 0.
 */
goog.dom.selection.getEndPoints = function(textfield) {
  'use strict';
  return goog.dom.selection.getEndPoints_(textfield, false);
};


/**
 * Returns the start and end points of the selection inside a textarea or a
 * text input.
 * @param {Element} textfield A textarea or text input.
 * @param {boolean} getOnlyStart Value indicating if only start
 *     cursor position is to be returned. In IE, obtaining the end position
 *     involves extra work, hence we have this parameter. In FF, there is not
 *     much extra effort involved.
 * @return {!Array<number>} An array with the start and end positions where the
 *     selection starts and ends or [0,0] if it was unable to find the
 *     positions or no selection exists. Note that we can't reliably tell the
 *     difference between an element that has no selection and one where
 *     it starts and ends at 0. If getOnlyStart was true, we return
 *     -1 as end offset.
 * @private
 */
goog.dom.selection.getEndPoints_ = function(textfield, getOnlyStart) {
  'use strict';
  textfield = /** @type {!HTMLInputElement|!HTMLTextAreaElement} */ (textfield);
  var startPos = 0;
  var endPos = 0;
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    startPos = textfield.selectionStart;
    endPos = getOnlyStart ? -1 : textfield.selectionEnd;
  }
  return [startPos, endPos];
};


/**
 * Sets the place where the selection should end inside a text area or a text
 * input
 * @param {Element} textfield A textarea or text input.
 * @param {number} pos The position to end the selection at.
 */
goog.dom.selection.setEnd = function(textfield, pos) {
  'use strict';
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    textfield.selectionEnd = pos;
  }
};


/**
 * Returns the place where the selection ends inside a textarea or a text input
 * @param {Element} textfield A textarea or text input.
 * @return {number} The position where the selection ends or 0 if it was
 *     unable to find the position or no selection exists.
 */
goog.dom.selection.getEnd = function(textfield) {
  'use strict';
  return goog.dom.selection.getEndPoints_(textfield, false)[1];
};


/**
 * Sets the cursor position within a textfield.
 * @param {Element} textfield A textarea or text input.
 * @param {number} pos The position within the text field.
 */
goog.dom.selection.setCursorPosition = function(textfield, pos) {
  'use strict';
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    // Mozilla directly supports this
    textfield.selectionStart = pos;
    textfield.selectionEnd = pos;

  }
};


/**
 * Sets the selected text inside a textarea or a text input
 * @param {Element} textfield A textarea or text input.
 * @param {string} text The text to change the selection to.
 */
goog.dom.selection.setText = function(textfield, text) {
  'use strict';
  textfield = /** @type {!HTMLInputElement|!HTMLTextAreaElement} */ (textfield);
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    var value = textfield.value;
    var oldSelectionStart = textfield.selectionStart;
    var before = value.substr(0, oldSelectionStart);
    var after = value.substr(textfield.selectionEnd);
    textfield.value = before + text + after;
    textfield.selectionStart = oldSelectionStart;
    textfield.selectionEnd = oldSelectionStart + text.length;
  } else {
    throw new Error('Cannot set the selection end');
  }
};


/**
 * Returns the selected text inside a textarea or a text input
 * @param {Element} textfield A textarea or text input.
 * @return {string} The selected text.
 */
goog.dom.selection.getText = function(textfield) {
  'use strict';
  textfield = /** @type {!HTMLInputElement|!HTMLTextAreaElement} */ (textfield);
  if (goog.dom.selection.useSelectionProperties_(textfield)) {
    var s = textfield.value;
    return s.substring(textfield.selectionStart, textfield.selectionEnd);
  }

  throw new Error('Cannot get the selection text');
};


/**
 * Returns the selected text within a textarea in IE.
 * IE treats newline characters as \r\n characters, and we need to check for
 * these characters at the edge of our selection, to ensure that we return the
 * right string.
 * @param {TextRange} selRange Selected range object.
 * @return {string} Selected text in the textarea.
 * @private
 */
goog.dom.selection.getSelectionRangeText_ = function(selRange) {
  'use strict';
  // Create a duplicate of the selected range object to perform our actions
  // against. Suppose the text in the textarea is "Hello\r\nWorld" and the
  // selection encompasses the "o\r\n" bit, initial selectionRange will be "o"
  // (assuming that the cursor is just after the \r\n combination)
  var selectionRange = selRange.duplicate();

  // Text within the selection , e.g. "o" assuming that the cursor is just after
  // the \r\n combination.
  var selectionText = selectionRange.text;
  // Text within the selection, e.g.,  "o" (this will later include the \r\n
  // sequences also)
  var untrimmedSelectionText = selectionText;

  // Boolean indicating whether we are done dealing with the text inside the
  // selection.
  var isSelectionRangeEndTrimmed = false;
  // Go over the selected range until it becomes a 0-lengthed range or until
  // the range text starts changing when we move the end back by one character.
  // If after moving the end back by one character, the text remains the same,
  // then we need to add a "\r\n" at the end to get the actual text.
  while (!isSelectionRangeEndTrimmed) {
    if (selectionRange.compareEndPoints('StartToEnd', selectionRange) == 0) {
      isSelectionRangeEndTrimmed = true;
    } else {
      selectionRange.moveEnd('character', -1);
      if (selectionRange.text == selectionText) {
        // If the selection was not empty, and the end point of the selection
        // was just after a \r\n, we would have skipped it in one go with the
        // moveEnd call, and this implies that we should add a \r\n to the
        // untrimmedSelectionText string.
        untrimmedSelectionText += '\r\n';
      } else {
        isSelectionRangeEndTrimmed = true;
      }
    }
  }
  return untrimmedSelectionText;
};


/**
 * Helper function for returning the range for an object as well as the
 * selection range
 * @private
 * @param {Element} el The element to get the range for.
 * @return {!Array<TextRange>} Range of object and selection range in two
 *     element array.
 */
goog.dom.selection.getRangeIe_ = function(el) {
  'use strict';
  var doc = el.ownerDocument || el.document;

  var selectionRange = doc.selection.createRange();
  // el.createTextRange() doesn't work on textareas
  var range;

  if (/** @type {?} */ (el).type == goog.dom.InputType.TEXTAREA) {
    range = doc.body.createTextRange();
    range.moveToElementText(el);
  } else {
    range = el.createTextRange();
  }

  return [range, selectionRange];
};


/**
 * Helper function for canonicalizing a position inside a textfield in IE.
 * Deals with the issue that \r\n counts as 2 characters, but
 * move('character', n) passes over both characters in one move.
 * @private
 * @param {Element} textfield The text element.
 * @param {number} pos The position desired in that element.
 * @return {number} The canonicalized position that will work properly with
 *     move('character', pos).
 */
goog.dom.selection.canonicalizePositionIe_ = function(textfield, pos) {
  'use strict';
  textfield = /** @type {!HTMLTextAreaElement} */ (textfield);
  if (textfield.type == goog.dom.InputType.TEXTAREA) {
    // We do this only for textarea because it is the only one which can
    // have a \r\n (input cannot have this).
    var value = textfield.value.substring(0, pos);
    pos = goog.string.canonicalizeNewlines(value).length;
  }
  return pos;
};


/**
 * Helper function to determine whether it's okay to use
 * selectionStart/selectionEnd.
 *
 * @param {Element} el The element to check for.
 * @return {boolean} Whether it's okay to use the selectionStart and
 *     selectionEnd properties on `el`.
 * @private
 */
goog.dom.selection.useSelectionProperties_ = function(el) {
  'use strict';
  try {
    return typeof el.selectionStart == 'number';
  } catch (e) {
    // Firefox throws an exception if you try to access selectionStart
    // on an element with display: none.
    return false;
  }
};

//third_party/javascript/closure/events/keycodes.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Constant declarations for common key codes.
 *
 * @see ../demos/keyhandler.html
 */

goog.provide('goog.events.KeyCodes');

goog.require('goog.userAgent');
goog.requireType('goog.events.BrowserEvent');


/**
 * Key codes for common characters.
 *
 * This list is not localized and therefore some of the key codes are not
 * correct for non US keyboard layouts. See comments below.
 *
 * @enum {number}
 */
goog.events.KeyCodes = {
  WIN_KEY_FF_LINUX: 0,
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,  // NUMLOCK on FF/Safari Mac
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,    // also NUM_NORTH_EAST
  PAGE_DOWN: 34,  // also NUM_SOUTH_EAST
  END: 35,        // also NUM_SOUTH_WEST
  HOME: 36,       // also NUM_NORTH_WEST
  LEFT: 37,       // also NUM_WEST
  UP: 38,         // also NUM_NORTH
  RIGHT: 39,      // also NUM_EAST
  DOWN: 40,       // also NUM_SOUTH
  PLUS_SIGN: 43,  // NOT numpad plus
  PRINT_SCREEN: 44,
  INSERT: 45,  // also NUM_INSERT
  DELETE: 46,  // also NUM_DELETE
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  FF_SEMICOLON: 59,  // Firefox (Gecko) fires this for semicolon instead of 186
  FF_EQUALS: 61,     // Firefox (Gecko) fires this for equals instead of 187
  FF_DASH: 173,      // Firefox (Gecko) fires this for dash instead of 189
  // Firefox (Gecko) fires this for # on UK keyboards, rather than
  // Shift+SINGLE_QUOTE.
  FF_HASH: 163,
  // Firefox (Gecko) fires this for ' (:) on JP keyboards, rather than
  // SINGLE_QUOTE (US keyboard layout) or SEMICOLON (JP keyboard layout in
  // chrome)
  FF_JP_QUOTE: 58,
  QUESTION_MARK: 63,  // needs localization
  AT_SIGN: 64,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,  // WIN_KEY_LEFT
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SCROLL_LOCK: 145,

  // OS-specific media keys like volume controls and browser controls.
  FIRST_MEDIA_KEY: 166,
  LAST_MEDIA_KEY: 183,

  SEMICOLON: 186,             // needs localization
  DASH: 189,                  // needs localization
  EQUALS: 187,                // needs localization
  COMMA: 188,                 // needs localization
  PERIOD: 190,                // needs localization
  SLASH: 191,                 // needs localization
  APOSTROPHE: 192,            // needs localization
  TILDE: 192,                 // needs localization
  SINGLE_QUOTE: 222,          // needs localization
  OPEN_SQUARE_BRACKET: 219,   // needs localization
  BACKSLASH: 220,             // needs localization
  CLOSE_SQUARE_BRACKET: 221,  // needs localization
  WIN_KEY: 224,
  MAC_FF_META:
      224,  // Firefox (Gecko) fires this for the meta key instead of 91
  MAC_WK_CMD_LEFT: 91,   // WebKit Left Command key fired, same as META
  MAC_WK_CMD_RIGHT: 93,  // WebKit Right Command key fired, different from META
  WIN_IME: 229,

  // "Reserved for future use". Some programs (e.g. the SlingPlayer 2.4 ActiveX
  // control) fire this as a hacky way to disable screensavers.
  VK_NONAME: 252,

  // We've seen users whose machines fire this keycode at regular one
  // second intervals. The common thread among these users is that
  // they're all using Dell Inspiron laptops, so we suspect that this
  // indicates a hardware/bios problem.
  // http://en.community.dell.com/support-forums/laptop/f/3518/p/19285957/19523128.aspx
  PHANTOM: 255
};


/**
 * Returns false if the event does not contain a text modifying key.
 *
 * When it returns true, the event might be text modifying. It is infeasible to
 * say for sure because of the many different keyboard layouts, so this method
 * errs on the side of assuming a key event is text-modifiable if we cannot be
 * certain it is not. As an example, it will return true for ctrl+a, though in
 * many standard keyboard layouts that key combination would mean "select all",
 * and not actually modify the text.
 *
 * @param {goog.events.BrowserEvent} e A key event.
 * @return {boolean} Whether it's a text modifying key.
 */
goog.events.KeyCodes.isTextModifyingKeyEvent = function(e) {
  'use strict';
  if (e.altKey && !e.ctrlKey || e.metaKey ||
      // Function keys don't generate text
      e.keyCode >= goog.events.KeyCodes.F1 &&
          e.keyCode <= goog.events.KeyCodes.F12) {
    return false;
  }

  if (goog.events.KeyCodes.isCharacterKey(e.keyCode)) {
    return true;
  }

  switch (e.keyCode) {
    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    case goog.events.KeyCodes.ALT:
    case goog.events.KeyCodes.CAPS_LOCK:
    case goog.events.KeyCodes.CONTEXT_MENU:
    case goog.events.KeyCodes.CTRL:
    case goog.events.KeyCodes.DOWN:
    case goog.events.KeyCodes.END:
    case goog.events.KeyCodes.ESC:
    case goog.events.KeyCodes.HOME:
    case goog.events.KeyCodes.INSERT:
    case goog.events.KeyCodes.LEFT:
    case goog.events.KeyCodes.MAC_FF_META:
    case goog.events.KeyCodes.META:
    case goog.events.KeyCodes.NUMLOCK:
    case goog.events.KeyCodes.NUM_CENTER:
    case goog.events.KeyCodes.PAGE_DOWN:
    case goog.events.KeyCodes.PAGE_UP:
    case goog.events.KeyCodes.PAUSE:
    case goog.events.KeyCodes.PHANTOM:
    case goog.events.KeyCodes.PRINT_SCREEN:
    case goog.events.KeyCodes.RIGHT:
    case goog.events.KeyCodes.SCROLL_LOCK:
    case goog.events.KeyCodes.SHIFT:
    case goog.events.KeyCodes.UP:
    case goog.events.KeyCodes.VK_NONAME:
    case goog.events.KeyCodes.WIN_KEY:
    case goog.events.KeyCodes.WIN_KEY_RIGHT:
      return false;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return !goog.userAgent.GECKO;
    default:
      return e.keyCode < goog.events.KeyCodes.FIRST_MEDIA_KEY ||
          e.keyCode > goog.events.KeyCodes.LAST_MEDIA_KEY;
  }
};


/**
 * Returns true if the key fires a keypress event in the current browser.
 *
 * Accoridng to MSDN [1] IE only fires keypress events for the following keys:
 * - Letters: A - Z (uppercase and lowercase)
 * - Numerals: 0 - 9
 * - Symbols: ! @ # $ % ^ & * ( ) _ - + = < [ ] { } , . / ? \ | ' ` " ~
 * - System: ESC, SPACEBAR, ENTER
 *
 * That's not entirely correct though, for instance there's no distinction
 * between upper and lower case letters.
 *
 * [1] http://msdn2.microsoft.com/en-us/library/ms536939(VS.85).aspx)
 *
 * Safari is similar to IE, but does not fire keypress for ESC.
 *
 * Additionally, IE6 does not fire keydown or keypress events for letters when
 * the control or alt keys are held down and the shift key is not. IE7 does
 * fire keydown in these cases, though, but not keypress.
 *
 * @param {number} keyCode A key code.
 * @param {number=} opt_heldKeyCode Key code of a currently-held key.
 * @param {boolean=} opt_shiftKey Whether the shift key is held down.
 * @param {boolean=} opt_ctrlKey Whether the control key is held down.
 * @param {boolean=} opt_altKey Whether the alt key is held down.
 * @param {boolean=} opt_metaKey Whether the meta key is held down.
 * @return {boolean} Whether it's a key that fires a keypress event.
 */
goog.events.KeyCodes.firesKeyPressEvent = function(
    keyCode, opt_heldKeyCode, opt_shiftKey, opt_ctrlKey, opt_altKey,
    opt_metaKey) {
  'use strict';
  if (goog.userAgent.MAC && opt_altKey) {
    return goog.events.KeyCodes.isCharacterKey(keyCode);
  }

  // Alt but not AltGr which is represented as Alt+Ctrl.
  if (opt_altKey && !opt_ctrlKey) {
    return false;
  }

  // Saves Ctrl or Alt + key for IE and WebKit 525+, which won't fire keypress.
  // WebKit prior to 525 won't get this far so no need to check the user agent.
  // Gecko doesn't need to use the held key for modifiers, it just checks the
  // ctrl/meta/alt/shiftKey fields.
  if (!goog.userAgent.GECKO) {
    if (typeof opt_heldKeyCode === 'number') {
      opt_heldKeyCode = goog.events.KeyCodes.normalizeKeyCode(opt_heldKeyCode);
    }
    var heldKeyIsModifier = opt_heldKeyCode == goog.events.KeyCodes.CTRL ||
        opt_heldKeyCode == goog.events.KeyCodes.ALT ||
        goog.userAgent.MAC && opt_heldKeyCode == goog.events.KeyCodes.META;
    // The Shift key blocks keypresses on Mac iff accompanied by another
    // modifier.
    var modifiedShiftKey = opt_heldKeyCode == goog.events.KeyCodes.SHIFT &&
        (opt_ctrlKey || opt_metaKey);
    if ((!opt_shiftKey || goog.userAgent.MAC) && heldKeyIsModifier ||
        goog.userAgent.MAC && modifiedShiftKey) {
      return false;
    }
  }

  // Some keys with Ctrl/Shift do not issue keypress in WEBKIT.
  if ((goog.userAgent.WEBKIT || goog.userAgent.EDGE) && opt_ctrlKey &&
      opt_shiftKey) {
    switch (keyCode) {
      case goog.events.KeyCodes.BACKSLASH:
      case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
      case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
      case goog.events.KeyCodes.TILDE:
      case goog.events.KeyCodes.SEMICOLON:
      case goog.events.KeyCodes.DASH:
      case goog.events.KeyCodes.EQUALS:
      case goog.events.KeyCodes.COMMA:
      case goog.events.KeyCodes.PERIOD:
      case goog.events.KeyCodes.SLASH:
      case goog.events.KeyCodes.APOSTROPHE:
      case goog.events.KeyCodes.SINGLE_QUOTE:
        return false;
    }
  }

  // When Ctrl+<somekey> is held in IE, it only fires a keypress once, but it
  // continues to fire keydown events as the event repeats.
  if (goog.userAgent.IE && opt_ctrlKey && opt_heldKeyCode == keyCode) {
    return false;
  }

  switch (keyCode) {
    case goog.events.KeyCodes.ENTER:
      if (goog.userAgent.GECKO) {
        // Only Enter, Shift + Enter, Ctrl + Enter causes keypress event on
        // Firefox.
        if (opt_metaKey || opt_altKey) {
          return false;
        }
        return !(opt_shiftKey && opt_ctrlKey);
      } else {
        return true;
      }
    case goog.events.KeyCodes.ESC:
      return !(
          goog.userAgent.WEBKIT || goog.userAgent.EDGE || goog.userAgent.GECKO);
  }

  // Gecko won't fire a keypress event even when the key is a character key if
  // ctrl, meta or alt are pressed. In all other cases, a keypress event is
  // only fired when the key is a character.
  if (goog.userAgent.GECKO && (opt_ctrlKey || opt_altKey || opt_metaKey)) {
    return false;
  } else {
    return goog.events.KeyCodes.isCharacterKey(keyCode);
  }
};


/**
 * Returns true if the key produces a character.
 * This does not cover characters on non-US keyboards (Russian, Hebrew, etc.).
 *
 * @param {number} keyCode A key code.
 * @return {boolean} Whether it's a character key.
 */
goog.events.KeyCodes.isCharacterKey = function(keyCode) {
  'use strict';
  if (keyCode >= goog.events.KeyCodes.ZERO &&
      keyCode <= goog.events.KeyCodes.NINE) {
    return true;
  }

  if (keyCode >= goog.events.KeyCodes.NUM_ZERO &&
      keyCode <= goog.events.KeyCodes.NUM_MULTIPLY) {
    return true;
  }

  if (keyCode >= goog.events.KeyCodes.A && keyCode <= goog.events.KeyCodes.Z) {
    return true;
  }

  // Safari sends zero key code for non-latin characters.
  if ((goog.userAgent.WEBKIT || goog.userAgent.EDGE) && keyCode == 0) {
    return true;
  }

  switch (keyCode) {
    case goog.events.KeyCodes.SPACE:
    case goog.events.KeyCodes.PLUS_SIGN:
    case goog.events.KeyCodes.QUESTION_MARK:
    case goog.events.KeyCodes.AT_SIGN:
    case goog.events.KeyCodes.NUM_PLUS:
    case goog.events.KeyCodes.NUM_MINUS:
    case goog.events.KeyCodes.NUM_PERIOD:
    case goog.events.KeyCodes.NUM_DIVISION:
    case goog.events.KeyCodes.SEMICOLON:
    case goog.events.KeyCodes.FF_SEMICOLON:
    case goog.events.KeyCodes.DASH:
    case goog.events.KeyCodes.EQUALS:
    case goog.events.KeyCodes.FF_EQUALS:
    case goog.events.KeyCodes.COMMA:
    case goog.events.KeyCodes.PERIOD:
    case goog.events.KeyCodes.SLASH:
    case goog.events.KeyCodes.APOSTROPHE:
    case goog.events.KeyCodes.SINGLE_QUOTE:
    case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
    case goog.events.KeyCodes.BACKSLASH:
    case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
    case goog.events.KeyCodes.FF_HASH:
    case goog.events.KeyCodes.FF_JP_QUOTE:
      return true;
    case goog.events.KeyCodes.FF_DASH:
      return goog.userAgent.GECKO;
    default:
      return false;
  }
};


/**
 * Normalizes key codes from OS/Browser-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeKeyCode = function(keyCode) {
  'use strict';
  if (goog.userAgent.GECKO) {
    return goog.events.KeyCodes.normalizeGeckoKeyCode(keyCode);
  } else if (goog.userAgent.MAC && goog.userAgent.WEBKIT) {
    return goog.events.KeyCodes.normalizeMacWebKitKeyCode(keyCode);
  } else {
    return keyCode;
  }
};


/**
 * Normalizes key codes from their Gecko-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeGeckoKeyCode = function(keyCode) {
  'use strict';
  switch (keyCode) {
    case goog.events.KeyCodes.FF_EQUALS:
      return goog.events.KeyCodes.EQUALS;
    case goog.events.KeyCodes.FF_SEMICOLON:
      return goog.events.KeyCodes.SEMICOLON;
    case goog.events.KeyCodes.FF_DASH:
      return goog.events.KeyCodes.DASH;
    case goog.events.KeyCodes.MAC_FF_META:
      return goog.events.KeyCodes.META;
    case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
      return goog.events.KeyCodes.WIN_KEY;
    default:
      return keyCode;
  }
};


/**
 * Normalizes key codes from their Mac WebKit-specific value to the general one.
 * @param {number} keyCode The native key code.
 * @return {number} The normalized key code.
 */
goog.events.KeyCodes.normalizeMacWebKitKeyCode = function(keyCode) {
  'use strict';
  switch (keyCode) {
    case goog.events.KeyCodes.MAC_WK_CMD_RIGHT:  // 93
      return goog.events.KeyCodes.META;          // 91
    default:
      return keyCode;
  }
};

//third_party/javascript/closure/events/keyevent.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview This file contains a class for working with keyboard events
 */

goog.provide('goog.events.KeyEvent');

goog.require('goog.events.BrowserEvent');

/**
 * This class is used for the goog.events.KeyEvent.EventType.KEY event and
 * it overrides the key code with the fixed key code.
 * @param {number} keyCode The adjusted key code.
 * @param {number} charCode The unicode character code.
 * @param {boolean} repeat Whether this event was generated by keyboard repeat.
 * @param {Event} browserEvent Browser event object.
 * @constructor
 * @extends {goog.events.BrowserEvent}
 * @final
 */
goog.events.KeyEvent = function(keyCode, charCode, repeat, browserEvent) {
  'use strict';
  goog.events.BrowserEvent.call(this, browserEvent);
  this.type = goog.events.KeyEvent.EventType.KEY;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = keyCode;

  /**
   * Unicode character code.
   * @type {number}
   */
  this.charCode = charCode;

  /**
   * True if this event was generated by keyboard auto-repeat (i.e., the user is
   * holding the key down.)
   * @type {boolean}
   */
  this.repeat = repeat;
};
goog.inherits(goog.events.KeyEvent, goog.events.BrowserEvent);

/**
 * Enum type for the events fired by the key handler
 * @enum {string}
 */
goog.events.KeyEvent.EventType = {
  KEY: 'key'
};

//third_party/javascript/closure/events/keyhandler.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview This file contains a class for working with keyboard events
 * that repeat consistently across browsers and platforms. It also unifies the
 * key code so that it is the same in all browsers and platforms.
 *
 * Different web browsers have very different keyboard event handling. Most
 * importantly is that only certain browsers repeat keydown events:
 * IE, Opera, FF/Win32, and Safari 3 repeat keydown events.
 * FF/Mac and Safari 2 do not.
 *
 * For the purposes of this code, "Safari 3" means WebKit 525+, when WebKit
 * decided that they should try to match IE's key handling behavior.
 * Safari 3.0.4, which shipped with Leopard (WebKit 523), has the
 * Safari 2 behavior.
 *
 * Firefox, Safari, Opera prevent on keypress
 *
 * IE prevents on keydown
 *
 * Firefox does not fire keypress for shift, ctrl, alt
 * Firefox does fire keydown for shift, ctrl, alt, meta
 * Firefox does not repeat keydown for shift, ctrl, alt, meta
 *
 * Firefox does not fire keypress for up and down in an input
 *
 * Opera fires keypress for shift, ctrl, alt, meta
 * Opera does not repeat keypress for shift, ctrl, alt, meta
 *
 * Safari 2 and 3 do not fire keypress for shift, ctrl, alt
 * Safari 2 does not fire keydown for shift, ctrl, alt
 * Safari 3 *does* fire keydown for shift, ctrl, alt
 *
 * IE provides the keycode for keyup/down events and the charcode (in the
 * keycode field) for keypress.
 *
 * Mozilla provides the keycode for keyup/down and the charcode for keypress
 * unless it's a non text modifying key in which case the keycode is provided.
 *
 * Safari 3 provides the keycode and charcode for all events.
 *
 * Opera provides the keycode for keyup/down event and either the charcode or
 * the keycode (in the keycode field) for keypress events.
 *
 * Firefox x11 doesn't fire keydown events if a another key is already held down
 * until the first key is released. This can cause a key event to be fired with
 * a keyCode for the first key and a charCode for the second key.
 *
 * Safari in keypress
 *
 *        charCode keyCode which
 * ENTER:       13      13    13
 * F1:       63236   63236 63236
 * F8:       63243   63243 63243
 * ...
 * p:          112     112   112
 * P:           80      80    80
 *
 * Firefox, keypress:
 *
 *        charCode keyCode which
 * ENTER:        0      13    13
 * F1:           0     112     0
 * F8:           0     119     0
 * ...
 * p:          112       0   112
 * P:           80       0    80
 *
 * Opera, Mac+Win32, keypress:
 *
 *         charCode keyCode which
 * ENTER: undefined      13    13
 * F1:    undefined     112     0
 * F8:    undefined     119     0
 * ...
 * p:     undefined     112   112
 * P:     undefined      80    80
 *
 * IE7, keydown
 *
 *         charCode keyCode     which
 * ENTER: undefined      13 undefined
 * F1:    undefined     112 undefined
 * F8:    undefined     119 undefined
 * ...
 * p:     undefined      80 undefined
 * P:     undefined      80 undefined
 *
 * @see ../demos/keyhandler.html
 */


goog.provide('goog.events.KeyHandler');
goog.provide('goog.events.KeyHandler.EventType');

goog.require('goog.events');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyEvent');
goog.require('goog.userAgent');



/**
 * A wrapper around an element that you want to listen to keyboard events on.
 * @param {Element|Document=} opt_element The element or document to listen on.
 * @param {boolean=} opt_capture Whether to listen for browser events in
 *     capture phase (defaults to false).
 * @constructor
 * @extends {goog.events.EventTarget}
 * @final
 */
goog.events.KeyHandler = function(opt_element, opt_capture) {
  'use strict';
  goog.events.EventTarget.call(this);

  if (opt_element) {
    this.attach(opt_element, opt_capture);
  }
};
goog.inherits(goog.events.KeyHandler, goog.events.EventTarget);


/**
 * This is the element that we will listen to the real keyboard events on.
 * @type {?Element|?Document|null}
 * @private
 */
goog.events.KeyHandler.prototype.element_ = null;


/**
 * The key for the key press listener.
 * @type {?goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyPressKey_ = null;


/**
 * The key for the key down listener.
 * @type {?goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyDownKey_ = null;


/**
 * The key for the key up listener.
 * @type {?goog.events.Key}
 * @private
 */
goog.events.KeyHandler.prototype.keyUpKey_ = null;


/**
 * Used to detect keyboard repeat events.
 * @private
 * @type {number}
 */
goog.events.KeyHandler.prototype.lastKey_ = -1;


/**
 * Keycode recorded for key down events. As most browsers don't report the
 * keycode in the key press event we need to record it in the key down phase.
 * @private
 * @type {number}
 */
goog.events.KeyHandler.prototype.keyCode_ = -1;


/**
 * Alt key recorded for key down events. FF on Mac does not report the alt key
 * flag in the key press event, we need to record it in the key down phase.
 * @type {boolean}
 * @private
 */
goog.events.KeyHandler.prototype.altKey_ = false;


/**
 * Enum type for the events fired by the key handler
 * @const
 * @deprecated use `goog.events.KeyEvent.EventType` instead.
 */
goog.events.KeyHandler.EventType = goog.events.KeyEvent.EventType;


/**
 * An enumeration of key codes that Safari 2 does incorrectly
 * @type {Object}
 * @private
 */
goog.events.KeyHandler.safariKey_ = {
  '3': goog.events.KeyCodes.ENTER,             // 13
  '12': goog.events.KeyCodes.NUMLOCK,          // 144
  '63232': goog.events.KeyCodes.UP,            // 38
  '63233': goog.events.KeyCodes.DOWN,          // 40
  '63234': goog.events.KeyCodes.LEFT,          // 37
  '63235': goog.events.KeyCodes.RIGHT,         // 39
  '63236': goog.events.KeyCodes.F1,            // 112
  '63237': goog.events.KeyCodes.F2,            // 113
  '63238': goog.events.KeyCodes.F3,            // 114
  '63239': goog.events.KeyCodes.F4,            // 115
  '63240': goog.events.KeyCodes.F5,            // 116
  '63241': goog.events.KeyCodes.F6,            // 117
  '63242': goog.events.KeyCodes.F7,            // 118
  '63243': goog.events.KeyCodes.F8,            // 119
  '63244': goog.events.KeyCodes.F9,            // 120
  '63245': goog.events.KeyCodes.F10,           // 121
  '63246': goog.events.KeyCodes.F11,           // 122
  '63247': goog.events.KeyCodes.F12,           // 123
  '63248': goog.events.KeyCodes.PRINT_SCREEN,  // 44
  '63272': goog.events.KeyCodes.DELETE,        // 46
  '63273': goog.events.KeyCodes.HOME,          // 36
  '63275': goog.events.KeyCodes.END,           // 35
  '63276': goog.events.KeyCodes.PAGE_UP,       // 33
  '63277': goog.events.KeyCodes.PAGE_DOWN,     // 34
  '63289': goog.events.KeyCodes.NUMLOCK,       // 144
  '63302': goog.events.KeyCodes.INSERT         // 45
};


/**
 * An enumeration of key identifiers currently part of the W3C draft for DOM3
 * and their mappings to keyCodes.
 * http://www.w3.org/TR/DOM-Level-3-Events/keyset.html#KeySet-Set
 * This is currently supported in Safari and should be platform independent.
 * @type {Object}
 * @private
 */
goog.events.KeyHandler.keyIdentifier_ = {
  'Up': goog.events.KeyCodes.UP,               // 38
  'Down': goog.events.KeyCodes.DOWN,           // 40
  'Left': goog.events.KeyCodes.LEFT,           // 37
  'Right': goog.events.KeyCodes.RIGHT,         // 39
  'Enter': goog.events.KeyCodes.ENTER,         // 13
  'F1': goog.events.KeyCodes.F1,               // 112
  'F2': goog.events.KeyCodes.F2,               // 113
  'F3': goog.events.KeyCodes.F3,               // 114
  'F4': goog.events.KeyCodes.F4,               // 115
  'F5': goog.events.KeyCodes.F5,               // 116
  'F6': goog.events.KeyCodes.F6,               // 117
  'F7': goog.events.KeyCodes.F7,               // 118
  'F8': goog.events.KeyCodes.F8,               // 119
  'F9': goog.events.KeyCodes.F9,               // 120
  'F10': goog.events.KeyCodes.F10,             // 121
  'F11': goog.events.KeyCodes.F11,             // 122
  'F12': goog.events.KeyCodes.F12,             // 123
  'U+007F': goog.events.KeyCodes.DELETE,       // 46
  'Home': goog.events.KeyCodes.HOME,           // 36
  'End': goog.events.KeyCodes.END,             // 35
  'PageUp': goog.events.KeyCodes.PAGE_UP,      // 33
  'PageDown': goog.events.KeyCodes.PAGE_DOWN,  // 34
  'Insert': goog.events.KeyCodes.INSERT        // 45
};




/**
 * If true, the alt key flag is saved during the key down and reused when
 * handling the key press. FF on Mac does not set the alt flag in the key press
 * event.
 * @type {boolean}
 * @private
 */
goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ =
    goog.userAgent.MAC && goog.userAgent.GECKO;


/**
 * Records the keycode for browsers that only returns the keycode for key up/
 * down events. For browser/key combinations that doesn't trigger a key pressed
 * event it also fires the patched key event.
 * @param {goog.events.BrowserEvent} e The key down event.
 * @private
 */
goog.events.KeyHandler.prototype.handleKeyDown_ = function(e) {
  'use strict';
  // Ctrl-Tab and Alt-Tab can cause the focus to be moved to another window
  // before we've caught a key-up event.  If the last-key was one of these we
  // reset the state.
  if (goog.userAgent.WEBKIT || goog.userAgent.EDGE) {
    if (this.lastKey_ == goog.events.KeyCodes.CTRL && !e.ctrlKey ||
        this.lastKey_ == goog.events.KeyCodes.ALT && !e.altKey ||
        goog.userAgent.MAC && this.lastKey_ == goog.events.KeyCodes.META &&
            !e.metaKey) {
      this.resetState();
    }
  }

  if (this.lastKey_ == -1) {
    if (e.ctrlKey && e.keyCode != goog.events.KeyCodes.CTRL) {
      this.lastKey_ = goog.events.KeyCodes.CTRL;
    } else if (e.altKey && e.keyCode != goog.events.KeyCodes.ALT) {
      this.lastKey_ = goog.events.KeyCodes.ALT;
    } else if (e.metaKey && e.keyCode != goog.events.KeyCodes.META) {
      this.lastKey_ = goog.events.KeyCodes.META;
    }
  }

  if (!goog.events.KeyCodes.firesKeyPressEvent(
          e.keyCode, this.lastKey_, e.shiftKey, e.ctrlKey, e.altKey,
          e.metaKey)) {
    this.handleEvent(e);
  } else {
    this.keyCode_ = goog.events.KeyCodes.normalizeKeyCode(e.keyCode);
    if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) {
      this.altKey_ = e.altKey;
    }
  }
};


/**
 * Resets the stored previous values. Needed to be called for webkit which will
 * not generate a key up for meta key operations. This should only be called
 * when having finished with repeat key possibilities.
 */
goog.events.KeyHandler.prototype.resetState = function() {
  'use strict';
  this.lastKey_ = -1;
  this.keyCode_ = -1;
};


/**
 * Clears the stored previous key value, resetting the key repeat status. Uses
 * -1 because the Safari 3 Windows beta reports 0 for certain keys (like Home
 * and End.)
 * @param {goog.events.BrowserEvent} e The keyup event.
 * @private
 */
goog.events.KeyHandler.prototype.handleKeyup_ = function(e) {
  'use strict';
  this.resetState();
  this.altKey_ = e.altKey;
};


/**
 * Handles the events on the element.
 * @param {goog.events.BrowserEvent} e  The keyboard event sent from the
 *     browser.
 */
goog.events.KeyHandler.prototype.handleEvent = function(e) {
  'use strict';
  var be = e.getBrowserEvent();
  var keyCode, charCode;
  var altKey = be.altKey;

  // IE reports the character code in the keyCode field for keypress events.
  // There are two exceptions however, Enter and Escape.
  if (goog.userAgent.IE && e.type == goog.events.EventType.KEYPRESS) {
    keyCode = this.keyCode_;
    charCode = keyCode != goog.events.KeyCodes.ENTER &&
            keyCode != goog.events.KeyCodes.ESC ?
        be.keyCode :
        0;

    // Safari reports the character code in the keyCode field for keypress
    // events but also has a charCode field.
  } else if (
      (goog.userAgent.WEBKIT || goog.userAgent.EDGE) &&
      e.type == goog.events.EventType.KEYPRESS) {
    keyCode = this.keyCode_;
    charCode = be.charCode >= 0 && be.charCode < 63232 &&
            goog.events.KeyCodes.isCharacterKey(keyCode) ?
        be.charCode :
        0;

    // Opera reports the keycode or the character code in the keyCode field.
  } else {
    if (e.type == goog.events.EventType.KEYPRESS) {
      if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) {
        altKey = this.altKey_;
      }

      // Newer versions of Firefox will set the keyCode of non-function keys to
      // be the same as charCode. We need to account for this and update the
      // key event values accordingly. See
      // https://github.com/google/closure-library/issues/932 for more details.
      if (be.keyCode == be.charCode) {
        // Adjust any function key (ie. non-printable, such as ESC or
        // backspace) to not have a charCode. We don't want these keys to
        // accidentally be interpreted as insertable characters.
        if (be.keyCode < 0x20) {
          keyCode = be.keyCode;
          charCode = 0;
        } else {
          // For character keys, we want to use the preserved key code rather
          // than the keyCode on the browser event, which now uses the charCode.
          // These differ (eg. pressing 'a' gives keydown with keyCode = 65,
          // keypress with keyCode = charCode = 97) and so we need to account
          // for this.
          keyCode = this.keyCode_;
          charCode = be.charCode;
        }
      } else {
        keyCode = be.keyCode || this.keyCode_;
        charCode = be.charCode || 0;
      }
    } else {
      keyCode = be.keyCode || this.keyCode_;
      charCode = be.charCode || 0;
    }

    // On the Mac, shift-/ triggers a question mark char code and no key code
    // (WIN_KEY_FF_LINUX), so we synthesize the latter.
    if (goog.userAgent.MAC && charCode == goog.events.KeyCodes.QUESTION_MARK &&
        keyCode == goog.events.KeyCodes.WIN_KEY) {
      keyCode = goog.events.KeyCodes.SLASH;
    }
  }

  keyCode = goog.events.KeyCodes.normalizeKeyCode(keyCode);
  var key = keyCode;

  // Correct the key value for certain browser-specific quirks.
  if (keyCode) {
    if (keyCode >= 63232 && keyCode in goog.events.KeyHandler.safariKey_) {
      // NOTE(nicksantos): Safari 3 has fixed this problem,
      // this is only needed for Safari 2.
      key = goog.events.KeyHandler.safariKey_[keyCode];
    } else {
      // Safari returns 25 for Shift+Tab instead of 9.
      if (keyCode == 25 && e.shiftKey) {
        key = 9;
      }
    }
  } else if (
      be.keyIdentifier &&
      be.keyIdentifier in goog.events.KeyHandler.keyIdentifier_) {
    // This is needed for Safari Windows because it currently doesn't give a
    // keyCode/which for non printable keys.
    key = goog.events.KeyHandler.keyIdentifier_[be.keyIdentifier];
  }

  // If this was a redundant keypress event, we ignore it to avoid double-firing
  // an event as the event would've been handled by KEYDOWN. Gecko is currently
  // in the process of removing keypress events for non-printable characters
  // (https://bugzilla.mozilla.org/show_bug.cgi?id=968056) so we simulate this
  // logic here for older Gecko versions which still fire the events.
  if (goog.userAgent.GECKO && e.type == goog.events.EventType.KEYPRESS &&
      !goog.events.KeyCodes.firesKeyPressEvent(
          key, this.lastKey_, e.shiftKey, e.ctrlKey, altKey, e.metaKey)) {
    return;
  }

  // If we get the same keycode as a keydown/keypress without having seen a
  // keyup event, then this event was caused by key repeat.
  var repeat = key == this.lastKey_;
  this.lastKey_ = key;

  var event = new goog.events.KeyEvent(key, charCode, repeat, be);
  event.altKey = altKey;
  this.dispatchEvent(event);
};


/**
 * Returns the element listened on for the real keyboard events.
 * @return {Element|Document|null} The element listened on for the real
 *     keyboard events.
 */
goog.events.KeyHandler.prototype.getElement = function() {
  'use strict';
  return this.element_;
};


/**
 * Adds the proper key event listeners to the element.
 * @param {Element|Document} element The element to listen on.
 * @param {boolean=} opt_capture Whether to listen for browser events in
 *     capture phase (defaults to false).
 */
goog.events.KeyHandler.prototype.attach = function(element, opt_capture) {
  'use strict';
  if (this.keyUpKey_) {
    this.detach();
  }

  this.element_ = element;

  this.keyPressKey_ = goog.events.listen(
      this.element_, goog.events.EventType.KEYPRESS, this, opt_capture);

  // Most browsers (Safari 2 being the notable exception) doesn't include the
  // keyCode in keypress events (IE has the char code in the keyCode field and
  // Mozilla only included the keyCode if there's no charCode). Thus we have to
  // listen for keydown to capture the keycode.
  this.keyDownKey_ = goog.events.listen(
      this.element_, goog.events.EventType.KEYDOWN, this.handleKeyDown_,
      opt_capture, this);


  this.keyUpKey_ = goog.events.listen(
      this.element_, goog.events.EventType.KEYUP, this.handleKeyup_,
      opt_capture, this);
};


/**
 * Removes the listeners that may exist.
 */
goog.events.KeyHandler.prototype.detach = function() {
  'use strict';
  if (this.keyPressKey_) {
    goog.events.unlistenByKey(this.keyPressKey_);
    goog.events.unlistenByKey(this.keyDownKey_);
    goog.events.unlistenByKey(this.keyUpKey_);
    this.keyPressKey_ = null;
    this.keyDownKey_ = null;
    this.keyUpKey_ = null;
  }
  this.element_ = null;
  this.lastKey_ = -1;
  this.keyCode_ = -1;
};


/** @override */
goog.events.KeyHandler.prototype.disposeInternal = function() {
  'use strict';
  goog.events.KeyHandler.superClass_.disposeInternal.call(this);
  this.detach();
};

//third_party/javascript/closure/ui/ac/inputhandler.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Class for managing the interactions between an
 * auto-complete object and a text-input or textarea.
 *
 * IME note:
 *
 * We used to suspend autocomplete while there are IME preedit characters, but
 * now for parity with Search we do not. We still detect the beginning and end
 * of IME entry because we need to listen to more events while an IME commit is
 * happening, but we update continuously as the user types.
 *
 * IMEs vary across operating systems, browsers, and even input languages. This
 * class tries to handle IME for:
 * - Windows x {FF3, IE7, Chrome} x MS IME 2002 (Japanese)
 * - Mac     x {FF3, Safari3}     x Kotoeri (Japanese)
 * - Linux   x {FF3}              x UIM + Anthy (Japanese)
 *
 * TODO(yuzo): We cannot handle {Mac, Linux} x FF3 correctly.
 * TODO(yuzo): We need to support Windows x Google IME.
 *
 * This class was tested with hiragana input. The event sequence when inputting
 * 'ai<enter>' with IME on (which commits two characters) is as follows:
 *
 * Notation: [key down code, key press, key up code]
 *           key code or +: event fired
 *           -: event not fired
 *
 * - Win/FF3: [WIN_IME, +, A], [-, -, ENTER]
 *            Note: No events are fired for 'i'.
 *
 * - Win/IE7: [WIN_IME, -, A], [WIN_IME, -, I], [WIN_IME, -, ENTER]
 *
 * - Win/Chrome: Same as Win/IE7
 *
 * - Mac/FF3: [A, -, A], [I, -, I], [ENTER, -, ENTER]
 *
 * - Mac/Safari3: Same as Win/IE7
 *
 * - Linux/FF3: No events are generated.
 *
 * With IME off,
 *
 * - ALL: [A, +, A], [I, +, I], [ENTER, +, ENTER]
 *        Note: Key code of key press event varies across configuration.
 *
 * With Microsoft Pinyin IME 3.0 (Simplified Chinese),
 *
 * - Win/IE7: Same as Win/IE7 with MS IME 2002 (Japanese)
 *
 *   The issue with this IME is that the key sequence that ends preedit is not
 *   a single ENTER key up.
 *   - ENTER key up following either ENTER or SPACE ends preedit.
 *   - SPACE key up following even number of LEFT, RIGHT, or SPACE (any
 *     combination) ends preedit.
 *   TODO(yuzo): We only support SPACE-then-ENTER sequence.
 *   TODO(mpd): With the change to autocomplete during IME, this might not be an
 *   issue. Remove this comment once tested.
 *
 * With Microsoft Korean IME 2002,
 *
 * - Win/IE7: Same as Win/IE7 with MS IME 2002 (Japanese), but there is no
 *   sequence that ends the preedit.
 *
 * The following is the algorithm we use to detect IME preedit:
 *
 * - WIN_IME key down starts predit.
 * - (1) ENTER key up or (2) CTRL-M key up ends preedit.
 * - Any key press not immediately following WIN_IME key down signifies that
 *   preedit has ended.
 *
 * If you need to change this algorithm, please note the OS, browser, language,
 * and behavior above so that we can avoid regressions. Contact mpd or yuzo
 * if you have questions or concerns.
 */


goog.provide('goog.ui.ac.InputHandler');

goog.require('goog.Disposable');
goog.require('goog.Timer');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.dispose');
goog.require('goog.dom');
goog.require('goog.dom.selection');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyHandler');
goog.require('goog.string');
goog.require('goog.userAgent');
goog.requireType('goog.events.BrowserEvent');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.EventTarget');



/**
 * Class for managing the interaction between an auto-complete object and a
 * text-input or textarea.
 *
 * @param {?string=} opt_separators Separators to split multiple entries.
 *     If none passed, uses ',' and ';'.
 * @param {?string=} opt_literals Characters used to delimit text literals.
 * @param {?boolean=} opt_multi Whether to allow multiple entries
 *     (Default: true).
 * @param {?number=} opt_throttleTime Number of milliseconds to throttle
 *     keyevents with (Default: 150). Use -1 to disable updates on typing. Note
 *     that typing the separator will update autocomplete suggestions.
 * @constructor
 * @extends {goog.Disposable}
 */
goog.ui.ac.InputHandler = function(
    opt_separators, opt_literals, opt_multi, opt_throttleTime) {
  'use strict';
  goog.Disposable.call(this);
  var throttleTime = opt_throttleTime || 150;

  /**
   * Whether this input accepts multiple values
   * @type {boolean}
   * @private
   */
  this.multi_ = opt_multi != null ? opt_multi : true;

  // Set separators depends on this.multi_ being set correctly
  this.setSeparators(
      opt_separators || goog.ui.ac.InputHandler.STANDARD_LIST_SEPARATORS);

  /**
   * Characters that are used to delimit literal text. Separarator characters
   * found within literal text are not processed as separators
   * @type {string}
   * @private
   */
  this.literals_ = opt_literals || '';

  /**
   * Whether to prevent highlighted item selection when tab is pressed.
   * @type {boolean}
   * @private
   */
  this.preventSelectionOnTab_ = false;

  /**
   * Whether to prevent the default behavior (moving focus to another element)
   * when tab is pressed.  This occurs by default only for multi-value mode.
   * @type {boolean}
   * @private
   */
  this.preventDefaultOnTab_ = this.multi_;

  /**
   * A timer object used to monitor for changes when an element is active.
   *
   * TODO(pupius): Consider tuning the throttle time, so that it takes into
   * account the length of the token.  When the token is short it is likely to
   * match lots of rows, therefore we want to check less frequently.  Even
   * something as simple as <3-chars = 150ms, then 100ms otherwise.
   *
   * @type {goog.Timer}
   * @private
   */
  this.timer_ = throttleTime > 0 ? new goog.Timer(throttleTime) : null;

  /**
   * Event handler used by the input handler to manage events.
   * @type {goog.events.EventHandler<!goog.ui.ac.InputHandler>}
   * @private
   */
  this.eh_ = new goog.events.EventHandler(this);

  /**
   * Event handler to help us find an input element that already has the focus.
   * @type {goog.events.EventHandler<!goog.ui.ac.InputHandler>}
   * @private
   */
  this.activateHandler_ = new goog.events.EventHandler(this);

  /**
   * The keyhandler used for listening on most key events.  This takes care of
   * abstracting away some of the browser differences.
   * @type {goog.events.KeyHandler}
   * @private
   */
  this.keyHandler_ = new goog.events.KeyHandler();

  /**
   * The last key down key code.
   * @type {number}
   * @private
   */
  this.lastKeyCode_ = -1;  // Initialize to a non-existent value.
};
goog.inherits(goog.ui.ac.InputHandler, goog.Disposable);


/**
 * Whether or not we need to pause the execution of the blur handler in order
 * to allow the execution of the selection handler to run first. This is
 * currently true when running on IOS version prior to 4.2, since we need
 * some special logic for these devices to handle bug 4484488.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.REQUIRES_ASYNC_BLUR_ = false;


/**
 * Standard list separators.
 * @type {string}
 * @const
 */
goog.ui.ac.InputHandler.STANDARD_LIST_SEPARATORS = ',;';


/**
 * Literals for quotes.
 * @type {string}
 * @const
 */
goog.ui.ac.InputHandler.QUOTE_LITERALS = '"';


/**
 * The AutoComplete instance this inputhandler is associated with.
 * @type {goog.ui.ac.AutoComplete}
 */
goog.ui.ac.InputHandler.prototype.ac_;


/**
 * Characters that can be used to split multiple entries in an input string
 * @type {string}
 * @private
 */
goog.ui.ac.InputHandler.prototype.separators_;


/**
 * The separator we use to reconstruct the string
 * @type {string}
 * @private
 */
goog.ui.ac.InputHandler.prototype.defaultSeparator_;


/**
 * Regular expression used from trimming tokens or null for no trimming.
 * @type {?RegExp}
 * @private
 */
goog.ui.ac.InputHandler.prototype.trimmer_;


/**
 * Regular expression to test whether a separator exists
 * @type {?RegExp}
 * @private
 */
goog.ui.ac.InputHandler.prototype.separatorCheck_;


/**
 * Should auto-completed tokens be wrapped in whitespace?  Used in selectRow.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.whitespaceWrapEntries_ = true;


/**
 * Should the occurrence of a literal indicate a token boundary?
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.generateNewTokenOnLiteral_ = true;


/**
 * Whether to flip the orientation of up & down for hiliting next
 * and previous autocomplete entries.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.upsideDown_ = false;


/**
 * If we're in 'multi' mode, does typing a separator force the updating of
 * suggestions?
 * For example, if somebody finishes typing "obama, hillary,", should the last
 * comma trigger updating suggestions in a guaranteed manner? Especially useful
 * when the suggestions depend on complete keywords. Note that "obama, hill"
 * (a leading sub-string of "obama, hillary" will lead to different and possibly
 * irrelevant suggestions.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.separatorUpdates_ = true;


/**
 * If we're in 'multi' mode, does typing a separator force the current term to
 * autocomplete?
 * For example, if 'tomato' is a suggested completion and the user has typed
 * 'to,', do we autocomplete to turn that into 'tomato,'?
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.separatorSelects_ = true;


/**
 * The id of the currently active timeout, so it can be cleared if required.
 * @type {?number}
 * @private
 */
goog.ui.ac.InputHandler.prototype.activeTimeoutId_ = null;


/**
 * The element that is currently active.
 * @type {?Element}
 * @private
 */
goog.ui.ac.InputHandler.prototype.activeElement_ = null;


/**
 * The previous value of the active element.
 * @type {string}
 * @private
 */
goog.ui.ac.InputHandler.prototype.lastValue_ = '';


/**
 * Flag used to indicate that the IME key has been seen and we need to wait for
 * the up event.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.waitingForIme_ = false;


/**
 * Flag used to indicate that the user just selected a row and we should
 * therefore ignore the change of the input value.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.rowJustSelected_ = false;


/**
 * Flag indicating whether the result list should be updated continuously
 * during typing or only after a short pause.
 * @type {boolean}
 * @private
 */
goog.ui.ac.InputHandler.prototype.updateDuringTyping_ = true;


/**
 * Attach an instance of an AutoComplete
 * @param {goog.ui.ac.AutoComplete} ac Autocomplete object.
 */
goog.ui.ac.InputHandler.prototype.attachAutoComplete = function(ac) {
  'use strict';
  this.ac_ = ac;
};


/**
 * Returns the associated autocomplete instance.
 * @return {goog.ui.ac.AutoComplete} The associated autocomplete instance.
 */
goog.ui.ac.InputHandler.prototype.getAutoComplete = function() {
  'use strict';
  return this.ac_;
};


/**
 * Returns the current active element.
 * @return {Element} The currently active element.
 */
goog.ui.ac.InputHandler.prototype.getActiveElement = function() {
  'use strict';
  return this.activeElement_;
};


/**
 * Returns the value of the current active element.
 * @return {string} The value of the current active element.
 */
goog.ui.ac.InputHandler.prototype.getValue = function() {
  'use strict';
  return this.activeElement_.value;
};


/**
 * Sets the value of the current active element.
 * @param {string} value The new value.
 */
goog.ui.ac.InputHandler.prototype.setValue = function(value) {
  'use strict';
  this.activeElement_.value = value;
};


/**
 * Returns the current cursor position.
 * @return {number} The index of the cursor position.
 */
goog.ui.ac.InputHandler.prototype.getCursorPosition = function() {
  'use strict';
  return goog.dom.selection.getStart(this.activeElement_);
};


/**
 * Sets the cursor at the given position.
 * @param {number} pos The index of the cursor position.
 */
goog.ui.ac.InputHandler.prototype.setCursorPosition = function(pos) {
  'use strict';
  goog.dom.selection.setStart(this.activeElement_, pos);
  goog.dom.selection.setEnd(this.activeElement_, pos);
};


/**
 * Attaches the input handler to a target element. The target element
 * should be a textarea, input box, or other focusable element with the
 * same interface.
 * @param {Element|goog.events.EventTarget} target An element to attach the
 *     input handler to.
 */
goog.ui.ac.InputHandler.prototype.attachInput = function(target) {
  'use strict';
  if (goog.dom.isElement(target)) {
    var el = /** @type {!Element} */ (target);
    goog.a11y.aria.setRole(el, goog.a11y.aria.Role.COMBOBOX);
    goog.a11y.aria.setState(el, goog.a11y.aria.State.AUTOCOMPLETE, 'list');
  }

  this.eh_.listen(target, goog.events.EventType.FOCUS, this.handleFocus);
  this.eh_.listen(target, goog.events.EventType.BLUR, this.handleBlur);

  if (!this.activeElement_) {
    this.activateHandler_.listen(
        target, goog.events.EventType.KEYDOWN,
        this.onKeyDownOnInactiveElement_);

    // Don't wait for a focus event if the element already has focus.
    if (goog.dom.isElement(target)) {
      var ownerDocument = goog.dom.getOwnerDocument(
          /** @type {Element} */ (target));
      if (goog.dom.getActiveElement(ownerDocument) == target) {
        this.processFocus(/** @type {!Element} */ (target));
      }
    }
  }
};


/**
 * Detaches the input handler from the provided element.
 * @param {Element|goog.events.EventTarget} target An element to detach the
 *     input handler from.
 */
goog.ui.ac.InputHandler.prototype.detachInput = function(target) {
  'use strict';
  if (goog.dom.isElement(target)) {
    var el = /** @type {!Element} */ (target);
    goog.a11y.aria.removeRole(el);
    goog.a11y.aria.removeState(el, goog.a11y.aria.State.AUTOCOMPLETE);
  }

  if (target == this.activeElement_) {
    this.handleBlur();
  }
  this.eh_.unlisten(target, goog.events.EventType.FOCUS, this.handleFocus);
  this.eh_.unlisten(target, goog.events.EventType.BLUR, this.handleBlur);

  if (!this.activeElement_) {
    this.activateHandler_.unlisten(
        target, goog.events.EventType.KEYDOWN,
        this.onKeyDownOnInactiveElement_);
  }
};


/**
 * Attaches the input handler to multiple elements.
 * @param {...Element} var_args Elements to attach the input handler too.
 */
goog.ui.ac.InputHandler.prototype.attachInputs = function(var_args) {
  'use strict';
  for (var i = 0; i < arguments.length; i++) {
    this.attachInput(arguments[i]);
  }
};


/**
 * Detaches the input handler from multuple elements.
 * @param {...Element} var_args Variable arguments for elements to unbind from.
 */
goog.ui.ac.InputHandler.prototype.detachInputs = function(var_args) {
  'use strict';
  for (var i = 0; i < arguments.length; i++) {
    this.detachInput(arguments[i]);
  }
};


/**
 * Selects the given row.  Implements the SelectionHandler interface.
 * @param {?} row The row to select.
 * @param {boolean=} opt_multi Should this be treated as a single or multi-token
 *     auto-complete?  Overrides previous setting of opt_multi on constructor.
 * @return {boolean} Whether to suppress the update event.
 */
goog.ui.ac.InputHandler.prototype.selectRow = function(row, opt_multi) {
  'use strict';
  if (this.activeElement_) {
    this.setTokenText(row.toString(), opt_multi);
  }
  return false;
};


/**
 * Sets the text of the current token without updating the autocomplete
 * choices.
 * @param {string} tokenText The text for the current token.
 * @param {boolean=} opt_multi Should this be treated as a single or multi-token
 *     auto-complete?  Overrides previous setting of opt_multi on constructor.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.setTokenText = function(
    tokenText, opt_multi) {
  'use strict';
  if (opt_multi !== undefined ? opt_multi : this.multi_) {
    var index = this.getTokenIndex_(this.getValue(), this.getCursorPosition());

    // Break up the current input string.
    var entries = this.splitInput_(this.getValue());

    // Get the new value, ignoring whitespace associated with the entry.
    var replaceValue = tokenText;

    // Only add punctuation if there isn't already a separator available.
    if (this.separatorCheck_ && !this.separatorCheck_.test(replaceValue)) {
      replaceValue =
          goog.string.trimRight(replaceValue) + this.defaultSeparator_;
    }

    // Ensure there's whitespace wrapping the entries, if whitespaceWrapEntries_
    // has been set to true.
    if (this.whitespaceWrapEntries_) {
      if (index != 0 && !goog.string.isEmptyOrWhitespace(entries[index - 1])) {
        replaceValue = ' ' + replaceValue;
      }
      // Add a space only if it's the last token; otherwise, we assume the
      // next token already has the proper spacing.
      if (index == entries.length - 1) {
        replaceValue = replaceValue + ' ';
      }
    }

    // If the token needs changing, then update the input box and move the
    // cursor to the correct position.
    if (replaceValue != entries[index]) {
      // Replace the value in the array.
      entries[index] = replaceValue;

      var el = this.activeElement_;
      // If there is an uncommitted IME in Firefox or IE 9, setting the value
      // fails and results in actually clearing the value that's already in the
      // input.
      // The FF bug is http://bugzilla.mozilla.org/show_bug.cgi?id=549674
      // Blurring before setting the value works around this problem. We'd like
      // to do this only if there is an uncommitted IME, but this isn't possible
      // to detect. Since text editing is finicky we restrict this
      // workaround to Firefox and IE 9 where it's necessary.
      // (Note: this has been fixed in Edge and since FF 41)
      if (goog.userAgent.GECKO || goog.userAgent.IE) {
        el.blur();
      }
      // Join the array and replace the contents of the input.
      el.value = entries.join('');

      // Calculate which position to put the cursor at.
      var pos = 0;
      for (var i = 0; i <= index; i++) {
        pos += entries[i].length;
      }

      // Set the cursor.
      el.focus();
      this.setCursorPosition(pos);
    }
  } else {
    this.setValue(tokenText);
  }

  // Avoid triggering an autocomplete just because the value changed.
  this.rowJustSelected_ = true;
};


/** @override */
goog.ui.ac.InputHandler.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.ac.InputHandler.superClass_.disposeInternal.call(this);
  if (this.activeTimeoutId_ != null) {
    // Need to check against null explicitly because 0 is a valid value.
    window.clearTimeout(this.activeTimeoutId_);
  }
  this.eh_.dispose();
  delete this.eh_;
  this.activateHandler_.dispose();
  this.keyHandler_.dispose();
  goog.dispose(this.timer_);
};


/**
 * Sets the entry separator characters.
 *
 * @param {string} separators The separator characters to set.
 * @param {string=} opt_defaultSeparators The defaultSeparator character to set.
 */
goog.ui.ac.InputHandler.prototype.setSeparators = function(
    separators, opt_defaultSeparators) {
  'use strict';
  this.separators_ = separators;
  this.defaultSeparator_ = (opt_defaultSeparators != null) ?
      opt_defaultSeparators :
      this.separators_.substring(0, 1);

  var wspaceExp = this.multi_ ? '[\\s' + this.separators_ + ']+' : '[\\s]+';

  this.trimmer_ = new RegExp('^' + wspaceExp + '|' + wspaceExp + '$', 'g');
  this.separatorCheck_ = new RegExp('\\s*[' + this.separators_ + ']$');
};


/**
 * Sets whether to flip the orientation of up & down for hiliting next
 * and previous autocomplete entries.
 * @param {boolean} upsideDown Whether the orientation is upside down.
 */
goog.ui.ac.InputHandler.prototype.setUpsideDown = function(upsideDown) {
  'use strict';
  this.upsideDown_ = upsideDown;
};


/**
 * Sets whether auto-completed tokens should be wrapped with whitespace.
 * @param {boolean} newValue boolean value indicating whether or not
 *     auto-completed tokens should be wrapped with whitespace.
 */
goog.ui.ac.InputHandler.prototype.setWhitespaceWrapEntries = function(
    newValue) {
  'use strict';
  this.whitespaceWrapEntries_ = newValue;
};


/**
 * Sets whether new tokens should be generated from literals.  That is, should
 * hello'world be two tokens, assuming ' is a literal?
 * @param {boolean} newValue boolean value indicating whether or not
 * new tokens should be generated from literals.
 */
goog.ui.ac.InputHandler.prototype.setGenerateNewTokenOnLiteral = function(
    newValue) {
  'use strict';
  this.generateNewTokenOnLiteral_ = newValue;
};


/**
 * Sets the regular expression used to trim the tokens before passing them to
 * the matcher:  every substring that matches the given regular expression will
 * be removed.  This can also be set to null to disable trimming.
 * @param {?RegExp} trimmer Regexp to use for trimming or null to disable it.
 */
goog.ui.ac.InputHandler.prototype.setTrimmingRegExp = function(trimmer) {
  'use strict';
  this.trimmer_ = trimmer;
};


/**
 * Sets the regular expression used to check whether the replacement (used to
 * update the text area after a row is selected) ends with a separator. This can
 * be set to null if the input handler should never automatically append a
 * separator to the replacement string.
 * @param {?RegExp} separatorCheck Regexp to use for checking whether the
 *     replacement ends with a separator.
 */
goog.ui.ac.InputHandler.prototype.setEndsWithSeparatorRegExp = function(
    separatorCheck) {
  'use strict';
  this.separatorCheck_ = separatorCheck;
};


/**
 * Sets whether we will prevent the default input behavior (moving focus to the
 * next focusable  element) on TAB.
 * @param {boolean} newValue Whether to preventDefault on TAB.
 */
goog.ui.ac.InputHandler.prototype.setPreventDefaultOnTab = function(newValue) {
  'use strict';
  this.preventDefaultOnTab_ = newValue;
};


/**
 * Sets whether we will prevent highlighted item selection on TAB.
 * @param {boolean} newValue Whether to prevent selection on TAB.
 */
goog.ui.ac.InputHandler.prototype.setPreventSelectionOnTab = function(
    newValue) {
  'use strict';
  this.preventSelectionOnTab_ = newValue;
};


/**
 * Sets whether separators perform autocomplete.
 * @param {boolean} newValue Whether to autocomplete on separators.
 */
goog.ui.ac.InputHandler.prototype.setSeparatorCompletes = function(newValue) {
  'use strict';
  this.separatorUpdates_ = newValue;
  this.separatorSelects_ = newValue;
};


/**
 * Sets whether separators perform autocomplete.
 * @param {boolean} newValue Whether to autocomplete on separators.
 */
goog.ui.ac.InputHandler.prototype.setSeparatorSelects = function(newValue) {
  'use strict';
  this.separatorSelects_ = newValue;
};


/**
 * Gets the time to wait before updating the results. If the update during
 * typing flag is switched on, this delay counts from the last update,
 * otherwise from the last keypress.
 * @return {number} Throttle time in milliseconds.
 */
goog.ui.ac.InputHandler.prototype.getThrottleTime = function() {
  'use strict';
  return this.timer_ ? this.timer_.getInterval() : -1;
};


/**
 * Sets whether a row has just been selected.
 * @param {boolean} justSelected Whether or not the row has just been selected.
 */
goog.ui.ac.InputHandler.prototype.setRowJustSelected = function(justSelected) {
  'use strict';
  this.rowJustSelected_ = justSelected;
};


/**
 * Sets the time to wait before updating the results.
 * @param {number} time New throttle time in milliseconds.
 */
goog.ui.ac.InputHandler.prototype.setThrottleTime = function(time) {
  'use strict';
  if (time < 0) {
    this.timer_.dispose();
    this.timer_ = null;
    return;
  }
  if (this.timer_) {
    this.timer_.setInterval(time);
  } else {
    this.timer_ = new goog.Timer(time);
  }
};


/**
 * Gets whether the result list is updated during typing.
 * @return {boolean} Value of the flag.
 */
goog.ui.ac.InputHandler.prototype.getUpdateDuringTyping = function() {
  'use strict';
  return this.updateDuringTyping_;
};


/**
 * Sets whether the result list should be updated during typing.
 * @param {boolean} value New value of the flag.
 */
goog.ui.ac.InputHandler.prototype.setUpdateDuringTyping = function(value) {
  'use strict';
  this.updateDuringTyping_ = value;
};


/**
 * Handles a key event.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @return {boolean} True if the key event was handled.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.handleKeyEvent = function(e) {
  'use strict';
  switch (e.keyCode) {
    // If the menu is open and 'down' caused a change then prevent the default
    // action and prevent scrolling.  If the box isn't a multi autocomplete
    // and the menu isn't open, we force it open now.
    case goog.events.KeyCodes.DOWN:
      if (this.ac_.isOpen()) {
        this.moveDown_();
        e.preventDefault();
        return true;

      } else if (!this.multi_) {
        this.update(true);
        e.preventDefault();
        return true;
      }
      break;

    // If the menu is open and 'up' caused a change then prevent the default
    // action and prevent scrolling.
    case goog.events.KeyCodes.UP:
      if (this.ac_.isOpen()) {
        this.moveUp_();
        e.preventDefault();
        return true;
      }
      break;

    // If tab key is pressed, select the current highlighted item.  The default
    // action is also prevented if the input is a multi input, to prevent the
    // user tabbing out of the field.
    case goog.events.KeyCodes.TAB:
      if (this.ac_.isOpen() && !e.shiftKey && !this.preventSelectionOnTab_) {
        // Ensure the menu is up to date before completing.
        this.update();
        if (this.ac_.selectHilited() && this.preventDefaultOnTab_) {
          e.preventDefault();
          return true;
        }
      } else {
        this.ac_.dismiss();
      }
      break;

    // On enter, just select the highlighted row.
    case goog.events.KeyCodes.ENTER:
      if (this.ac_.isOpen()) {
        // Ensure the menu is up to date before completing.
        this.update();
        if (this.ac_.selectHilited()) {
          e.preventDefault();
          e.stopPropagation();
          return true;
        }
      } else {
        this.ac_.dismiss();
      }
      break;

    // On escape tell the autocomplete to dismiss.
    case goog.events.KeyCodes.ESC:
      if (this.ac_.isOpen()) {
        this.ac_.dismiss();
        e.preventDefault();
        e.stopPropagation();
        return true;
      }
      break;

    // The IME keycode indicates an IME sequence has started, we ignore all
    // changes until we get an enter key-up.
    case goog.events.KeyCodes.WIN_IME:
      if (!this.waitingForIme_) {
        this.startWaitingForIme_();
        return true;
      }
      break;

    default:
      if (this.timer_ && !this.updateDuringTyping_) {
        // Waits throttle time before sending the request again.
        this.timer_.stop();
        this.timer_.start();
      }
  }

  return this.handleSeparator_(e);
};


/**
 * Handles a key event for a separator key.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @return {boolean} True if the key event was handled.
 * @private
 */
goog.ui.ac.InputHandler.prototype.handleSeparator_ = function(e) {
  'use strict';
  var isSeparatorKey = this.multi_ && e.charCode &&
      this.separators_.indexOf(String.fromCharCode(e.charCode)) != -1;
  if (this.separatorUpdates_ && isSeparatorKey) {
    this.update();
  }
  if (this.separatorSelects_ && isSeparatorKey) {
    if (this.ac_.selectHilited()) {
      e.preventDefault();
      return true;
    }
  }
  return false;
};


/**
 * @return {boolean} Whether this inputhandler need to listen on key-up.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.needKeyUpListener = function() {
  'use strict';
  return false;
};


/**
 * Handles the key up event. Registered only if needKeyUpListener returns true.
 * @param {goog.events.Event} e The keyup event.
 * @return {boolean} Whether an action was taken or not.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.handleKeyUp = function(e) {
  'use strict';
  return false;
};


/**
 * Adds the necessary input event handlers.
 * @private
 */
goog.ui.ac.InputHandler.prototype.addEventHandlers_ = function() {
  'use strict';
  this.keyHandler_.attach(this.activeElement_);
  this.eh_.listen(
      this.keyHandler_, goog.events.KeyHandler.EventType.KEY, this.onKey_);
  if (this.needKeyUpListener()) {
    this.eh_.listen(
        this.activeElement_, goog.events.EventType.KEYUP, this.handleKeyUp);
  }
  this.eh_.listen(
      this.activeElement_, goog.events.EventType.MOUSEDOWN, this.onMouseDown_);

  // IE6 also needs a keypress to check if the user typed a separator
  if (goog.userAgent.IE) {
    this.eh_.listen(
        this.activeElement_, goog.events.EventType.KEYPRESS,
        this.onIeKeyPress_);
  }
};


/**
 * Removes the necessary input event handlers.
 * @private
 */
goog.ui.ac.InputHandler.prototype.removeEventHandlers_ = function() {
  'use strict';
  this.eh_.unlisten(
      this.keyHandler_, goog.events.KeyHandler.EventType.KEY, this.onKey_);
  this.keyHandler_.detach();
  this.eh_.unlisten(
      this.activeElement_, goog.events.EventType.KEYUP, this.handleKeyUp);
  this.eh_.unlisten(
      this.activeElement_, goog.events.EventType.MOUSEDOWN, this.onMouseDown_);

  if (goog.userAgent.IE) {
    this.eh_.unlisten(
        this.activeElement_, goog.events.EventType.KEYPRESS,
        this.onIeKeyPress_);
  }

  if (this.waitingForIme_) {
    this.stopWaitingForIme_();
  }
};


/**
 * Handles an element getting focus.
 * @param {goog.events.Event} e Browser event object.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.handleFocus = function(e) {
  'use strict';
  this.processFocus(/** @type {Element} */ (e.target || null));
};


/**
 * Registers handlers for the active element when it receives focus.
 * @param {Element} target The element to focus.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.processFocus = function(target) {
  'use strict';
  this.activateHandler_.removeAll();

  if (this.ac_) {
    this.ac_.cancelDelayedDismiss();
  }

  // Double-check whether the active element has actually changed.
  // This is a fix for Safari 3, which fires spurious focus events.
  if (target != this.activeElement_) {
    this.activeElement_ = target;
    if (this.timer_) {
      this.timer_.start();
      this.eh_.listen(this.timer_, goog.Timer.TICK, this.onTick_);
    }
    this.lastValue_ = this.getValue();
    this.addEventHandlers_();
  }
};


/**
 * Handles an element blurring.
 * @param {goog.events.Event=} opt_e Browser event object.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.handleBlur = function(opt_e) {
  'use strict';
  // Phones running iOS prior to version 4.2.
  if (goog.ui.ac.InputHandler.REQUIRES_ASYNC_BLUR_) {
    // @bug 4484488 This is required so that the menu works correctly on
    // iOS prior to version 4.2. Otherwise, the blur action closes the menu
    // before the menu button click can be processed.
    // In order to fix the bug, we set a timeout to process the blur event, so
    // that any pending selection event can be processed first.
    this.activeTimeoutId_ =
        window.setTimeout(goog.bind(this.processBlur, this), 0);
    return;
  } else {
    this.processBlur();
  }
};


/**
 * Helper function that does the logic to handle an element blurring.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.processBlur = function() {
  'use strict';
  // it's possible that a blur event could fire when there's no active element,
  // in the case where attachInput was called on an input that already had
  // the focus
  if (this.activeElement_) {
    this.removeEventHandlers_();
    this.activeElement_ = null;

    if (this.timer_) {
      this.timer_.stop();
      this.eh_.unlisten(this.timer_, goog.Timer.TICK, this.onTick_);
    }

    if (this.ac_) {
      // Pause dismissal slightly to take into account any other events that
      // might fire on the renderer (e.g. a click will lose the focus).
      this.ac_.dismissOnDelay();
    }
  }
};


/**
 * Handles the timer's tick event.  Calculates the current token, and reports
 * any update to the autocomplete.
 * @param {goog.events.Event} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onTick_ = function(e) {
  'use strict';
  this.update();
};


/**
 * Handles typing in an inactive input element. Activate it.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onKeyDownOnInactiveElement_ = function(e) {
  'use strict';
  this.handleFocus(e);
};


/**
 * Handles typing in the active input element.  Checks if the key is a special
 * key and does the relevant action as appropriate.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onKey_ = function(e) {
  'use strict';
  this.lastKeyCode_ = e.keyCode;
  if (this.ac_) {
    this.handleKeyEvent(e);
  }
};


/**
 * Handles a KEYPRESS event generated by typing in the active input element.
 * Checks if IME input is ended.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onKeyPress_ = function(e) {
  'use strict';
  if (this.waitingForIme_ &&
      this.lastKeyCode_ != goog.events.KeyCodes.WIN_IME) {
    this.stopWaitingForIme_();
  }
};


/**
 * Handles the key-up event.  This is only ever used by Mac FF or when we are in
 * an IME entry scenario.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onKeyUp_ = function(e) {
  'use strict';
  if (this.waitingForIme_ &&
      (e.keyCode == goog.events.KeyCodes.ENTER ||
       (e.keyCode == goog.events.KeyCodes.M && e.ctrlKey))) {
    this.stopWaitingForIme_();
  }
};


/**
 * Handles mouse-down event.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onMouseDown_ = function(e) {
  'use strict';
  if (this.ac_) {
    this.handleMouseDown(e);
  }
};


/**
 * For subclasses to override to handle the mouse-down event.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.handleMouseDown = function(e) {};


/**
 * Starts waiting for IME.
 * @private
 */
goog.ui.ac.InputHandler.prototype.startWaitingForIme_ = function() {
  'use strict';
  if (this.waitingForIme_) {
    return;
  }
  this.eh_.listen(
      this.activeElement_, goog.events.EventType.KEYUP, this.onKeyUp_);
  this.eh_.listen(
      this.activeElement_, goog.events.EventType.KEYPRESS, this.onKeyPress_);
  this.waitingForIme_ = true;
};


/**
 * Stops waiting for IME.
 * @private
 */
goog.ui.ac.InputHandler.prototype.stopWaitingForIme_ = function() {
  'use strict';
  if (!this.waitingForIme_) {
    return;
  }
  this.waitingForIme_ = false;
  this.eh_.unlisten(
      this.activeElement_, goog.events.EventType.KEYPRESS, this.onKeyPress_);
  this.eh_.unlisten(
      this.activeElement_, goog.events.EventType.KEYUP, this.onKeyUp_);
};


/**
 * Handles the key-press event for IE, checking to see if the user typed a
 * separator character.
 * @param {goog.events.BrowserEvent} e Browser event object.
 * @private
 */
goog.ui.ac.InputHandler.prototype.onIeKeyPress_ = function(e) {
  'use strict';
  this.handleSeparator_(e);
};


/**
 * Checks if an update has occurred and notified the autocomplete of the new
 * token.
 * @param {boolean=} opt_force If true the menu will be forced to update.
 */
goog.ui.ac.InputHandler.prototype.update = function(opt_force) {
  'use strict';
  if (this.activeElement_ &&
      (opt_force || this.getValue() != this.lastValue_)) {
    if (opt_force || !this.rowJustSelected_) {
      var token = this.parseToken();

      if (this.ac_) {
        this.ac_.setTarget(this.activeElement_);
        this.ac_.setToken(token, this.getValue());
      }
    }
    this.lastValue_ = this.getValue();
  }
  this.rowJustSelected_ = false;
};


/**
 * Parses a text area or input box for the currently highlighted token.
 * @return {string} Token to complete.
 * @protected
 */
goog.ui.ac.InputHandler.prototype.parseToken = function() {
  'use strict';
  return this.parseToken_();
};


/**
 * Moves hilite up.  May hilite next or previous depending on orientation.
 * @return {boolean} True if successful.
 * @private
 */
goog.ui.ac.InputHandler.prototype.moveUp_ = function() {
  'use strict';
  return this.upsideDown_ ? this.ac_.hiliteNext() : this.ac_.hilitePrev();
};


/**
 * Moves hilite down.  May hilite next or previous depending on orientation.
 * @return {boolean} True if successful.
 * @private
 */
goog.ui.ac.InputHandler.prototype.moveDown_ = function() {
  'use strict';
  return this.upsideDown_ ? this.ac_.hilitePrev() : this.ac_.hiliteNext();
};


/**
 * Parses a text area or input box for the currently highlighted token.
 * @return {string} Token to complete.
 * @private
 */
goog.ui.ac.InputHandler.prototype.parseToken_ = function() {
  'use strict';
  var caret = this.getCursorPosition();
  var text = this.getValue();
  return this.trim_(this.splitInput_(text)[this.getTokenIndex_(text, caret)]);
};


/**
 * Trims a token of characters that we want to ignore
 * @param {string} text string to trim.
 * @return {string} Trimmed string.
 * @private
 */
goog.ui.ac.InputHandler.prototype.trim_ = function(text) {
  'use strict';
  return this.trimmer_ ? String(text).replace(this.trimmer_, '') : text;
};


/**
 * Gets the index of the currently highlighted token
 * @param {string} text string to parse.
 * @param {number} caret Position of cursor in string.
 * @return {number} Index of token.
 * @private
 */
goog.ui.ac.InputHandler.prototype.getTokenIndex_ = function(text, caret) {
  'use strict';
  // Split up the input string into multiple entries
  var entries = this.splitInput_(text);

  // Short-circuit to select the last entry
  if (caret == text.length) return entries.length - 1;

  // Calculate which of the entries the cursor is currently in
  var current = 0;
  for (var i = 0, pos = 0; i < entries.length && pos <= caret; i++) {
    pos += entries[i].length;
    current = i;
  }

  // Get the token for the current item
  return current;
};


/**
 * Splits an input string of text at the occurrence of a character in
 * {@link goog.ui.ac.InputHandler.prototype.separators_} and creates
 * an array of tokens.  Each token may contain additional whitespace and
 * formatting marks.  If necessary use
 * {@link goog.ui.ac.InputHandler.prototype.trim_} to clean up the
 * entries.
 *
 * @param {string} text Input text.
 * @return {!Array<string>} Parsed array.
 * @private
 */
goog.ui.ac.InputHandler.prototype.splitInput_ = function(text) {
  'use strict';
  if (!this.multi_) {
    return [text];
  }

  var arr = String(text).split('');
  var parts = [];
  var cache = [];

  for (var i = 0, inLiteral = false; i < arr.length; i++) {
    if (this.literals_ && this.literals_.indexOf(arr[i]) != -1) {
      if (this.generateNewTokenOnLiteral_ && !inLiteral) {
        parts.push(cache.join(''));
        cache.length = 0;
      }
      cache.push(arr[i]);
      inLiteral = !inLiteral;

    } else if (!inLiteral && this.separators_.indexOf(arr[i]) != -1) {
      cache.push(arr[i]);
      parts.push(cache.join(''));
      cache.length = 0;

    } else {
      cache.push(arr[i]);
    }
  }
  parts.push(cache.join(''));

  return parts;
};

//third_party/javascript/closure/ui/ac/remotearraymatcher.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Class that retrieves autocomplete matches via an ajax call.
 */

goog.provide('goog.ui.ac.RemoteArrayMatcher');

goog.require('goog.Disposable');
goog.require('goog.Uri');
goog.require('goog.events');
goog.require('goog.net.EventType');
goog.require('goog.net.XhrIo');
goog.requireType('goog.events.Event');
goog.requireType('goog.net.XmlHttpFactory');
goog.requireType('goog.structs.Map');



/**
 * An array matcher that requests matches via ajax.
 * @param {string} url The Uri which generates the auto complete matches.  The
 *     search term is passed to the server as the 'token' query param.
 * @param {boolean=} opt_noSimilar If true, request that the server does not do
 *     similarity matches for the input token against the dictionary.
 *     The value is sent to the server as the 'use_similar' query param which is
 *     either "1" (opt_noSimilar==false) or "0" (opt_noSimilar==true).
 * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Specify the
 *     XmlHttpFactory used to retrieve the matches.
 * @constructor
 * @extends {goog.Disposable}
 */
goog.ui.ac.RemoteArrayMatcher = function(
    url, opt_noSimilar, opt_xmlHttpFactory) {
  'use strict';
  goog.Disposable.call(this);

  /**
   * The base URL for the ajax call.  The token and max_matches are added as
   * query params.
   * @type {string}
   * @private
   */
  this.url_ = url;

  /**
   * Whether similar matches should be found as well.  This is sent as a hint
   * to the server only.
   * @type {boolean}
   * @private
   */
  this.useSimilar_ = !opt_noSimilar;

  /**
   * The XhrIo object used for making remote requests.  When a new request
   * is made, the current one is aborted and the new one sent.
   * @type {goog.net.XhrIo}
   * @private
   */
  this.xhr_ = new goog.net.XhrIo(opt_xmlHttpFactory);
};
goog.inherits(goog.ui.ac.RemoteArrayMatcher, goog.Disposable);


/**
 * The HTTP send method (GET, POST) to use when making the ajax call.
 * @type {string}
 * @private
 */
goog.ui.ac.RemoteArrayMatcher.prototype.method_ = 'GET';


/**
 * Data to submit during a POST.
 * @type {string|undefined}
 * @private
 */
goog.ui.ac.RemoteArrayMatcher.prototype.content_ = undefined;


/**
 * Headers to send with every HTTP request.
 * @type {?Object|?goog.structs.Map}
 * @private
 */
goog.ui.ac.RemoteArrayMatcher.prototype.headers_ = null;


/**
 * Key to the listener on XHR. Used to clear previous listeners.
 * @type {?goog.events.Key}
 * @private
 */
goog.ui.ac.RemoteArrayMatcher.prototype.lastListenerKey_ = null;


/**
 * Set the send method ("GET", "POST").
 * @param {string} method The send method; default: GET.
 */
goog.ui.ac.RemoteArrayMatcher.prototype.setMethod = function(method) {
  'use strict';
  this.method_ = method;
};


/**
 * Set the post data.
 * @param {string} content Post data.
 */
goog.ui.ac.RemoteArrayMatcher.prototype.setContent = function(content) {
  'use strict';
  this.content_ = content;
};


/**
 * Set the HTTP headers.
 * @param {Object|goog.structs.Map} headers Map of headers to add to the
 *     request.
 */
goog.ui.ac.RemoteArrayMatcher.prototype.setHeaders = function(headers) {
  'use strict';
  this.headers_ = headers;
};


/**
 * Set the timeout interval.
 * @param {number} interval Number of milliseconds after which an
 *     incomplete request will be aborted; 0 means no timeout is set.
 */
goog.ui.ac.RemoteArrayMatcher.prototype.setTimeoutInterval = function(
    interval) {
  'use strict';
  this.xhr_.setTimeoutInterval(interval);
};


/**
 * Builds a complete GET-style URL, given the base URI and autocomplete related
 * parameter values.
 * <b>Override this to build any customized lookup URLs.</b>
 * <b>Can be used to change request method and any post content as well.</b>
 * @param {string} uri The base URI of the request target.
 * @param {string} token Current token in autocomplete.
 * @param {number} maxMatches Maximum number of matches required.
 * @param {boolean} useSimilar A hint to the server.
 * @param {string=} opt_fullString Complete text in the input element.
 * @return {?string} The complete url. Return null if no request should be sent.
 * @protected
 */
goog.ui.ac.RemoteArrayMatcher.prototype.buildUrl = function(
    uri, token, maxMatches, useSimilar, opt_fullString) {
  'use strict';
  var url = new goog.Uri(uri);
  url.setParameterValue('token', token);
  url.setParameterValue('max_matches', String(maxMatches));
  url.setParameterValue('use_similar', String(Number(useSimilar)));
  return url.toString();
};


/**
 * Returns whether the suggestions should be updated?
 * <b>Override this to prevent updates eg - when token is empty.</b>
 * @param {string} uri The base URI of the request target.
 * @param {string} token Current token in autocomplete.
 * @param {number} maxMatches Maximum number of matches required.
 * @param {boolean} useSimilar A hint to the server.
 * @param {string=} opt_fullString Complete text in the input element.
 * @return {boolean} Whether new matches be requested.
 * @protected
 */
goog.ui.ac.RemoteArrayMatcher.prototype.shouldRequestMatches = function(
    uri, token, maxMatches, useSimilar, opt_fullString) {
  'use strict';
  return true;
};


/**
 * Parses and retrieves the array of suggestions from XHR response.
 * <b>Override this if the response is not a simple JSON array.</b>
 * @param {string} responseText The XHR response text.
 * @return {Array<string>} The array of suggestions.
 * @protected
 */
goog.ui.ac.RemoteArrayMatcher.prototype.parseResponseText = function(
    responseText) {
  'use strict';
  var matches = [];
  // If there is no response text, JSON.parse will throw a syntax error.
  if (responseText) {

    try {
      matches = JSON.parse(responseText);
    } catch (exception) {
    }
  }
  return /** @type {Array<string>} */ (matches);
};


/**
 * Handles the XHR response.
 * @param {string} token The XHR autocomplete token.
 * @param {Function} matchHandler The AutoComplete match handler.
 * @param {goog.events.Event} event The XHR success event.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.RemoteArrayMatcher.prototype.xhrCallback = function(
    token, matchHandler, event) {
  'use strict';
  var text = event.target.getResponseText();
  matchHandler(token, this.parseResponseText(text));
};


/**
 * Retrieve a set of matching rows from the server via ajax.
 * @param {string} token The text that should be matched; passed to the server
 *     as the 'token' query param.
 * @param {number} maxMatches The maximum number of matches requested from the
 *     server; passed as the 'max_matches' query param.  The server is
 *     responsible for limiting the number of matches that are returned.
 * @param {Function} matchHandler Callback to execute on the result after
 *     matching.
 * @param {string=} opt_fullString The full string from the input box.
 */
goog.ui.ac.RemoteArrayMatcher.prototype.requestMatchingRows = function(
    token, maxMatches, matchHandler, opt_fullString) {
  'use strict';
  if (!this.shouldRequestMatches(
          this.url_, token, maxMatches, this.useSimilar_, opt_fullString)) {
    return;
  }
  // Set the query params on the URL.
  var url = this.buildUrl(
      this.url_, token, maxMatches, this.useSimilar_, opt_fullString);
  if (!url) {
    // Do nothing if there is no URL.
    return;
  }

  // The callback evals the server response and calls the match handler on
  // the array of matches.
  var callback = goog.bind(this.xhrCallback, this, token, matchHandler);

  // Abort the current request and issue the new one; prevent requests from
  // being queued up by the browser with a slow server
  if (this.xhr_.isActive()) {
    this.xhr_.abort();
  }
  // This ensures if previous XHR is aborted or ends with error, the
  // corresponding success-callbacks are cleared.
  if (this.lastListenerKey_) {
    goog.events.unlistenByKey(this.lastListenerKey_);
  }
  // Listen once ensures successful callback gets cleared by itself.
  this.lastListenerKey_ =
      goog.events.listenOnce(this.xhr_, goog.net.EventType.SUCCESS, callback);
  this.xhr_.send(url, this.method_, this.content_, this.headers_);
};


/** @override */
goog.ui.ac.RemoteArrayMatcher.prototype.disposeInternal = function() {
  'use strict';
  this.xhr_.dispose();
  goog.ui.ac.RemoteArrayMatcher.superClass_.disposeInternal.call(this);
};

//third_party/javascript/closure/color/names.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Names of standard colors with their associated hex values.
 */

goog.provide('goog.color.names');


/**
 * A map that contains a lot of colors that are recognised by various browsers.
 * This list is way larger than the minimal one dictated by W3C.
 * The keys of this map are the lowercase "readable" names of the colors, while
 * the values are the "hex" values.
 *
 * @type {!Object<string, string>}
 */
goog.color.names = {
  'aliceblue': '#f0f8ff',
  'antiquewhite': '#faebd7',
  'aqua': '#00ffff',
  'aquamarine': '#7fffd4',
  'azure': '#f0ffff',
  'beige': '#f5f5dc',
  'bisque': '#ffe4c4',
  'black': '#000000',
  'blanchedalmond': '#ffebcd',
  'blue': '#0000ff',
  'blueviolet': '#8a2be2',
  'brown': '#a52a2a',
  'burlywood': '#deb887',
  'cadetblue': '#5f9ea0',
  'chartreuse': '#7fff00',
  'chocolate': '#d2691e',
  'coral': '#ff7f50',
  'cornflowerblue': '#6495ed',
  'cornsilk': '#fff8dc',
  'crimson': '#dc143c',
  'cyan': '#00ffff',
  'darkblue': '#00008b',
  'darkcyan': '#008b8b',
  'darkgoldenrod': '#b8860b',
  'darkgray': '#a9a9a9',
  'darkgreen': '#006400',
  'darkgrey': '#a9a9a9',
  'darkkhaki': '#bdb76b',
  'darkmagenta': '#8b008b',
  'darkolivegreen': '#556b2f',
  'darkorange': '#ff8c00',
  'darkorchid': '#9932cc',
  'darkred': '#8b0000',
  'darksalmon': '#e9967a',
  'darkseagreen': '#8fbc8f',
  'darkslateblue': '#483d8b',
  'darkslategray': '#2f4f4f',
  'darkslategrey': '#2f4f4f',
  'darkturquoise': '#00ced1',
  'darkviolet': '#9400d3',
  'deeppink': '#ff1493',
  'deepskyblue': '#00bfff',
  'dimgray': '#696969',
  'dimgrey': '#696969',
  'dodgerblue': '#1e90ff',
  'firebrick': '#b22222',
  'floralwhite': '#fffaf0',
  'forestgreen': '#228b22',
  'fuchsia': '#ff00ff',
  'gainsboro': '#dcdcdc',
  'ghostwhite': '#f8f8ff',
  'gold': '#ffd700',
  'goldenrod': '#daa520',
  'gray': '#808080',
  'green': '#008000',
  'greenyellow': '#adff2f',
  'grey': '#808080',
  'honeydew': '#f0fff0',
  'hotpink': '#ff69b4',
  'indianred': '#cd5c5c',
  'indigo': '#4b0082',
  'ivory': '#fffff0',
  'khaki': '#f0e68c',
  'lavender': '#e6e6fa',
  'lavenderblush': '#fff0f5',
  'lawngreen': '#7cfc00',
  'lemonchiffon': '#fffacd',
  'lightblue': '#add8e6',
  'lightcoral': '#f08080',
  'lightcyan': '#e0ffff',
  'lightgoldenrodyellow': '#fafad2',
  'lightgray': '#d3d3d3',
  'lightgreen': '#90ee90',
  'lightgrey': '#d3d3d3',
  'lightpink': '#ffb6c1',
  'lightsalmon': '#ffa07a',
  'lightseagreen': '#20b2aa',
  'lightskyblue': '#87cefa',
  'lightslategray': '#778899',
  'lightslategrey': '#778899',
  'lightsteelblue': '#b0c4de',
  'lightyellow': '#ffffe0',
  'lime': '#00ff00',
  'limegreen': '#32cd32',
  'linen': '#faf0e6',
  'magenta': '#ff00ff',
  'maroon': '#800000',
  'mediumaquamarine': '#66cdaa',
  'mediumblue': '#0000cd',
  'mediumorchid': '#ba55d3',
  'mediumpurple': '#9370db',
  'mediumseagreen': '#3cb371',
  'mediumslateblue': '#7b68ee',
  'mediumspringgreen': '#00fa9a',
  'mediumturquoise': '#48d1cc',
  'mediumvioletred': '#c71585',
  'midnightblue': '#191970',
  'mintcream': '#f5fffa',
  'mistyrose': '#ffe4e1',
  'moccasin': '#ffe4b5',
  'navajowhite': '#ffdead',
  'navy': '#000080',
  'oldlace': '#fdf5e6',
  'olive': '#808000',
  'olivedrab': '#6b8e23',
  'orange': '#ffa500',
  'orangered': '#ff4500',
  'orchid': '#da70d6',
  'palegoldenrod': '#eee8aa',
  'palegreen': '#98fb98',
  'paleturquoise': '#afeeee',
  'palevioletred': '#db7093',
  'papayawhip': '#ffefd5',
  'peachpuff': '#ffdab9',
  'peru': '#cd853f',
  'pink': '#ffc0cb',
  'plum': '#dda0dd',
  'powderblue': '#b0e0e6',
  'purple': '#800080',
  'red': '#ff0000',
  'rosybrown': '#bc8f8f',
  'royalblue': '#4169e1',
  'saddlebrown': '#8b4513',
  'salmon': '#fa8072',
  'sandybrown': '#f4a460',
  'seagreen': '#2e8b57',
  'seashell': '#fff5ee',
  'sienna': '#a0522d',
  'silver': '#c0c0c0',
  'skyblue': '#87ceeb',
  'slateblue': '#6a5acd',
  'slategray': '#708090',
  'slategrey': '#708090',
  'snow': '#fffafa',
  'springgreen': '#00ff7f',
  'steelblue': '#4682b4',
  'tan': '#d2b48c',
  'teal': '#008080',
  'thistle': '#d8bfd8',
  'tomato': '#ff6347',
  'turquoise': '#40e0d0',
  'violet': '#ee82ee',
  'wheat': '#f5deb3',
  'white': '#ffffff',
  'whitesmoke': '#f5f5f5',
  'yellow': '#ffff00',
  'yellowgreen': '#9acd32'
};

//third_party/javascript/closure/color/color.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities related to color and color conversion.
 */

goog.provide('goog.color');
goog.provide('goog.color.Hsl');
goog.provide('goog.color.Hsv');
goog.provide('goog.color.Rgb');

goog.require('goog.color.names');
goog.require('goog.math');


/**
 * RGB color representation. An array containing three elements [r, g, b],
 * each an integer in [0, 255], representing the red, green, and blue components
 * of the color respectively.
 * @typedef {Array<number>}
 */
goog.color.Rgb;


/**
 * HSV color representation. An array containing three elements [h, s, v]:
 * h (hue) must be an integer in [0, 360], cyclic.
 * s (saturation) must be a number in [0, 1].
 * v (value/brightness) must be an integer in [0, 255].
 * @typedef {Array<number>}
 */
goog.color.Hsv;


/**
 * HSL color representation. An array containing three elements [h, s, l]:
 * h (hue) must be an integer in [0, 360], cyclic.
 * s (saturation) must be a number in [0, 1].
 * l (lightness) must be a number in [0, 1].
 * @typedef {Array<number>}
 */
goog.color.Hsl;


/**
 * Parses a color out of a string.
 * @param {string} str Color in some format.
 * @return {{hex: string, type: string}} 'hex' is a string containing a hex
 *     representation of the color, 'type' is a string containing the type
 *     of color format passed in ('hex', 'rgb', 'named').
 */
goog.color.parse = function(str) {
  'use strict';
  const result = {};
  str = String(str);

  const maybeHex = goog.color.prependHashIfNecessaryHelper(str);
  if (goog.color.isValidHexColor_(maybeHex)) {
    result.hex = goog.color.normalizeHex(maybeHex);
    result.type = 'hex';
    return result;
  } else {
    const rgb = goog.color.isValidRgbColor_(str);
    if (rgb.length) {
      result.hex = goog.color.rgbArrayToHex(rgb);
      result.type = 'rgb';
      return result;
    } else if (goog.color.names) {
      const hex = goog.color.names[str.toLowerCase()];
      if (hex) {
        result.hex = hex;
        result.type = 'named';
        return result;
      }
    }
  }
  throw Error(str + ' is not a valid color string');
};


/**
 * Determines if the given string can be parsed as a color.
 *     {@see goog.color.parse}.
 * @param {string} str Potential color string.
 * @return {boolean} True if str is in a format that can be parsed to a color.
 */
goog.color.isValidColor = function(str) {
  'use strict';
  const maybeHex = goog.color.prependHashIfNecessaryHelper(str);
  return !!(
      goog.color.isValidHexColor_(maybeHex) ||
      goog.color.isValidRgbColor_(str).length ||
      goog.color.names && goog.color.names[str.toLowerCase()]);
};


/**
 * Parses red, green, blue components out of a valid rgb color string.
 * Throws Error if the color string is invalid.
 * @param {string} str RGB representation of a color.
 *    {@see goog.color.isValidRgbColor_}.
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.parseRgb = function(str) {
  'use strict';
  const rgb = goog.color.isValidRgbColor_(str);
  if (!rgb.length) {
    throw Error(str + ' is not a valid RGB color');
  }
  return rgb;
};


/**
 * Converts a hex representation of a color to RGB.
 * @param {string} hexColor Color to convert.
 * @return {string} string of the form 'rgb(R,G,B)' which can be used in
 *    styles.
 */
goog.color.hexToRgbStyle = function(hexColor) {
  'use strict';
  return goog.color.rgbStyle_(goog.color.hexToRgb(hexColor));
};


/**
 * Regular expression for extracting the digits in a hex color triplet.
 * @type {!RegExp}
 * @private
 */
goog.color.hexTripletRe_ = /#(.)(.)(.)/;


/**
 * Normalize an hex representation of a color
 * @param {string} hexColor an hex color string.
 * @return {string} hex color in the format '#rrggbb' with all lowercase
 *     literals.
 */
goog.color.normalizeHex = function(hexColor) {
  'use strict';
  if (!goog.color.isValidHexColor_(hexColor)) {
    throw Error("'" + hexColor + "' is not a valid hex color");
  }
  if (hexColor.length == 4) {  // of the form #RGB
    hexColor = hexColor.replace(goog.color.hexTripletRe_, '#$1$1$2$2$3$3');
  }
  return hexColor.toLowerCase();
};


/**
 * Converts a hex representation of a color to RGB.
 * @param {string} hexColor Color to convert.
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.hexToRgb = function(hexColor) {
  'use strict';
  hexColor = goog.color.normalizeHex(hexColor);
  const rgb = parseInt(hexColor.substr(1), 16);
  const r = rgb >> 16;
  const g = (rgb >> 8) & 255;
  const b = rgb & 255;

  return [r, g, b];
};


/**
 * Converts a color from RGB to hex representation.
 * @param {number} r Amount of red, int between 0 and 255.
 * @param {number} g Amount of green, int between 0 and 255.
 * @param {number} b Amount of blue, int between 0 and 255.
 * @return {string} hex representation of the color.
 */
goog.color.rgbToHex = function(r, g, b) {
  'use strict';
  r = Number(r);
  g = Number(g);
  b = Number(b);
  if (r != (r & 255) || g != (g & 255) || b != (b & 255)) {
    throw Error('"(' + r + ',' + g + ',' + b + '") is not a valid RGB color');
  }
  const rgb = (r << 16) | (g << 8) | b;
  if (r < 0x10) {
    return '#' + (0x1000000 | rgb).toString(16).substr(1);
  }
  return '#' + rgb.toString(16);
};


/**
 * Converts a color from RGB to hex representation.
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @return {string} hex representation of the color.
 */
goog.color.rgbArrayToHex = function(rgb) {
  'use strict';
  return goog.color.rgbToHex(rgb[0], rgb[1], rgb[2]);
};


/**
 * Converts a color from RGB color space to HSL color space.
 * Modified from {@link http://en.wikipedia.org/wiki/HLS_color_space}.
 * @param {number} r Value of red, in [0, 255].
 * @param {number} g Value of green, in [0, 255].
 * @param {number} b Value of blue, in [0, 255].
 * @return {!goog.color.Hsl} hsl representation of the color.
 */
goog.color.rgbToHsl = function(r, g, b) {
  'use strict';
  // First must normalize r, g, b to be between 0 and 1.
  const normR = r / 255;
  const normG = g / 255;
  const normB = b / 255;
  const max = Math.max(normR, normG, normB);
  const min = Math.min(normR, normG, normB);
  let h = 0;
  let s = 0;

  // Luminosity is the average of the max and min rgb color intensities.
  const l = 0.5 * (max + min);

  // The hue and saturation are dependent on which color intensity is the max.
  // If max and min are equal, the color is gray and h and s should be 0.
  if (max != min) {
    if (max == normR) {
      h = 60 * (normG - normB) / (max - min);
    } else if (max == normG) {
      h = 60 * (normB - normR) / (max - min) + 120;
    } else if (max == normB) {
      h = 60 * (normR - normG) / (max - min) + 240;
    }

    if (0 < l && l <= 0.5) {
      s = (max - min) / (2 * l);
    } else {
      s = (max - min) / (2 - 2 * l);
    }
  }

  // Make sure the hue falls between 0 and 360.
  return [Math.round(h + 360) % 360, s, l];
};


/**
 * Converts a color from RGB color space to HSL color space.
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @return {!goog.color.Hsl} hsl representation of the color.
 */
goog.color.rgbArrayToHsl = function(rgb) {
  'use strict';
  return goog.color.rgbToHsl(rgb[0], rgb[1], rgb[2]);
};


/**
 * Helper for hslToRgb.
 * @param {number} v1 Helper variable 1.
 * @param {number} v2 Helper variable 2.
 * @param {number} vH Helper variable 3.
 * @return {number} Appropriate RGB value, given the above.
 * @private
 */
goog.color.hueToRgb_ = function(v1, v2, vH) {
  'use strict';
  if (vH < 0) {
    vH += 1;
  } else if (vH > 1) {
    vH -= 1;
  }
  if ((6 * vH) < 1) {
    return (v1 + (v2 - v1) * 6 * vH);
  } else if (2 * vH < 1) {
    return v2;
  } else if (3 * vH < 2) {
    return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
  }
  return v1;
};


/**
 * Converts a color from HSL color space to RGB color space.
 * Modified from {@link http://www.easyrgb.com/math.html}
 * @param {number} h Hue, in [0, 360].
 * @param {number} s Saturation, in [0, 1].
 * @param {number} l Luminosity, in [0, 1].
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.hslToRgb = function(h, s, l) {
  'use strict';
  let r = 0;
  let g = 0;
  let b = 0;
  const normH = h / 360;  // normalize h to fall in [0, 1]

  if (s == 0) {
    r = g = b = l * 255;
  } else {
    let temp1 = 0;
    let temp2 = 0;
    if (l < 0.5) {
      temp2 = l * (1 + s);
    } else {
      temp2 = l + s - (s * l);
    }
    temp1 = 2 * l - temp2;
    r = 255 * goog.color.hueToRgb_(temp1, temp2, normH + (1 / 3));
    g = 255 * goog.color.hueToRgb_(temp1, temp2, normH);
    b = 255 * goog.color.hueToRgb_(temp1, temp2, normH - (1 / 3));
  }

  return [Math.round(r), Math.round(g), Math.round(b)];
};


/**
 * Converts a color from HSL color space to RGB color space.
 * @param {goog.color.Hsl} hsl hsl representation of the color.
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.hslArrayToRgb = function(hsl) {
  'use strict';
  return goog.color.hslToRgb(hsl[0], hsl[1], hsl[2]);
};


/**
 * Helper for isValidHexColor_.
 * @type {!RegExp}
 * @private
 */
goog.color.validHexColorRe_ = /^#(?:[0-9a-f]{3}){1,2}$/i;


/**
 * Checks if a string is a valid hex color.  We expect strings of the format
 * #RRGGBB (ex: #1b3d5f) or #RGB (ex: #3CA == #33CCAA).
 * @param {string} str String to check.
 * @return {boolean} Whether the string is a valid hex color.
 * @private
 */
goog.color.isValidHexColor_ = function(str) {
  'use strict';
  return goog.color.validHexColorRe_.test(str);
};


/**
 * Regular expression for matching and capturing RGB style strings. Helper for
 * isValidRgbColor_.
 * @type {!RegExp}
 * @private
 */
goog.color.rgbColorRe_ =
    /^(?:rgb)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2})\)$/i;


/**
 * Checks if a string is a valid rgb color.  We expect strings of the format
 * '(r, g, b)', or 'rgb(r, g, b)', where each color component is an int in
 * [0, 255].
 * @param {string} str String to check.
 * @return {!goog.color.Rgb} the rgb representation of the color if it is
 *     a valid color, or the empty array otherwise.
 * @private
 */
goog.color.isValidRgbColor_ = function(str) {
  'use strict';
  // Each component is separate (rather than using a repeater) so we can
  // capture the match. Also, we explicitly set each component to be either 0,
  // or start with a non-zero, to prevent octal numbers from slipping through.
  const regExpResultArray = str.match(goog.color.rgbColorRe_);
  if (regExpResultArray) {
    const r = Number(regExpResultArray[1]);
    const g = Number(regExpResultArray[2]);
    const b = Number(regExpResultArray[3]);
    if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
      return [r, g, b];
    }
  }
  return [];
};


/**
 * Takes a hex value and prepends a zero if it's a single digit.
 * Small helper method for use by goog.color and friends.
 * @param {string} hex Hex value to prepend if single digit.
 * @return {string} hex value prepended with zero if it was single digit,
 *     otherwise the same value that was passed in.
 */
goog.color.prependZeroIfNecessaryHelper = function(hex) {
  'use strict';
  return hex.length == 1 ? '0' + hex : hex;
};


/**
 * Takes a string a prepends a '#' sign if one doesn't exist.
 * Small helper method for use by goog.color and friends.
 * @param {string} str String to check.
 * @return {string} The value passed in, prepended with a '#' if it didn't
 *     already have one.
 */
goog.color.prependHashIfNecessaryHelper = function(str) {
  'use strict';
  return str.charAt(0) == '#' ? str : '#' + str;
};


/**
 * Takes an array of [r, g, b] and converts it into a string appropriate for
 * CSS styles.
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @return {string} string of the form 'rgb(r,g,b)'.
 * @private
 */
goog.color.rgbStyle_ = function(rgb) {
  'use strict';
  return 'rgb(' + rgb.join(',') + ')';
};


/**
 * Converts an HSV triplet to an RGB array.  V is brightness because b is
 *   reserved for blue in RGB.
 * @param {number} h Hue value in [0, 360].
 * @param {number} s Saturation value in [0, 1].
 * @param {number} brightness brightness in [0, 255].
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.hsvToRgb = function(h, s, brightness) {
  'use strict';
  let red = 0;
  let green = 0;
  let blue = 0;
  if (s == 0) {
    red = brightness;
    green = brightness;
    blue = brightness;
  } else {
    const sextant = Math.floor(h / 60);
    const remainder = (h / 60) - sextant;
    const val1 = brightness * (1 - s);
    const val2 = brightness * (1 - (s * remainder));
    const val3 = brightness * (1 - (s * (1 - remainder)));
    switch (sextant) {
      case 1:
        red = val2;
        green = brightness;
        blue = val1;
        break;
      case 2:
        red = val1;
        green = brightness;
        blue = val3;
        break;
      case 3:
        red = val1;
        green = val2;
        blue = brightness;
        break;
      case 4:
        red = val3;
        green = val1;
        blue = brightness;
        break;
      case 5:
        red = brightness;
        green = val1;
        blue = val2;
        break;
      case 6:
      case 0:
        red = brightness;
        green = val3;
        blue = val1;
        break;
    }
  }

  return [Math.round(red), Math.round(green), Math.round(blue)];
};


/**
 * Converts from RGB values to an array of HSV values.
 * @param {number} red Red value in [0, 255].
 * @param {number} green Green value in [0, 255].
 * @param {number} blue Blue value in [0, 255].
 * @return {!goog.color.Hsv} hsv representation of the color.
 */
goog.color.rgbToHsv = function(red, green, blue) {
  'use strict';
  const max = Math.max(Math.max(red, green), blue);
  const min = Math.min(Math.min(red, green), blue);
  let hue;
  let saturation;
  const value = max;
  if (min == max) {
    hue = 0;
    saturation = 0;
  } else {
    const delta = (max - min);
    saturation = delta / max;

    if (red == max) {
      hue = (green - blue) / delta;
    } else if (green == max) {
      hue = 2 + ((blue - red) / delta);
    } else {
      hue = 4 + ((red - green) / delta);
    }
    hue *= 60;
    if (hue < 0) {
      hue += 360;
    }
    if (hue > 360) {
      hue -= 360;
    }
  }

  return [hue, saturation, value];
};


/**
 * Converts from an array of RGB values to an array of HSV values.
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @return {!goog.color.Hsv} hsv representation of the color.
 */
goog.color.rgbArrayToHsv = function(rgb) {
  'use strict';
  return goog.color.rgbToHsv(rgb[0], rgb[1], rgb[2]);
};


/**
 * Converts an HSV triplet to an RGB array.
 * @param {goog.color.Hsv} hsv hsv representation of the color.
 * @return {!goog.color.Rgb} rgb representation of the color.
 */
goog.color.hsvArrayToRgb = function(hsv) {
  'use strict';
  return goog.color.hsvToRgb(hsv[0], hsv[1], hsv[2]);
};


/**
 * Converts a hex representation of a color to HSL.
 * @param {string} hex Color to convert.
 * @return {!goog.color.Hsl} hsl representation of the color.
 */
goog.color.hexToHsl = function(hex) {
  'use strict';
  const rgb = goog.color.hexToRgb(hex);
  return goog.color.rgbToHsl(rgb[0], rgb[1], rgb[2]);
};


/**
 * Converts from h,s,l values to a hex string
 * @param {number} h Hue, in [0, 360].
 * @param {number} s Saturation, in [0, 1].
 * @param {number} l Luminosity, in [0, 1].
 * @return {string} hex representation of the color.
 */
goog.color.hslToHex = function(h, s, l) {
  'use strict';
  return goog.color.rgbArrayToHex(goog.color.hslToRgb(h, s, l));
};


/**
 * Converts from an hsl array to a hex string
 * @param {goog.color.Hsl} hsl hsl representation of the color.
 * @return {string} hex representation of the color.
 */
goog.color.hslArrayToHex = function(hsl) {
  'use strict';
  return goog.color.rgbArrayToHex(goog.color.hslToRgb(hsl[0], hsl[1], hsl[2]));
};


/**
 * Converts a hex representation of a color to HSV
 * @param {string} hex Color to convert.
 * @return {!goog.color.Hsv} hsv representation of the color.
 */
goog.color.hexToHsv = function(hex) {
  'use strict';
  return goog.color.rgbArrayToHsv(goog.color.hexToRgb(hex));
};


/**
 * Converts from h,s,v values to a hex string
 * @param {number} h Hue, in [0, 360].
 * @param {number} s Saturation, in [0, 1].
 * @param {number} v Value, in [0, 255].
 * @return {string} hex representation of the color.
 */
goog.color.hsvToHex = function(h, s, v) {
  'use strict';
  return goog.color.rgbArrayToHex(goog.color.hsvToRgb(h, s, v));
};


/**
 * Converts from an HSV array to a hex string
 * @param {goog.color.Hsv} hsv hsv representation of the color.
 * @return {string} hex representation of the color.
 */
goog.color.hsvArrayToHex = function(hsv) {
  'use strict';
  return goog.color.hsvToHex(hsv[0], hsv[1], hsv[2]);
};


/**
 * Calculates the Euclidean distance between two color vectors on an HSL sphere.
 * A demo of the sphere can be found at:
 * http://en.wikipedia.org/wiki/HSL_color_space
 * In short, a vector for color (H, S, L) in this system can be expressed as
 * (S*L'*cos(2*PI*H), S*L'*sin(2*PI*H), L), where L' = abs(L - 0.5), and we
 * simply calculate the 1-2 distance using these coordinates
 * @param {goog.color.Hsl} hsl1 First color in hsl representation.
 * @param {goog.color.Hsl} hsl2 Second color in hsl representation.
 * @return {number} Distance between the two colors, in the range [0, 1].
 */
goog.color.hslDistance = function(hsl1, hsl2) {
  'use strict';
  let sl1;
  let sl2;

  if (hsl1[2] <= 0.5) {
    sl1 = hsl1[1] * hsl1[2];
  } else {
    sl1 = hsl1[1] * (1.0 - hsl1[2]);
  }

  if (hsl2[2] <= 0.5) {
    sl2 = hsl2[1] * hsl2[2];
  } else {
    sl2 = hsl2[1] * (1.0 - hsl2[2]);
  }

  const h1 = hsl1[0] / 360.0;
  const h2 = hsl2[0] / 360.0;
  const dh = (h1 - h2) * 2.0 * Math.PI;
  return (hsl1[2] - hsl2[2]) * (hsl1[2] - hsl2[2]) + sl1 * sl1 + sl2 * sl2 -
      2 * sl1 * sl2 * Math.cos(dh);
};


/**
 * Blend two colors together, using the specified factor to indicate the weight
 * given to the first color
 * @param {goog.color.Rgb} rgb1 First color represented in rgb.
 * @param {goog.color.Rgb} rgb2 Second color represented in rgb.
 * @param {number} factor The weight to be given to rgb1 over rgb2. Values
 *     should be in the range [0, 1]. If less than 0, factor will be set to 0.
 *     If greater than 1, factor will be set to 1.
 * @return {!goog.color.Rgb} Combined color represented in rgb.
 */
goog.color.blend = function(rgb1, rgb2, factor) {
  'use strict';
  factor = goog.math.clamp(factor, 0, 1);

  return [
    Math.round(rgb2[0] + factor * (rgb1[0] - rgb2[0])),
    Math.round(rgb2[1] + factor * (rgb1[1] - rgb2[1])),
    Math.round(rgb2[2] + factor * (rgb1[2] - rgb2[2]))
  ];
};


/**
 * Adds black to the specified color, darkening it
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @param {number} factor Number in the range [0, 1]. 0 will do nothing, while
 *     1 will return black. If less than 0, factor will be set to 0. If greater
 *     than 1, factor will be set to 1.
 * @return {!goog.color.Rgb} Combined rgb color.
 */
goog.color.darken = function(rgb, factor) {
  'use strict';
  const black = [0, 0, 0];
  return goog.color.blend(black, rgb, factor);
};


/**
 * Adds white to the specified color, lightening it
 * @param {goog.color.Rgb} rgb rgb representation of the color.
 * @param {number} factor Number in the range [0, 1].  0 will do nothing, while
 *     1 will return white. If less than 0, factor will be set to 0. If greater
 *     than 1, factor will be set to 1.
 * @return {!goog.color.Rgb} Combined rgb color.
 */
goog.color.lighten = function(rgb, factor) {
  'use strict';
  const white = [255, 255, 255];
  return goog.color.blend(white, rgb, factor);
};


/**
 * Find the "best" (highest-contrast) of the suggested colors for the prime
 * color. Uses W3C formula for judging readability and visual accessibility:
 * http://www.w3.org/TR/AERT#color-contrast
 * @param {goog.color.Rgb} prime Color represented as a rgb array.
 * @param {Array<goog.color.Rgb>} suggestions Array of colors,
 *     each representing a rgb array.
 * @return {!goog.color.Rgb} Highest-contrast color represented by an array..
 */
goog.color.highContrast = function(prime, suggestions) {
  'use strict';
  const suggestionsWithDiff = [];
  for (let i = 0; i < suggestions.length; i++) {
    suggestionsWithDiff.push({
      color: suggestions[i],
      diff: goog.color.yiqBrightnessDiff_(suggestions[i], prime) +
          goog.color.colorDiff_(suggestions[i], prime)
    });
  }
  suggestionsWithDiff.sort(function(a, b) {
    'use strict';
    return b.diff - a.diff;
  });
  return suggestionsWithDiff[0].color;
};


/**
 * Calculate brightness of a color according to YIQ formula (brightness is Y).
 * More info on YIQ here: http://en.wikipedia.org/wiki/YIQ. Helper method for
 * goog.color.highContrast()
 * @param {goog.color.Rgb} rgb Color represented by a rgb array.
 * @return {number} brightness (Y).
 * @private
 */
goog.color.yiqBrightness_ = function(rgb) {
  'use strict';
  return Math.round((rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000);
};


/**
 * Calculate difference in brightness of two colors. Helper method for
 * goog.color.highContrast()
 * @param {goog.color.Rgb} rgb1 Color represented by a rgb array.
 * @param {goog.color.Rgb} rgb2 Color represented by a rgb array.
 * @return {number} Brightness difference.
 * @private
 */
goog.color.yiqBrightnessDiff_ = function(rgb1, rgb2) {
  'use strict';
  return Math.abs(
      goog.color.yiqBrightness_(rgb1) - goog.color.yiqBrightness_(rgb2));
};


/**
 * Calculate color difference between two colors. Helper method for
 * goog.color.highContrast()
 * @param {goog.color.Rgb} rgb1 Color represented by a rgb array.
 * @param {goog.color.Rgb} rgb2 Color represented by a rgb array.
 * @return {number} Color difference.
 * @private
 */
goog.color.colorDiff_ = function(rgb1, rgb2) {
  'use strict';
  return Math.abs(rgb1[0] - rgb2[0]) + Math.abs(rgb1[1] - rgb2[1]) +
      Math.abs(rgb1[2] - rgb2[2]);
};

//third_party/javascript/closure/async/animationdelay.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A delayed callback that pegs to the next animation frame
 * instead of a user-configurable timeout.
 */

goog.provide('goog.async.AnimationDelay');

goog.require('goog.Disposable');
goog.require('goog.events');
goog.require('goog.functions');



// TODO(nicksantos): Should we factor out the common code between this and
// goog.async.Delay? I'm not sure if there's enough code for this to really
// make sense. Subclassing seems like the wrong approach for a variety of
// reasons. Maybe there should be a common interface?



/**
 * A delayed callback that pegs to the next animation frame
 * instead of a user configurable timeout. By design, this should have
 * the same interface as goog.async.Delay.
 *
 * Uses requestAnimationFrame and friends when available, but falls
 * back to a timeout of goog.async.AnimationDelay.TIMEOUT.
 *
 * For more on requestAnimationFrame and how you can use it to create smoother
 * animations, see:
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 *
 * @param {function(this:THIS, number)} listener Function to call
 *     when the delay completes. Will be passed the timestamp when it's called,
 *     in unix ms.
 * @param {Window=} opt_window The window object to execute the delay in.
 *     Defaults to the global object.
 * @param {THIS=} opt_handler The object scope to invoke the function in.
 * @template THIS
 * @constructor
 * @struct
 * @extends {goog.Disposable}
 * @final
 */
goog.async.AnimationDelay = function(listener, opt_window, opt_handler) {
  'use strict';
  goog.async.AnimationDelay.base(this, 'constructor');

  /**
   * Identifier of the active delay timeout, or event listener,
   * or null when inactive.
   * @private {?goog.events.Key|number}
   */
  this.id_ = null;

  /**
   * If we're using dom listeners.
   * @private {?boolean}
   */
  this.usingListeners_ = false;

  /**
   * The function that will be invoked after a delay.
   * @const
   * @private
   */
  this.listener_ = listener;

  /**
   * The object context to invoke the callback in.
   * @const
   * @private {(THIS|undefined)}
   */
  this.handler_ = opt_handler;

  /**
   * @private {Window}
   */
  this.win_ = opt_window || window;

  /**
   * Cached callback function invoked when the delay finishes.
   * @private {function()}
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.AnimationDelay, goog.Disposable);


/**
 * Default wait timeout for animations (in milliseconds).  Only used for timed
 * animation, which uses a timer (setTimeout) to schedule animation.
 *
 * @type {number}
 * @const
 */
goog.async.AnimationDelay.TIMEOUT = 20;


/**
 * Name of event received from the requestAnimationFrame in Firefox.
 *
 * @type {string}
 * @const
 * @private
 */
goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_ = 'MozBeforePaint';


/**
 * Starts the delay timer. The provided listener function will be called
 * before the next animation frame.
 */
goog.async.AnimationDelay.prototype.start = function() {
  'use strict';
  this.stop();
  this.usingListeners_ = false;

  var raf = this.getRaf_();
  var cancelRaf = this.getCancelRaf_();
  if (raf && !cancelRaf && this.win_.mozRequestAnimationFrame) {
    // Because Firefox (Gecko) runs animation in separate threads, it also saves
    // time by running the requestAnimationFrame callbacks in that same thread.
    // Sadly this breaks the assumption of implicit thread-safety in JS, and can
    // thus create thread-based inconsistencies on counters etc.
    //
    // Calling cycleAnimations_ using the MozBeforePaint event instead of as
    // callback fixes this.
    //
    // Trigger this condition only if the mozRequestAnimationFrame is available,
    // but not the W3C requestAnimationFrame function (as in draft) or the
    // equivalent cancel functions.
    this.id_ = goog.events.listen(
        this.win_, goog.async.AnimationDelay.MOZ_BEFORE_PAINT_EVENT_,
        this.callback_);
    this.win_.mozRequestAnimationFrame(null);
    this.usingListeners_ = true;
  } else if (raf && cancelRaf) {
    this.id_ = raf.call(this.win_, this.callback_);
  } else {
    this.id_ = this.win_.setTimeout(
        // Prior to Firefox 13, Gecko passed a non-standard parameter
        // to the callback that we want to ignore.
        goog.functions.lock(this.callback_), goog.async.AnimationDelay.TIMEOUT);
  }
};


/**
 * Starts the delay timer if it's not already active.
 */
goog.async.AnimationDelay.prototype.startIfNotActive = function() {
  'use strict';
  if (!this.isActive()) {
    this.start();
  }
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.AnimationDelay.prototype.stop = function() {
  'use strict';
  if (this.isActive()) {
    var raf = this.getRaf_();
    var cancelRaf = this.getCancelRaf_();
    if (raf && !cancelRaf && this.win_.mozRequestAnimationFrame) {
      goog.events.unlistenByKey(this.id_);
    } else if (raf && cancelRaf) {
      cancelRaf.call(this.win_, /** @type {number} */ (this.id_));
    } else {
      this.win_.clearTimeout(/** @type {number} */ (this.id_));
    }
  }
  this.id_ = null;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.AnimationDelay.prototype.fire = function() {
  'use strict';
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.AnimationDelay.prototype.fireIfActive = function() {
  'use strict';
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.AnimationDelay.prototype.isActive = function() {
  'use strict';
  return this.id_ != null;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.AnimationDelay.prototype.doAction_ = function() {
  'use strict';
  if (this.usingListeners_ && this.id_) {
    goog.events.unlistenByKey(this.id_);
  }
  this.id_ = null;

  // We are not using the timestamp returned by requestAnimationFrame
  // because it may be either a Date.now-style time or a
  // high-resolution time (depending on browser implementation). Using
  // goog.now() will ensure that the timestamp used is consistent and
  // compatible with goog.fx.Animation.
  this.listener_.call(this.handler_, goog.now());
};


/** @override */
goog.async.AnimationDelay.prototype.disposeInternal = function() {
  'use strict';
  this.stop();
  goog.async.AnimationDelay.base(this, 'disposeInternal');
};


/**
 * @return {?function(function(number)): number} The requestAnimationFrame
 *     function, or null if not available on this browser.
 * @private
 */
goog.async.AnimationDelay.prototype.getRaf_ = function() {
  'use strict';
  var win = this.win_;
  return win.requestAnimationFrame || win.webkitRequestAnimationFrame ||
      win.mozRequestAnimationFrame || win.oRequestAnimationFrame ||
      win.msRequestAnimationFrame || null;
};


/**
 * @return {?function(number): undefined} The cancelAnimationFrame function,
 *     or null if not available on this browser.
 * @private
 */
goog.async.AnimationDelay.prototype.getCancelRaf_ = function() {
  'use strict';
  var win = this.win_;
  return win.cancelAnimationFrame || win.cancelRequestAnimationFrame ||
      win.webkitCancelRequestAnimationFrame ||
      win.mozCancelRequestAnimationFrame || win.oCancelRequestAnimationFrame ||
      win.msCancelRequestAnimationFrame || null;
};

//third_party/javascript/closure/async/delay.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines a class useful for handling functions that must be
 * invoked after a delay, especially when that delay is frequently restarted.
 * Examples include delaying before displaying a tooltip, menu hysteresis,
 * idle timers, etc.
 * @see ../demos/timers.html
 */


goog.provide('goog.async.Delay');

goog.require('goog.Disposable');
goog.require('goog.Timer');



/**
 * A Delay object invokes the associated function after a specified delay. The
 * interval duration can be specified once in the constructor, or can be defined
 * each time the delay is started. Calling start on an active delay will reset
 * the timer.
 *
 * @param {function(this:THIS)} listener Function to call when the
 *     delay completes.
 * @param {number=} opt_interval The default length of the invocation delay (in
 *     milliseconds).
 * @param {THIS=} opt_handler The object scope to invoke the function in.
 * @template THIS
 * @constructor
 * @struct
 * @extends {goog.Disposable}
 * @final
 */
goog.async.Delay = function(listener, opt_interval, opt_handler) {
  'use strict';
  goog.async.Delay.base(this, 'constructor');

  /**
   * The function that will be invoked after a delay.
   * @private {function(this:THIS)}
   */
  this.listener_ = listener;

  /**
   * The default amount of time to delay before invoking the callback.
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 0;

  /**
   * The object context to invoke the callback in.
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;


  /**
   * Cached callback function invoked when the delay finishes.
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.Delay, goog.Disposable);


/**
 * Identifier of the active delay timeout, or 0 when inactive.
 * @type {number}
 * @private
 */
goog.async.Delay.prototype.id_ = 0;


/**
 * Disposes of the object, cancelling the timeout if it is still outstanding and
 * removing all object references.
 * @override
 * @protected
 */
goog.async.Delay.prototype.disposeInternal = function() {
  'use strict';
  goog.async.Delay.base(this, 'disposeInternal');
  this.stop();
  delete this.listener_;
  delete this.handler_;
};


/**
 * Starts the delay timer. The provided listener function will be called after
 * the specified interval. Calling start on an active timer will reset the
 * delay interval.
 * @param {number=} opt_interval If specified, overrides the object's default
 *     interval with this one (in milliseconds).
 */
goog.async.Delay.prototype.start = function(opt_interval) {
  'use strict';
  this.stop();
  this.id_ = goog.Timer.callOnce(
      this.callback_,
      opt_interval !== undefined ? opt_interval : this.interval_);
};


/**
 * Starts the delay timer if it's not already active.
 * @param {number=} opt_interval If specified and the timer is not already
 *     active, overrides the object's default interval with this one (in
 *     milliseconds).
 */
goog.async.Delay.prototype.startIfNotActive = function(opt_interval) {
  'use strict';
  if (!this.isActive()) {
    this.start(opt_interval);
  }
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.Delay.prototype.stop = function() {
  'use strict';
  if (this.isActive()) {
    goog.Timer.clear(this.id_);
  }
  this.id_ = 0;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.Delay.prototype.fire = function() {
  'use strict';
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.Delay.prototype.fireIfActive = function() {
  'use strict';
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.Delay.prototype.isActive = function() {
  'use strict';
  return this.id_ != 0;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.Delay.prototype.doAction_ = function() {
  'use strict';
  this.id_ = 0;
  if (this.listener_) {
    this.listener_.call(this.handler_);
  }
};

//third_party/javascript/closure/fx/anim/anim.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Basic animation controls.
 */
goog.provide('goog.fx.anim');
goog.provide('goog.fx.anim.Animated');

goog.require('goog.async.AnimationDelay');
goog.require('goog.async.Delay');
goog.require('goog.dispose');
goog.require('goog.object');



/**
 * An interface for programatically animated objects. I.e. rendered in
 * javascript frame by frame.
 *
 * @interface
 */
goog.fx.anim.Animated = function() {};


/**
 * Function called when a frame is requested for the animation.
 *
 * @param {number} now Current time in milliseconds.
 */
goog.fx.anim.Animated.prototype.onAnimationFrame;


/**
 * Default wait timeout for animations (in milliseconds).  Only used for timed
 * animation, which uses a timer (setTimeout) to schedule animation.
 *
 * @type {number}
 * @const
 */
goog.fx.anim.TIMEOUT = goog.async.AnimationDelay.TIMEOUT;


/**
 * A map of animations which should be cycled on the global timer.
 *
 * @type {!Object<number, goog.fx.anim.Animated>}
 * @private
 */
goog.fx.anim.activeAnimations_ = {};


/**
 * An optional animation window.
 * @type {?Window}
 * @private
 */
goog.fx.anim.animationWindow_ = null;


/**
 * An interval ID for the global timer or event handler uid.
 * @type {?goog.async.Delay|?goog.async.AnimationDelay}
 * @private
 */
goog.fx.anim.animationDelay_ = null;


/**
 * Registers an animation to be cycled on the global timer.
 * @param {goog.fx.anim.Animated} animation The animation to register.
 */
goog.fx.anim.registerAnimation = function(animation) {
  'use strict';
  var uid = goog.getUid(animation);
  if (!(uid in goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.activeAnimations_[uid] = animation;
  }

  // If the timer is not already started, start it now.
  goog.fx.anim.requestAnimationFrame_();
};


/**
 * Removes an animation from the list of animations which are cycled on the
 * global timer.
 * @param {goog.fx.anim.Animated} animation The animation to unregister.
 */
goog.fx.anim.unregisterAnimation = function(animation) {
  'use strict';
  var uid = goog.getUid(animation);
  delete goog.fx.anim.activeAnimations_[uid];

  // If a timer is running and we no longer have any active timers we stop the
  // timers.
  if (goog.object.isEmpty(goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.cancelAnimationFrame_();
  }
};


/**
 * Tears down this module. Useful for testing.
 */
// TODO(nicksantos): Wow, this api is pretty broken. This should be fixed.
goog.fx.anim.tearDown = function() {
  'use strict';
  goog.fx.anim.animationWindow_ = null;
  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.activeAnimations_ = {};
};


/**
 * Registers an animation window. This allows usage of the timing control API
 * for animations. Note that this window must be visible, as non-visible
 * windows can potentially stop animating. This window does not necessarily
 * need to be the window inside which animation occurs, but must remain visible.
 * See: https://developer.mozilla.org/en/DOM/window.mozRequestAnimationFrame.
 *
 * @param {Window} animationWindow The window in which to animate elements.
 */
goog.fx.anim.setAnimationWindow = function(animationWindow) {
  'use strict';
  // If a timer is currently running, reset it and restart with new functions
  // after a timeout. This is to avoid mismatching timer UIDs if we change the
  // animation window during a running animation.
  //
  // In practice this cannot happen before some animation window and timer
  // control functions has already been set.
  var hasTimer =
      goog.fx.anim.animationDelay_ && goog.fx.anim.animationDelay_.isActive();

  goog.dispose(goog.fx.anim.animationDelay_);
  goog.fx.anim.animationDelay_ = null;
  goog.fx.anim.animationWindow_ = animationWindow;

  // If the timer was running, start it again.
  if (hasTimer) {
    goog.fx.anim.requestAnimationFrame_();
  }
};


/**
 * Requests an animation frame based on the requestAnimationFrame and
 * cancelRequestAnimationFrame function pair.
 * @private
 */
goog.fx.anim.requestAnimationFrame_ = function() {
  'use strict';
  if (!goog.fx.anim.animationDelay_) {
    // We cannot guarantee that the global window will be one that fires
    // requestAnimationFrame events (consider off-screen chrome extension
    // windows). Default to use goog.async.Delay, unless
    // the client has explicitly set an animation window.
    if (goog.fx.anim.animationWindow_) {
      // requestAnimationFrame will call cycleAnimations_ with the current
      // time in ms, as returned from goog.now().
      goog.fx.anim.animationDelay_ =
          new goog.async.AnimationDelay(function(now) {
            'use strict';
            goog.fx.anim.cycleAnimations_(now);
          }, goog.fx.anim.animationWindow_);
    } else {
      goog.fx.anim.animationDelay_ = new goog.async.Delay(function() {
        'use strict';
        goog.fx.anim.cycleAnimations_(goog.now());
      }, goog.fx.anim.TIMEOUT);
    }
  }

  var delay = goog.fx.anim.animationDelay_;
  if (!delay.isActive()) {
    delay.start();
  }
};


/**
 * Cancels an animation frame created by requestAnimationFrame_().
 * @private
 */
goog.fx.anim.cancelAnimationFrame_ = function() {
  'use strict';
  if (goog.fx.anim.animationDelay_) {
    goog.fx.anim.animationDelay_.stop();
  }
};


/**
 * Cycles through all registered animations.
 * @param {number} now Current time in milliseconds.
 * @private
 */
goog.fx.anim.cycleAnimations_ = function(now) {
  'use strict';
  goog.object.forEach(goog.fx.anim.activeAnimations_, function(anim) {
    'use strict';
    anim.onAnimationFrame(now);
  });

  if (!goog.object.isEmpty(goog.fx.anim.activeAnimations_)) {
    goog.fx.anim.requestAnimationFrame_();
  }
};

//third_party/javascript/closure/fx/transition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview An interface for transition animation. This is a simple
 * interface that allows for playing and stopping a transition. It adds
 * a simple event model with BEGIN and END event.
 */

goog.provide('goog.fx.Transition');
goog.provide('goog.fx.Transition.EventType');



/**
 * An interface for programmatic transition. Must extend
 * `goog.events.EventTarget`.
 * @interface
 */
goog.fx.Transition = function() {};


/**
 * Transition event types.
 * @enum {string}
 */
goog.fx.Transition.EventType = {
  /** Dispatched when played for the first time OR when it is resumed. */
  PLAY: 'play',

  /** Dispatched only when the animation starts from the beginning. */
  BEGIN: 'begin',

  /** Dispatched only when animation is restarted after a pause. */
  RESUME: 'resume',

  /**
   * Dispatched when animation comes to the end of its duration OR stop
   * is called.
   */
  END: 'end',

  /** Dispatched only when stop is called. */
  STOP: 'stop',

  /** Dispatched only when animation comes to its end naturally. */
  FINISH: 'finish',

  /** Dispatched when an animation is paused. */
  PAUSE: 'pause'
};


/**
 * @type {function()}
 * Plays the transition.
 */
goog.fx.Transition.prototype.play;


/**
 * @type {function()}
 * Stops the transition.
 */
goog.fx.Transition.prototype.stop;

//third_party/javascript/closure/fx/transitionbase.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview An abstract base class for transitions. This is a simple
 * interface that allows for playing, pausing and stopping an animation. It adds
 * a simple event model, and animation status.
 */
goog.provide('goog.fx.TransitionBase');

goog.require('goog.events.EventTarget');
goog.require('goog.fx.Transition');  // Unreferenced: interface



/**
 * Constructor for a transition object.
 *
 * @constructor
 * @struct
 * @implements {goog.fx.Transition}
 * @extends {goog.events.EventTarget}
 */
goog.fx.TransitionBase = function() {
  'use strict';
  goog.fx.TransitionBase.base(this, 'constructor');

  /**
   * The internal state of the animation.
   * @type {goog.fx.TransitionBase.State}
   * @private
   */
  this.state_ = goog.fx.TransitionBase.State.STOPPED;

  /**
   * Timestamp for when the animation was started.
   * @type {?number}
   * @protected
   */
  this.startTime = null;

  /**
   * Timestamp for when the animation finished or was stopped.
   * @type {?number}
   * @protected
   */
  this.endTime = null;
};
goog.inherits(goog.fx.TransitionBase, goog.events.EventTarget);


/**
 * Enum for the possible states of an animation.
 * @enum {number}
 */
goog.fx.TransitionBase.State = {
  STOPPED: 0,
  PAUSED: -1,
  PLAYING: 1
};


/**
 * Plays the animation.
 *
 * @param {boolean=} opt_restart Optional parameter to restart the animation.
 * @return {boolean} True iff the animation was started.
 * @override
 */
goog.fx.TransitionBase.prototype.play = goog.abstractMethod;


/**
 * Stops the animation.
 *
 * @param {boolean=} opt_gotoEnd Optional boolean parameter to go the end of
 *     the animation.
 * @override
 */
goog.fx.TransitionBase.prototype.stop = goog.abstractMethod;


/**
 * Pauses the animation.
 */
goog.fx.TransitionBase.prototype.pause = goog.abstractMethod;


/**
 * Returns the current state of the animation.
 * @return {goog.fx.TransitionBase.State} State of the animation.
 */
goog.fx.TransitionBase.prototype.getStateInternal = function() {
  'use strict';
  return this.state_;
};


/**
 * Sets the current state of the animation to playing.
 * @protected
 */
goog.fx.TransitionBase.prototype.setStatePlaying = function() {
  'use strict';
  this.state_ = goog.fx.TransitionBase.State.PLAYING;
};


/**
 * Sets the current state of the animation to paused.
 * @protected
 */
goog.fx.TransitionBase.prototype.setStatePaused = function() {
  'use strict';
  this.state_ = goog.fx.TransitionBase.State.PAUSED;
};


/**
 * Sets the current state of the animation to stopped.
 * @protected
 */
goog.fx.TransitionBase.prototype.setStateStopped = function() {
  'use strict';
  this.state_ = goog.fx.TransitionBase.State.STOPPED;
};


/**
 * @return {boolean} True iff the current state of the animation is playing.
 */
goog.fx.TransitionBase.prototype.isPlaying = function() {
  'use strict';
  return this.state_ == goog.fx.TransitionBase.State.PLAYING;
};


/**
 * @return {boolean} True iff the current state of the animation is paused.
 */
goog.fx.TransitionBase.prototype.isPaused = function() {
  'use strict';
  return this.state_ == goog.fx.TransitionBase.State.PAUSED;
};


/**
 * @return {boolean} True iff the current state of the animation is stopped.
 */
goog.fx.TransitionBase.prototype.isStopped = function() {
  'use strict';
  return this.state_ == goog.fx.TransitionBase.State.STOPPED;
};


/**
 * Dispatches the BEGIN event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onBegin = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.BEGIN);
};


/**
 * Dispatches the END event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onEnd = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.END);
};


/**
 * Dispatches the FINISH event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onFinish = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.FINISH);
};


/**
 * Dispatches the PAUSE event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onPause = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.PAUSE);
};


/**
 * Dispatches the PLAY event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onPlay = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.PLAY);
};


/**
 * Dispatches the RESUME event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onResume = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.RESUME);
};


/**
 * Dispatches the STOP event. Sub classes should override this instead
 * of listening to the event, and call this instead of dispatching the event.
 * @protected
 */
goog.fx.TransitionBase.prototype.onStop = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Transition.EventType.STOP);
};


/**
 * Dispatches an event object for the current animation.
 * @param {string} type Event type that will be dispatched.
 * @protected
 */
goog.fx.TransitionBase.prototype.dispatchAnimationEvent = function(type) {
  'use strict';
  this.dispatchEvent(type);
};

//third_party/javascript/closure/fx/animation.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Classes for doing animations and visual effects.
 *
 * (Based loosly on my animation code for 13thparallel.org, with extra
 * inspiration from the DojoToolkit's modifications to my code)
 */

goog.provide('goog.fx.Animation');
goog.provide('goog.fx.Animation.EventType');
goog.provide('goog.fx.Animation.State');
goog.provide('goog.fx.AnimationEvent');

goog.require('goog.asserts');
goog.require('goog.events.Event');
goog.require('goog.fx.Transition');
goog.require('goog.fx.TransitionBase');
goog.require('goog.fx.anim');
goog.require('goog.fx.anim.Animated');



/**
 * Constructor for an animation object.
 * @param {Array<number>} start Array for start coordinates.
 * @param {Array<number>} end Array for end coordinates.
 * @param {number} duration Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @constructor
 * @struct
 * @implements {goog.fx.anim.Animated}
 * @implements {goog.fx.Transition}
 * @extends {goog.fx.TransitionBase}
 */
goog.fx.Animation = function(start, end, duration, opt_acc) {
  'use strict';
  goog.fx.Animation.base(this, 'constructor');

  if (!Array.isArray(start) || !Array.isArray(end)) {
    throw new Error('Start and end parameters must be arrays');
  }

  if (start.length != end.length) {
    throw new Error('Start and end points must be the same length');
  }

  /**
   * Start point.
   * @type {Array<number>}
   * @protected
   */
  this.startPoint = start;

  /**
   * End point.
   * @type {Array<number>}
   * @protected
   */
  this.endPoint = end;

  /**
   * Duration of animation in milliseconds.
   * @type {number}
   * @protected
   */
  this.duration = duration;

  /**
   * Acceleration function, which must return a number between 0 and 1 for
   * inputs between 0 and 1.
   * @type {Function|undefined}
   * @private
   */
  this.accel_ = opt_acc;

  /**
   * Current coordinate for animation.
   * @type {Array<number>}
   * @protected
   */
  this.coords = [];

  /**
   * Whether the animation should use "right" rather than "left" to position
   * elements in RTL.  This is a temporary flag to allow clients to transition
   * to the new behavior at their convenience.  At some point it will be the
   * default.
   * @type {boolean}
   * @private
   */
  this.useRightPositioningForRtl_ = false;

  /**
   * Current frame rate.
   * @private {number}
   */
  this.fps_ = 0;

  /**
   * Percent of the way through the animation.
   * @protected {number}
   */
  this.progress = 0;

  /**
   * Timestamp for when last frame was run.
   * @protected {?number}
   */
  this.lastFrame = null;
};
goog.inherits(goog.fx.Animation, goog.fx.TransitionBase);


/**
 * @return {number} The duration of this animation in milliseconds.
 */
goog.fx.Animation.prototype.getDuration = function() {
  'use strict';
  return this.duration;
};


/**
 * Sets whether the animation should use "right" rather than "left" to position
 * elements.  This is a temporary flag to allow clients to transition
 * to the new component at their convenience.  At some point "right" will be
 * used for RTL elements by default.
 * @param {boolean} useRightPositioningForRtl True if "right" should be used for
 *     positioning, false if "left" should be used for positioning.
 */
goog.fx.Animation.prototype.enableRightPositioningForRtl = function(
    useRightPositioningForRtl) {
  'use strict';
  this.useRightPositioningForRtl_ = useRightPositioningForRtl;
};


/**
 * Whether the animation should use "right" rather than "left" to position
 * elements.  This is a temporary flag to allow clients to transition
 * to the new component at their convenience.  At some point "right" will be
 * used for RTL elements by default.
 * @return {boolean} True if "right" should be used for positioning, false if
 *     "left" should be used for positioning.
 */
goog.fx.Animation.prototype.isRightPositioningForRtlEnabled = function() {
  'use strict';
  return this.useRightPositioningForRtl_;
};


/**
 * Events fired by the animation.
 * @enum {string}
 */
goog.fx.Animation.EventType = {
  /**
   * Dispatched when played for the first time OR when it is resumed.
   * @deprecated Use goog.fx.Transition.EventType.PLAY.
   */
  PLAY: goog.fx.Transition.EventType.PLAY,

  /**
   * Dispatched only when the animation starts from the beginning.
   * @deprecated Use goog.fx.Transition.EventType.BEGIN.
   */
  BEGIN: goog.fx.Transition.EventType.BEGIN,

  /**
   * Dispatched only when animation is restarted after a pause.
   * @deprecated Use goog.fx.Transition.EventType.RESUME.
   */
  RESUME: goog.fx.Transition.EventType.RESUME,

  /**
   * Dispatched when animation comes to the end of its duration OR stop
   * is called.
   * @deprecated Use goog.fx.Transition.EventType.END.
   */
  END: goog.fx.Transition.EventType.END,

  /**
   * Dispatched only when stop is called.
   * @deprecated Use goog.fx.Transition.EventType.STOP.
   */
  STOP: goog.fx.Transition.EventType.STOP,

  /**
   * Dispatched only when animation comes to its end naturally.
   * @deprecated Use goog.fx.Transition.EventType.FINISH.
   */
  FINISH: goog.fx.Transition.EventType.FINISH,

  /**
   * Dispatched when an animation is paused.
   * @deprecated Use goog.fx.Transition.EventType.PAUSE.
   */
  PAUSE: goog.fx.Transition.EventType.PAUSE,

  /**
   * Dispatched each frame of the animation.  This is where the actual animator
   * will listen.
   */
  ANIMATE: 'animate',

  /**
   * Dispatched when the animation is destroyed.
   */
  DESTROY: 'destroy'
};


/**
 * @deprecated Use goog.fx.anim.TIMEOUT.
 */
goog.fx.Animation.TIMEOUT = goog.fx.anim.TIMEOUT;


/**
 * Enum for the possible states of an animation.
 * @deprecated Use goog.fx.Transition.State instead.
 * @enum {number}
 */
goog.fx.Animation.State = goog.fx.TransitionBase.State;


/**
 * @deprecated Use goog.fx.anim.setAnimationWindow.
 * @param {Window} animationWindow The window in which to animate elements.
 */
goog.fx.Animation.setAnimationWindow = function(animationWindow) {
  'use strict';
  goog.fx.anim.setAnimationWindow(animationWindow);
};


/**
 * Starts or resumes an animation.
 * @param {boolean=} opt_restart Whether to restart the
 *     animation from the beginning if it has been paused.
 * @return {boolean} Whether animation was started.
 * @override
 */
goog.fx.Animation.prototype.play = function(opt_restart) {
  'use strict';
  if (opt_restart || this.isStopped()) {
    this.progress = 0;
    this.coords = this.startPoint;
  } else if (this.isPlaying()) {
    return false;
  }

  goog.fx.anim.unregisterAnimation(this);

  var now = /** @type {number} */ (goog.now());

  this.startTime = now;
  if (this.isPaused()) {
    this.startTime -= this.duration * this.progress;
  }

  this.endTime = this.startTime + this.duration;
  this.lastFrame = this.startTime;

  if (!this.progress) {
    this.onBegin();
  }

  this.onPlay();

  if (this.isPaused()) {
    this.onResume();
  }

  this.setStatePlaying();

  goog.fx.anim.registerAnimation(this);
  this.cycle(now);

  return true;
};


/**
 * Stops the animation.
 * @param {boolean=} opt_gotoEnd If true the animation will move to the
 *     end coords.
 * @override
 */
goog.fx.Animation.prototype.stop = function(opt_gotoEnd) {
  'use strict';
  goog.fx.anim.unregisterAnimation(this);
  this.setStateStopped();

  if (opt_gotoEnd) {
    this.progress = 1;
  }

  this.updateCoords_(this.progress);

  this.onStop();
  this.onEnd();
};


/**
 * Pauses the animation (iff it's playing).
 * @override
 */
goog.fx.Animation.prototype.pause = function() {
  'use strict';
  if (this.isPlaying()) {
    goog.fx.anim.unregisterAnimation(this);
    this.setStatePaused();
    this.onPause();
  }
};


/**
 * @return {number} The current progress of the animation, the number
 *     is between 0 and 1 inclusive.
 */
goog.fx.Animation.prototype.getProgress = function() {
  'use strict';
  return this.progress;
};


/**
 * Sets the progress of the animation.
 * @param {number} progress The new progress of the animation.
 */
goog.fx.Animation.prototype.setProgress = function(progress) {
  'use strict';
  this.progress = progress;
  if (this.isPlaying()) {
    var now = goog.now();
    // If the animation is already playing, we recompute startTime and endTime
    // such that the animation plays consistently, that is:
    // now = startTime + progress * duration.
    this.startTime = now - this.duration * this.progress;
    this.endTime = this.startTime + this.duration;
  }
};


/**
 * Disposes of the animation.  Stops an animation, fires a 'destroy' event and
 * then removes all the event handlers to clean up memory.
 * @override
 * @protected
 */
goog.fx.Animation.prototype.disposeInternal = function() {
  'use strict';
  if (!this.isStopped()) {
    this.stop(false);
  }
  this.onDestroy();
  goog.fx.Animation.base(this, 'disposeInternal');
};


/**
 * Stops an animation, fires a 'destroy' event and then removes all the event
 * handlers to clean up memory.
 * @deprecated Use dispose() instead.
 */
goog.fx.Animation.prototype.destroy = function() {
  'use strict';
  this.dispose();
};


/** @override */
goog.fx.Animation.prototype.onAnimationFrame = function(now) {
  'use strict';
  this.cycle(now);
};


/**
 * Handles the actual iteration of the animation in a timeout
 * @param {number} now The current time.
 */
goog.fx.Animation.prototype.cycle = function(now) {
  'use strict';
  goog.asserts.assertNumber(this.startTime);
  goog.asserts.assertNumber(this.endTime);
  goog.asserts.assertNumber(this.lastFrame);
  // Happens in rare system clock reset.
  if (now < this.startTime) {
    this.endTime = now + this.endTime - this.startTime;
    this.startTime = now;
  }
  this.progress = (now - this.startTime) / (this.endTime - this.startTime);

  if (this.progress > 1) {
    this.progress = 1;
  }

  this.fps_ = 1000 / (now - this.lastFrame);
  this.lastFrame = now;

  this.updateCoords_(this.progress);

  // Animation has finished.
  if (this.progress == 1) {
    this.setStateStopped();
    goog.fx.anim.unregisterAnimation(this);

    this.onFinish();
    this.onEnd();

    // Animation is still under way.
  } else if (this.isPlaying()) {
    this.onAnimate();
  }
};


/**
 * Calculates current coordinates, based on the current state.  Applies
 * the acceleration function if it exists.
 * @param {number} t Percentage of the way through the animation as a decimal.
 * @private
 */
goog.fx.Animation.prototype.updateCoords_ = function(t) {
  'use strict';
  if (typeof this.accel_ === 'function') {
    t = this.accel_(t);
  }
  this.coords = new Array(this.startPoint.length);
  for (var i = 0; i < this.startPoint.length; i++) {
    this.coords[i] =
        (this.endPoint[i] - this.startPoint[i]) * t + this.startPoint[i];
  }
};


/**
 * Dispatches the ANIMATE event. Sub classes should override this instead
 * of listening to the event.
 * @protected
 */
goog.fx.Animation.prototype.onAnimate = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Animation.EventType.ANIMATE);
};


/**
 * Dispatches the DESTROY event. Sub classes should override this instead
 * of listening to the event.
 * @protected
 */
goog.fx.Animation.prototype.onDestroy = function() {
  'use strict';
  this.dispatchAnimationEvent(goog.fx.Animation.EventType.DESTROY);
};


/** @override */
goog.fx.Animation.prototype.dispatchAnimationEvent = function(type) {
  'use strict';
  this.dispatchEvent(new goog.fx.AnimationEvent(type, this));
};



/**
 * Class for an animation event object.
 * @param {string} type Event type.
 * @param {goog.fx.Animation} anim An animation object.
 * @constructor
 * @struct
 * @extends {goog.events.Event}
 */
goog.fx.AnimationEvent = function(type, anim) {
  'use strict';
  goog.fx.AnimationEvent.base(this, 'constructor', type);

  /**
   * The current coordinates.
   * @type {Array<number>}
   */
  this.coords = anim.coords;

  /**
   * The x coordinate.
   * @type {number}
   */
  this.x = anim.coords[0];

  /**
   * The y coordinate.
   * @type {number}
   */
  this.y = anim.coords[1];

  /**
   * The z coordinate.
   * @type {number}
   */
  this.z = anim.coords[2];

  /**
   * The current duration.
   * @type {number}
   */
  this.duration = anim.duration;

  /**
   * The current progress.
   * @type {number}
   */
  this.progress = anim.getProgress();

  /**
   * Frames per second so far.
   */
  this.fps = anim.fps_;

  /**
   * The state of the animation.
   * @type {number}
   */
  this.state = anim.getStateInternal();

  /**
   * The animation object.
   * @type {goog.fx.Animation}
   */
  // TODO(arv): This can be removed as this is the same as the target
  this.anim = anim;
};
goog.inherits(goog.fx.AnimationEvent, goog.events.Event);


/**
 * Returns the coordinates as integers (rounded to nearest integer).
 * @return {!Array<number>} An array of the coordinates rounded to
 *     the nearest integer.
 */
goog.fx.AnimationEvent.prototype.coordsAsInts = function() {
  'use strict';
  return this.coords.map(Math.round);
};

//third_party/javascript/closure/useragent/platform.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utilities for getting details about the user's platform.
 */

goog.provide('goog.userAgent.platform');

goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Detects the version of the OS/platform the browser is running in. Not
 * supported for Linux, where an empty string is returned.
 *
 * @private
 * @return {string} The platform version.
 */
goog.userAgent.platform.determineVersion_ = function() {
  'use strict';
  var re;
  if (goog.userAgent.WINDOWS) {
    re = /Windows NT ([0-9.]+)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    if (match) {
      return match[1];
    } else {
      return '0';
    }
  } else if (goog.userAgent.MAC) {
    re = /1[0|1][_.][0-9_.]+/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    // Note: some old versions of Camino do not report an OSX version.
    // Default to 10.
    return match ? match[0].replace(/_/g, '.') : '10';
  } else if (goog.userAgent.ANDROID) {
    re = /Android\s+([^\);]+)(\)|;)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    return match ? match[1] : '';
  } else if (
      goog.userAgent.IPHONE || goog.userAgent.IPAD || goog.userAgent.IPOD) {
    re = /(?:iPhone|CPU)\s+OS\s+(\S+)/;
    var match = re.exec(goog.userAgent.getUserAgentString());
    // Report the version as x.y.z and not x_y_z
    return match ? match[1].replace(/_/g, '.') : '';
  }

  return '';
};


/**
 * The version of the platform. We don't determine the version of Linux.
 * For Windows, we only look at the NT version. Non-NT-based versions
 * (e.g. 95, 98, etc.) are given version 0.0.
 * @type {string}
 */
goog.userAgent.platform.VERSION = goog.userAgent.platform.determineVersion_();


/**
 * Whether the user agent platform version is higher or the same as the given
 * version.
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent platform version is higher or the
 *     same as the given version.
 */
goog.userAgent.platform.isVersion = function(version) {
  'use strict';
  return goog.string.compareVersions(
             goog.userAgent.platform.VERSION, version) >= 0;
};

//third_party/javascript/closure/useragent/product.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Detects the specific browser and not just the rendering engine.
 */

goog.provide('goog.userAgent.product');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.platform');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether the code is running on the Firefox web browser.
 */
goog.userAgent.product.ASSUME_FIREFOX =
    goog.define('goog.userAgent.product.ASSUME_FIREFOX', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     iPhone.
 */
goog.userAgent.product.ASSUME_IPHONE =
    goog.define('goog.userAgent.product.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     iPad.
 */
goog.userAgent.product.ASSUME_IPAD =
    goog.define('goog.userAgent.product.ASSUME_IPAD', false);


/**
 * @define {boolean} Whether we know at compile-time that the product is an
 *     AOSP browser or WebView inside a pre KitKat Android phone or tablet.
 */
goog.userAgent.product.ASSUME_ANDROID =
    goog.define('goog.userAgent.product.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the code is running on the Chrome web browser on
 * any platform or AOSP browser or WebView in a KitKat+ Android phone or tablet.
 */
goog.userAgent.product.ASSUME_CHROME =
    goog.define('goog.userAgent.product.ASSUME_CHROME', false);


/**
 * @define {boolean} Whether the code is running on the Safari web browser.
 */
goog.userAgent.product.ASSUME_SAFARI =
    goog.define('goog.userAgent.product.ASSUME_SAFARI', false);


/**
 * Whether we know the product type at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA ||
    goog.userAgent.product.ASSUME_FIREFOX ||
    goog.userAgent.product.ASSUME_IPHONE ||
    goog.userAgent.product.ASSUME_IPAD ||
    goog.userAgent.product.ASSUME_ANDROID ||
    goog.userAgent.product.ASSUME_CHROME ||
    goog.userAgent.product.ASSUME_SAFARI;


/**
 * Whether the code is running on the Opera web browser.
 * @type {boolean}
 */
goog.userAgent.product.OPERA = goog.userAgent.OPERA;


/**
 * Whether the code is running on an IE web browser.
 * @type {boolean}
 */
goog.userAgent.product.IE = goog.userAgent.IE;


/**
 * Whether the code is running on an Edge web browser (EdgeHTML based).
 * @type {boolean}
 */
goog.userAgent.product.EDGE = goog.userAgent.EDGE;


/**
 * Whether the code is running on the Firefox web browser.
 * @type {boolean}
 */
goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_FIREFOX :
    goog.labs.userAgent.browser.isFirefox();


/**
 * Whether the user agent is an iPhone or iPod (as in iPod touch).
 * @return {boolean}
 * @private
 */
goog.userAgent.product.isIphoneOrIpod_ = function() {
  'use strict';
  return goog.labs.userAgent.platform.isIphone() ||
      goog.labs.userAgent.platform.isIpod();
};


/**
 * Whether the code is running on an iPhone or iPod touch.
 *
 * iPod touch is considered an iPhone for legacy reasons.
 * @type {boolean}
 */
goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_IPHONE :
    goog.userAgent.product.isIphoneOrIpod_();


/**
 * Whether the code is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_IPAD :
    goog.labs.userAgent.platform.isIpad();


/**
 * Whether the code is running on AOSP browser or WebView inside
 * a pre KitKat Android phone or tablet.
 * @type {boolean}
 */
goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_ANDROID :
    goog.labs.userAgent.browser.isAndroidBrowser();


/**
 * Whether the code is running on any Chromium-based web browser on any platform
 * or AOSP browser or WebView in a KitKat+ Android phone or tablet.
 * @type {boolean}
 */
goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_CHROME :
    goog.labs.userAgent.browser.isChrome();


/**
 * @return {boolean} Whether the browser is Safari on desktop.
 * @private
 */
goog.userAgent.product.isSafariDesktop_ = function() {
  'use strict';
  return goog.labs.userAgent.browser.isSafari() &&
      !goog.labs.userAgent.platform.isIos();
};


/**
 * Whether the code is running on the desktop Safari web browser.
 * Note: the legacy behavior here is only true for Safari not running
 * on iOS.
 * @type {boolean}
 */
goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ?
    goog.userAgent.product.ASSUME_SAFARI :
    goog.userAgent.product.isSafariDesktop_();

//third_party/javascript/closure/useragent/product_isversion.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Functions for understanding the version of the browser.
 * This is pulled out of product.js to ensure that only builds that need
 * this functionality actually get it, without having to rely on the compiler
 * to strip out unneeded pieces.
 *
 * TODO(nnaze): Move to more appropriate filename/namespace.
 */


goog.provide('goog.userAgent.product.isVersion');


goog.require('goog.labs.userAgent.platform');
goog.require('goog.string');
goog.require('goog.userAgent');
goog.require('goog.userAgent.product');


/**
 * @return {string} The string that describes the version number of the user
 *     agent product.  This is a string rather than a number because it may
 *     contain 'b', 'a', and so on.
 * @private
 */
goog.userAgent.product.determineVersion_ = function() {
  'use strict';
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  if (goog.userAgent.product.FIREFOX) {
    // Firefox/2.0.0.1 or Firefox/3.5.3
    return goog.userAgent.product.getFirstRegExpGroup_(/Firefox\/([0-9.]+)/);
  }

  if (goog.userAgent.product.IE || goog.userAgent.product.EDGE ||
      goog.userAgent.product.OPERA) {
    return goog.userAgent.VERSION;
  }

  if (goog.userAgent.product.CHROME) {
    // CriOS is Chrome on iOS, but iPadOS 13+ spoofs macOS by default.
    // So it's possible that CriOS appears to be running on macOS.
    if (goog.labs.userAgent.platform.isIos() ||
        goog.labs.userAgent.platform.isMacintosh()) {
      // CriOS/56.0.2924.79
      const chromeIosVersion =
          goog.userAgent.product.getFirstRegExpGroup_(/CriOS\/([0-9.]+)/);
      if (chromeIosVersion) {
        return chromeIosVersion;
      }
    }
    // Chrome/4.0.223.1
    return goog.userAgent.product.getFirstRegExpGroup_(/Chrome\/([0-9.]+)/);
  }

  // This replicates legacy logic, which considered Safari and iOS to be
  // different products.
  if (goog.userAgent.product.SAFARI && !goog.labs.userAgent.platform.isIos()) {
    // Version/5.0.3
    //
    // NOTE: Before version 3, Safari did not report a product version number.
    // The product version number for these browsers will be the empty string.
    // They may be differentiated by WebKit version number in goog.userAgent.
    return goog.userAgent.product.getFirstRegExpGroup_(/Version\/([0-9.]+)/);
  }

  if (goog.userAgent.product.IPHONE || goog.userAgent.product.IPAD) {
    // Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1
    // (KHTML, like Gecko) Version/3.0 Mobile/3A100a Safari/419.3
    // Version is the browser version, Mobile is the build number. We combine
    // the version string with the build number: 3.0.3A100a for the example.
    var arr =
        goog.userAgent.product.execRegExp_(/Version\/(\S+).*Mobile\/(\S+)/);
    if (arr) {
      return arr[1] + '.' + arr[2];
    }
  } else if (goog.userAgent.product.ANDROID) {
    // Mozilla/5.0 (Linux; U; Android 0.5; en-us) AppleWebKit/522+
    // (KHTML, like Gecko) Safari/419.3
    //
    // Mozilla/5.0 (Linux; U; Android 1.0; en-us; dream) AppleWebKit/525.10+
    // (KHTML, like Gecko) Version/3.0.4 Mobile Safari/523.12.2
    //
    // Prefer Version number if present, else make do with the OS number
    var version =
        goog.userAgent.product.getFirstRegExpGroup_(/Android\s+([0-9.]+)/);
    if (version) {
      return version;
    }

    return goog.userAgent.product.getFirstRegExpGroup_(/Version\/([0-9.]+)/);
  }

  return '';
};


/**
 * Return the first group of the given regex.
 * @param {!RegExp} re Regular expression with at least one group.
 * @return {string} Contents of the first group or an empty string if no match.
 * @private
 */
goog.userAgent.product.getFirstRegExpGroup_ = function(re) {
  'use strict';
  var arr = goog.userAgent.product.execRegExp_(re);
  return arr ? arr[1] : '';
};


/**
 * Run regexp's exec() on the userAgent string.
 * @param {!RegExp} re Regular expression.
 * @return {?IArrayLike<string>} A result array, or null for no match.
 * @private
 */
goog.userAgent.product.execRegExp_ = function(re) {
  'use strict';
  return re.exec(goog.userAgent.getUserAgentString());
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.product.VERSION = goog.userAgent.product.determineVersion_();


/**
 * Whether the user agent product version is higher or the same as the given
 * version.
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent product version is higher or the
 *     same as the given version.
 */
goog.userAgent.product.isVersion = function(version) {
  'use strict';
  return goog.string.compareVersions(goog.userAgent.product.VERSION, version) >=
      0;
};

//third_party/javascript/closure/style/bidi.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Bidi utility functions.
 */

goog.provide('goog.style.bidi');

goog.require('goog.dom');
goog.require('goog.style');
goog.require('goog.userAgent');
goog.require('goog.userAgent.platform');
goog.require('goog.userAgent.product');
goog.require('goog.userAgent.product.isVersion');


/**
 * Returns the normalized scrollLeft position for a scrolled element.
 * @param {Element} element The scrolled element.
 * @return {number} The number of pixels the element is scrolled. 0 indicates
 *     that the element is not scrolled at all (which, in general, is the
 *     left-most position in ltr and the right-most position in rtl).
 */
goog.style.bidi.getScrollLeft = function(element) {
  'use strict';
  var isRtl = goog.style.isRightToLeft(element);
  if (isRtl && goog.style.bidi.usesNegativeScrollLeftInRtl_()) {
    return -element.scrollLeft;
  } else if (isRtl && !goog.userAgent.EDGE_OR_IE) {
    // ScrollLeft starts at the maximum positive value and decreases towards
    // 0 as the element is scrolled towards the left. However, for overflow
    // visible, there is no scrollLeft and the value always stays correctly at 0
    var overflowX = goog.style.getComputedOverflowX(element);
    if (overflowX == 'visible') {
      return element.scrollLeft;
    } else {
      return element.scrollWidth - element.clientWidth - element.scrollLeft;
    }
  }
  // ScrollLeft behavior is identical in rtl and ltr, it starts at 0 and
  // increases as the element is scrolled away from the start.
  return element.scrollLeft;
};


/**
 * Returns the "offsetStart" of an element, analogous to offsetLeft but
 * normalized for right-to-left environments and various browser
 * inconsistencies. This value returned can always be passed to setScrollOffset
 * to scroll to an element's left edge in a left-to-right offsetParent or
 * right edge in a right-to-left offsetParent.
 *
 * For example, here offsetStart is 10px in an LTR environment and 5px in RTL:
 *
 * <pre>
 * |          xxxxxxxxxx     |
 *  ^^^^^^^^^^   ^^^^   ^^^^^
 *     10px      elem    5px
 * </pre>
 *
 * If an element is positioned before the start of its offsetParent, the
 * startOffset may be negative.  This can be used with setScrollOffset to
 * reliably scroll to an element:
 *
 * <pre>
 * var scrollOffset = goog.style.bidi.getOffsetStart(element);
 * goog.style.bidi.setScrollOffset(element.offsetParent, scrollOffset);
 * </pre>
 *
 * @see setScrollOffset
 *
 * @param {Element} element The element for which we need to determine the
 *     offsetStart position.
 * @return {number} The offsetStart for that element.
 */
goog.style.bidi.getOffsetStart = function(element) {
  'use strict';
  element = /** @type {!HTMLElement} */ (element);
  var offsetLeftForReal = element.offsetLeft;

  // The element might not have an offsetParent.
  // For example, the node might not be attached to the DOM tree,
  // and position:fixed children do not have an offset parent.
  // Just try to do the best we can with what we have.
  var bestParent = element.offsetParent;

  if (!bestParent && goog.style.getComputedPosition(element) == 'fixed') {
    bestParent = goog.dom.getOwnerDocument(element).documentElement;
  }

  // Just give up in this case.
  if (!bestParent) {
    return offsetLeftForReal;
  }

  if (goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher(58)) {
    // When calculating an element's offsetLeft, Firefox 57 and below
    // erroneously subtracts the border width from the actual distance.
    // So we need to add it back. (Fixed in FireFox 58+)
    var borderWidths = goog.style.getBorderBox(bestParent);
    offsetLeftForReal += borderWidths.left;
  } else if (
      goog.userAgent.isDocumentModeOrHigher(8) &&
      !goog.userAgent.isDocumentModeOrHigher(9)) {
    // When calculating an element's offsetLeft, IE8/9-Standards Mode
    // erroneously adds the border width to the actual distance.  So we need to
    // subtract it.
    var borderWidths = goog.style.getBorderBox(bestParent);
    offsetLeftForReal -= borderWidths.left;
  }

  if (goog.style.isRightToLeft(bestParent)) {
    // Right edge of the element relative to the left edge of its parent.
    var elementRightOffset = offsetLeftForReal + element.offsetWidth;

    // Distance from the parent's right edge to the element's right edge.
    return bestParent.clientWidth - elementRightOffset;
  }

  return offsetLeftForReal;
};


/**
 * Sets the element's scrollLeft attribute so it is correctly scrolled by
 * offsetStart pixels.  This takes into account whether the element is RTL and
 * the nuances of different browsers.  To scroll to the "beginning" of an
 * element use getOffsetStart to obtain the element's offsetStart value and then
 * pass the value to setScrollOffset.
 * @see getOffsetStart
 * @param {Element} element The element to set scrollLeft on.
 * @param {number} offsetStart The number of pixels to scroll the element.
 *     If this value is < 0, 0 is used.
 */
goog.style.bidi.setScrollOffset = function(element, offsetStart) {
  'use strict';
  offsetStart = Math.max(offsetStart, 0);
  // In LTR and in "mirrored" browser RTL (such as IE), we set scrollLeft to
  // the number of pixels to scroll.
  // Otherwise, in RTL, we need to account for different browser behavior.
  if (!goog.style.isRightToLeft(element)) {
    element.scrollLeft = offsetStart;
  } else if (goog.style.bidi.usesNegativeScrollLeftInRtl_()) {
    element.scrollLeft = -offsetStart;
  } else if (!goog.userAgent.EDGE_OR_IE) {
    // Take the current scrollLeft value and move to the right by the
    // offsetStart to get to the left edge of the element, and then by
    // the clientWidth of the element to get to the right edge.
    element.scrollLeft =
        element.scrollWidth - offsetStart - element.clientWidth;
  } else {
    element.scrollLeft = offsetStart;
  }
};


/**
 * @return {boolean} Whether the current browser returns negative scrollLeft
 *     values for RTL elements. If true, then scrollLeft starts at 0 and then
 *     becomes more negative as the element is scrolled towards the left.
 * @private
 */
goog.style.bidi.usesNegativeScrollLeftInRtl_ = function() {
  'use strict';
  var isSafari10Plus =
      goog.userAgent.product.SAFARI && goog.userAgent.product.isVersion(10);
  var isIOS10Plus = goog.userAgent.IOS && goog.userAgent.platform.isVersion(10);
  const isChrome85Plus =
      goog.userAgent.product.CHROME && goog.userAgent.product.isVersion(85);
  return goog.userAgent.GECKO || isSafari10Plus || isIOS10Plus ||
      isChrome85Plus;
};


/**
 * Sets the element's left style attribute in LTR or right style attribute in
 * RTL.  Also clears the left attribute in RTL and the right attribute in LTR.
 * @param {Element} elem The element to position.
 * @param {number} left The left position in LTR; will be set as right in RTL.
 * @param {?number} top The top position.  If null only the left/right is set.
 * @param {boolean} isRtl Whether we are in RTL mode.
 */
goog.style.bidi.setPosition = function(elem, left, top, isRtl) {
  'use strict';
  if (top !== null) {
    elem.style.top = top + 'px';
  }
  if (isRtl) {
    elem.style.right = left + 'px';
    elem.style.left = '';
  } else {
    elem.style.left = left + 'px';
    elem.style.right = '';
  }
};

//third_party/javascript/closure/fx/dom.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Predefined DHTML animations such as slide, resize and fade.
 *
 * @see ../demos/effects.html
 */

goog.provide('goog.fx.dom');
goog.provide('goog.fx.dom.BgColorTransform');
goog.provide('goog.fx.dom.ColorTransform');
goog.provide('goog.fx.dom.Fade');
goog.provide('goog.fx.dom.FadeIn');
goog.provide('goog.fx.dom.FadeInAndShow');
goog.provide('goog.fx.dom.FadeOut');
goog.provide('goog.fx.dom.FadeOutAndHide');
goog.provide('goog.fx.dom.PredefinedEffect');
goog.provide('goog.fx.dom.Resize');
goog.provide('goog.fx.dom.ResizeHeight');
goog.provide('goog.fx.dom.ResizeWidth');
goog.provide('goog.fx.dom.Scroll');
goog.provide('goog.fx.dom.Slide');
goog.provide('goog.fx.dom.SlideFrom');
goog.provide('goog.fx.dom.Swipe');

goog.require('goog.color');
goog.require('goog.events');
goog.require('goog.fx.Animation');
goog.require('goog.fx.Transition');
goog.require('goog.style');
goog.require('goog.style.bidi');
goog.requireType('goog.events.EventHandler');



/**
 * Abstract class that provides reusable functionality for predefined animations
 * that manipulate a single DOM element
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start Array for start coordinates.
 * @param {Array<number>} end Array for end coordinates.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.Animation}
 * @constructor
 * @struct
 */
goog.fx.dom.PredefinedEffect = function(element, start, end, time, opt_acc) {
  'use strict';
  goog.fx.dom.PredefinedEffect.base(
      this, 'constructor', start, end, time, opt_acc);

  /**
   * DOM Node that will be used in the animation
   * @type {Element}
   */
  this.element = element;

  /**
   * Whether the element is rendered right-to-left. We cache this here for
   * efficiency.
   * @private {boolean|undefined}
   */
  this.rightToLeft_;
};
goog.inherits(goog.fx.dom.PredefinedEffect, goog.fx.Animation);


/**
 * Called to update the style of the element.
 * @protected
 */
goog.fx.dom.PredefinedEffect.prototype.updateStyle = goog.nullFunction;


/**
 * Whether the DOM element being manipulated is rendered right-to-left.
 * @return {boolean} True if the DOM element is rendered right-to-left, false
 *     otherwise.
 */
goog.fx.dom.PredefinedEffect.prototype.isRightToLeft = function() {
  'use strict';
  if (this.rightToLeft_ === undefined) {
    this.rightToLeft_ = goog.style.isRightToLeft(this.element);
  }
  return this.rightToLeft_;
};


/** @override */
goog.fx.dom.PredefinedEffect.prototype.onAnimate = function() {
  'use strict';
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onAnimate.call(this);
};


/** @override */
goog.fx.dom.PredefinedEffect.prototype.onEnd = function() {
  'use strict';
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onEnd.call(this);
};


/** @override */
goog.fx.dom.PredefinedEffect.prototype.onBegin = function() {
  'use strict';
  this.updateStyle();
  goog.fx.dom.PredefinedEffect.superClass_.onBegin.call(this);
};



/**
 * Creates an animation object that will slide an element from A to B.  (This
 * in effect automatically sets up the onanimate event for an Animation object)
 *
 * Start and End should be 2 dimensional arrays
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 2D array for start coordinates (X, Y).
 * @param {Array<number>} end 2D array for end coordinates (X, Y).
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.Slide = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 2 || end.length != 2) {
    throw new Error('Start and end points must be 2D');
  }
  goog.fx.dom.Slide.base(
      this, 'constructor', element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.Slide, goog.fx.dom.PredefinedEffect);


/** @override */
goog.fx.dom.Slide.prototype.updateStyle = function() {
  'use strict';
  var pos = (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?
      'right' :
      'left';
  this.element.style[pos] = Math.round(this.coords[0]) + 'px';
  this.element.style.top = Math.round(this.coords[1]) + 'px';
};



/**
 * Slides an element from its current position.
 *
 * @param {Element} element DOM node to be used in the animation.
 * @param {Array<number>} end 2D array for end coordinates (X, Y).
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.Slide}
 * @constructor
 * @struct
 */
goog.fx.dom.SlideFrom = function(element, end, time, opt_acc) {
  'use strict';
  var offsetLeft = /** @type {!HTMLElement} */ (element).offsetLeft;
  var start = [offsetLeft, /** @type {!HTMLElement} */ (element).offsetTop];
  goog.fx.dom.SlideFrom.base(
      this, 'constructor', element, start, end, time, opt_acc);
  /** @type {?Array<number>} */
  this.startPoint;
};
goog.inherits(goog.fx.dom.SlideFrom, goog.fx.dom.Slide);


/** @override */
goog.fx.dom.SlideFrom.prototype.onBegin = function() {
  'use strict';
  var offsetLeft = this.isRightPositioningForRtlEnabled() ?
      goog.style.bidi.getOffsetStart(this.element) :
      /** @type {!HTMLElement} */ (this.element).offsetLeft;
  this.startPoint = [
    offsetLeft,
    /** @type {!HTMLElement} */ (this.element).offsetTop
  ];
  goog.fx.dom.SlideFrom.superClass_.onBegin.call(this);
};



/**
 * Creates an animation object that will slide an element into its final size.
 * Requires that the element is absolutely positioned.
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 2D array for start size (W, H).
 * @param {Array<number>} end 2D array for end size (W, H).
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.Swipe = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 2 || end.length != 2) {
    throw new Error('Start and end points must be 2D');
  }
  goog.fx.dom.Swipe.base(
      this, 'constructor', element, start, end, time, opt_acc);

  /**
   * Maximum width for element.
   * @type {number}
   * @private
   */
  this.maxWidth_ = Math.max(this.endPoint[0], this.startPoint[0]);

  /**
   * Maximum height for element.
   * @type {number}
   * @private
   */
  this.maxHeight_ = Math.max(this.endPoint[1], this.startPoint[1]);
};
goog.inherits(goog.fx.dom.Swipe, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will resize an element by setting its width,
 * height and clipping.
 * @protected
 * @override
 */
goog.fx.dom.Swipe.prototype.updateStyle = function() {
  'use strict';
  var x = this.coords[0];
  var y = this.coords[1];
  this.clip_(Math.round(x), Math.round(y), this.maxWidth_, this.maxHeight_);
  this.element.style.width = Math.round(x) + 'px';
  var marginX =
      (this.isRightPositioningForRtlEnabled() && this.isRightToLeft()) ?
      'marginRight' :
      'marginLeft';

  this.element.style[marginX] = Math.round(x) - this.maxWidth_ + 'px';
  this.element.style.marginTop = Math.round(y) - this.maxHeight_ + 'px';
};


/**
 * Helper function for setting element clipping.
 * @param {number} x Current element width.
 * @param {number} y Current element height.
 * @param {number} w Maximum element width.
 * @param {number} h Maximum element height.
 * @private
 */
goog.fx.dom.Swipe.prototype.clip_ = function(x, y, w, h) {
  'use strict';
  this.element.style.clip =
      'rect(' + (h - y) + 'px ' + w + 'px ' + h + 'px ' + (w - x) + 'px)';
};



/**
 * Creates an animation object that will scroll an element from A to B.
 *
 * Start and End should be 2 dimensional arrays
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 2D array for start scroll left and top.
 * @param {Array<number>} end 2D array for end scroll left and top.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.Scroll = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 2 || end.length != 2) {
    throw new Error('Start and end points must be 2D');
  }
  goog.fx.dom.Scroll.base(
      this, 'constructor', element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.Scroll, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will set the scroll position of an element.
 * @protected
 * @override
 */
goog.fx.dom.Scroll.prototype.updateStyle = function() {
  'use strict';
  if (this.isRightPositioningForRtlEnabled()) {
    goog.style.bidi.setScrollOffset(this.element, Math.round(this.coords[0]));
  } else {
    this.element.scrollLeft = Math.round(this.coords[0]);
  }
  this.element.scrollTop = Math.round(this.coords[1]);
};



/**
 * Creates an animation object that will resize an element between two widths
 * and heights.
 *
 * Start and End should be 2 dimensional arrays
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 2D array for start width and height.
 * @param {Array<number>} end 2D array for end width and height.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.Resize = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 2 || end.length != 2) {
    throw new Error('Start and end points must be 2D');
  }
  goog.fx.dom.Resize.base(
      this, 'constructor', element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.Resize, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will resize an element by setting its width and
 * height.
 * @protected
 * @override
 */
goog.fx.dom.Resize.prototype.updateStyle = function() {
  'use strict';
  this.element.style.width = Math.round(this.coords[0]) + 'px';
  this.element.style.height = Math.round(this.coords[1]) + 'px';
};



/**
 * Creates an animation object that will resize an element between two widths
 *
 * Start and End should be numbers
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} start Start width.
 * @param {number} end End width.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.ResizeWidth = function(element, start, end, time, opt_acc) {
  'use strict';
  goog.fx.dom.ResizeWidth.base(
      this, 'constructor', element, [start], [end], time, opt_acc);
};
goog.inherits(goog.fx.dom.ResizeWidth, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will resize an element by setting its width.
 * @protected
 * @override
 */
goog.fx.dom.ResizeWidth.prototype.updateStyle = function() {
  'use strict';
  this.element.style.width = Math.round(this.coords[0]) + 'px';
};



/**
 * Creates an animation object that will resize an element between two heights
 *
 * Start and End should be numbers
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} start Start height.
 * @param {number} end End height.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.ResizeHeight = function(element, start, end, time, opt_acc) {
  'use strict';
  goog.fx.dom.ResizeHeight.base(
      this, 'constructor', element, [start], [end], time, opt_acc);
};
goog.inherits(goog.fx.dom.ResizeHeight, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will resize an element by setting its height.
 * @protected
 * @override
 */
goog.fx.dom.ResizeHeight.prototype.updateStyle = function() {
  'use strict';
  this.element.style.height = Math.round(this.coords[0]) + 'px';
};



/**
 * Creates an animation object that fades the opacity of an element between two
 * limits.
 *
 * Start and End should be floats between 0 and 1
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>|number} start 1D Array or Number with start opacity.
 * @param {Array<number>|number} end 1D Array or Number for end opacity.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.Fade = function(element, start, end, time, opt_acc) {
  'use strict';
  if (typeof start === 'number') start = [start];
  if (typeof end === 'number') end = [end];

  goog.fx.dom.Fade.base(
      this, 'constructor', element, start, end, time, opt_acc);

  if (start.length != 1 || end.length != 1) {
    throw new Error('Start and end points must be 1D');
  }

  /**
   * The last opacity we set, or -1 for not set.
   * @private {number}
   */
  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;
};
goog.inherits(goog.fx.dom.Fade, goog.fx.dom.PredefinedEffect);


/**
 * The quantization of opacity values to use.
 * @private {number}
 */
goog.fx.dom.Fade.TOLERANCE_ = 1.0 / 0x400;  // 10-bit color


/**
 * Value indicating that the opacity must be set on next update.
 * @private {number}
 */
goog.fx.dom.Fade.OPACITY_UNSET_ = -1;


/**
 * Animation event handler that will set the opacity of an element.
 * @protected
 * @override
 */
goog.fx.dom.Fade.prototype.updateStyle = function() {
  'use strict';
  var opacity = this.coords[0];
  var delta = Math.abs(opacity - this.lastOpacityUpdate_);
  // In order to keep eager browsers from over-rendering, only update
  // on a potentially visible change in opacity.
  if (delta >= goog.fx.dom.Fade.TOLERANCE_) {
    goog.style.setOpacity(this.element, opacity);
    this.lastOpacityUpdate_ = opacity;
  }
};


/** @override */
goog.fx.dom.Fade.prototype.onBegin = function() {
  'use strict';
  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;
  goog.fx.dom.Fade.base(this, 'onBegin');
};


/** @override */
goog.fx.dom.Fade.prototype.onEnd = function() {
  'use strict';
  this.lastOpacityUpdate_ = goog.fx.dom.Fade.OPACITY_UNSET_;
  goog.fx.dom.Fade.base(this, 'onEnd');
};


/**
 * Animation event handler that will show the element.
 */
goog.fx.dom.Fade.prototype.show = function() {
  'use strict';
  this.element.style.display = '';
};


/**
 * Animation event handler that will hide the element
 */
goog.fx.dom.Fade.prototype.hide = function() {
  'use strict';
  this.element.style.display = 'none';
};



/**
 * Fades an element out from full opacity to completely transparent.
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.Fade}
 * @constructor
 * @struct
 */
goog.fx.dom.FadeOut = function(element, time, opt_acc) {
  'use strict';
  goog.fx.dom.FadeOut.base(this, 'constructor', element, 1, 0, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeOut, goog.fx.dom.Fade);



/**
 * Fades an element in from completely transparent to fully opacity.
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.Fade}
 * @constructor
 * @struct
 */
goog.fx.dom.FadeIn = function(element, time, opt_acc) {
  'use strict';
  goog.fx.dom.FadeIn.base(this, 'constructor', element, 0, 1, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeIn, goog.fx.dom.Fade);



/**
 * Fades an element out from full opacity to completely transparent and then
 * sets the display to 'none'
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.Fade}
 * @constructor
 * @struct
 */
goog.fx.dom.FadeOutAndHide = function(element, time, opt_acc) {
  'use strict';
  goog.fx.dom.FadeOutAndHide.base(
      this, 'constructor', element, 1, 0, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeOutAndHide, goog.fx.dom.Fade);


/** @override */
goog.fx.dom.FadeOutAndHide.prototype.onBegin = function() {
  'use strict';
  this.show();
  goog.fx.dom.FadeOutAndHide.superClass_.onBegin.call(this);
};


/** @override */
goog.fx.dom.FadeOutAndHide.prototype.onEnd = function() {
  'use strict';
  this.hide();
  goog.fx.dom.FadeOutAndHide.superClass_.onEnd.call(this);
};



/**
 * Sets an element's display to be visible and then fades an element in from
 * completely transparent to fully opaque.
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.Fade}
 * @constructor
 * @struct
 */
goog.fx.dom.FadeInAndShow = function(element, time, opt_acc) {
  'use strict';
  goog.fx.dom.FadeInAndShow.base(
      this, 'constructor', element, 0, 1, time, opt_acc);
};
goog.inherits(goog.fx.dom.FadeInAndShow, goog.fx.dom.Fade);


/** @override */
goog.fx.dom.FadeInAndShow.prototype.onBegin = function() {
  'use strict';
  this.show();
  goog.fx.dom.FadeInAndShow.superClass_.onBegin.call(this);
};



/**
 * Provides a transformation of an elements background-color.
 *
 * Start and End should be 3D arrays representing R,G,B
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 3D Array for RGB of start color.
 * @param {Array<number>} end 3D Array for RGB of end color.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @extends {goog.fx.dom.PredefinedEffect}
 * @constructor
 * @struct
 */
goog.fx.dom.BgColorTransform = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 3 || end.length != 3) {
    throw new Error('Start and end points must be 3D');
  }
  goog.fx.dom.BgColorTransform.base(
      this, 'constructor', element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.BgColorTransform, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will set the background-color of an element
 */
goog.fx.dom.BgColorTransform.prototype.setColor = function() {
  'use strict';
  var coordsAsInts = [];
  for (var i = 0; i < this.coords.length; i++) {
    coordsAsInts[i] = Math.round(this.coords[i]);
  }
  var color = 'rgb(' + coordsAsInts.join(',') + ')';
  this.element.style.backgroundColor = color;
};


/** @override */
goog.fx.dom.BgColorTransform.prototype.updateStyle = function() {
  'use strict';
  this.setColor();
};


/**
 * Fade elements background color from start color to the element's current
 * background color.
 *
 * Start should be a 3D array representing R,G,B
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 3D Array for RGB of start color.
 * @param {number} time Length of animation in milliseconds.
 * @param {goog.events.EventHandler=} opt_eventHandler Optional event handler
 *     to use when listening for events.
 */
goog.fx.dom.bgColorFadeIn = function(element, start, time, opt_eventHandler) {
  'use strict';
  var initialBgColor = element.style.backgroundColor || '';
  var computedBgColor = goog.style.getBackgroundColor(element);
  var end;

  if (computedBgColor && computedBgColor != 'transparent' &&
      computedBgColor != 'rgba(0, 0, 0, 0)') {
    end = goog.color.hexToRgb(goog.color.parse(computedBgColor).hex);
  } else {
    end = [255, 255, 255];
  }

  var anim = new goog.fx.dom.BgColorTransform(element, start, end, time);

  function setBgColor() {
    element.style.backgroundColor = initialBgColor;
  }

  if (opt_eventHandler) {
    opt_eventHandler.listen(anim, goog.fx.Transition.EventType.END, setBgColor);
  } else {
    goog.events.listen(anim, goog.fx.Transition.EventType.END, setBgColor);
  }

  anim.play();
};



/**
 * Provides a transformation of an elements color.
 *
 * @param {Element} element Dom Node to be used in the animation.
 * @param {Array<number>} start 3D Array representing R,G,B.
 * @param {Array<number>} end 3D Array representing R,G,B.
 * @param {number} time Length of animation in milliseconds.
 * @param {Function=} opt_acc Acceleration function, returns 0-1 for inputs 0-1.
 * @constructor
 * @struct
 * @extends {goog.fx.dom.PredefinedEffect}
 */
goog.fx.dom.ColorTransform = function(element, start, end, time, opt_acc) {
  'use strict';
  if (start.length != 3 || end.length != 3) {
    throw new Error('Start and end points must be 3D');
  }
  goog.fx.dom.ColorTransform.base(
      this, 'constructor', element, start, end, time, opt_acc);
};
goog.inherits(goog.fx.dom.ColorTransform, goog.fx.dom.PredefinedEffect);


/**
 * Animation event handler that will set the color of an element.
 * @protected
 * @override
 */
goog.fx.dom.ColorTransform.prototype.updateStyle = function() {
  'use strict';
  var coordsAsInts = [];
  for (var i = 0; i < this.coords.length; i++) {
    coordsAsInts[i] = Math.round(this.coords[i]);
  }
  var color = 'rgb(' + coordsAsInts.join(',') + ')';
  this.element.style.color = color;
};

//third_party/javascript/closure/positioning/positioning.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Common positioning code.
 */

goog.provide('goog.positioning');
goog.provide('goog.positioning.Corner');
goog.provide('goog.positioning.CornerBit');
goog.provide('goog.positioning.Overflow');
goog.provide('goog.positioning.OverflowStatus');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.math.Size');
goog.require('goog.style');
goog.require('goog.style.bidi');
goog.requireType('goog.math.Box');


/**
 * Enum for bits in the {@see goog.positioning.Corner) bitmap.
 *
 * @enum {number}
 */
goog.positioning.CornerBit = {
  BOTTOM: 1,
  CENTER: 2,
  RIGHT: 4,
  FLIP_RTL: 8
};


/**
 * Enum for representing an element corner for positioning the popup.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 *
 * @enum {number}
 */
goog.positioning.Corner = {
  TOP_LEFT: 0,
  TOP_RIGHT: goog.positioning.CornerBit.RIGHT,
  BOTTOM_LEFT: goog.positioning.CornerBit.BOTTOM,
  BOTTOM_RIGHT:
      goog.positioning.CornerBit.BOTTOM | goog.positioning.CornerBit.RIGHT,
  TOP_START: goog.positioning.CornerBit.FLIP_RTL,
  TOP_END:
      goog.positioning.CornerBit.FLIP_RTL | goog.positioning.CornerBit.RIGHT,
  BOTTOM_START:
      goog.positioning.CornerBit.BOTTOM | goog.positioning.CornerBit.FLIP_RTL,
  BOTTOM_END: goog.positioning.CornerBit.BOTTOM |
      goog.positioning.CornerBit.RIGHT | goog.positioning.CornerBit.FLIP_RTL,
  TOP_CENTER: goog.positioning.CornerBit.CENTER,
  BOTTOM_CENTER:
      goog.positioning.CornerBit.BOTTOM | goog.positioning.CornerBit.CENTER
};


/**
 * Enum for representing position handling in cases where the element would be
 * positioned outside the viewport.
 *
 * @enum {number}
 */
goog.positioning.Overflow = {
  /** Ignore overflow */
  IGNORE: 0,

  /** Try to fit horizontally in the viewport at all costs. */
  ADJUST_X: 1,

  /** If the element can't fit horizontally, report positioning failure. */
  FAIL_X: 2,

  /** Try to fit vertically in the viewport at all costs. */
  ADJUST_Y: 4,

  /** If the element can't fit vertically, report positioning failure. */
  FAIL_Y: 8,

  /** Resize the element's width to fit in the viewport. */
  RESIZE_WIDTH: 16,

  /** Resize the element's height to fit in the viewport. */
  RESIZE_HEIGHT: 32,

  /**
   * If the anchor goes off-screen in the x-direction, position the movable
   * element off-screen. Otherwise, try to fit horizontally in the viewport.
   */
  ADJUST_X_EXCEPT_OFFSCREEN: 64 | 1,

  /**
   * If the anchor goes off-screen in the y-direction, position the movable
   * element off-screen. Otherwise, try to fit vertically in the viewport.
   */
  ADJUST_Y_EXCEPT_OFFSCREEN: 128 | 4
};


/**
 * Enum for representing the outcome of a positioning call.
 *
 * @enum {number}
 */
goog.positioning.OverflowStatus = {
  NONE: 0,
  ADJUSTED_X: 1,
  ADJUSTED_Y: 2,
  WIDTH_ADJUSTED: 4,
  HEIGHT_ADJUSTED: 8,
  FAILED_LEFT: 16,
  FAILED_RIGHT: 32,
  FAILED_TOP: 64,
  FAILED_BOTTOM: 128,
  FAILED_OUTSIDE_VIEWPORT: 256,
  /** Shorthand to check if a status code contains any fail code. */
  FAILED: 16 | 32 | 64 | 128 | 256,
  /** Shorthand to check if horizontal positioning failed. */
  FAILED_HORIZONTAL: 16 | 32,
  /** Shorthand to check if vertical positioning failed. */
  FAILED_VERTICAL: 64 | 128,
};


/**
 * Positions a movable element relative to an anchor element. The caller
 * specifies the corners that should touch. This functions then moves the
 * movable element accordingly.
 *
 * @param {Element} anchorElement The element that is the anchor for where
 *    the movable element should position itself.
 * @param {goog.positioning.Corner} anchorElementCorner The corner of the
 *     anchorElement for positioning the movable element.
 * @param {Element} movableElement The element to move.
 * @param {goog.positioning.Corner} movableElementCorner The corner of the
 *     movableElement that that should be positioned adjacent to the anchor
 *     element.
 * @param {goog.math.Coordinate=} opt_offset An offset specified in pixels.
 *    After the normal positioning algorithm is applied, the offset is then
 *    applied. Positive coordinates move the popup closer to the center of the
 *    anchor element. Negative coordinates move the popup away from the center
 *    of the anchor element.
 * @param {goog.math.Box=} opt_margin A margin specified in pixels.
 *    After the normal positioning algorithm is applied and any offset, the
 *    margin is then applied. Positive coordinates move the popup away from the
 *    spot it was positioned towards its center. Negative coordinates move it
 *    towards the spot it was positioned away from its center.
 * @param {?number=} opt_overflow Overflow handling mode. Defaults to IGNORE if
 *     not specified. Bitmap, {@see goog.positioning.Overflow}.
 * @param {goog.math.Size=} opt_preferredSize The preferred size of the
 *     movableElement.
 * @param {goog.math.Box=} opt_viewport Box object describing the dimensions of
 *     the viewport. The viewport is specified relative to offsetParent of
 *     `movableElement`. In other words, the viewport can be thought of as
 *     describing a "position: absolute" element contained in the offsetParent.
 *     It defaults to visible area of nearest scrollable ancestor of
 *     `movableElement` (see `goog.style.getVisibleRectForElement`).
 * @return {goog.positioning.OverflowStatus} Status bitmap,
 *     {@see goog.positioning.OverflowStatus}.
 */
goog.positioning.positionAtAnchor = function(
    anchorElement, anchorElementCorner, movableElement, movableElementCorner,
    opt_offset, opt_margin, opt_overflow, opt_preferredSize, opt_viewport) {
  'use strict';
  goog.asserts.assert(movableElement);
  var movableParentTopLeft =
      goog.positioning.getOffsetParentPageOffset(movableElement);

  // Get the visible part of the anchor element.  anchorRect is
  // relative to anchorElement's page.
  var anchorRect = goog.positioning.getVisiblePart_(anchorElement);

  // Translate anchorRect to be relative to movableElement's page.
  goog.style.translateRectForAnotherFrame(
      anchorRect, goog.dom.getDomHelper(anchorElement),
      goog.dom.getDomHelper(movableElement));

  // Offset based on which corner of the element we want to position against.
  var corner =
      goog.positioning.getEffectiveCorner(anchorElement, anchorElementCorner);
  var offsetLeft = anchorRect.left;
  if (corner & goog.positioning.CornerBit.RIGHT) {
    offsetLeft += anchorRect.width;
  } else if (corner & goog.positioning.CornerBit.CENTER) {
    offsetLeft += anchorRect.width / 2;
  }

  // absolutePos is a candidate position relative to the
  // movableElement's window.
  var absolutePos = new goog.math.Coordinate(
      offsetLeft, anchorRect.top +
          (corner & goog.positioning.CornerBit.BOTTOM ? anchorRect.height : 0));

  // Translate absolutePos to be relative to the offsetParent.
  absolutePos =
      goog.math.Coordinate.difference(absolutePos, movableParentTopLeft);

  // Apply offset, if specified
  if (opt_offset) {
    absolutePos.x +=
        (corner & goog.positioning.CornerBit.RIGHT ? -1 : 1) * opt_offset.x;
    absolutePos.y +=
        (corner & goog.positioning.CornerBit.BOTTOM ? -1 : 1) * opt_offset.y;
  }

  // Determine dimension of viewport.
  var viewport;
  if (opt_overflow) {
    if (opt_viewport) {
      viewport = opt_viewport;
    } else {
      viewport = goog.style.getVisibleRectForElement(movableElement);
      if (viewport) {
        viewport.top -= movableParentTopLeft.y;
        viewport.right -= movableParentTopLeft.x;
        viewport.bottom -= movableParentTopLeft.y;
        viewport.left -= movableParentTopLeft.x;
      }
    }
  }

  return goog.positioning.positionAtCoordinate(
      absolutePos, movableElement, movableElementCorner, opt_margin, viewport,
      opt_overflow, opt_preferredSize);
};


/**
 * Calculates the page offset of the given element's
 * offsetParent. This value can be used to translate any x- and
 * y-offset relative to the page to an offset relative to the
 * offsetParent, which can then be used directly with as position
 * coordinate for `positionWithCoordinate`.
 * @param {!Element} movableElement The element to calculate.
 * @return {!goog.math.Coordinate} The page offset, may be (0, 0).
 */
goog.positioning.getOffsetParentPageOffset = function(movableElement) {
  'use strict';
  // Ignore offset for the BODY element unless its position is non-static.
  // For cases where the offset parent is HTML rather than the BODY (such as in
  // IE strict mode) there's no need to get the position of the BODY as it
  // doesn't affect the page offset.
  var movableParentTopLeft;
  var parent = /** @type {?} */ (movableElement).offsetParent;
  if (parent) {
    var isBody = parent.tagName == goog.dom.TagName.HTML ||
        parent.tagName == goog.dom.TagName.BODY;
    if (!isBody || goog.style.getComputedPosition(parent) != 'static') {
      // Get the top-left corner of the parent, in page coordinates.
      movableParentTopLeft = goog.style.getPageOffset(parent);

      if (!isBody) {
        movableParentTopLeft = goog.math.Coordinate.difference(
            movableParentTopLeft,
            new goog.math.Coordinate(
                goog.style.bidi.getScrollLeft(parent), parent.scrollTop));
      }
    }
  }

  return movableParentTopLeft || new goog.math.Coordinate();
};


/**
 * Returns intersection of the specified element and
 * goog.style.getVisibleRectForElement for it.
 *
 * @param {Element} el The target element.
 * @return {!goog.math.Rect} Intersection of getVisibleRectForElement
 *     and the current bounding rectangle of the element.  If the
 *     intersection is empty, returns the bounding rectangle.
 * @private
 */
goog.positioning.getVisiblePart_ = function(el) {
  'use strict';
  var rect = goog.style.getBounds(el);
  var visibleBox = goog.style.getVisibleRectForElement(el);
  if (visibleBox) {
    rect.intersection(goog.math.Rect.createFromBox(visibleBox));
  }
  return rect;
};


/**
 * Positions the specified corner of the movable element at the
 * specified coordinate.
 *
 * @param {goog.math.Coordinate} absolutePos The coordinate to position the
 *     element at.
 * @param {Element} movableElement The element to be positioned.
 * @param {goog.positioning.Corner} movableElementCorner The corner of the
 *     movableElement that that should be positioned.
 * @param {goog.math.Box=} opt_margin A margin specified in pixels.
 *    After the normal positioning algorithm is applied and any offset, the
 *    margin is then applied. Positive coordinates move the popup away from the
 *    spot it was positioned towards its center. Negative coordinates move it
 *    towards the spot it was positioned away from its center.
 * @param {goog.math.Box=} opt_viewport Box object describing the dimensions of
 *     the viewport. Required if opt_overflow is specified.
 * @param {?number=} opt_overflow Overflow handling mode. Defaults to IGNORE if
 *     not specified, {@see goog.positioning.Overflow}.
 * @param {goog.math.Size=} opt_preferredSize The preferred size of the
 *     movableElement. Defaults to the current size.
 * @return {goog.positioning.OverflowStatus} Status bitmap.
 */
goog.positioning.positionAtCoordinate = function(
    absolutePos, movableElement, movableElementCorner, opt_margin, opt_viewport,
    opt_overflow, opt_preferredSize) {
  'use strict';
  absolutePos = absolutePos.clone();

  // Offset based on attached corner and desired margin.
  var corner =
      goog.positioning.getEffectiveCorner(movableElement, movableElementCorner);
  var elementSize = goog.style.getSize(movableElement);
  var size =
      opt_preferredSize ? opt_preferredSize.clone() : elementSize.clone();

  var positionResult = goog.positioning.getPositionAtCoordinate(
      absolutePos, size, corner, opt_margin, opt_viewport, opt_overflow);

  if (positionResult.status & goog.positioning.OverflowStatus.FAILED) {
    return positionResult.status;
  }

  goog.style.setPosition(movableElement, positionResult.rect.getTopLeft());
  size = positionResult.rect.getSize();
  if (!goog.math.Size.equals(elementSize, size)) {
    goog.style.setBorderBoxSize(movableElement, size);
  }

  return positionResult.status;
};


/**
 * Computes the position for an element to be placed on-screen at the
 * specified coordinates. Returns an object containing both the resulting
 * rectangle, and the overflow status bitmap.
 *
 * @param {!goog.math.Coordinate} absolutePos The coordinate to position the
 *     element at.
 * @param {!goog.math.Size} elementSize The size of the element to be
 *     positioned.
 * @param {goog.positioning.Corner} elementCorner The corner of the
 *     movableElement that that should be positioned.
 * @param {goog.math.Box=} opt_margin A margin specified in pixels.
 *    After the normal positioning algorithm is applied and any offset, the
 *    margin is then applied. Positive coordinates move the popup away from the
 *    spot it was positioned towards its center. Negative coordinates move it
 *    towards the spot it was positioned away from its center.
 * @param {goog.math.Box=} opt_viewport Box object describing the dimensions of
 *     the viewport. Required if opt_overflow is specified.
 * @param {?number=} opt_overflow Overflow handling mode. Defaults to IGNORE
 *     if not specified, {@see goog.positioning.Overflow}.
 * @return {{rect:!goog.math.Rect, status:goog.positioning.OverflowStatus}}
 *     Object containing the computed position and status bitmap.
 */
goog.positioning.getPositionAtCoordinate = function(
    absolutePos, elementSize, elementCorner, opt_margin, opt_viewport,
    opt_overflow) {
  'use strict';
  absolutePos = absolutePos.clone();
  elementSize = elementSize.clone();
  var status = goog.positioning.OverflowStatus.NONE;

  if (opt_margin || elementCorner != goog.positioning.Corner.TOP_LEFT) {
    if (elementCorner & goog.positioning.CornerBit.RIGHT) {
      absolutePos.x -= elementSize.width + (opt_margin ? opt_margin.right : 0);
    } else if (elementCorner & goog.positioning.CornerBit.CENTER) {
      absolutePos.x -= elementSize.width / 2;
    } else if (opt_margin) {
      absolutePos.x += opt_margin.left;
    }
    if (elementCorner & goog.positioning.CornerBit.BOTTOM) {
      absolutePos.y -=
          elementSize.height + (opt_margin ? opt_margin.bottom : 0);
    } else if (opt_margin) {
      absolutePos.y += opt_margin.top;
    }
  }

  // Adjust position to fit inside viewport.
  if (opt_overflow) {
    status = opt_viewport ?
        goog.positioning.adjustForViewport_(
            absolutePos, elementSize, opt_viewport, opt_overflow) :
        goog.positioning.OverflowStatus.FAILED_OUTSIDE_VIEWPORT;
  }

  var rect = new goog.math.Rect(0, 0, 0, 0);
  rect.left = absolutePos.x;
  rect.top = absolutePos.y;
  rect.width = elementSize.width;
  rect.height = elementSize.height;
  return {rect: rect, status: status};
};


/**
 * Adjusts the position and/or size of an element, identified by its position
 * and size, to fit inside the viewport. If the position or size of the element
 * is adjusted the pos or size objects, respectively, are modified.
 *
 * @param {goog.math.Coordinate} pos Position of element, updated if the
 *     position is adjusted.
 * @param {goog.math.Size} size Size of element, updated if the size is
 *     adjusted.
 * @param {goog.math.Box} viewport Bounding box describing the viewport.
 * @param {number} overflow Overflow handling mode,
 *     {@see goog.positioning.Overflow}.
 * @return {goog.positioning.OverflowStatus} Status bitmap,
 *     {@see goog.positioning.OverflowStatus}.
 * @private
 */
goog.positioning.adjustForViewport_ = function(pos, size, viewport, overflow) {
  'use strict';
  var status = goog.positioning.OverflowStatus.NONE;

  var ADJUST_X_EXCEPT_OFFSCREEN =
      goog.positioning.Overflow.ADJUST_X_EXCEPT_OFFSCREEN;
  var ADJUST_Y_EXCEPT_OFFSCREEN =
      goog.positioning.Overflow.ADJUST_Y_EXCEPT_OFFSCREEN;
  if ((overflow & ADJUST_X_EXCEPT_OFFSCREEN) == ADJUST_X_EXCEPT_OFFSCREEN &&
      (pos.x < viewport.left || pos.x >= viewport.right)) {
    overflow &= ~goog.positioning.Overflow.ADJUST_X;
  }
  if ((overflow & ADJUST_Y_EXCEPT_OFFSCREEN) == ADJUST_Y_EXCEPT_OFFSCREEN &&
      (pos.y < viewport.top || pos.y >= viewport.bottom)) {
    overflow &= ~goog.positioning.Overflow.ADJUST_Y;
  }

  // Left edge outside viewport, try to move it.
  if (pos.x < viewport.left && overflow & goog.positioning.Overflow.ADJUST_X) {
    pos.x = viewport.left;
    status |= goog.positioning.OverflowStatus.ADJUSTED_X;
  }

  // Ensure object is inside the viewport width if required.
  if (overflow & goog.positioning.Overflow.RESIZE_WIDTH) {
    // Move left edge inside viewport.
    var originalX = pos.x;
    if (pos.x < viewport.left) {
      pos.x = viewport.left;
      status |= goog.positioning.OverflowStatus.WIDTH_ADJUSTED;
    }

    // Shrink width to inside right of viewport.
    if (pos.x + size.width > viewport.right) {
      // Set the width to be either the new maximum width within the viewport
      // or the width originally within the viewport, whichever is less.
      size.width = Math.min(
          viewport.right - pos.x, originalX + size.width - viewport.left);
      size.width = Math.max(size.width, 0);
      status |= goog.positioning.OverflowStatus.WIDTH_ADJUSTED;
    }
  }

  // Right edge outside viewport, try to move it.
  if (pos.x + size.width > viewport.right &&
      overflow & goog.positioning.Overflow.ADJUST_X) {
    pos.x = Math.max(viewport.right - size.width, viewport.left);
    status |= goog.positioning.OverflowStatus.ADJUSTED_X;
  }

  // Left or right edge still outside viewport, fail if the FAIL_X option was
  // specified, ignore it otherwise.
  if (overflow & goog.positioning.Overflow.FAIL_X) {
    status |=
        (pos.x < viewport.left ? goog.positioning.OverflowStatus.FAILED_LEFT :
                                 0) |
        (pos.x + size.width > viewport.right ?
             goog.positioning.OverflowStatus.FAILED_RIGHT :
             0);
  }

  // Top edge outside viewport, try to move it.
  if (pos.y < viewport.top && overflow & goog.positioning.Overflow.ADJUST_Y) {
    pos.y = viewport.top;
    status |= goog.positioning.OverflowStatus.ADJUSTED_Y;
  }

  // Ensure object is inside the viewport height if required.
  if (overflow & goog.positioning.Overflow.RESIZE_HEIGHT) {
    // Move top edge inside viewport.
    var originalY = pos.y;
    if (pos.y < viewport.top) {
      pos.y = viewport.top;
      status |= goog.positioning.OverflowStatus.HEIGHT_ADJUSTED;
    }

    // Shrink height to inside bottom of viewport.
    if (pos.y + size.height > viewport.bottom) {
      // Set the height to be either the new maximum height within the viewport
      // or the height originally within the viewport, whichever is less.
      size.height = Math.min(
          viewport.bottom - pos.y, originalY + size.height - viewport.top);
      size.height = Math.max(size.height, 0);
      status |= goog.positioning.OverflowStatus.HEIGHT_ADJUSTED;
    }
  }

  // Bottom edge outside viewport, try to move it.
  if (pos.y + size.height > viewport.bottom &&
      overflow & goog.positioning.Overflow.ADJUST_Y) {
    pos.y = Math.max(viewport.bottom - size.height, viewport.top);
    status |= goog.positioning.OverflowStatus.ADJUSTED_Y;
  }

  // Top or bottom edge still outside viewport, fail if the FAIL_Y option was
  // specified, ignore it otherwise.
  if (overflow & goog.positioning.Overflow.FAIL_Y) {
    status |=
        (pos.y < viewport.top ? goog.positioning.OverflowStatus.FAILED_TOP :
                                0) |
        (pos.y + size.height > viewport.bottom ?
             goog.positioning.OverflowStatus.FAILED_BOTTOM :
             0);
  }

  return /** @type {!goog.positioning.OverflowStatus} */ (status);
};


/**
 * Returns an absolute corner (top/bottom left/right) given an absolute
 * or relative (top/bottom start/end) corner and the direction of an element.
 * Absolute corners remain unchanged.
 * @param {Element} element DOM element to test for RTL direction.
 * @param {goog.positioning.Corner} corner The popup corner used for
 *     positioning.
 * @return {goog.positioning.Corner} Effective corner.
 */
goog.positioning.getEffectiveCorner = function(element, corner) {
  'use strict';
  return /** @type {goog.positioning.Corner} */ (
      (corner & goog.positioning.CornerBit.FLIP_RTL &&
               goog.style.isRightToLeft(element) ?
           corner ^ goog.positioning.CornerBit.RIGHT :
           corner) &
      ~goog.positioning.CornerBit.FLIP_RTL);
};


/**
 * Returns the corner opposite the given one horizontally.
 * @param {goog.positioning.Corner} corner The popup corner used to flip.
 * @return {goog.positioning.Corner} The opposite corner horizontally.
 */
goog.positioning.flipCornerHorizontal = function(corner) {
  'use strict';
  return /** @type {goog.positioning.Corner} */ (
      corner ^ goog.positioning.CornerBit.RIGHT);
};


/**
 * Returns the corner opposite the given one vertically.
 * @param {goog.positioning.Corner} corner The popup corner used to flip.
 * @return {goog.positioning.Corner} The opposite corner vertically.
 */
goog.positioning.flipCornerVertical = function(corner) {
  'use strict';
  return /** @type {goog.positioning.Corner} */ (
      corner ^ goog.positioning.CornerBit.BOTTOM);
};


/**
 * Returns the corner opposite the given one horizontally and vertically.
 * @param {goog.positioning.Corner} corner The popup corner used to flip.
 * @return {goog.positioning.Corner} The opposite corner horizontally and
 *     vertically.
 */
goog.positioning.flipCorner = function(corner) {
  'use strict';
  return /** @type {goog.positioning.Corner} */ (
      corner ^ goog.positioning.CornerBit.BOTTOM ^
      goog.positioning.CornerBit.RIGHT);
};

//third_party/javascript/closure/ui/ac/renderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Class for rendering the results of an auto complete and
 * allow the user to select an row.
 */

goog.provide('goog.ui.ac.Renderer');
goog.provide('goog.ui.ac.Renderer.CustomRenderer');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dispose');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.events');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.fx.dom.FadeInAndShow');
goog.require('goog.fx.dom.FadeOutAndHide');
goog.require('goog.positioning');
goog.require('goog.positioning.Corner');
goog.require('goog.positioning.Overflow');
goog.require('goog.string');
goog.require('goog.style');
goog.require('goog.ui.IdGenerator');
goog.require('goog.ui.ac.AutoComplete');
goog.requireType('goog.events.Event');
goog.requireType('goog.fx.Animation');



/**
 * Class for rendering the results of an auto-complete in a drop down list.
 *
 * @constructor
 * @param {Element=} opt_parentNode optional reference to the parent element
 *     that will hold the autocomplete elements. goog.dom.getDocument().body
 *     will be used if this is null.
 * @param {?({renderRow}|{render})=} opt_customRenderer Custom full renderer to
 *     render each row. Should be something with a renderRow or render method.
 * @param {boolean=} opt_rightAlign Determines if the autocomplete will always
 *     be right aligned. False by default.
 * @param {boolean=} opt_useStandardHighlighting Determines if standard
 *     highlighting should be applied to each row of data. Standard highlighting
 *     bolds every matching substring for a given token in each row. True by
 *     default.
 * @extends {goog.events.EventTarget}
 * @suppress {underscore}
 */
goog.ui.ac.Renderer = function(
    opt_parentNode, opt_customRenderer, opt_rightAlign,
    opt_useStandardHighlighting) {
  'use strict';
  goog.ui.ac.Renderer.base(this, 'constructor');

  /**
   * Reference to the parent element that will hold the autocomplete elements
   * @type {Element}
   * @private
   */
  this.parent_ = opt_parentNode || goog.dom.getDocument().body;

  /**
   * Dom helper for the parent element's document.
   * @type {goog.dom.DomHelper}
   * @private
   */
  this.dom_ = goog.dom.getDomHelper(this.parent_);

  /**
   * Whether to reposition the autocomplete UI below the target node
   * @type {boolean}
   * @private
   */
  this.reposition_ = !opt_parentNode;

  /**
   * Reference to the main element that controls the rendered autocomplete
   * @type {?Element}
   * @private
   */
  this.element_ = null;

  /**
   * The current token that has been entered
   * @type {string}
   * @private
   */
  this.token_ = '';

  /**
   * Array used to store the current set of rows being displayed
   * @type {Array<!Object>}
   * @private
   */
  this.rows_ = [];

  /**
   * Array of the node divs that hold each result that is being displayed.
   * @type {Array<Element>}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.rowDivs_ = [];

  /**
   * The index of the currently highlighted row
   * @type {number}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.hilitedRow_ = -1;

  /**
   * The time that the rendering of the menu rows started
   * @type {number}
   * @protected
   * @suppress {underscore|visibility}
   */
  this.startRenderingRows_ = -1;

  /**
   * Store the current state for the renderer
   * @type {boolean}
   * @private
   */
  this.visible_ = false;

  /**
   * Classname for the main element.  This must be a single valid class name.
   * @type {string}
   */
  this.className = goog.getCssName('ac-renderer');

  /**
   * Classname for row divs.  This must be a single valid class name.
   * @type {string}
   */
  this.rowClassName = goog.getCssName('ac-row');

  // TODO(gboyer): Remove this as soon as we remove references and ensure that
  // no groups are pushing javascript using this.
  /**
   * The old class name for active row.  This name is deprecated because its
   * name is generic enough that a typical implementation would require a
   * descendant selector.
   * Active row will have rowClassName & activeClassName &
   * legacyActiveClassName.
   * @type {string}
   * @private
   */
  this.legacyActiveClassName_ = goog.getCssName('active');

  /**
   * Class name for active row div.  This must be a single valid class name.
   * Active row will have rowClassName & activeClassName &
   * legacyActiveClassName.
   * @type {string}
   */
  this.activeClassName = goog.getCssName('ac-active');

  /**
   * Class name for the bold tag highlighting the matched part of the text.
   * @type {string}
   */
  this.highlightedClassName = goog.getCssName('ac-highlighted');

  /**
   * Custom full renderer
   * @type {?({renderRow}|{render})}
   * @private
   */
  this.customRenderer_ = opt_customRenderer || null;

  /**
   * Flag to indicate whether standard highlighting should be applied.
   * this is set to true if left unspecified to retain existing
   * behaviour for autocomplete clients
   * @type {boolean}
   * @private
   */
  this.useStandardHighlighting_ =
      opt_useStandardHighlighting != null ? opt_useStandardHighlighting : true;

  /**
   * Flag to indicate whether matches should be done on whole words instead
   * of any string.
   * @type {boolean}
   * @private
   */
  this.matchWordBoundary_ = true;

  /**
   * Flag to set all tokens as highlighted in the autocomplete row.
   * @type {boolean}
   * @private
   */
  this.highlightAllTokens_ = false;

  /**
   * Determines if the autocomplete will always be right aligned
   * @type {boolean}
   * @private
   */
  this.rightAlign_ = !!opt_rightAlign;

  /**
   * Whether to align with top of target field
   * @type {boolean}
   * @private
   */
  this.topAlign_ = false;

  /**
   * Duration (in msec) of fade animation when menu is shown/hidden.
   * Setting to 0 (default) disables animation entirely.
   * @type {number}
   * @private
   */
  this.menuFadeDuration_ = 0;

  /**
   * Whether we should limit the dropdown from extending past the bottom of the
   * screen and instead show a scrollbar on the dropdown.
   * @type {boolean}
   * @private
   */
  this.showScrollbarsIfTooLarge_ = false;

  /**
   * Animation in progress, if any.
   * @type {goog.fx.Animation|undefined}
   */
  this.animation_;
};
goog.inherits(goog.ui.ac.Renderer, goog.events.EventTarget);


/**
 * The anchor element to position the rendered autocompleter against.
 * @type {Element}
 * @private
 */
goog.ui.ac.Renderer.prototype.anchorElement_;


/**
 * The anchor element to position the rendered autocompleter against.
 * @protected {Element|undefined}
 */
goog.ui.ac.Renderer.prototype.target_;


/**
 * The element on which to base the width of the autocomplete.
 * @protected {Node}
 */
goog.ui.ac.Renderer.prototype.widthProvider_;


/**
 * The element on which to base the max width of the autocomplete.
 * @protected {!Node|undefined}
 */
goog.ui.ac.Renderer.prototype.maxWidthProvider_;


/**
 * The border width of the autocomplete dropdown, only used in calculating the
 * dropdown width.
 * @private {number}
 */
goog.ui.ac.Renderer.prototype.borderWidth_ = 0;


/**
 * A flag used to make sure we highlight only one match in the rendered row.
 * @private {boolean}
 */
goog.ui.ac.Renderer.prototype.wasHighlightedAtLeastOnce_;


/**
 * The delay before mouseover events are registered, in milliseconds
 * @type {number}
 * @const
 */
goog.ui.ac.Renderer.DELAY_BEFORE_MOUSEOVER = 300;


/**
 * Gets the renderer's element.
 * @return {Element} The  main element that controls the rendered autocomplete.
 */
goog.ui.ac.Renderer.prototype.getElement = function() {
  'use strict';
  return this.element_;
};


/**
 * Sets the width provider element. The provider is only used on redraw and as
 * such will not automatically update on resize.
 * @param {Node} widthProvider The element whose width should be mirrored.
 * @param {number=} opt_borderWidth The width of the border of the autocomplete,
 *     which will be subtracted from the width of the autocomplete dropdown.
 * @param {!Node=} maxWidthProvider The element whose width should be used
 *     as the autocomplete's max width.
 */
goog.ui.ac.Renderer.prototype.setWidthProvider = function(
    widthProvider, opt_borderWidth, maxWidthProvider = undefined) {
  this.widthProvider_ = widthProvider;
  if (opt_borderWidth) {
    this.borderWidth_ = opt_borderWidth;
  }
  if (maxWidthProvider) {
    this.maxWidthProvider_ = maxWidthProvider;
  }
};


/**
 * Set whether to align autocomplete to top of target element
 * @param {boolean} align If true, align to top.
 */
goog.ui.ac.Renderer.prototype.setTopAlign = function(align) {
  'use strict';
  this.topAlign_ = align;
};


/**
 * @return {boolean} Whether we should be aligning to the top of
 *     the target element.
 */
goog.ui.ac.Renderer.prototype.getTopAlign = function() {
  'use strict';
  return this.topAlign_;
};


/**
 * Set whether to align autocomplete to the right of the target element.
 * @param {boolean} align If true, align to right.
 */
goog.ui.ac.Renderer.prototype.setRightAlign = function(align) {
  'use strict';
  this.rightAlign_ = align;
};


/**
 * @return {boolean} Whether the autocomplete menu should be right aligned.
 */
goog.ui.ac.Renderer.prototype.getRightAlign = function() {
  'use strict';
  return this.rightAlign_;
};


/**
 * @param {boolean} show Whether we should limit the dropdown from extending
 *     past the bottom of the screen and instead show a scrollbar on the
 *     dropdown.
 */
goog.ui.ac.Renderer.prototype.setShowScrollbarsIfTooLarge = function(show) {
  'use strict';
  this.showScrollbarsIfTooLarge_ = show;
};


/**
 * Set whether or not standard highlighting should be used when rendering rows.
 * @param {boolean} useStandardHighlighting true if standard highlighting used.
 */
goog.ui.ac.Renderer.prototype.setUseStandardHighlighting = function(
    useStandardHighlighting) {
  'use strict';
  this.useStandardHighlighting_ = useStandardHighlighting;
};


/**
 * @param {boolean} matchWordBoundary Determines whether matches should be
 *     higlighted only when the token matches text at a whole-word boundary.
 *     True by default.
 */
goog.ui.ac.Renderer.prototype.setMatchWordBoundary = function(
    matchWordBoundary) {
  'use strict';
  this.matchWordBoundary_ = matchWordBoundary;
};


/**
 * Set whether or not to highlight all matching tokens rather than just the
 * first.
 * @param {boolean} highlightAllTokens Whether to highlight all matching tokens
 *     rather than just the first.
 */
goog.ui.ac.Renderer.prototype.setHighlightAllTokens = function(
    highlightAllTokens) {
  'use strict';
  this.highlightAllTokens_ = highlightAllTokens;
};


/**
 * Sets the duration (in msec) of the fade animation when menu is shown/hidden.
 * Setting to 0 (default) disables animation entirely.
 * @param {number} duration Duration (in msec) of the fade animation (or 0 for
 *     no animation).
 */
goog.ui.ac.Renderer.prototype.setMenuFadeDuration = function(duration) {
  'use strict';
  this.menuFadeDuration_ = duration;
};


/**
 * Sets the anchor element for the subsequent call to renderRows.
 * @param {Element} anchor The anchor element.
 */
goog.ui.ac.Renderer.prototype.setAnchorElement = function(anchor) {
  'use strict';
  this.anchorElement_ = anchor;
};


/**
 * @return {Element} The anchor element.
 * @protected
 */
goog.ui.ac.Renderer.prototype.getAnchorElement = function() {
  'use strict';
  return this.anchorElement_;
};


/**
 * Render the autocomplete UI
 *
 * @param {Array<!Object>} rows Matching UI rows.
 * @param {string} token Token we are currently matching against.
 * @param {Element=} opt_target Current HTML node, will position popup beneath
 *     this node.
 */
goog.ui.ac.Renderer.prototype.renderRows = function(rows, token, opt_target) {
  'use strict';
  this.token_ = token;
  this.rows_ = rows;
  this.hilitedRow_ = -1;
  this.startRenderingRows_ = goog.now();
  this.target_ = opt_target;
  this.rowDivs_ = [];
  this.redraw();
};


/**
 * Hide the object.
 */
goog.ui.ac.Renderer.prototype.dismiss = function() {
  'use strict';
  if (this.visible_) {
    this.visible_ = false;
    this.toggleAriaMarkup_(false /* isShown */);

    if (this.menuFadeDuration_ > 0) {
      goog.dispose(this.animation_);
      this.animation_ =
          new goog.fx.dom.FadeOutAndHide(this.element_, this.menuFadeDuration_);
      this.animation_.play();
    } else {
      goog.style.setElementShown(this.element_, false);
    }
  }
};


/**
 * Show the object.
 */
goog.ui.ac.Renderer.prototype.show = function() {
  'use strict';
  if (!this.visible_) {
    this.visible_ = true;
    this.toggleAriaMarkup_(true /* isShown */);

    if (this.menuFadeDuration_ > 0) {
      goog.dispose(this.animation_);
      this.animation_ =
          new goog.fx.dom.FadeInAndShow(this.element_, this.menuFadeDuration_);
      this.animation_.play();
    } else {
      goog.style.setElementShown(this.element_, true);
    }
  }
};


/**
 * Toggle the ARIA markup to add popup semantics when the target is shown and
 * to remove them when it is hidden.
 * @param {boolean} isShown Whether the menu is being shown.
 * @private
 */
goog.ui.ac.Renderer.prototype.toggleAriaMarkup_ = function(isShown) {
  'use strict';
  if (!this.target_) {
    return;
  }

  goog.a11y.aria.setState(this.target_, goog.a11y.aria.State.HASPOPUP, isShown);
  goog.a11y.aria.setState(
      goog.asserts.assert(this.element_), goog.a11y.aria.State.EXPANDED,
      isShown);
  goog.a11y.aria.setState(this.target_, goog.a11y.aria.State.EXPANDED, isShown);
  if (isShown) {
    goog.a11y.aria.setState(
        this.target_, goog.a11y.aria.State.OWNS, this.element_.id);
  } else {
    goog.a11y.aria.removeState(this.target_, goog.a11y.aria.State.OWNS);
    goog.a11y.aria.setActiveDescendant(this.target_, null);
  }
};


/**
 * @return {boolean} True if the object is visible.
 */
goog.ui.ac.Renderer.prototype.isVisible = function() {
  'use strict';
  return this.visible_;
};


/**
 * Sets the 'active' class of the nth item.
 * @param {number} index Index of the item to highlight.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.hiliteRow = function(index) {
  'use strict';
  var row =
      index >= 0 && index < this.rows_.length ? this.rows_[index] : undefined;
  var rowDiv = index >= 0 && index < this.rowDivs_.length ?
      this.rowDivs_[index] :
      undefined;

  var evtObj = /** @lends {goog.events.Event.prototype} */ ({
    type: goog.ui.ac.AutoComplete.EventType.ROW_HILITE,
    rowNode: rowDiv,
    row: row ? row.data : null
  });
  if (this.dispatchEvent(evtObj)) {
    this.hiliteNone();
    this.hilitedRow_ = index;
    if (rowDiv) {
      goog.dom.classlist.addAll(
          rowDiv, [this.activeClassName, this.legacyActiveClassName_]);
      if (this.target_) {
        goog.a11y.aria.setActiveDescendant(this.target_, rowDiv);
      }
      goog.style.scrollIntoContainerView(rowDiv, this.element_);
    }
  }
};


/**
 * Removes the 'active' class from the currently selected row.
 */
goog.ui.ac.Renderer.prototype.hiliteNone = function() {
  'use strict';
  if (this.hilitedRow_ >= 0) {
    goog.dom.classlist.removeAll(
        goog.asserts.assert(this.rowDivs_[this.hilitedRow_]),
        [this.activeClassName, this.legacyActiveClassName_]);
  }
};


/**
 * Sets the 'active' class of the item with a given id.
 * @param {number} id Id of the row to hilight. If id is -1 then no rows get
 *     hilited.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.hiliteId = function(id) {
  'use strict';
  if (id == -1) {
    this.hiliteRow(-1);
  } else {
    for (var i = 0; i < this.rows_.length; i++) {
      if (this.rows_[i].id == id) {
        this.hiliteRow(i);
        return;
      }
    }
  }
};


/**
 * Sets CSS classes on autocomplete conatainer element.
 *
 * @param {Element} elem The container element.
 * @private
 */
goog.ui.ac.Renderer.prototype.setMenuClasses_ = function(elem) {
  'use strict';
  goog.asserts.assert(elem);
  // Legacy clients may set the renderer's className to a space-separated list
  // or even have a trailing space.
  goog.dom.classlist.addAll(elem, goog.string.trim(this.className).split(' '));
};


/**
 * If the main HTML element hasn't been made yet, creates it and appends it
 * to the parent.
 * @private
 */
goog.ui.ac.Renderer.prototype.maybeCreateElement_ = function() {
  'use strict';
  if (!this.element_) {
    // Make element and add it to the parent
    var el = this.dom_.createDom(goog.dom.TagName.DIV, {style: 'display:none'});
    if (this.showScrollbarsIfTooLarge_) {
      // Make sure that the dropdown will get scrollbars if it isn't large
      // enough to show all rows.
      el.style.overflowY = 'auto';
    }
    this.element_ = el;
    this.setMenuClasses_(el);
    goog.a11y.aria.setRole(el, goog.a11y.aria.Role.LISTBOX);

    el.id = goog.ui.IdGenerator.getInstance().getNextUniqueId();

    this.dom_.appendChild(this.parent_, el);

    // Add this object as an event handler
    goog.events.listen(
        el, goog.events.EventType.CLICK, this.handleClick_, false, this);
    goog.events.listen(
        el, goog.events.EventType.MOUSEDOWN, this.handleMouseDown_, false,
        this);
    goog.events.listen(
        el, goog.events.EventType.MOUSEOVER, this.handleMouseOver_, false,
        this);
  }
};


/**
 * Redraw (or draw if this is the first call) the rendered auto-complete drop
 * down.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.redraw = function() {
  'use strict';
  // Create the element if it doesn't yet exist
  this.maybeCreateElement_();

  // For top aligned with target (= bottom aligned element),
  // we need to hide and then add elements while hidden to prevent
  // visible repositioning
  if (this.topAlign_) {
    this.element_.style.visibility = 'hidden';
  }

  if (this.widthProvider_) {
    var width = this.widthProvider_.clientWidth - this.borderWidth_ + 'px';
    this.element_.style.minWidth = width;
  }
  if (this.maxWidthProvider_) {
    const maxWidth =
        this.maxWidthProvider_.clientWidth - this.borderWidth_ + 'px';
    this.element_.style.maxWidth = maxWidth;
  }

  // Remove the current child nodes
  this.rowDivs_.length = 0;
  this.dom_.removeChildren(this.element_);

  // Generate the new rows (use forEach so we can change rows_ from an
  // array to a different datastructure if required)
  if (this.customRenderer_ && this.customRenderer_.render) {
    this.customRenderer_.render(this, this.element_, this.rows_, this.token_);
  } else {
    var curRow = null;
    this.rows_.forEach(function(row) {
      'use strict';
      row = this.renderRowHtml(row, this.token_);
      if (this.topAlign_) {
        // Aligned with top of target = best match at bottom
        this.element_.insertBefore(row, curRow);
      } else {
        this.dom_.appendChild(this.element_, row);
      }
      curRow = row;
    }, this);
  }

  // Don't show empty result sets
  if (this.rows_.length == 0) {
    this.dismiss();
    return;
  } else {
    this.show();
  }

  this.reposition();

  // Make the autocompleter unselectable, so that it
  // doesn't steal focus from the input field when clicked.
  goog.style.setUnselectable(this.element_, true);
};


/**
 * @return {goog.positioning.Corner} The anchor corner to position the popup at.
 * @protected
 */
goog.ui.ac.Renderer.prototype.getAnchorCorner = function() {
  'use strict';
  var anchorCorner = this.rightAlign_ ? goog.positioning.Corner.BOTTOM_RIGHT :
                                        goog.positioning.Corner.BOTTOM_LEFT;
  if (this.topAlign_) {
    anchorCorner = goog.positioning.flipCornerVertical(anchorCorner);
  }
  return anchorCorner;
};


/**
 * Repositions the auto complete popup relative to the location node, if it
 * exists and the auto position has been set.
 */
goog.ui.ac.Renderer.prototype.reposition = function() {
  'use strict';
  if (this.target_ && this.reposition_) {
    var anchorElement = this.anchorElement_ || this.target_;
    var anchorCorner = this.getAnchorCorner();

    var overflowMode = goog.positioning.Overflow.ADJUST_X_EXCEPT_OFFSCREEN;
    if (this.showScrollbarsIfTooLarge_) {
      // positionAtAnchor will set the height of this.element_ when it runs
      // (because of RESIZE_HEIGHT), and it will never increase it relative to
      // its current value when it runs again. But if the user scrolls their
      // page, then we might actually want a bigger height when the dropdown is
      // displayed next time. So we clear the height before calling
      // positionAtAnchor, so it is free to set the height as large as it
      // chooses.
      this.element_.style.height = '';
      overflowMode |= goog.positioning.Overflow.RESIZE_HEIGHT;
    }

    goog.positioning.positionAtAnchor(
        anchorElement, anchorCorner, this.element_,
        goog.positioning.flipCornerVertical(anchorCorner), null, null,
        overflowMode);

    if (this.topAlign_) {
      // This flickers, but is better than the alternative of positioning
      // in the wrong place and then moving.
      this.element_.style.visibility = 'visible';
    }
  }
};


/**
 * Sets whether the renderer should try to determine where to position the
 * drop down.
 * @param {boolean} auto Whether to autoposition the drop down.
 */
goog.ui.ac.Renderer.prototype.setAutoPosition = function(auto) {
  'use strict';
  this.reposition_ = auto;
};


/**
 * @return {boolean} Whether the drop down will be autopositioned.
 * @protected
 */
goog.ui.ac.Renderer.prototype.getAutoPosition = function() {
  'use strict';
  return this.reposition_;
};


/**
 * @return {Element} The target element.
 * @protected
 */
goog.ui.ac.Renderer.prototype.getTarget = function() {
  'use strict';
  return this.target_ || null;
};


/**
 * Disposes of the renderer and its associated HTML.
 * @override
 * @protected
 */
goog.ui.ac.Renderer.prototype.disposeInternal = function() {
  'use strict';
  if (this.element_) {
    goog.events.unlisten(
        this.element_, goog.events.EventType.CLICK, this.handleClick_, false,
        this);
    goog.events.unlisten(
        this.element_, goog.events.EventType.MOUSEDOWN, this.handleMouseDown_,
        false, this);
    goog.events.unlisten(
        this.element_, goog.events.EventType.MOUSEOVER, this.handleMouseOver_,
        false, this);
    this.dom_.removeNode(this.element_);
    this.element_ = null;
    this.visible_ = false;
  }

  goog.dispose(this.animation_);
  this.parent_ = null;

  goog.ui.ac.Renderer.base(this, 'disposeInternal');
};


/**
 * Generic function that takes a row and renders a DOM structure for that row.
 *
 * Normally this will only be matching a maximum of 20 or so items.  Even with
 * 40 rows, DOM this building is fine.
 * @param {Object} row Object representing row.
 * @param {string} token Token to highlight.
 * @param {Node} node The node to render into.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.renderRowContents_ = function(row, token, node) {
  'use strict';
  goog.dom.setTextContent(node, row.data.toString());
};


/**
 * Goes through a node and all of its child nodes, replacing HTML text that
 * matches a token with <b>token</b>.
 * The replacement will happen on the first match or all matches depending on
 * this.highlightAllTokens_ value.
 *
 * @param {Node} node Node to match.
 * @param {string|Array<string>} tokenOrArray Token to match or array of tokens
 *     to match.  By default, only the first match will be highlighted.  If
 *     highlightAllTokens is set, then all tokens appearing at the start of a
 *     word, in whatever order and however many times, will be highlighted.
 * @private
 */
goog.ui.ac.Renderer.prototype.startHiliteMatchingText_ = function(
    node, tokenOrArray) {
  'use strict';
  this.wasHighlightedAtLeastOnce_ = false;
  this.hiliteMatchingText_(node, tokenOrArray);
};


/**
 * @param {Node} node Node to match.
 * @param {string|Array<string>} tokenOrArray Token to match or array of tokens
 *     to match.
 * @private
 */
goog.ui.ac.Renderer.prototype.hiliteMatchingText_ = function(
    node, tokenOrArray) {
  'use strict';
  if (!this.highlightAllTokens_ && this.wasHighlightedAtLeastOnce_) {
    return;
  }

  if (node.nodeType == goog.dom.NodeType.TEXT) {
    var rest = null;
    if (Array.isArray(tokenOrArray) && tokenOrArray.length > 1 &&
        !this.highlightAllTokens_) {
      rest = tokenOrArray.slice(1);
    }

    var token = this.getTokenRegExp_(tokenOrArray);
    if (token.length == 0) return;

    var text = node.nodeValue;

    // Create a regular expression to match a token at the beginning of a line
    // or preceded by non-alpha-numeric characters. Note: token could have |
    // operators in it, so we need to parenthesise it before adding \b to it.
    // or preceded by non-alpha-numeric characters
    //
    // NOTE(adeboor): When using word matches, this used to have
    // a (^|\\W+) clause where it now has \\b but it caused various
    // browsers to hang on really long strings. The (^|\\W+) matcher was also
    // unnecessary, because \b already checks that the character before the
    // is a non-word character, and ^ matches the start of the line or following
    // a line terminator character, which is also \W. The regexp also used to
    // have a capturing match before the \\b, which would capture the
    // non-highlighted content, but that caused the regexp matching to run much
    // slower than the current version.
    var re = this.matchWordBoundary_ ?
        new RegExp('\\b(?:' + token + ')', 'gi') :
        new RegExp(token, 'gi');
    var textNodes = [];
    var lastIndex = 0;

    // Find all matches
    // Note: text.split(re) has inconsistencies between IE and FF, so
    // manually recreated the logic
    var match = re.exec(text);
    var numMatches = 0;
    while (match) {
      numMatches++;
      textNodes.push(text.substring(lastIndex, match.index));
      textNodes.push(text.substring(match.index, re.lastIndex));
      lastIndex = re.lastIndex;
      match = re.exec(text);
    }
    textNodes.push(text.substring(lastIndex));

    // Replace the tokens with bolded text.  Each pair of textNodes
    // (starting at index idx) includes a node of text before the bolded
    // token, and a node (at idx + 1) consisting of what should be
    // enclosed in bold tags.
    if (textNodes.length > 1) {
      var maxNumToBold = !this.highlightAllTokens_ ? 1 : numMatches;
      for (var i = 0; i < maxNumToBold; i++) {
        var idx = 2 * i;

        node.nodeValue = textNodes[idx];
        var boldTag = this.dom_.createElement(goog.dom.TagName.B);
        boldTag.className = this.highlightedClassName;
        this.dom_.appendChild(
            boldTag, this.dom_.createTextNode(textNodes[idx + 1]));
        boldTag = node.parentNode.insertBefore(boldTag, node.nextSibling);
        node.parentNode.insertBefore(
            this.dom_.createTextNode(''), boldTag.nextSibling);
        node = boldTag.nextSibling;
      }

      // Append the remaining text nodes to the end.
      var remainingTextNodes = textNodes.slice(maxNumToBold * 2);
      node.nodeValue = remainingTextNodes.join('');

      this.wasHighlightedAtLeastOnce_ = true;
    } else if (rest) {
      this.hiliteMatchingText_(node, rest);
    }
  } else {
    var child = node.firstChild;
    while (child) {
      var nextChild = child.nextSibling;
      this.hiliteMatchingText_(child, tokenOrArray);
      child = nextChild;
    }
  }
};


/**
 * Transforms a token into a string ready to be put into the regular expression
 * in hiliteMatchingText_.
 * @param {string|Array<string>} tokenOrArray The token or array to get the
 *     regex string from.
 * @return {string} The regex-ready token.
 * @private
 */
goog.ui.ac.Renderer.prototype.getTokenRegExp_ = function(tokenOrArray) {
  'use strict';
  var token = '';

  if (!tokenOrArray) {
    return token;
  }

  if (Array.isArray(tokenOrArray)) {
    // Remove invalid tokens from the array, which may leave us with nothing.
    tokenOrArray = tokenOrArray.filter(function(str) {
      'use strict';
      return !goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));
    });
  }

  // If highlighting all tokens, join them with '|' so the regular expression
  // will match on any of them.
  if (this.highlightAllTokens_) {
    if (Array.isArray(tokenOrArray)) {
      var tokenArray = tokenOrArray.map(goog.string.regExpEscape);
      token = tokenArray.join('|');
    } else {
      // Remove excess whitespace from the string so bars will separate valid
      // tokens in the regular expression.
      token = goog.string.collapseWhitespace(tokenOrArray);

      token = goog.string.regExpEscape(token);
      token = token.replace(/ /g, '|');
    }
  } else {
    // Not highlighting all matching tokens.  If tokenOrArray is a string, use
    // that as the token.  If it is an array, use the first element in the
    // array.
    // TODO(adeboor): why is this this way?. We should match against all
    // tokens in the array, but only accept the first match.
    if (Array.isArray(tokenOrArray)) {
      token = tokenOrArray.length > 0 ?
          goog.string.regExpEscape(tokenOrArray[0]) :
          '';
    } else {
      // For the single-match string token, we refuse to match anything if
      // the string begins with a non-word character, as matches by definition
      // can only occur at the start of a word. (This also handles the
      // goog.string.isEmptyOrWhitespace(goog.string.makeSafe(tokenOrArray))
      // case.)
      if (!/^\W/.test(tokenOrArray)) {
        token = goog.string.regExpEscape(tokenOrArray);
      }
    }
  }

  return token;
};


/**
 * Render a row by creating a div and then calling row rendering callback or
 * default row handler
 *
 * @param {Object} row Object representing row.
 * @param {string} token Token to highlight.
 * @return {!Element} An element with the rendered HTML.
 */
goog.ui.ac.Renderer.prototype.renderRowHtml = function(row, token) {
  'use strict';
  // Create and return the element.
  var elem = this.dom_.createDom(goog.dom.TagName.DIV, {
    className: this.rowClassName,
    id: goog.ui.IdGenerator.getInstance().getNextUniqueId()
  });
  goog.a11y.aria.setRole(elem, goog.a11y.aria.Role.OPTION);
  if (this.customRenderer_ && this.customRenderer_.renderRow) {
    this.customRenderer_.renderRow(row, token, elem);
  } else {
    this.renderRowContents_(row, token, elem);
  }

  if (token && this.useStandardHighlighting_) {
    this.startHiliteMatchingText_(elem, token);
  }

  goog.dom.classlist.add(elem, this.rowClassName);
  this.rowDivs_.push(elem);
  return elem;
};


/**
 * Given an event target looks up through the parents till it finds a div.  Once
 * found it will then look to see if that is one of the childnodes, if it is
 * then the index is returned, otherwise -1 is returned.
 * @param {Element} et HtmlElement.
 * @return {number} Index corresponding to event target.
 * @private
 */
goog.ui.ac.Renderer.prototype.getRowFromEventTarget_ = function(et) {
  'use strict';
  while (et && et != this.element_ &&
         !goog.dom.classlist.contains(et, this.rowClassName)) {
    et = /** @type {Element} */ (et.parentNode);
  }
  return et ? this.rowDivs_.indexOf(et) : -1;
};


/**
 * Handle the click events.  These are redirected to the AutoComplete object
 * which then makes a callback to select the correct row.
 * @param {goog.events.Event} e Browser event object.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.handleClick_ = function(e) {
  'use strict';
  var index = this.getRowFromEventTarget_(/** @type {Element} */ (e.target));
  if (index >= 0) {
    this.dispatchEvent(/** @lends {goog.events.Event.prototype} */ ({
      type: goog.ui.ac.AutoComplete.EventType.SELECT,
      row: this.rows_[index].id
    }));
  }
  e.stopPropagation();
};


/**
 * Handle the mousedown event and prevent the AC from losing focus.
 * @param {goog.events.Event} e Browser event object.
 * @private
 */
goog.ui.ac.Renderer.prototype.handleMouseDown_ = function(e) {
  'use strict';
  e.stopPropagation();
  e.preventDefault();
};


/**
 * Handle the mousing events.  These are redirected to the AutoComplete object
 * which then makes a callback to set the correctly highlighted row.  This is
 * because the AutoComplete can move the focus as well, and there is no sense
 * duplicating the code
 * @param {goog.events.Event} e Browser event object.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.ac.Renderer.prototype.handleMouseOver_ = function(e) {
  'use strict';
  var index = this.getRowFromEventTarget_(/** @type {Element} */ (e.target));
  if (index >= 0) {
    if ((goog.now() - this.startRenderingRows_) <
        goog.ui.ac.Renderer.DELAY_BEFORE_MOUSEOVER) {
      return;
    }

    this.dispatchEvent({
      type: goog.ui.ac.AutoComplete.EventType.HILITE,
      row: this.rows_[index].id
    });
  }
};



/**
 * Class allowing different implementations to custom render the autocomplete.
 * Extending classes should override the render function.
 * @constructor
 */
goog.ui.ac.Renderer.CustomRenderer = function() {};


/**
 * Renders the autocomplete box. May be set to null.
 *
 * Because of the type, this function cannot be documented with param JSDoc.
 *
 * The function expects the following parameters:
 *
 * renderer, goog.ui.ac.Renderer: The autocomplete renderer.
 * element, Element: The main element that controls the rendered autocomplete.
 * rows, Array: The current set of rows being displayed.
 * token, string: The current token that has been entered. *
 *
 * @type {function(goog.ui.ac.Renderer, Element, Array, string)|
 *        null|undefined}
 */
goog.ui.ac.Renderer.CustomRenderer.prototype.render = function(
    renderer, element, rows, token) {};


/**
 * Generic function that takes a row and renders a DOM structure for that row.
 * @param {Object} row Object representing row.
 * @param {string} token Token to highlight.
 * @param {Node} node The node to render into.
 */
goog.ui.ac.Renderer.CustomRenderer.prototype.renderRow = function(
    row, token, node) {};

//javascript/angular/jfkwrappers/autocomplete/autocomplete.js
/**
 * @fileoverview Angular directive "jfk-autocomplete". Apply to a HTML input
 * to give it Kennedy autocomplete style and behaviour.
 *
 *
 * Attributes:
 *
 * There are three ways to use the directive:
 *
 * The "values" attribute: The autocomplete will match against this given array
 * of string values.
 *
 * The "url" attribute: The autocomplete will send a GET request to the given
 * URL with query parameters "token" (the entered text), "max_matches" (the
 * maximum number of matches that the server should return) and "use_similar" (a
 * hint to the server for whether or not it should use fuzzy matching). The
 * server should respond with a JSON array of matching strings, up to length
 * max_matches (this maximum length is left to the server to enforce). The
 * server specification is the same as that required by a
 * goog.ui.ac.RemoteArrayMatcher.
 *
 * The "custom-matcher" attribute: The autocomplete will use the supplied
 * matching function to perform its matches. The signature for a matcher
 * function should be:
 *
 * param {string} token The token to match against.
 * param {number} maxMatches The maximum number of matches to find.
 * param {function(string, Array.<string>)} matchCallback The callback
 *     function that must be called with the token and the match array as
 *     arguments in order to have the matches appear as autocomplete
 *     suggestions.
 * function matcherFn(token, maxMatches, matchCallback) ...
 *
 * The matcher function should perform an action with the token to construct
 * an array of up to maxMatches matches. Somewhere inside the matcher,
 * "matchCallback(token, matches)" must be called, where "token" is the
 * original token and "matches" is the array of matches.
 *
 * There is an additional attribute, "fuzzy" - this affects "values" and "url"
 * autocompletes. For an autocomplete using "values", the fuzzy matching defined
 * in goog.ui.ac.ArrayMatcher will be used. For an autocomplete using "url", the
 * use_similar query parameter will be set to "1".
 *
 * There is an additional attribute, "createMenuInParent" - this will create the
 * menu DOM element inside the input tag's immediate parent. If this isn't set,
 * the menu DOM element will default to being created in document.body.
 *
 * The "maxMatches" attribute can be used to modify the maximum number
 * of displayed matches, or to modify the value of "max_matches" sent to
 * the remote server.
 *
 * The "autoHilite" attribute can be used to enable autoHilite in the
 * underlying AutoComplete object (which defaults to true).
 *
 * The "customRenderer" attribute: The autocomplete will use the supplied
 * goog.ui.ac.Renderer.CustomRenderer instead of the default one.
 *
 * The "customInputHandler" attribute: The autocomplete will use the supplied
 * goog.ui.ac.InputHandler instead of the default one. Since the
 * customInputHandler specifies the delimiter for multi values/select,
 * specifying the ngList attribute with values in conjunction with a
 * customInputHandler will throw an error.
 *
 * The "allowFreeSelect" attribute can be used to enable allowFreeSelect in the
 * underlying AutoComplete object (which defaults to false).
 *
 * The "triggerSuggestionsOnUpdate" attribute can be used to enable
 * triggerSuggestionsOnUpdate in the underlying AutoComplete object (which
 * defaults to false).
 *
 * The "matchWithinWords" attribute can be used to determine whether matches
 * should be highlighted regardless when the token matches text at a whole-word
 * boundary or not. False by default.
 * See "goog.ui.ac.Renderer matchWordBoundary".
 *
 * If ngList is used in conjunction this this input it will be a multi select.
 * The regular expression syntax for ngList separators is not supported and will
 * throw an exception if used.
 *
 * Usage Example:<br>
 * <code><pre>
 *   &lt;input jfk-autocomplete values="['aardvark','abacus',...]"&gt;
 *   &lt;input jfk-autocomplete values="['aardvark','abacus',...]" fuzzy&gt;
 *   &lt;input jfk-autocomplete url="'/autocomplete'" max-matches=5&gt;
 *   &lt;input jfk-autocomplete url="'/autocomplete'" fuzzy&gt;
 *   &lt;input jfk-autocomplete custom-matcher="customMatcherFn"&gt;
 *   &lt;input jfk-autocomplete custom-renderer="ctrl.customRenderer"&gt;
 *   &lt;input jfk-autocomplete
 *       custom-input-handler="ctrl.customInputHandler"&gt;
 * </pre></code>
 * End example.
 */
'use strict';

goog.provide('ng.jfk.Autocomplete');
goog.provide('ng.jfk.Autocomplete.SafeRemoteArrayMatcher');

goog.require('goog.a11y.aria');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.string');
goog.require('goog.ui.ac.ArrayMatcher');
goog.require('goog.ui.ac.AutoComplete');
goog.require('goog.ui.ac.InputHandler');
goog.require('goog.ui.ac.RemoteArrayMatcher');
goog.require('goog.ui.ac.Renderer');
goog.require('ng.jfk.Common');
goog.requireType('goog.events.Event');
goog.requireType('ng.jfk.CommonService');


/**
 * The Angular module for the JFK autocomplete.
 * @type {!angular.Module}
 */
ng.jfk.Autocomplete = angular.module('jfkAutocomplete', [ng.jfk.Common.name]);


/**
 * The CSS classes to give to the autocomplete renderer.
 * @type {string}
 * @const
 */
ng.jfk.Autocomplete.RENDERER_CLASS_NAME = 'goog-menu jfk-ac-renderer';


/**
 * The CSS class to give to the autocomplete rows.
 * This must be a single class as it is used by the Renderer as an argument to
 * goog.dom.classlist.contains.
 * @type {string}
 * @const
 */
ng.jfk.Autocomplete.ROW_CLASS_NAME = 'goog-menuitem';


/**
 * The CSS class to give to a selected autocomplete row.
 * @type {string}
 * @const
 */
ng.jfk.Autocomplete.ACTIVE_ROW_CLASS_NAME = 'goog-menuitem-highlight';


/**
 * The CSS class to give the autocomplete input element.
 * @type {string}
 * @const
 */
ng.jfk.Autocomplete.INPUT_CLASS_NAME = 'jfk-textinput';


/**
 * Attributes for which exactly one must be set for the directive to be valid.
 * @type {Array.<string>}
 * @private
 */
ng.jfk.Autocomplete.CONFLICTING_ATTRIBUTES_ =
    ['values', 'url', 'customMatcher'];

/**
 * The JSON prefix to avoid XSSI attacks.
 * @type {string}
 * @private
 * @const
 */
ng.jfk.Autocomplete.XSSI_PREFIX_ = ')]}\'\n';

/**
 * An extension of RemoteArrayMatcher that strips the XSSI prefix from the
 * response returned by the remote server.
 * @unrestricted
 */
ng.jfk.Autocomplete.SafeRemoteArrayMatcher =
    class extends goog.ui.ac.RemoteArrayMatcher {
  /**
   * @param {string} url The Uri which generates the auto complete matches.
   * @param {boolean=} opt_noSimilar If true, request that the server does not
   *     do similarity matches for the input token.
   */
  constructor(url, opt_noSimilar) {
    super(url, opt_noSimilar);
  }

  /**
   * Handles the XHR response which might contain a XSSI prefix.
   * @param {string} token The XHR autocomplete token.
   * @param {Function} matchHandler The AutoComplete match handler.
   * @param {goog.events.Event} event The XHR success event.
   * @override
   */
  xhrCallback(token, matchHandler, event) {
    matchHandler(
        token, event.target.getResponseJson(ng.jfk.Autocomplete.XSSI_PREFIX_));
  }
};



ng.jfk.Autocomplete.directive('jfkAutocomplete', [
  '$parse', 'jfkCommon',
  function($parse, jfkCommon) {
    return {
      'restrict': 'A',
      'require': '?ngModel',
      'link': function($scope, $element, $attrs, ngModel) {
        ng.jfk.Autocomplete.validateAttributes_($attrs);
        var autocomplete;
        var fuzzy = $attrs.hasOwnProperty('fuzzy');
        var createMenuInParent = $attrs.hasOwnProperty('createMenuInParent');

        var multi;
        // Assume that ngList elements should have multi complete enabled.
        if ($attrs.hasOwnProperty('ngList')) {
          multi = $attrs['ngList'] || ',';
          goog.asserts.assert(
              '/' != multi[0] != multi[multi.length - 1],
              'Invalid ngList value: ' + multi +
                  ' Autocomplete input does not support regular expressions');
        }

        // Required to stop input form history appearing above the suggestions.
        goog.dom.setProperties($element[0], {'autocomplete': 'off'});
        $element.addClass(ng.jfk.Autocomplete.INPUT_CLASS_NAME);
        ng.jfk.Autocomplete.setAccessibilityProperties_($element[0]);

        if ($attrs.hasOwnProperty('values')) {
          $scope.$watch($attrs['values'], function(values) {
            var matcher = new goog.ui.ac.ArrayMatcher(values, !fuzzy);
            autocomplete = ng.jfk.Autocomplete.rebuildAutocomplete_(
                jfkCommon, $scope, $attrs, ngModel, autocomplete, matcher,
                $element[0], multi, createMenuInParent);
          }, true /* deep */);
        }

        if ($attrs.hasOwnProperty('url')) {
          $scope.$watch($attrs['url'], function(url) {
            var matcher =
                new ng.jfk.Autocomplete.SafeRemoteArrayMatcher(url, !fuzzy);
            autocomplete = ng.jfk.Autocomplete.rebuildAutocomplete_(
                jfkCommon, $scope, $attrs, ngModel, autocomplete, matcher,
                $element[0], multi, createMenuInParent);
          });
        }

        if ($attrs.hasOwnProperty('customMatcher')) {
          $scope.$watch($attrs['customMatcher'], function(customMatcher) {
            var matcher = {requestMatchingRows: customMatcher};
            autocomplete = ng.jfk.Autocomplete.rebuildAutocomplete_(
                jfkCommon, $scope, $attrs, ngModel, autocomplete, matcher,
                $element[0], multi, createMenuInParent);
          });
        }
      }
    };
  }
]);


/**
 * Throws an error if greater or fewer than 1 conflicting attribute is set.
 * @param {!angular.Attributes} $attrs The attributes map.
 * @private
 */
ng.jfk.Autocomplete.validateAttributes_ = function($attrs) {
  var attributeCount = 0;
  goog.array.forEach(
      ng.jfk.Autocomplete.CONFLICTING_ATTRIBUTES_, function(attribute) {
        if ($attrs.hasOwnProperty(attribute)) {
          attributeCount++;
        }
      });
  if (attributeCount != 1) {
    throw new Error(
        'Exactly one attribute must be set of the following: ' +
        ng.jfk.Autocomplete.CONFLICTING_ATTRIBUTES_);
  }
};


/**
 * Sets the role and aria properties for the autocomplete.
 * @param {!Element} input The input element of the autocomplete.
 * @private
 */
ng.jfk.Autocomplete.setAccessibilityProperties_ = function(input) {
  goog.a11y.aria.setRole(input, 'combobox');
  goog.a11y.aria.setState(input, 'autocomplete', 'list');
};


/**
 * Creates the renderer to use to render the autocomplete rows.
 * @param {({render: ?}|{renderRow: ?})} opt_customRenderer Custom
 *     renderer to which rendering is handed over to for each row.
 * @param {Element=} opt_insertPoint The DOM element to render the menu in.
 * @return {!goog.ui.ac.Renderer} The newly created renderer.
 * @private
 */
ng.jfk.Autocomplete.createRenderer_ = function(
    opt_customRenderer, opt_insertPoint) {
  var renderer = new goog.ui.ac.Renderer(opt_insertPoint, opt_customRenderer);
  renderer.className = ng.jfk.Autocomplete.RENDERER_CLASS_NAME;
  renderer.rowClassName = ng.jfk.Autocomplete.ROW_CLASS_NAME;
  renderer.activeClassName = ng.jfk.Autocomplete.ACTIVE_ROW_CLASS_NAME;
  return renderer;
};


/**
 * Attaches an autocomplete to the given input that uses the given matcher.
 * @param {!Object} matcher The matcher to use. This must implement a method
 *     'requestMatchingRows'.
 * @param {!Element} input The input element to which to attach the
 *     autocomplete.
 * @param {!goog.ui.ac.InputHandler} inputHandler The input handler to
 *     use to handle input and suggestion selection events.
 * @param {boolean} matchWithinWords Determines whether matches should be
 *     highlighted regardless if the input matches text at a whole-word boundary
 *     or not. goog.ui.ac.Renderer sets this to false by default.
 *     See "matchWordBoundary".
 * @param {({render: ?}|{renderRow: ?})=} opt_customRenderer Custom
 *     renderer to which rendering is handed over to for each row.
 * @param {boolean=} opt_insertInParent If true, render the menu in the input's
 *     parent node. Otherwise document.body.
 * @return {!goog.ui.ac.AutoComplete} The attached autocomplete component.
 * @private
 */
ng.jfk.Autocomplete.attachAutocomplete_ = function(
    matcher, input, inputHandler, matchWithinWords, opt_customRenderer,
    opt_insertInParent) {
  var insertPoint = opt_insertInParent ? input.parentNode : undefined;
  var renderer = ng.jfk.Autocomplete.createRenderer_(
      opt_customRenderer,
      /** @type {Element|undefined} */ (insertPoint));
  renderer.setMatchWordBoundary(!matchWithinWords);
  var autocomplete =
      new goog.ui.ac.AutoComplete(matcher, renderer, inputHandler);
  inputHandler.attachAutoComplete(autocomplete);
  inputHandler.attachInputs(input);
  return autocomplete;
};


/**
 * Refreshes the autocomplete on a given element by removing it and attaching a
 * new one.
 * @param {!ng.jfk.CommonService} jfkCommon The JFK common service.
 * @param {!angular.Scope} $scope The scope.
 * @param {!angular.Attributes} $attrs The attributes map.
 * @param {angular.NgModelController} ngModel The Angular model.
 * @param {?goog.ui.ac.AutoComplete} autocomplete The autocomplete to rebuild.
 * @param {!Object} matcher The matcher to use. This must implement a method
 *     'requestMatchingRows'.
 * @param {!Element} input The input element to which to attach the
 *     autocomplete.
 * @param {string} opt_multi The separator to use for multi entry elements. If
 *     not present the element is assumed to be a single entry element.
 * @param {boolean} opt_insertInParent If true, render the menu in the input's
 *     parent node. Otherwise document.body.
 * @return {!goog.ui.ac.AutoComplete} The rebuilt autocomplete component.
 * @private
 */
ng.jfk.Autocomplete.rebuildAutocomplete_ = function(
    jfkCommon, $scope, $attrs, ngModel, autocomplete, matcher, input, opt_multi,
    opt_insertInParent) {
  if (autocomplete) {
    autocomplete.dispose();
  }
  var inputHandler;
  if ($attrs.hasOwnProperty('customInputHandler')) {
    // Verify that fields customInputHandler and ngList with attribute
    // values set are mutually exclusive properties.
    goog.asserts.assert(
        !$attrs.hasOwnProperty('ngList') ||
            goog.string.isEmptyOrWhitespace(
                goog.string.makeSafe($attrs['ngList'])),
        'Custom input handler and ngList with delimiter values are ' +
            'mutually exclusive properties.');
    inputHandler = /** @type {!goog.ui.ac.InputHandler} */ (
        $scope.$eval($attrs['customInputHandler']));
    goog.asserts.assert(inputHandler, 'Custom input handler must be defined.');
  } else {
    inputHandler =
        new goog.ui.ac.InputHandler(opt_multi, null, opt_multi != null);
  }
  var opt_customRenderer;
  if ($attrs.hasOwnProperty('customRenderer')) {
    opt_customRenderer = /** @type {({render: ?}|{renderRow: ?})} */ (
        $scope.$eval($attrs['customRenderer']));
    goog.asserts.assert(opt_customRenderer, 'Custom renderer must be defined.');
  }
  var matchWithinWords = false;
  if ($attrs.hasOwnProperty('matchWithinWords')) {
    matchWithinWords = $attrs['matchWithinWords'] == 'true';
  }
  autocomplete = ng.jfk.Autocomplete.attachAutocomplete_(
      matcher, input, inputHandler, matchWithinWords, opt_customRenderer,
      opt_insertInParent);
  if ($attrs['maxMatches']) {
    autocomplete.setMaxMatches($attrs['maxMatches']);
  }
  if ($attrs.hasOwnProperty('autoHilite')) {
    autocomplete.setAutoHilite($attrs['autoHilite'] == 'true');
  }
  if ($attrs.hasOwnProperty('allowFreeSelect')) {
    autocomplete.setAllowFreeSelect($attrs['allowFreeSelect'] == 'true');
  }
  if ($attrs.hasOwnProperty('triggerSuggestionsOnUpdate')) {
    autocomplete.setTriggerSuggestionsOnUpdate(
        $attrs['triggerSuggestionsOnUpdate'] == 'true');
  }
  if (ngModel) {
    jfkCommon.listenUntilDestroy(
        $scope, autocomplete, goog.ui.ac.AutoComplete.EventType.UPDATE,
        function(event) {
          $scope.$apply(function() {
            if (opt_multi != null) {
              ngModel.$setViewValue(input.value);
            } else if (event.row != null) {
              ngModel.$setViewValue(event.row);
            }
          });
        });
  }
  jfkCommon.componentLink($scope, $attrs, autocomplete);
  return autocomplete;
};

//javascript/jfk/position/popupposition.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Popup position with respect to an anchor.
 * @author chrishenry@google.com (Chris Henry)
 */

goog.provide('jfk.PopupPosition');


/**
 * Enumeration for different box positions (relative to the anchor
 * element). These positions respect RTL.
 * @enum {number}
 */
jfk.PopupPosition = {
  LEFT: 0,
  BOTTOM: 1,
  TOP: 2,
  RIGHT: 3
};


/**
 * Bit sequence used to flip popup position to its opposite (left to right,
 * top to bottom, and vice versa).
 * @type {number}
 * @const
 * @private
 */
jfk.PopupPosition.FLIP_POSITION_ = 3;


/**
 * Flips the given popup position to its opposite.
 * @param {!jfk.PopupPosition} position Initial popup position.
 * @return {!jfk.PopupPosition} Flipped popup position.
 */
jfk.PopupPosition.flip = function(position) {
  return /** @type {jfk.PopupPosition} */(
      position ^ jfk.PopupPosition.FLIP_POSITION_);
};

//javascript/angular/jfkwrappers/ngjfkposition.js
goog.loadModule(function(exports) {'use strict';goog.module('ng.jfk.Position');
goog.module.declareLegacyNamespace();

const PopupPosition = goog.require('jfk.PopupPosition');

/**
 * Static map of possible popup positions.
 * @type {!Object.<PopupPosition>}
 * @const
 */
const POSITION_MAP = {
  'LEFT': PopupPosition.LEFT,
  'BOTTOM': PopupPosition.BOTTOM,
  'TOP': PopupPosition.TOP,
  'RIGHT': PopupPosition.RIGHT
};

exports = {
  POSITION_MAP,
};

;return exports;});

//third_party/javascript/closure/soy/data.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Soy data primitives.
 *
 * The goal is to encompass data types used by Soy, especially to mark content
 * as known to be "safe".
 */

goog.provide('goog.soy.data');
goog.provide('goog.soy.data.SanitizedContent');
goog.provide('goog.soy.data.SanitizedContentKind');
goog.provide('goog.soy.data.SanitizedCss');
goog.provide('goog.soy.data.SanitizedHtml');
goog.provide('goog.soy.data.SanitizedHtmlAttribute');
goog.provide('goog.soy.data.SanitizedJs');
goog.provide('goog.soy.data.SanitizedTrustedResourceUri');
goog.provide('goog.soy.data.SanitizedUri');

goog.require('goog.Uri');
goog.require('goog.asserts');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeStyleSheet');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');
goog.require('goog.html.uncheckedconversions');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.string.Const');


/**
 * A type of textual content.
 *
 * This is an enum of type Object so that these values are unforgeable.
 *
 * @enum {!Object}
 */
goog.soy.data.SanitizedContentKind = {

  /**
   * A snippet of HTML that does not start or end inside a tag, comment, entity,
   * or DOCTYPE; and that does not contain any executable code
   * (JS, {@code <object>}s, etc.) from a different trust domain.
   */
  HTML: goog.DEBUG ? {sanitizedContentKindHtml: true} : {},

  /**
   * Executable JavaScript code or expression, safe for insertion in a
   * script-tag or event handler context, known to be free of any
   * attacker-controlled scripts. This can either be side-effect-free
   * JavaScript (such as JSON) or JavaScript that's entirely under Google's
   * control.
   */
  JS: goog.DEBUG ? {sanitizedContentJsChars: true} : {},

  /** A properly encoded portion of a URI. */
  URI: goog.DEBUG ? {sanitizedContentUri: true} : {},

  /** A resource URI not under attacker control. */
  TRUSTED_RESOURCE_URI:
      goog.DEBUG ? {sanitizedContentTrustedResourceUri: true} : {},

  /**
   * Repeated attribute names and values. For example,
   * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
   */
  ATTRIBUTES: goog.DEBUG ? {sanitizedContentHtmlAttribute: true} : {},

  // TODO: Consider separating rules, declarations, and values into
  // separate types, but for simplicity, we'll treat explicitly blessed
  // SanitizedContent as allowed in all of these contexts.
  /**
   * A CSS3 declaration, property, value or group of semicolon separated
   * declarations.
   */
  STYLE: goog.DEBUG ? {sanitizedContentStyle: true} : {},

  /** A CSS3 style sheet (list of rules). */
  CSS: goog.DEBUG ? {sanitizedContentCss: true} : {}

  // TEXT doesn't produce SanitizedContent anymore, use renderText.
};



/**
 * A string-like object that carries a content-type and a content direction.
 *
 * IMPORTANT! Do not create these directly, nor instantiate the subclasses.
 * Instead, use a trusted, centrally reviewed library as endorsed by your team
 * to generate these objects. Otherwise, you risk accidentally creating
 * SanitizedContent that is attacker-controlled and gets evaluated unescaped in
 * templates.
 *
 * @constructor
 */
goog.soy.data.SanitizedContent = function() {
  'use strict';
  throw new Error('Do not instantiate directly');
};


/**
 * The context in which this content is safe from XSS attacks.
 * @type {goog.soy.data.SanitizedContentKind}
 */
goog.soy.data.SanitizedContent.prototype.contentKind;


/**
 * The content's direction; null if unknown and thus to be estimated when
 * necessary.
 * @type {?goog.i18n.bidi.Dir}
 */
goog.soy.data.SanitizedContent.prototype.contentDir = null;


/**
 * The already-safe content.
 * @protected {string}
 */
goog.soy.data.SanitizedContent.prototype.content;


/**
 * Gets the already-safe content.
 * @return {string}
 */
goog.soy.data.SanitizedContent.prototype.getContent = function() {
  'use strict';
  return this.content;
};


/** @override */
goog.soy.data.SanitizedContent.prototype.toString = function() {
  'use strict';
  return this.content;
};


/**
 * Converts sanitized content of kind HTML into SafeHtml
 * @return {!goog.html.SafeHtml}
 * @throws {!Error} when the content kind is not HTML.
 */
goog.soy.data.SanitizedContent.prototype.toSafeHtml = function() {
  'use strict';
  if (this.contentKind !== goog.soy.data.SanitizedContentKind.HTML) {
    throw new Error('Sanitized content was not of kind HTML.');
  }
  return goog.html.uncheckedconversions
      .safeHtmlFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from(
              'Soy SanitizedContent of kind HTML produces ' +
              'SafeHtml-contract-compliant value.'),
          this.toString(), this.contentDir);
};


/**
 * Converts sanitized content of kind URI into SafeUrl without modification.
 * @return {!goog.html.SafeUrl}
 * @throws {Error} when the content kind is not URI.
 */
goog.soy.data.SanitizedContent.prototype.toSafeUrl = function() {
  'use strict';
  if (this.contentKind !== goog.soy.data.SanitizedContentKind.URI) {
    throw new Error('Sanitized content was not of kind URI.');
  }
  return goog.html.uncheckedconversions
      .safeUrlFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from(
              'Soy SanitizedContent of kind URI produces ' +
              'SafeHtml-contract-compliant value.'),
          this.toString());
};


/**
 * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
 *
 * The content is a string of HTML that can safely be embedded in a PCDATA
 * context in your app.  If you would be surprised to find that an HTML
 * sanitizer produced `s` (e.g.  it runs code or fetches bad URLs) and
 * you wouldn't write a template that produces `s` on security or privacy
 * grounds, then don't pass `s` here. The default content direction is
 * unknown, i.e. to be estimated when necessary.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedHtml = function() {
  'use strict';
  goog.soy.data.SanitizedHtml.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedHtml, goog.soy.data.SanitizedContent);


/** @override */
goog.soy.data.SanitizedHtml.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.HTML;


/**
 * Checks if the value could be used as the Soy type {html}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedHtml.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedHtml.isCompatibleWithStrict(value);
};


/**
 * Checks if the value could be used as the Soy type {html}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedHtml.isCompatibleWithStrict = function(value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedHtml ||
      value instanceof goog.html.SafeHtml;
};


/**
 * Content of type {@link goog.soy.data.SanitizedContentKind.JS}.
 *
 * The content is JavaScript source that when evaluated does not execute any
 * attacker-controlled scripts. The content direction is LTR.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedJs = function() {
  'use strict';
  goog.soy.data.SanitizedJs.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedJs, goog.soy.data.SanitizedContent);


/** @override */
goog.soy.data.SanitizedJs.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.JS;


/** @override */
goog.soy.data.SanitizedJs.prototype.contentDir = goog.i18n.bidi.Dir.LTR;


/**
 * Checks if the value could be used as the Soy type {js}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedJs.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedJs.isCompatibleWithStrict(value);
};

/**
 * Checks if the value could be used as the Soy type {js}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedJs.isCompatibleWithStrict = function(value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedJs ||
      value instanceof goog.html.SafeScript;
};


/**
 * Converts sanitized content of kind JS into SafeScript without modification.
 * @return {!goog.html.SafeScript}
 */
goog.soy.data.SanitizedJs.prototype.toSafeScript = function() {
  'use strict';
  return goog.html.uncheckedconversions
      .safeScriptFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from(
              'Soy SanitizedContent of kind JS produces ' +
              'SafeScript-contract-compliant value.'),
          this.toString());
};



/**
 * Content of type {@link goog.soy.data.SanitizedContentKind.URI}.
 *
 * The content is a URI chunk that the caller knows is safe to emit in a
 * template. The content direction is LTR.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedUri = function() {
  'use strict';
  goog.soy.data.SanitizedUri.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedUri, goog.soy.data.SanitizedContent);

/** @override */
goog.soy.data.SanitizedUri.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.URI;


/** @override */
goog.soy.data.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;


/**
 * Checks if the value could be used as the Soy type {uri}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedUri.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedUri.isCompatibleWithStrict(value);
};


/**
 * Checks if the value could be used as the Soy type {uri}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedUri.isCompatibleWithStrict = function(value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedUri ||
      value instanceof goog.html.SafeUrl ||
      value instanceof goog.html.TrustedResourceUrl ||
      value instanceof goog.Uri;
};



/**
 * Content of type
 * {@link goog.soy.data.SanitizedContentKind.TRUSTED_RESOURCE_URI}.
 *
 * The content is a TrustedResourceUri chunk that is not under attacker control.
 * The content direction is LTR.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedTrustedResourceUri = function() {
  'use strict';
  goog.soy.data.SanitizedTrustedResourceUri.base(this, 'constructor');
};
goog.inherits(
    goog.soy.data.SanitizedTrustedResourceUri, goog.soy.data.SanitizedContent);


/** @override */
goog.soy.data.SanitizedTrustedResourceUri.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.TRUSTED_RESOURCE_URI;


/** @override */
goog.soy.data.SanitizedTrustedResourceUri.prototype.contentDir =
    goog.i18n.bidi.Dir.LTR;


/**
 * Converts sanitized content into TrustedResourceUrl without modification.
 * @return {!goog.html.TrustedResourceUrl}
 */
goog.soy.data.SanitizedTrustedResourceUri.prototype.toTrustedResourceUrl =
    function() {
  'use strict';
  return goog.html.uncheckedconversions
      .trustedResourceUrlFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from(
              'Soy SanitizedContent of kind TRUSTED_RESOURCE_URI produces ' +
              'TrustedResourceUrl-contract-compliant value.'),
          this.toString());
};


/**
 * Checks if the value could be used as the Soy type {trusted_resource_uri}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedTrustedResourceUri.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedTrustedResourceUri.isCompatibleWithStrict(value);
};


/**
 * Checks if the value could be used as the Soy type {trusted_resource_uri}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedTrustedResourceUri.isCompatibleWithStrict = function(
    value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedTrustedResourceUri ||
      value instanceof goog.html.TrustedResourceUrl;
};



/**
 * Content of type {@link goog.soy.data.SanitizedContentKind.ATTRIBUTES}.
 *
 * The content should be safely embeddable within an open tag, such as a
 * key="value" pair. The content direction is LTR.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedHtmlAttribute = function() {
  'use strict';
  goog.soy.data.SanitizedHtmlAttribute.base(this, 'constructor');
};
goog.inherits(
    goog.soy.data.SanitizedHtmlAttribute, goog.soy.data.SanitizedContent);


/** @override */
goog.soy.data.SanitizedHtmlAttribute.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.ATTRIBUTES;


/** @override */
goog.soy.data.SanitizedHtmlAttribute.prototype.contentDir =
    goog.i18n.bidi.Dir.LTR;


/**
 * Checks if the value could be used as the Soy type {attribute}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedHtmlAttribute.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedHtmlAttribute.isCompatibleWithStrict(value);
};


/**
 * Checks if the value could be used as the Soy type {attribute}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedHtmlAttribute.isCompatibleWithStrict = function(value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedHtmlAttribute;
};



/**
 * Content of type {@link goog.soy.data.SanitizedContentKind.CSS}.
 *
 * The content is non-attacker-exploitable CSS, such as {@code @import url(x)}.
 * The content direction is LTR.
 *
 * @extends {goog.soy.data.SanitizedContent}
 * @constructor
 */
goog.soy.data.SanitizedCss = function() {
  'use strict';
  goog.soy.data.SanitizedCss.base(this, 'constructor');
};
goog.inherits(goog.soy.data.SanitizedCss, goog.soy.data.SanitizedContent);


/** @override */
goog.soy.data.SanitizedCss.prototype.contentKind =
    goog.soy.data.SanitizedContentKind.CSS;


/** @override */
goog.soy.data.SanitizedCss.prototype.contentDir = goog.i18n.bidi.Dir.LTR;


/**
 * Checks if the value could be used as the Soy type {css}.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedCss.isCompatibleWith = function(value) {
  'use strict';
  return typeof value === 'string' ||
      goog.soy.data.SanitizedCss.isCompatibleWithStrict(value);
};


/**
 * Checks if the value could be used as the Soy type {css}.
 * Strict: disallows strings.
 * @param {*} value
 * @return {boolean}
 */
goog.soy.data.SanitizedCss.isCompatibleWithStrict = function(value) {
  'use strict';
  return value instanceof goog.soy.data.SanitizedCss ||
      value instanceof goog.html.SafeStyle ||
      value instanceof goog.html.SafeStyleSheet;
};


/**
 * Converts SanitizedCss into SafeStyleSheet.
 * Note: SanitizedCss in Soy represents both SafeStyle and SafeStyleSheet in
 * Closure. It's about to be split so that SanitizedCss represents only
 * SafeStyleSheet.
 * @return {!goog.html.SafeStyleSheet}
 */
goog.soy.data.SanitizedCss.prototype.toSafeStyleSheet = function() {
  'use strict';
  var value = this.toString();
  goog.asserts.assert(
      /[@{]|^\s*$/.test(value),
      'value doesn\'t look like style sheet: ' + value);
  return goog.html.uncheckedconversions
      .safeStyleSheetFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from(
              'Soy SanitizedCss produces SafeStyleSheet-contract-compliant ' +
              'value.'),
          value);
};

//javascript/template/soy/checks.js
goog.loadModule(function(exports) {'use strict';/*
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Provides Soy runtime checks for safe types.
 */

goog.module('soy.checks');

const asserts = goog.require('goog.asserts');

const {SanitizedContentKind, SanitizedCss, SanitizedHtml, SanitizedHtmlAttribute, SanitizedJs, SanitizedTrustedResourceUri, SanitizedUri} = goog.require('goog.soy.data');

/**
 * Checks whether a given value is of a given content kind.
 *
 * @param {?} value The value to be examined.
 * @param {!SanitizedContentKind} contentKind The desired content
 *     kind.
 * @param {!Object} constructor
 * @return {boolean} Whether the given value is of the given kind.
 */
const isContentKind_ = function(value, contentKind, constructor) {
  const ret = value != null && value.contentKind === contentKind;
  if (ret) {
    asserts.assert(value.constructor === constructor);
  }
  return ret;
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isHtml = function(value) {
  return isContentKind_(value, SanitizedContentKind.HTML, SanitizedHtml);
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isCss = function(value) {
  return isContentKind_(value, SanitizedContentKind.CSS, SanitizedCss);
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isAttribute = function(value) {
  return isContentKind_(
      value, SanitizedContentKind.ATTRIBUTES, SanitizedHtmlAttribute);
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isJS = function(value) {
  return isContentKind_(value, SanitizedContentKind.JS, SanitizedJs);
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isTrustedResourceURI = function(value) {
  return isContentKind_(
      value, SanitizedContentKind.TRUSTED_RESOURCE_URI,
      SanitizedTrustedResourceUri);
};

/**
 * @param {?} value
 * @return {boolean}
 */
exports.isURI = function(value) {
  return isContentKind_(value, SanitizedContentKind.URI, SanitizedUri);
};

;return exports;});

//third_party/javascript/tslib/tslib_closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview
 * Hand-modified Closure version of tslib.js.
 * These use the literal space optimized code from TypeScript for
 * compatibility.
 *
 * @suppress {undefinedVars}
 */

// Do not use @license

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

goog.module('google3.third_party.javascript.tslib.tslib');

/** @suppress {missingPolyfill} the code below intentionally feature-tests. */
var extendStatics = Object.setPrototypeOf ||
    ({__proto__: []} instanceof Array && function(d, b) {d.__proto__ = b;}) ||
    function(d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

/**
 * @param {?} d
 * @param {?} b
 */
exports.__extends = function(d, b) {
    extendStatics(d, b);
    // LOCAL MODIFICATION: Add jsdoc annotation here:
    /** @constructor */
    function __() { /** @type {?} */ (this).constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

exports.__assign = Object.assign || /** @return {?} */ function (/** ? */ t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

/**
 * @param {?} s
 * @param {?} e
 * @return {?}
 */
exports.__rest = function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};

/**
 * @param {?} decorators
 * @param {T} target
 * @param {?=} key
 * @param {?=} desc
 * @return {T}
 * @template T
 */
exports.__decorate = function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    // google3 local modification: use quoted property access to work around
    // https://b.corp.google.com/issues/77140019.
    if (typeof Reflect === "object" && Reflect && typeof Reflect['decorate'] === "function") r = Reflect['decorate'](decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * @param {?} metadataKey
 * @param {?} metadataValue
 * @return {?}
 */
exports.__metadata = function (metadataKey, metadataValue) {
  // google3 local modification: use quoted property access to work around
  // https://b.corp.google.com/issues/77140019.
  if (typeof Reflect === "object" && Reflect && typeof Reflect['metadata'] === "function") return Reflect['metadata'](metadataKey, metadataValue);
};

/**
 * @param {?} paramIndex
 * @param {?} decorator
 * @return {?}
 */
exports.__param = function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
};

/**
 * @template T
 * @param {T} thisArg
 * @param {?} _arguments
 * @param {?} P
 * @param {function(this:T)} generator
 * @return {?}
 */
exports.__awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    // LOCAL MODIFICATION: Cannot express the function + keys pattern in
    // closure, so we escape generator.next with ? type.
    function fulfilled(value) {
      try {
        step((/** @type {?} */ (generator)).next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator['throw'](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve) {
                                              resolve(result.value);
                                            }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments)).next());
  });
};

/**
 * @param {?} thisArg
 * @param {?} body
 * @return {?}
 */
exports.__generator = function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1) throw (/** @type {!Error} */ (t[1]));
      return t[1];
    },
    trys: [],
    ops: []
  },
      f, y, t, g;
  // LOCAL MODIFICATION: Originally iterator body was "return this", but it
  // doesn't compile as this is unknown. Changed to g, which is equivalent.
  return g = {next: verb(0), "throw": verb(1), "return": verb(2)},
         typeof Symbol === "function" && (g[Symbol.iterator] = function() {
           return g;
         }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
        if (f = 1,
            y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) &&
                !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t) op = [0, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {value: op[1], done: false};
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) &&
                (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5) throw (/** @type {!Error} */ (op[1]));
    return {value: op[0] ? op[1] : void 0, done: true};
  }
};

/**
 * @param {?} m
 * @param {?} e
 */
exports.__exportStar = function (m, e) {
    for (var p in m) if (!e.hasOwnProperty(p)) e[p] = m[p];
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__values = function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

/**
 * @param {?} o
 * @param {?=} n
 * @return {?}
 */
exports.__read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {error: error};
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw (/** @type {!Error} */ (e.error));
    }
  }
  return ar;
};

/**
 * @return {!Array}
 * @deprecated since TypeScript 4.2
 */
exports.__spread = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(exports.__read(arguments[i]));
  return ar;
};

/**
 * @return {!Array<?>}
 * @deprecated since TypeScript 4.2
 */
exports.__spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};

/**
 * @param {!Array<?>} to
 * @param {!Array<?>} from
 * @return {!Array<?>}
 */
exports.__spreadArray = function(to, from) {
  // LOCAL MODIFICATION: https://github.com/microsoft/TypeScript/issues/43353
  // We have to accept NodeList because they don't implement Iterable in Edge.
  if (!Array.isArray(from) && !(from instanceof NodeList)) {
    throw new TypeError('Expected an Array or NodeList: ' + String(from));
  }
  // END LOCAL MODIFICATION
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
    to[j] = from[i];
  return to;
};

/**
 * @constructor
 * LOCAL MODIFICATION: Originally used "this" in function body,
 * @this {?}
 * END LOCAL MODIFICATION
 * @param {?} v
 * @return {?}
 */
exports.__await = function(v) {
  return this instanceof exports.__await ? (this.v = v, this) :
                                           new exports.__await(v);
};

/**
 * @template T
 * @param {T} thisArg
 * @param {?} _arguments
 * @param {function(this:T)} generator
 * @return {?}
 */
exports.__asyncGenerator = function __asyncGenerator(
    thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb('next'), verb('throw'), verb('return'),
         i[Symbol.asyncIterator] = function() {
           return (/** @type {?} */ (this));
         }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof exports.__await ?
        Promise.resolve(/** @type {?} */ (r.value).v).then(fulfill, reject) :
        settle(q[0][2], r);
  }
  function fulfill(value) {
    resume('next', value);
  }
  function reject(value) {
    resume('throw', value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__asyncDelegator = function(o) {
  var i, p;
  // LOCAL MODIFICATION: Originally iterator body was "return this", but it
  // doesn't compile in some builds, as this is unknown. Changed to i, which is
  // equivalent.
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return i; }, i;
  /**
   * @param {?} n
   * @param {?=} f
   * @return {?}
   */
  function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: new exports.__await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
};

/**
 * @param {?} o
 * @return {?}
 */
exports.__asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator];
  return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
};

/**
 * @param {?=} cooked
 * @param {?=} raw
 * @return {?}
 */
exports.__makeTemplateObject = function(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


/**
 * @param {?} receiver
 * @param {!WeakMap} privateMap
 * @return {?}
 */
exports.__classPrivateFieldGet = function (receiver, privateMap) {
  if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
};

/**
 * @param {?} receiver
 * @param {!WeakMap} privateMap
 * @param {?} value
 * @return {?}
 */
exports.__classPrivateFieldSet = function (receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
};

;return exports;});

//javascript/typescript/safevalues/implementation/pure.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/pure.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.pure');
var module = module || { id: 'javascript/typescript/safevalues/implementation/pure.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * Mark an expression as being free of side effects.
 * @template T
 * @param {function(): T} valueOf
 * @return {T}
 */
function pure(valueOf) {
    // This odd looking expression is a workaround specific to the Closure
    // compiler to mark an expression as pure.
    // BEGIN-INTERNAL
    // TODO(b/155299094): Refactor after adding compiler support.
    // END-INTERNAL
    return ({ valueOf }).valueOf();
}
exports.pure = pure;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3B1cmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFDQSxTQUFnQixJQUFJLENBQUksT0FBZ0I7SUFDdEMsc0VBQXNFO0lBQ3RFLDBDQUEwQztJQUMxQyxpQkFBaUI7SUFDakIsNkRBQTZEO0lBQzdELGVBQWU7SUFDZixPQUFPLENBQUMsRUFBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQy9CLENBQUM7QUFQRCxvQkFPQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBNYXJrIGFuIGV4cHJlc3Npb24gYXMgYmVpbmcgZnJlZSBvZiBzaWRlIGVmZmVjdHMuICovXG5leHBvcnQgZnVuY3Rpb24gcHVyZTxUPih2YWx1ZU9mOiAoKSA9PiBUKTogVCB7XG4gIC8vIFRoaXMgb2RkIGxvb2tpbmcgZXhwcmVzc2lvbiBpcyBhIHdvcmthcm91bmQgc3BlY2lmaWMgdG8gdGhlIENsb3N1cmVcbiAgLy8gY29tcGlsZXIgdG8gbWFyayBhbiBleHByZXNzaW9uIGFzIHB1cmUuXG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIC8vIFRPRE8oYi8xNTUyOTkwOTQpOiBSZWZhY3RvciBhZnRlciBhZGRpbmcgY29tcGlsZXIgc3VwcG9ydC5cbiAgLy8gRU5ELUlOVEVSTkFMXG4gIHJldHVybiAoe3ZhbHVlT2Z9KS52YWx1ZU9mKCk7XG59XG4iXX0=
;return exports;});

//javascript/typescript/safevalues/implementation/secrets.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/secrets.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.secrets');
var module = module || { id: 'javascript/typescript/safevalues/implementation/secrets.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * A secret token that must be passed to safe type constructors. It is only
 * accessible from within safevalues, ensuring that unrestricted safe type
 * creation is only possible within safevalues. In particular, this prevents
 * forgery such as `safeHtmlValue.constructor('javascript:evil')`.
 * @type {*}
 */
exports.secretToken = {};
/**
 * Asserts that the given token matches the secret safevalues token. An
 * exception is thrown if that is not the case.
 * @param {!Object} token
 * @return {void}
 */
function ensureTokenIsValid(token) {
    if (token !== exports.secretToken) {
        throw new Error('Bad secret');
    }
}
exports.ensureTokenIsValid = ensureTokenIsValid;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcmV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3NlY3JldHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBTWEsUUFBQSxXQUFXLEdBQUcsRUFBRTs7Ozs7OztBQU03QixTQUFnQixrQkFBa0IsQ0FBQyxLQUFhO0lBQzlDLElBQUksS0FBSyxLQUFLLG1CQUFXLEVBQUU7UUFDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUMvQjtBQUNILENBQUM7QUFKRCxnREFJQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzZWNyZXQgdG9rZW4gdGhhdCBtdXN0IGJlIHBhc3NlZCB0byBzYWZlIHR5cGUgY29uc3RydWN0b3JzLiBJdCBpcyBvbmx5XG4gKiBhY2Nlc3NpYmxlIGZyb20gd2l0aGluIHNhZmV2YWx1ZXMsIGVuc3VyaW5nIHRoYXQgdW5yZXN0cmljdGVkIHNhZmUgdHlwZVxuICogY3JlYXRpb24gaXMgb25seSBwb3NzaWJsZSB3aXRoaW4gc2FmZXZhbHVlcy4gSW4gcGFydGljdWxhciwgdGhpcyBwcmV2ZW50c1xuICogZm9yZ2VyeSBzdWNoIGFzIGBzYWZlSHRtbFZhbHVlLmNvbnN0cnVjdG9yKCdqYXZhc2NyaXB0OmV2aWwnKWAuXG4gKi9cbmV4cG9ydCBjb25zdCBzZWNyZXRUb2tlbiA9IHt9O1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gdG9rZW4gbWF0Y2hlcyB0aGUgc2VjcmV0IHNhZmV2YWx1ZXMgdG9rZW4uIEFuXG4gKiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoYXQgaXMgbm90IHRoZSBjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVG9rZW5Jc1ZhbGlkKHRva2VuOiBvYmplY3QpIHtcbiAgaWYgKHRva2VuICE9PSBzZWNyZXRUb2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHNlY3JldCcpO1xuICB9XG59XG4iXX0=
;return exports;});

//javascript/typescript/safevalues/implementation/trusted_types.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/trusted_types.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// BEGIN-INTERNAL
goog.module('google3.javascript.typescript.safevalues.implementation.trusted_types');
var module = module || { id: 'javascript/typescript/safevalues/implementation/trusted_types.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
/**
 * @define {string} The name of the Trusted Types policy used by TS safevalues, or empty
 * to disable Trusted Types.
 */
const TRUSTED_TYPES_POLICY_NAME = goog.define('typescript.safevalues.TRUSTED_TYPES_POLICY_NAME', 'google#safe');
// END-INTERNAL
/**
 * The name of the Trusted Types policy used by TS safevalues, or empty
 * to disable Trusted Types. This duplicates the TRUSTED_TYPES_POLICY_NAME, but
 * can be overridden in tests.
 * @type {string}
 */
let trustedTypesPolicyName = TRUSTED_TYPES_POLICY_NAME;
/**
 * Helper to retrieve the value of `window.trustedTypes`.
 * @return {(undefined|!TrustedTypePolicyFactory)}
 */
function trustedTypes() {
    if (typeof window !== 'undefined') {
        return window.trustedTypes;
    }
    return undefined;
}
/**
 * Returns window.trustedTypes if Trusted Types are enabled and supported, or
 * null otherwise.
 * @return {(null|!TrustedTypePolicyFactory)}
 */
function getTrustedTypes() {
    var _a;
    return (trustedTypesPolicyName !== '') ? ((_a = trustedTypes()) !== null && _a !== void 0 ? _a : null) : null;
}
exports.getTrustedTypes = getTrustedTypes;
/**
 * The Trusted Types policy used by TS safevalues, or null if Trusted Types
 * are not enabled/supported, or undefined if the policy has not been created
 * yet.
 * @type {(undefined|null|!TrustedTypePolicy<!TrustedTypePolicyOptions>)}
 */
let trustedTypesPolicy;
/**
 * Returns the Trusted Types policy used by TS safevalues, or null if Trusted
 * Types are not enabled/supported. The first call to this function will
 * create the policy.
 * @return {(null|!TrustedTypePolicy<!TrustedTypePolicyOptions>)}
 */
function getTrustedTypesPolicy() {
    var _a, _b;
    if (trustedTypesPolicy === undefined) {
        try {
            trustedTypesPolicy =
                (_b = (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.createPolicy(trustedTypesPolicyName, {
                    createHTML: (/**
                     * @param {string} s
                     * @return {string}
                     */
                    (s) => s),
                    createScript: (/**
                     * @param {string} s
                     * @return {string}
                     */
                    (s) => s),
                    createScriptURL: (/**
                     * @param {string} s
                     * @return {string}
                     */
                    (s) => s)
                })) !== null && _b !== void 0 ? _b : null;
        }
        catch (e) {
            // In Chromium versions before 81, trustedTypes.createPolicy throws if
            // called with a name that is already registered, even if no CSP is set.
            // Until users have largely migrated to 81 or above, catch the error not
            // to break the applications functionally. In such case, the code will
            // fall back to using regular Safe Types.
            trustedTypesPolicy = null;
            console.log(e);
        }
    }
    return trustedTypesPolicy;
}
exports.getTrustedTypesPolicy = getTrustedTypesPolicy;
/**
 * Helpers for tests.
 * @type {{resetDefaults: function(): void, setTrustedTypesPolicyName: function(string): void}}
 */
exports.TEST_ONLY = {
    /**
     * @return {void}
     */
    resetDefaults() {
        trustedTypesPolicy = undefined;
        trustedTypesPolicyName = TRUSTED_TYPES_POLICY_NAME;
    },
    /**
     * @param {string} name
     * @return {void}
     */
    setTrustedTypesPolicyName(name) {
        trustedTypesPolicyName = name;
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1c3RlZF90eXBlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3RydXN0ZWRfdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztNQUtNLHlCQUF5QixHQUFXLElBQUksQ0FBQyxNQUFNLENBQ2pELGlEQUFpRCxFQUFFLGFBQWEsQ0FBQzs7Ozs7Ozs7SUFRakUsc0JBQXNCLEdBQUcseUJBQXlCOzs7OztBQUd0RCxTQUFTLFlBQVk7SUFDbkIsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7UUFDakMsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQzs7Ozs7O0FBTUQsU0FBZ0IsZUFBZTs7SUFDN0IsT0FBTyxDQUFDLHNCQUFzQixLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQUEsWUFBWSxFQUFFLG1DQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDM0UsQ0FBQztBQUZELDBDQUVDOzs7Ozs7O0lBT0csa0JBQW9EOzs7Ozs7O0FBT3hELFNBQWdCLHFCQUFxQjs7SUFDbkMsSUFBSSxrQkFBa0IsS0FBSyxTQUFTLEVBQUU7UUFDcEMsSUFBSTtZQUNGLGtCQUFrQjtnQkFDZCxNQUFBLE1BQUEsZUFBZSxFQUFFLDBDQUFFLFlBQVksQ0FBQyxzQkFBc0IsRUFBRTtvQkFDdEQsVUFBVTs7OztvQkFBRSxDQUFDLENBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBO29CQUM1QixZQUFZOzs7O29CQUFFLENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUE7b0JBQzlCLGVBQWU7Ozs7b0JBQUUsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTtpQkFDbEMsQ0FBQyxtQ0FDRixJQUFJLENBQUM7U0FDVjtRQUFDLE9BQU8sQ0FBVSxFQUFFO1lBQ25CLHNFQUFzRTtZQUN0RSx3RUFBd0U7WUFDeEUsd0VBQXdFO1lBQ3hFLHNFQUFzRTtZQUN0RSx5Q0FBeUM7WUFDekMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO1lBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEI7S0FDRjtJQUNELE9BQU8sa0JBQWtCLENBQUM7QUFDNUIsQ0FBQztBQXJCRCxzREFxQkM7Ozs7O0FBR1ksUUFBQSxTQUFTLEdBQUc7Ozs7SUFDdkIsYUFBYTtRQUNYLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztRQUMvQixzQkFBc0IsR0FBRyx5QkFBeUIsQ0FBQztJQUNyRCxDQUFDOzs7OztJQUNELHlCQUF5QixDQUFDLElBQVk7UUFDcEMsc0JBQXNCLEdBQUcsSUFBSSxDQUFDO0lBQ2hDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIEBkZWZpbmUgVGhlIG5hbWUgb2YgdGhlIFRydXN0ZWQgVHlwZXMgcG9saWN5IHVzZWQgYnkgVFMgc2FmZXZhbHVlcywgb3IgZW1wdHlcbiAqIHRvIGRpc2FibGUgVHJ1c3RlZCBUeXBlcy5cbiAqL1xuY29uc3QgVFJVU1RFRF9UWVBFU19QT0xJQ1lfTkFNRTogc3RyaW5nID0gZ29vZy5kZWZpbmUoXG4gICAgJ3R5cGVzY3JpcHQuc2FmZXZhbHVlcy5UUlVTVEVEX1RZUEVTX1BPTElDWV9OQU1FJywgJ2dvb2dsZSNzYWZlJyk7XG4vLyBFTkQtSU5URVJOQUxcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgVHJ1c3RlZCBUeXBlcyBwb2xpY3kgdXNlZCBieSBUUyBzYWZldmFsdWVzLCBvciBlbXB0eVxuICogdG8gZGlzYWJsZSBUcnVzdGVkIFR5cGVzLiBUaGlzIGR1cGxpY2F0ZXMgdGhlIFRSVVNURURfVFlQRVNfUE9MSUNZX05BTUUsIGJ1dFxuICogY2FuIGJlIG92ZXJyaWRkZW4gaW4gdGVzdHMuXG4gKi9cbmxldCB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lID0gVFJVU1RFRF9UWVBFU19QT0xJQ1lfTkFNRTtcblxuLyoqIEhlbHBlciB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb2YgYHdpbmRvdy50cnVzdGVkVHlwZXNgLiAqL1xuZnVuY3Rpb24gdHJ1c3RlZFR5cGVzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93LnRydXN0ZWRUeXBlcztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2luZG93LnRydXN0ZWRUeXBlcyBpZiBUcnVzdGVkIFR5cGVzIGFyZSBlbmFibGVkIGFuZCBzdXBwb3J0ZWQsIG9yXG4gKiBudWxsIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRydXN0ZWRUeXBlcygpOiBUcnVzdGVkVHlwZVBvbGljeUZhY3Rvcnl8bnVsbCB7XG4gIHJldHVybiAodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSAhPT0gJycpID8gKHRydXN0ZWRUeXBlcygpID8/IG51bGwpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgVHJ1c3RlZCBUeXBlcyBwb2xpY3kgdXNlZCBieSBUUyBzYWZldmFsdWVzLCBvciBudWxsIGlmIFRydXN0ZWQgVHlwZXNcbiAqIGFyZSBub3QgZW5hYmxlZC9zdXBwb3J0ZWQsIG9yIHVuZGVmaW5lZCBpZiB0aGUgcG9saWN5IGhhcyBub3QgYmVlbiBjcmVhdGVkXG4gKiB5ZXQuXG4gKi9cbmxldCB0cnVzdGVkVHlwZXNQb2xpY3k6IFRydXN0ZWRUeXBlUG9saWN5fG51bGx8dW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFRydXN0ZWQgVHlwZXMgcG9saWN5IHVzZWQgYnkgVFMgc2FmZXZhbHVlcywgb3IgbnVsbCBpZiBUcnVzdGVkXG4gKiBUeXBlcyBhcmUgbm90IGVuYWJsZWQvc3VwcG9ydGVkLiBUaGUgZmlyc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIGNyZWF0ZSB0aGUgcG9saWN5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJ1c3RlZFR5cGVzUG9saWN5KCk6IFRydXN0ZWRUeXBlUG9saWN5fG51bGwge1xuICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID1cbiAgICAgICAgICBnZXRUcnVzdGVkVHlwZXMoKT8uY3JlYXRlUG9saWN5KHRydXN0ZWRUeXBlc1BvbGljeU5hbWUsIHtcbiAgICAgICAgICAgIGNyZWF0ZUhUTUw6IChzOiBzdHJpbmcpID0+IHMsXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IChzOiBzdHJpbmcpID0+IHMsXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHRVUkw6IChzOiBzdHJpbmcpID0+IHNcbiAgICAgICAgICB9KSA/P1xuICAgICAgICAgIG51bGw7XG4gICAgfSBjYXRjaCAoZTogdW5rbm93bikge1xuICAgICAgLy8gSW4gQ2hyb21pdW0gdmVyc2lvbnMgYmVmb3JlIDgxLCB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5IHRocm93cyBpZlxuICAgICAgLy8gY2FsbGVkIHdpdGggYSBuYW1lIHRoYXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCBldmVuIGlmIG5vIENTUCBpcyBzZXQuXG4gICAgICAvLyBVbnRpbCB1c2VycyBoYXZlIGxhcmdlbHkgbWlncmF0ZWQgdG8gODEgb3IgYWJvdmUsIGNhdGNoIHRoZSBlcnJvciBub3RcbiAgICAgIC8vIHRvIGJyZWFrIHRoZSBhcHBsaWNhdGlvbnMgZnVuY3Rpb25hbGx5LiBJbiBzdWNoIGNhc2UsIHRoZSBjb2RlIHdpbGxcbiAgICAgIC8vIGZhbGwgYmFjayB0byB1c2luZyByZWd1bGFyIFNhZmUgVHlwZXMuXG4gICAgICB0cnVzdGVkVHlwZXNQb2xpY3kgPSBudWxsO1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3k7XG59XG5cbi8qKiBIZWxwZXJzIGZvciB0ZXN0cy4gKi9cbmV4cG9ydCBjb25zdCBURVNUX09OTFkgPSB7XG4gIHJlc2V0RGVmYXVsdHMoKSB7XG4gICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gdW5kZWZpbmVkO1xuICAgIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUgPSBUUlVTVEVEX1RZUEVTX1BPTElDWV9OQU1FO1xuICB9LFxuICBzZXRUcnVzdGVkVHlwZXNQb2xpY3lOYW1lKG5hbWU6IHN0cmluZykge1xuICAgIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUgPSBuYW1lO1xuICB9LFxufTtcbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/implementation/safe_html_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_html_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_html_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_html_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_pure_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.pure");
const tsickle_secrets_2 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const tsickle_trusted_types_3 = goog.requireType("google3.javascript.typescript.safevalues.implementation.trusted_types");
const pure_1 = goog.require('google3.javascript.typescript.safevalues.implementation.pure');
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
const trusted_types_1 = goog.require('google3.javascript.typescript.safevalues.implementation.trusted_types');
// BEGIN-INTERNAL
/**
 * String that is safe to use in HTML contexts in DOM APIs and HTML documents.
 *
 * See http://go/safehtmltypecontracts#safehtml
 * @abstract
 */
class SafeHtml {
}
exports.SafeHtml = SafeHtml;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeHtml.prototype.brand;
}
// END-INTERNAL
/**
 * Implementation for `SafeHtml`
 * @extends {SafeHtml}
 */
class SafeHtmlImpl extends SafeHtml {
    /**
     * @param {(string|!TrustedHTML)} html
     * @param {!Object} token
     */
    constructor(html, token) {
        super(); // LINE-INTERNAL
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedHtml = html;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedHtml.toString();
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {(string|!TrustedHTML)} */
    SafeHtmlImpl.prototype.privateDoNotAccessOrElseWrappedHtml;
}
/**
 * @param {string} html
 * @param {(undefined|!TrustedHTML)=} trusted
 * @return {!SafeHtml}
 */
function createSafeHtmlInternal(html, trusted) {
    // BEGIN-INTERNAL
    return new SafeHtmlImpl(trusted !== null && trusted !== void 0 ? trusted : html, secrets_1.secretToken);
    // END-INTERNAL
    // BEGIN-EXTERNAL
    // return (trusted ?? new SafeHtmlImpl(html, secretToken)) as SafeHtml;
    // END-EXTERNAL
}
/**
 * Builds a new `SafeHtml` from the given string, without enforcing safety
 * guarantees. It may cause side effects by creating a Trusted Types policy.
 * This shouldn't be exposed to application developers, and must only be used as
 * a step towards safe builders or safe constants.
 * @param {string} html
 * @return {!SafeHtml}
 */
function createSafeHtml(html) {
    var _a;
    /**
     * @noinline
     * @type {string}
     */
    const noinlineHtml = html;
    return createSafeHtmlInternal(noinlineHtml, (_a = trusted_types_1.getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(noinlineHtml));
}
exports.createSafeHtml = createSafeHtml;
/**
 * An empty `SafeHtml` constant.
 * Unlike the function above, using this will not create a policy.
 * @type {!SafeHtml}
 */
exports.EMPTY_HTML = pure_1.pure((/**
 * @return {!SafeHtml}
 */
() => { var _a; return createSafeHtmlInternal('', (_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyHTML); }));
/**
 * Returns the value of the passed `SafeHtml` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedHTML` or a string if Trusted Types are disabled.
 *
 * The strange return type is to ensure the value can be used at sinks without a
 * cast despite the TypeScript DOM lib not supporting Trusted Types.
 * (https://github.com/microsoft/TypeScript/issues/30024)
 *
 * Note that while the return type is compatible with `string`, you shouldn't
 * use any string functions on the result as that will fail in browsers
 * supporting Trusted Types.
 * @param {!SafeHtml} value
 * @return {?}
 */
function unwrapTrustedHTML(value) {
    var _a;
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isHTML(value)) {
        return (/** @type {?} */ (value));
    }
    else if (value instanceof SafeHtmlImpl) {
        /** @type {(string|!TrustedHTML)} */
        const unwrapped = value.privateDoNotAccessOrElseWrappedHtml;
        return (/** @type {?} */ (unwrapped));
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapTrustedHTML = unwrapTrustedHTML;
/**
 * Same as `unwrapTrustedHTML`, but returns an actual string.
 *
 * Also ensures to return the right string value for `TrustedHTML` objects if
 * the `toString` function has been overwritten on the object.
 * @param {!SafeHtml} value
 * @return {string}
 */
function unwrapSafeHtmlAsString(value) {
    var _a;
    /** @type {?} */
    const unwrapped = unwrapTrustedHTML(value);
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isHTML(unwrapped)) {
        // TODO: Remove once the spec freezes instances of `TrustedHTML`.
        return TrustedHTML.prototype.toString.apply(unwrapped);
    }
    else {
        return unwrapped;
    }
}
exports.unwrapSafeHtmlAsString = unwrapSafeHtmlAsString;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9odG1sX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3R5cGVzY3JpcHQvc2FmZXZhbHVlcy9pbXBsZW1lbnRhdGlvbi9zYWZlX2h0bWxfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDRGQUE0QjtBQUM1QixrR0FBMEQ7QUFDMUQsOEdBQXVFOzs7Ozs7OztBQVF2RSxNQUFzQixRQUFRO0NBRzdCO0FBSEQsNEJBR0M7Ozs7Ozs7SUFEQyx5QkFBK0I7Ozs7Ozs7QUFLakMsTUFBTSxZQUFhLFNBQVEsUUFBUTs7Ozs7SUFHakMsWUFBWSxJQUF3QixFQUFFLEtBQWE7UUFDakQsS0FBSyxFQUFFLENBQUMsQ0FBRSxnQkFBZ0I7UUFDMUIsNEJBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLG1DQUFtQyxHQUFHLElBQUksQ0FBQztJQUNsRCxDQUFDOzs7OztJQUdELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3RCxDQUFDO0NBQ0Y7Ozs7SUFaQywyREFBaUU7Ozs7Ozs7QUFjbkUsU0FBUyxzQkFBc0IsQ0FBQyxJQUFZLEVBQUUsT0FBcUI7SUFDakUsaUJBQWlCO0lBQ2pCLE9BQU8sSUFBSSxZQUFZLENBQUMsT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksSUFBSSxFQUFFLHFCQUFXLENBQUMsQ0FBQztJQUN0RCxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLHVFQUF1RTtJQUN2RSxlQUFlO0FBQ2pCLENBQUM7Ozs7Ozs7OztBQVFELFNBQWdCLGNBQWMsQ0FBQyxJQUFZOzs7Ozs7VUFFbkMsWUFBWSxHQUFHLElBQUk7SUFDekIsT0FBTyxzQkFBc0IsQ0FDekIsWUFBWSxFQUFFLE1BQUEscUNBQXFCLEVBQUUsMENBQUUsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUxELHdDQUtDOzs7Ozs7QUFNWSxRQUFBLFVBQVUsR0FDbkIsV0FBSTs7O0FBQUMsR0FBRyxFQUFFLFdBQUMsT0FBQSxzQkFBc0IsQ0FBQyxFQUFFLEVBQUUsTUFBQSwrQkFBZSxFQUFFLDBDQUFFLFNBQVMsQ0FBQyxDQUFBLEVBQUEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQnhFLFNBQWdCLGlCQUFpQixDQUFDLEtBQWU7O0lBQy9DLElBQUksTUFBQSwrQkFBZSxFQUFFLDBDQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNwQyxPQUFPLG1CQUFBLEtBQUssRUFBd0IsQ0FBQztLQUN0QztTQUFNLElBQUksS0FBSyxZQUFZLFlBQVksRUFBRTs7Y0FDbEMsU0FBUyxHQUFHLEtBQUssQ0FBQyxtQ0FBbUM7UUFDM0QsT0FBTyxtQkFBQSxTQUFTLEVBQXdCLENBQUM7S0FDMUM7U0FBTTtRQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDL0I7QUFDSCxDQUFDO0FBVEQsOENBU0M7Ozs7Ozs7OztBQVFELFNBQWdCLHNCQUFzQixDQUFDLEtBQWU7OztVQUM5QyxTQUFTLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDO0lBQzFDLElBQUksTUFBQSwrQkFBZSxFQUFFLDBDQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUN4QyxpRUFBaUU7UUFDakUsT0FBTyxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDeEQ7U0FBTTtRQUNMLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQVJELHdEQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwdXJlfSBmcm9tICcuL3B1cmUnO1xuaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuaW1wb3J0IHtnZXRUcnVzdGVkVHlwZXMsIGdldFRydXN0ZWRUeXBlc1BvbGljeX0gZnJvbSAnLi90cnVzdGVkX3R5cGVzJztcblxuLy8gQkVHSU4tSU5URVJOQUxcbi8qKlxuICogU3RyaW5nIHRoYXQgaXMgc2FmZSB0byB1c2UgaW4gSFRNTCBjb250ZXh0cyBpbiBET00gQVBJcyBhbmQgSFRNTCBkb2N1bWVudHMuXG4gKlxuICogU2VlIGh0dHA6Ly9nby9zYWZlaHRtbHR5cGVjb250cmFjdHMjc2FmZWh0bWxcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNhZmVIdG1sIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuICBwcml2YXRlIHJlYWRvbmx5IGJyYW5kPzogbmV2ZXI7ICAvLyBUbyBwcmV2ZW50IHN0cnVjdHVyYWwgdHlwaW5nLlxufVxuLy8gRU5ELUlOVEVSTkFMXG5cbi8qKiBJbXBsZW1lbnRhdGlvbiBmb3IgYFNhZmVIdG1sYCAqL1xuY2xhc3MgU2FmZUh0bWxJbXBsIGV4dGVuZHMgU2FmZUh0bWwge1xuICByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkSHRtbDogVHJ1c3RlZEhUTUx8c3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGh0bWw6IFRydXN0ZWRIVE1MfHN0cmluZywgdG9rZW46IG9iamVjdCkge1xuICAgIHN1cGVyKCk7ICAvLyBMSU5FLUlOVEVSTkFMXG4gICAgZW5zdXJlVG9rZW5Jc1ZhbGlkKHRva2VuKTtcbiAgICB0aGlzLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRIdG1sID0gaHRtbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkSHRtbC50b1N0cmluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNhZmVIdG1sSW50ZXJuYWwoaHRtbDogc3RyaW5nLCB0cnVzdGVkPzogVHJ1c3RlZEhUTUwpOiBTYWZlSHRtbCB7XG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIHJldHVybiBuZXcgU2FmZUh0bWxJbXBsKHRydXN0ZWQgPz8gaHRtbCwgc2VjcmV0VG9rZW4pO1xuICAvLyBFTkQtSU5URVJOQUxcbiAgLy8gQkVHSU4tRVhURVJOQUxcbiAgLy8gcmV0dXJuICh0cnVzdGVkID8/IG5ldyBTYWZlSHRtbEltcGwoaHRtbCwgc2VjcmV0VG9rZW4pKSBhcyBTYWZlSHRtbDtcbiAgLy8gRU5ELUVYVEVSTkFMXG59XG5cbi8qKlxuICogQnVpbGRzIGEgbmV3IGBTYWZlSHRtbGAgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCB3aXRob3V0IGVuZm9yY2luZyBzYWZldHlcbiAqIGd1YXJhbnRlZXMuIEl0IG1heSBjYXVzZSBzaWRlIGVmZmVjdHMgYnkgY3JlYXRpbmcgYSBUcnVzdGVkIFR5cGVzIHBvbGljeS5cbiAqIFRoaXMgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8gYXBwbGljYXRpb24gZGV2ZWxvcGVycywgYW5kIG11c3Qgb25seSBiZSB1c2VkIGFzXG4gKiBhIHN0ZXAgdG93YXJkcyBzYWZlIGJ1aWxkZXJzIG9yIHNhZmUgY29uc3RhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZUh0bWwoaHRtbDogc3RyaW5nKTogU2FmZUh0bWwge1xuICAvKiogQG5vaW5saW5lICovXG4gIGNvbnN0IG5vaW5saW5lSHRtbCA9IGh0bWw7XG4gIHJldHVybiBjcmVhdGVTYWZlSHRtbEludGVybmFsKFxuICAgICAgbm9pbmxpbmVIdG1sLCBnZXRUcnVzdGVkVHlwZXNQb2xpY3koKT8uY3JlYXRlSFRNTChub2lubGluZUh0bWwpKTtcbn1cblxuLyoqXG4gKiBBbiBlbXB0eSBgU2FmZUh0bWxgIGNvbnN0YW50LlxuICogVW5saWtlIHRoZSBmdW5jdGlvbiBhYm92ZSwgdXNpbmcgdGhpcyB3aWxsIG5vdCBjcmVhdGUgYSBwb2xpY3kuXG4gKi9cbmV4cG9ydCBjb25zdCBFTVBUWV9IVE1MOiBTYWZlSHRtbCA9XG4gICAgcHVyZSgoKSA9PiBjcmVhdGVTYWZlSHRtbEludGVybmFsKCcnLCBnZXRUcnVzdGVkVHlwZXMoKT8uZW1wdHlIVE1MKSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHBhc3NlZCBgU2FmZUh0bWxgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKlxuICogUmV0dXJucyBhIG5hdGl2ZSBgVHJ1c3RlZEhUTUxgIG9yIGEgc3RyaW5nIGlmIFRydXN0ZWQgVHlwZXMgYXJlIGRpc2FibGVkLlxuICpcbiAqIFRoZSBzdHJhbmdlIHJldHVybiB0eXBlIGlzIHRvIGVuc3VyZSB0aGUgdmFsdWUgY2FuIGJlIHVzZWQgYXQgc2lua3Mgd2l0aG91dCBhXG4gKiBjYXN0IGRlc3BpdGUgdGhlIFR5cGVTY3JpcHQgRE9NIGxpYiBub3Qgc3VwcG9ydGluZyBUcnVzdGVkIFR5cGVzLlxuICogKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzAwMjQpXG4gKlxuICogTm90ZSB0aGF0IHdoaWxlIHRoZSByZXR1cm4gdHlwZSBpcyBjb21wYXRpYmxlIHdpdGggYHN0cmluZ2AsIHlvdSBzaG91bGRuJ3RcbiAqIHVzZSBhbnkgc3RyaW5nIGZ1bmN0aW9ucyBvbiB0aGUgcmVzdWx0IGFzIHRoYXQgd2lsbCBmYWlsIGluIGJyb3dzZXJzXG4gKiBzdXBwb3J0aW5nIFRydXN0ZWQgVHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBUcnVzdGVkSFRNTCh2YWx1ZTogU2FmZUh0bWwpOiBUcnVzdGVkSFRNTCZzdHJpbmcge1xuICBpZiAoZ2V0VHJ1c3RlZFR5cGVzKCk/LmlzSFRNTCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgYXMgVHJ1c3RlZEhUTUwgJiBzdHJpbmc7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlSHRtbEltcGwpIHtcbiAgICBjb25zdCB1bndyYXBwZWQgPSB2YWx1ZS5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkSHRtbDtcbiAgICByZXR1cm4gdW53cmFwcGVkIGFzIFRydXN0ZWRIVE1MICYgc3RyaW5nO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgdHlwZScpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgdW53cmFwVHJ1c3RlZEhUTUxgLCBidXQgcmV0dXJucyBhbiBhY3R1YWwgc3RyaW5nLlxuICpcbiAqIEFsc28gZW5zdXJlcyB0byByZXR1cm4gdGhlIHJpZ2h0IHN0cmluZyB2YWx1ZSBmb3IgYFRydXN0ZWRIVE1MYCBvYmplY3RzIGlmXG4gKiB0aGUgYHRvU3RyaW5nYCBmdW5jdGlvbiBoYXMgYmVlbiBvdmVyd3JpdHRlbiBvbiB0aGUgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwU2FmZUh0bWxBc1N0cmluZyh2YWx1ZTogU2FmZUh0bWwpOiBzdHJpbmcge1xuICBjb25zdCB1bndyYXBwZWQgPSB1bndyYXBUcnVzdGVkSFRNTCh2YWx1ZSk7XG4gIGlmIChnZXRUcnVzdGVkVHlwZXMoKT8uaXNIVE1MKHVud3JhcHBlZCkpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSB0aGUgc3BlYyBmcmVlemVzIGluc3RhbmNlcyBvZiBgVHJ1c3RlZEhUTUxgLlxuICAgIHJldHVybiBUcnVzdGVkSFRNTC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodW53cmFwcGVkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW53cmFwcGVkO1xuICB9XG59XG4iXX0=
;return exports;});

//javascript/typescript/safevalues/safe_html.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/safe_html.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_html');
var module = module || { id: 'javascript/typescript/safevalues/safe_html.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_html_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_html_impl");
/** Reexport the public type (but not the Impl). */
const safe_html_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_html_impl');
exports.EMPTY_HTML = safe_html_impl_1.EMPTY_HTML;
exports.SafeHtml = safe_html_impl_1.SafeHtml;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9odG1sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vamF2YXNjcmlwdC90eXBlc2NyaXB0L3NhZmV2YWx1ZXMvc2FmZV9odG1sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSxnSEFBcUU7QUFBN0Qsc0NBQUEsVUFBVSxDQUFBO0FBQUUsb0NBQUEsUUFBUSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIFJlZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSAoYnV0IG5vdCB0aGUgSW1wbCkuICovXG5leHBvcnQge0VNUFRZX0hUTUwsIFNhZmVIdG1sfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3NhZmVfaHRtbF9pbXBsJztcbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/implementation/safe_script_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_script_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_script_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_script_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_pure_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.pure");
const tsickle_secrets_2 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const tsickle_trusted_types_3 = goog.requireType("google3.javascript.typescript.safevalues.implementation.trusted_types");
const pure_1 = goog.require('google3.javascript.typescript.safevalues.implementation.pure');
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
const trusted_types_1 = goog.require('google3.javascript.typescript.safevalues.implementation.trusted_types');
// BEGIN-INTERNAL
/**
 * JavaScript code that is safe to evaluate and use as the content of an HTML
 * script element.
 *
 * See http://go/safehtmltypecontracts#safescript
 * @abstract
 */
class SafeScript {
}
exports.SafeScript = SafeScript;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeScript.prototype.brand;
}
// END-INTERNAL
/**
 * Implementation for `SafeScript`
 * @extends {SafeScript}
 */
class SafeScriptImpl extends SafeScript {
    /**
     * @param {(string|!TrustedScript)} script
     * @param {!Object} token
     */
    constructor(script, token) {
        super(); // LINE-INTERNAL
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedScript = script;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedScript.toString();
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {(string|!TrustedScript)} */
    SafeScriptImpl.prototype.privateDoNotAccessOrElseWrappedScript;
}
/**
 * @param {string} script
 * @param {(undefined|!TrustedScript)=} trusted
 * @return {!SafeScript}
 */
function createSafeScriptInternal(script, trusted) {
    // BEGIN-INTERNAL
    return new SafeScriptImpl(trusted !== null && trusted !== void 0 ? trusted : script, secrets_1.secretToken);
    // END-INTERNAL
    // BEGIN-EXTERNAL
    // return (trusted ?? new SafeScriptImpl(script, secretToken)) as SafeScript;
    // END-EXTERNAL
}
/**
 * Builds a new `SafeScript` from the given string, without enforcing
 * safety guarantees. It may cause side effects by creating a Trusted Types
 * policy. This shouldn't be exposed to application developers, and must only be
 * used as a step towards safe builders or safe constants.
 * @param {string} script
 * @return {!SafeScript}
 */
function createSafeScript(script) {
    var _a;
    /**
     * @noinline
     * @type {string}
     */
    const noinlineScript = script;
    return createSafeScriptInternal(noinlineScript, (_a = trusted_types_1.getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(noinlineScript));
}
exports.createSafeScript = createSafeScript;
/**
 * An empty `SafeScript` constant.
 * Unlike the functions above, using this will not create a policy.
 * @type {!SafeScript}
 */
exports.EMPTY_SCRIPT = pure_1.pure((/**
 * @return {!SafeScript}
 */
() => { var _a; return createSafeScriptInternal('', (_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyScript); }));
/**
 * Returns the value of the passed `SafeScript` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedScript` or a string if Trusted Types are disabled.
 *
 * The strange return type is to ensure the value can be used at sinks without a
 * cast despite the TypeScript DOM lib not supporting Trusted Types.
 * (https://github.com/microsoft/TypeScript/issues/30024)
 *
 * Note that while the return type is compatible with `string`, you shouldn't
 * use any string functions on the result as that will fail in browsers
 * supporting Trusted Types.
 * @param {!SafeScript} value
 * @return {?}
 */
function unwrapTrustedScript(value) {
    var _a;
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScript(value)) {
        return (/** @type {?} */ (value));
    }
    else if (value instanceof SafeScriptImpl) {
        /** @type {(string|!TrustedScript)} */
        const unwrapped = value.privateDoNotAccessOrElseWrappedScript;
        return (/** @type {?} */ (unwrapped));
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapTrustedScript = unwrapTrustedScript;
/**
 * Same as `unwrapTrustedScript`, but returns an actual string
 *
 * Also ensures to return the right string value for `TrustedScript` objects if
 * the `toString function has been overwritten on the object.
 * @param {!SafeScript} value
 * @return {string}
 */
function unwrapSafeScriptAsString(value) {
    var _a;
    /** @type {?} */
    const unwrapped = unwrapTrustedScript(value);
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScript(unwrapped)) {
        // TODO: Remove once the spec freezes instances of `TrustedScript`.
        return TrustedScript.prototype.toString.apply(unwrapped);
    }
    else {
        return unwrapped;
    }
}
exports.unwrapSafeScriptAsString = unwrapSafeScriptAsString;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zY3JpcHRfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3NhZmVfc2NyaXB0X2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSw0RkFBNEI7QUFDNUIsa0dBQTBEO0FBQzFELDhHQUF1RTs7Ozs7Ozs7O0FBU3ZFLE1BQXNCLFVBQVU7Q0FHL0I7QUFIRCxnQ0FHQzs7Ozs7OztJQURDLDJCQUErQjs7Ozs7OztBQUtqQyxNQUFNLGNBQWUsU0FBUSxVQUFVOzs7OztJQUdyQyxZQUFZLE1BQTRCLEVBQUUsS0FBYTtRQUNyRCxLQUFLLEVBQUUsQ0FBQyxDQUFFLGdCQUFnQjtRQUMxQiw0QkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMscUNBQXFDLEdBQUcsTUFBTSxDQUFDO0lBQ3RELENBQUM7Ozs7O0lBR0QsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLHFDQUFxQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9ELENBQUM7Q0FDRjs7OztJQVpDLCtEQUFxRTs7Ozs7OztBQWN2RSxTQUFTLHdCQUF3QixDQUM3QixNQUFjLEVBQUUsT0FBdUI7SUFDekMsaUJBQWlCO0lBQ2pCLE9BQU8sSUFBSSxjQUFjLENBQUMsT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksTUFBTSxFQUFFLHFCQUFXLENBQUMsQ0FBQztJQUMxRCxlQUFlO0lBQ2YsaUJBQWlCO0lBQ2pCLDZFQUE2RTtJQUM3RSxlQUFlO0FBQ2pCLENBQUM7Ozs7Ozs7OztBQVFELFNBQWdCLGdCQUFnQixDQUFDLE1BQWM7Ozs7OztVQUV2QyxjQUFjLEdBQUcsTUFBTTtJQUM3QixPQUFPLHdCQUF3QixDQUMzQixjQUFjLEVBQUUsTUFBQSxxQ0FBcUIsRUFBRSwwQ0FBRSxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztBQUM3RSxDQUFDO0FBTEQsNENBS0M7Ozs7OztBQU1ZLFFBQUEsWUFBWSxHQUNyQixXQUFJOzs7QUFBQyxHQUFHLEVBQUUsV0FBQyxPQUFBLHdCQUF3QixDQUFDLEVBQUUsRUFBRSxNQUFBLCtCQUFlLEVBQUUsMENBQUUsV0FBVyxDQUFDLENBQUEsRUFBQSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCNUUsU0FBZ0IsbUJBQW1CLENBQUMsS0FBaUI7O0lBQ25ELElBQUksTUFBQSwrQkFBZSxFQUFFLDBDQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN0QyxPQUFPLG1CQUFBLEtBQUssRUFBMEIsQ0FBQztLQUN4QztTQUFNLElBQUksS0FBSyxZQUFZLGNBQWMsRUFBRTs7Y0FDcEMsU0FBUyxHQUFHLEtBQUssQ0FBQyxxQ0FBcUM7UUFDN0QsT0FBTyxtQkFBQSxTQUFTLEVBQTBCLENBQUM7S0FDNUM7U0FBTTtRQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDL0I7QUFDSCxDQUFDO0FBVEQsa0RBU0M7Ozs7Ozs7OztBQVFELFNBQWdCLHdCQUF3QixDQUFDLEtBQWlCOzs7VUFDbEQsU0FBUyxHQUFHLG1CQUFtQixDQUFDLEtBQUssQ0FBQztJQUM1QyxJQUFJLE1BQUEsK0JBQWUsRUFBRSwwQ0FBRSxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDMUMsbUVBQW1FO1FBQ25FLE9BQU8sYUFBYSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzFEO1NBQU07UUFDTCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFSRCw0REFRQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cHVyZX0gZnJvbSAnLi9wdXJlJztcbmltcG9ydCB7ZW5zdXJlVG9rZW5Jc1ZhbGlkLCBzZWNyZXRUb2tlbn0gZnJvbSAnLi9zZWNyZXRzJztcbmltcG9ydCB7Z2V0VHJ1c3RlZFR5cGVzLCBnZXRUcnVzdGVkVHlwZXNQb2xpY3l9IGZyb20gJy4vdHJ1c3RlZF90eXBlcyc7XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIEphdmFTY3JpcHQgY29kZSB0aGF0IGlzIHNhZmUgdG8gZXZhbHVhdGUgYW5kIHVzZSBhcyB0aGUgY29udGVudCBvZiBhbiBIVE1MXG4gKiBzY3JpcHQgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cDovL2dvL3NhZmVodG1sdHlwZWNvbnRyYWN0cyNzYWZlc2NyaXB0XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTYWZlU2NyaXB0IHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuICBwcml2YXRlIHJlYWRvbmx5IGJyYW5kPzogbmV2ZXI7ICAvLyBUbyBwcmV2ZW50IHN0cnVjdHVyYWwgdHlwaW5nLlxufVxuLy8gRU5ELUlOVEVSTkFMXG5cbi8qKiBJbXBsZW1lbnRhdGlvbiBmb3IgYFNhZmVTY3JpcHRgICovXG5jbGFzcyBTYWZlU2NyaXB0SW1wbCBleHRlbmRzIFNhZmVTY3JpcHQge1xuICByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU2NyaXB0OiBUcnVzdGVkU2NyaXB0fHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzY3JpcHQ6IFRydXN0ZWRTY3JpcHR8c3RyaW5nLCB0b2tlbjogb2JqZWN0KSB7XG4gICAgc3VwZXIoKTsgIC8vIExJTkUtSU5URVJOQUxcbiAgICBlbnN1cmVUb2tlbklzVmFsaWQodG9rZW4pO1xuICAgIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFNjcmlwdCA9IHNjcmlwdDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU2NyaXB0LnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU2FmZVNjcmlwdEludGVybmFsKFxuICAgIHNjcmlwdDogc3RyaW5nLCB0cnVzdGVkPzogVHJ1c3RlZFNjcmlwdCk6IFNhZmVTY3JpcHQge1xuICAvLyBCRUdJTi1JTlRFUk5BTFxuICByZXR1cm4gbmV3IFNhZmVTY3JpcHRJbXBsKHRydXN0ZWQgPz8gc2NyaXB0LCBzZWNyZXRUb2tlbik7XG4gIC8vIEVORC1JTlRFUk5BTFxuICAvLyBCRUdJTi1FWFRFUk5BTFxuICAvLyByZXR1cm4gKHRydXN0ZWQgPz8gbmV3IFNhZmVTY3JpcHRJbXBsKHNjcmlwdCwgc2VjcmV0VG9rZW4pKSBhcyBTYWZlU2NyaXB0O1xuICAvLyBFTkQtRVhURVJOQUxcbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBuZXcgYFNhZmVTY3JpcHRgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBJdCBtYXkgY2F1c2Ugc2lkZSBlZmZlY3RzIGJ5IGNyZWF0aW5nIGEgVHJ1c3RlZCBUeXBlc1xuICogcG9saWN5LiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZCBtdXN0IG9ubHkgYmVcbiAqIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVTY3JpcHQoc2NyaXB0OiBzdHJpbmcpOiBTYWZlU2NyaXB0IHtcbiAgLyoqIEBub2lubGluZSAqL1xuICBjb25zdCBub2lubGluZVNjcmlwdCA9IHNjcmlwdDtcbiAgcmV0dXJuIGNyZWF0ZVNhZmVTY3JpcHRJbnRlcm5hbChcbiAgICAgIG5vaW5saW5lU2NyaXB0LCBnZXRUcnVzdGVkVHlwZXNQb2xpY3koKT8uY3JlYXRlU2NyaXB0KG5vaW5saW5lU2NyaXB0KSk7XG59XG5cbi8qKlxuICogQW4gZW1wdHkgYFNhZmVTY3JpcHRgIGNvbnN0YW50LlxuICogVW5saWtlIHRoZSBmdW5jdGlvbnMgYWJvdmUsIHVzaW5nIHRoaXMgd2lsbCBub3QgY3JlYXRlIGEgcG9saWN5LlxuICovXG5leHBvcnQgY29uc3QgRU1QVFlfU0NSSVBUOiBTYWZlU2NyaXB0ID1cbiAgICBwdXJlKCgpID0+IGNyZWF0ZVNhZmVTY3JpcHRJbnRlcm5hbCgnJywgZ2V0VHJ1c3RlZFR5cGVzKCk/LmVtcHR5U2NyaXB0KSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHBhc3NlZCBgU2FmZVNjcmlwdGAgb2JqZWN0IHdoaWxlIGVuc3VyaW5nIGl0XG4gKiBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqXG4gKiBSZXR1cm5zIGEgbmF0aXZlIGBUcnVzdGVkU2NyaXB0YCBvciBhIHN0cmluZyBpZiBUcnVzdGVkIFR5cGVzIGFyZSBkaXNhYmxlZC5cbiAqXG4gKiBUaGUgc3RyYW5nZSByZXR1cm4gdHlwZSBpcyB0byBlbnN1cmUgdGhlIHZhbHVlIGNhbiBiZSB1c2VkIGF0IHNpbmtzIHdpdGhvdXQgYVxuICogY2FzdCBkZXNwaXRlIHRoZSBUeXBlU2NyaXB0IERPTSBsaWIgbm90IHN1cHBvcnRpbmcgVHJ1c3RlZCBUeXBlcy5cbiAqIChodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMwMDI0KVxuICpcbiAqIE5vdGUgdGhhdCB3aGlsZSB0aGUgcmV0dXJuIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIGBzdHJpbmdgLCB5b3Ugc2hvdWxkbid0XG4gKiB1c2UgYW55IHN0cmluZyBmdW5jdGlvbnMgb24gdGhlIHJlc3VsdCBhcyB0aGF0IHdpbGwgZmFpbCBpbiBicm93c2Vyc1xuICogc3VwcG9ydGluZyBUcnVzdGVkIFR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwVHJ1c3RlZFNjcmlwdCh2YWx1ZTogU2FmZVNjcmlwdCk6IFRydXN0ZWRTY3JpcHQmc3RyaW5nIHtcbiAgaWYgKGdldFRydXN0ZWRUeXBlcygpPy5pc1NjcmlwdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgYXMgVHJ1c3RlZFNjcmlwdCAmIHN0cmluZztcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTY3JpcHRJbXBsKSB7XG4gICAgY29uc3QgdW53cmFwcGVkID0gdmFsdWUucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFNjcmlwdDtcbiAgICByZXR1cm4gdW53cmFwcGVkIGFzIFRydXN0ZWRTY3JpcHQgJiBzdHJpbmc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyB0eXBlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGB1bndyYXBUcnVzdGVkU2NyaXB0YCwgYnV0IHJldHVybnMgYW4gYWN0dWFsIHN0cmluZ1xuICpcbiAqIEFsc28gZW5zdXJlcyB0byByZXR1cm4gdGhlIHJpZ2h0IHN0cmluZyB2YWx1ZSBmb3IgYFRydXN0ZWRTY3JpcHRgIG9iamVjdHMgaWZcbiAqIHRoZSBgdG9TdHJpbmcgZnVuY3Rpb24gaGFzIGJlZW4gb3ZlcndyaXR0ZW4gb24gdGhlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFNhZmVTY3JpcHRBc1N0cmluZyh2YWx1ZTogU2FmZVNjcmlwdCk6IHN0cmluZyB7XG4gIGNvbnN0IHVud3JhcHBlZCA9IHVud3JhcFRydXN0ZWRTY3JpcHQodmFsdWUpO1xuICBpZiAoZ2V0VHJ1c3RlZFR5cGVzKCk/LmlzU2NyaXB0KHVud3JhcHBlZCkpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSB0aGUgc3BlYyBmcmVlemVzIGluc3RhbmNlcyBvZiBgVHJ1c3RlZFNjcmlwdGAuXG4gICAgcmV0dXJuIFRydXN0ZWRTY3JpcHQucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHVud3JhcHBlZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVud3JhcHBlZDtcbiAgfVxufVxuIl19
;return exports;});

//javascript/typescript/safevalues/safe_script.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/safe_script.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_script');
var module = module || { id: 'javascript/typescript/safevalues/safe_script.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_script_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_script_impl");
/** Reexport the public type (but not the Impl). */
const safe_script_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_script_impl');
exports.EMPTY_SCRIPT = safe_script_impl_1.EMPTY_SCRIPT;
exports.SafeScript = safe_script_impl_1.SafeScript;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zY3JpcHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3R5cGVzY3JpcHQvc2FmZXZhbHVlcy9zYWZlX3NjcmlwdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esb0hBQTJFO0FBQW5FLDBDQUFBLFlBQVksQ0FBQTtBQUFFLHdDQUFBLFVBQVUsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBSZWV4cG9ydCB0aGUgcHVibGljIHR5cGUgKGJ1dCBub3QgdGhlIEltcGwpLiAqL1xuZXhwb3J0IHtFTVBUWV9TQ1JJUFQsIFNhZmVTY3JpcHR9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vc2FmZV9zY3JpcHRfaW1wbCc7XG4iXX0=
;return exports;});

//javascript/typescript/safevalues/implementation/safe_style_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_style_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_style_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_style_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_secrets_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
/**
 * Sequence of CSS declarations safe to use in style contexts in an HTML
 * document or in DOM APIs.
 *
 * See http://go/safehtmltypecontracts#safestyle
 * @abstract
 */
class SafeStyle {
}
exports.SafeStyle = SafeStyle;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeStyle.prototype.brand;
}
/**
 * Implementation for `SafeStyle`
 * @extends {SafeStyle}
 */
class SafeStyleImpl extends SafeStyle {
    /**
     * @param {string} style
     * @param {!Object} token
     */
    constructor(style, token) {
        super();
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedStyle = style;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedStyle;
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {string} */
    SafeStyleImpl.prototype.privateDoNotAccessOrElseWrappedStyle;
}
/**
 * Builds a new `SafeStyle` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} style
 * @return {!SafeStyle}
 */
function createSafeStyle(style) {
    return new SafeStyleImpl(style, secrets_1.secretToken);
}
exports.createSafeStyle = createSafeStyle;
/**
 * Returns the string value of the passed `SafeStyle` object while ensuring it
 * has the correct type.
 * @param {!SafeStyle} value
 * @return {string}
 */
function unwrapSafeStyle(value) {
    if (value instanceof SafeStyleImpl) {
        return value.privateDoNotAccessOrElseWrappedStyle;
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapSafeStyle = unwrapSafeStyle;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zdHlsZV9pbXBsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF2YXNjcmlwdC90eXBlc2NyaXB0L3NhZmV2YWx1ZXMvaW1wbGVtZW50YXRpb24vc2FmZV9zdHlsZV9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGtHQUEwRDs7Ozs7Ozs7QUFRMUQsTUFBc0IsU0FBUztDQUc5QjtBQUhELDhCQUdDOzs7Ozs7O0lBREMsMEJBQStCOzs7Ozs7QUFJakMsTUFBTSxhQUFjLFNBQVEsU0FBUzs7Ozs7SUFHbkMsWUFBWSxLQUFhLEVBQUUsS0FBYTtRQUN0QyxLQUFLLEVBQUUsQ0FBQztRQUNSLDRCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxvQ0FBb0MsR0FBRyxLQUFLLENBQUM7SUFDcEQsQ0FBQzs7Ozs7SUFHRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsb0NBQW9DLENBQUM7SUFDbkQsQ0FBQztDQUNGOzs7O0lBWkMsNkRBQXNEOzs7Ozs7Ozs7QUFtQnhELFNBQWdCLGVBQWUsQ0FBQyxLQUFhO0lBQzNDLE9BQU8sSUFBSSxhQUFhLENBQUMsS0FBSyxFQUFFLHFCQUFXLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRkQsMENBRUM7Ozs7Ozs7QUFNRCxTQUFnQixlQUFlLENBQUMsS0FBZ0I7SUFDOUMsSUFBSSxLQUFLLFlBQVksYUFBYSxFQUFFO1FBQ2xDLE9BQU8sS0FBSyxDQUFDLG9DQUFvQyxDQUFDO0tBQ25EO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQU5ELDBDQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuXG4vKipcbiAqIFNlcXVlbmNlIG9mIENTUyBkZWNsYXJhdGlvbnMgc2FmZSB0byB1c2UgaW4gc3R5bGUgY29udGV4dHMgaW4gYW4gSFRNTFxuICogZG9jdW1lbnQgb3IgaW4gRE9NIEFQSXMuXG4gKlxuICogU2VlIGh0dHA6Ly9nby9zYWZlaHRtbHR5cGVjb250cmFjdHMjc2FmZXN0eWxlXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTYWZlU3R5bGUge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG4gIHByaXZhdGUgcmVhZG9ubHkgYnJhbmQ/OiBuZXZlcjsgIC8vIFRvIHByZXZlbnQgc3RydWN0dXJhbCB0eXBpbmcuXG59XG5cbi8qKiBJbXBsZW1lbnRhdGlvbiBmb3IgYFNhZmVTdHlsZWAgKi9cbmNsYXNzIFNhZmVTdHlsZUltcGwgZXh0ZW5kcyBTYWZlU3R5bGUge1xuICByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU3R5bGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzdHlsZTogc3RyaW5nLCB0b2tlbjogb2JqZWN0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBlbnN1cmVUb2tlbklzVmFsaWQodG9rZW4pO1xuICAgIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFN0eWxlID0gc3R5bGU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFN0eWxlO1xuICB9XG59XG5cbi8qKlxuICogQnVpbGRzIGEgbmV3IGBTYWZlU3R5bGVgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVTdHlsZShzdHlsZTogc3RyaW5nKTogU2FmZVN0eWxlIHtcbiAgcmV0dXJuIG5ldyBTYWZlU3R5bGVJbXBsKHN0eWxlLCBzZWNyZXRUb2tlbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFNhZmVTdHlsZWAgb2JqZWN0IHdoaWxlIGVuc3VyaW5nIGl0XG4gKiBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFNhZmVTdHlsZSh2YWx1ZTogU2FmZVN0eWxlKTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVN0eWxlSW1wbCkge1xuICAgIHJldHVybiB2YWx1ZS5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyB0eXBlJyk7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/safe_style.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/safe_style.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_style');
var module = module || { id: 'javascript/typescript/safevalues/safe_style.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_style_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_style_impl");
/** Reexport the public type (but not the Impl). */
const safe_style_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_style_impl');
exports.SafeStyle = safe_style_impl_1.SafeStyle;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zdHlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL3NhZmVfc3R5bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLGtIQUEyRDtBQUFuRCxzQ0FBQSxTQUFTLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUmVleHBvcnQgdGhlIHB1YmxpYyB0eXBlIChidXQgbm90IHRoZSBJbXBsKS4gKi9cbmV4cG9ydCB7U2FmZVN0eWxlfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3NhZmVfc3R5bGVfaW1wbCc7XG4iXX0=
;return exports;});

//javascript/typescript/safevalues/implementation/safe_style_sheet_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_style_sheet_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_style_sheet_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_style_sheet_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_secrets_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
/**
 * A complete CSS style sheet, safe to use in style contexts in an HTML document
 * or DOM APIs.
 *
 * See http://go/safehtmltypecontracts#safestylesheet
 * @abstract
 */
class SafeStyleSheet {
}
exports.SafeStyleSheet = SafeStyleSheet;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeStyleSheet.prototype.brand;
}
/**
 * Implementation for `SafeStyleSheet`
 * @extends {SafeStyleSheet}
 */
class SafeStyleSheetImpl extends SafeStyleSheet {
    /**
     * @param {string} styleSheet
     * @param {!Object} token
     */
    constructor(styleSheet, token) {
        super();
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedStyleSheet = styleSheet;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedStyleSheet;
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {string} */
    SafeStyleSheetImpl.prototype.privateDoNotAccessOrElseWrappedStyleSheet;
}
/**
 * Builds a new `SafeStyleSheet` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} styleSheet
 * @return {!SafeStyleSheet}
 */
function createSafeStyleSheet(styleSheet) {
    return new SafeStyleSheetImpl(styleSheet, secrets_1.secretToken);
}
exports.createSafeStyleSheet = createSafeStyleSheet;
/**
 * Returns the string value of the passed `SafeStyleSheet` object while
 * ensuring it has the correct type.
 * @param {!SafeStyleSheet} value
 * @return {string}
 */
function unwrapSafeStyleSheet(value) {
    if (value instanceof SafeStyleSheetImpl) {
        return value.privateDoNotAccessOrElseWrappedStyleSheet;
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapSafeStyleSheet = unwrapSafeStyleSheet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zdHlsZV9zaGVldF9pbXBsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF2YXNjcmlwdC90eXBlc2NyaXB0L3NhZmV2YWx1ZXMvaW1wbGVtZW50YXRpb24vc2FmZV9zdHlsZV9zaGVldF9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGtHQUEwRDs7Ozs7Ozs7QUFRMUQsTUFBc0IsY0FBYztDQUduQztBQUhELHdDQUdDOzs7Ozs7O0lBREMsK0JBQStCOzs7Ozs7QUFJakMsTUFBTSxrQkFBbUIsU0FBUSxjQUFjOzs7OztJQUc3QyxZQUFZLFVBQWtCLEVBQUUsS0FBYTtRQUMzQyxLQUFLLEVBQUUsQ0FBQztRQUNSLDRCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyx5Q0FBeUMsR0FBRyxVQUFVLENBQUM7SUFDOUQsQ0FBQzs7Ozs7SUFHRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMseUNBQXlDLENBQUM7SUFDeEQsQ0FBQztDQUNGOzs7O0lBWkMsdUVBQTJEOzs7Ozs7Ozs7QUFtQjdELFNBQWdCLG9CQUFvQixDQUFDLFVBQWtCO0lBQ3JELE9BQU8sSUFBSSxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUscUJBQVcsQ0FBQyxDQUFDO0FBQ3pELENBQUM7QUFGRCxvREFFQzs7Ozs7OztBQU1ELFNBQWdCLG9CQUFvQixDQUFDLEtBQXFCO0lBQ3hELElBQUksS0FBSyxZQUFZLGtCQUFrQixFQUFFO1FBQ3ZDLE9BQU8sS0FBSyxDQUFDLHlDQUF5QyxDQUFDO0tBQ3hEO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQU5ELG9EQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuXG4vKipcbiAqIEEgY29tcGxldGUgQ1NTIHN0eWxlIHNoZWV0LCBzYWZlIHRvIHVzZSBpbiBzdHlsZSBjb250ZXh0cyBpbiBhbiBIVE1MIGRvY3VtZW50XG4gKiBvciBET00gQVBJcy5cbiAqXG4gKiBTZWUgaHR0cDovL2dvL3NhZmVodG1sdHlwZWNvbnRyYWN0cyNzYWZlc3R5bGVzaGVldFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2FmZVN0eWxlU2hlZXQge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLXZhcmlhYmxlXG4gIHByaXZhdGUgcmVhZG9ubHkgYnJhbmQ/OiBuZXZlcjsgIC8vIFRvIHByZXZlbnQgc3RydWN0dXJhbCB0eXBpbmcuXG59XG5cbi8qKiBJbXBsZW1lbnRhdGlvbiBmb3IgYFNhZmVTdHlsZVNoZWV0YCAqL1xuY2xhc3MgU2FmZVN0eWxlU2hlZXRJbXBsIGV4dGVuZHMgU2FmZVN0eWxlU2hlZXQge1xuICByZWFkb25seSBwcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU3R5bGVTaGVldDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHN0eWxlU2hlZXQ6IHN0cmluZywgdG9rZW46IG9iamVjdCkge1xuICAgIHN1cGVyKCk7XG4gICAgZW5zdXJlVG9rZW5Jc1ZhbGlkKHRva2VuKTtcbiAgICB0aGlzLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRTdHlsZVNoZWV0ID0gc3R5bGVTaGVldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU3R5bGVTaGVldDtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBgU2FmZVN0eWxlU2hlZXRgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVTdHlsZVNoZWV0KHN0eWxlU2hlZXQ6IHN0cmluZyk6IFNhZmVTdHlsZVNoZWV0IHtcbiAgcmV0dXJuIG5ldyBTYWZlU3R5bGVTaGVldEltcGwoc3R5bGVTaGVldCwgc2VjcmV0VG9rZW4pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgcGFzc2VkIGBTYWZlU3R5bGVTaGVldGAgb2JqZWN0IHdoaWxlXG4gKiBlbnN1cmluZyBpdCBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFNhZmVTdHlsZVNoZWV0KHZhbHVlOiBTYWZlU3R5bGVTaGVldCk6IHN0cmluZyB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHlsZVNoZWV0SW1wbCkge1xuICAgIHJldHVybiB2YWx1ZS5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkU3R5bGVTaGVldDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHR5cGUnKTtcbiAgfVxufVxuIl19
;return exports;});

//javascript/typescript/safevalues/safe_style_sheet.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/safe_style_sheet.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_style_sheet');
var module = module || { id: 'javascript/typescript/safevalues/safe_style_sheet.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_style_sheet_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_style_sheet_impl");
/** Reexport the public type (but not the Impl). */
const safe_style_sheet_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_style_sheet_impl');
exports.SafeStyleSheet = safe_style_sheet_impl_1.SafeStyleSheet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9zdHlsZV9zaGVldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL3NhZmVfc3R5bGVfc2hlZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLDhIQUFzRTtBQUE5RCxpREFBQSxjQUFjLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUmVleHBvcnQgdGhlIHB1YmxpYyB0eXBlIChidXQgbm90IHRoZSBJbXBsKS4gKi9cbmV4cG9ydCB7U2FmZVN0eWxlU2hlZXR9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vc2FmZV9zdHlsZV9zaGVldF9pbXBsJztcbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/implementation/safe_attribute_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_attribute_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_attribute_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_attribute_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_secrets_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
/**
 * A prefix with which an attribute is safe to set using plain strings.
 * @abstract
 */
class SafeAttributePrefix {
}
exports.SafeAttributePrefix = SafeAttributePrefix;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeAttributePrefix.prototype.brand;
}
/**
 * Implementation for `SafeAttributePrefix`
 * @extends {SafeAttributePrefix}
 */
class SafeAttributePrefixImpl extends SafeAttributePrefix {
    /**
     * @param {string} attrPrefix
     * @param {!Object} token
     */
    constructor(attrPrefix, token) {
        super();
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedAttrPrefix = attrPrefix;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedAttrPrefix;
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {string} */
    SafeAttributePrefixImpl.prototype.privateDoNotAccessOrElseWrappedAttrPrefix;
}
/**
 * Builds a new `SafeAttribute` from the given string, without enforcing
 * safety guarantees. This shouldn't be exposed to application developers, and
 * must only be used as a step towards safe builders or safe constants.
 * @param {string} attrPrefix
 * @return {!SafeAttributePrefix}
 */
function createSafeAttributePrefix(attrPrefix) {
    return new SafeAttributePrefixImpl(attrPrefix, secrets_1.secretToken);
}
exports.createSafeAttributePrefix = createSafeAttributePrefix;
/**
 * Returns the string value of the passed `SafeAttributePrefix` object while
 * ensuring it has the correct type.
 * @param {!SafeAttributePrefix} value
 * @return {string}
 */
function unwrapSafeAttributePrefix(value) {
    if (value instanceof SafeAttributePrefixImpl) {
        return value.privateDoNotAccessOrElseWrappedAttrPrefix;
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapSafeAttributePrefix = unwrapSafeAttributePrefix;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV9hdHRyaWJ1dGVfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3NhZmVfYXR0cmlidXRlX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsa0dBQTBEOzs7OztBQUcxRCxNQUFzQixtQkFBbUI7Q0FHeEM7QUFIRCxrREFHQzs7Ozs7OztJQURDLG9DQUErQjs7Ozs7O0FBSWpDLE1BQU0sdUJBQXdCLFNBQVEsbUJBQW1COzs7OztJQUd2RCxZQUFZLFVBQWtCLEVBQUUsS0FBYTtRQUMzQyxLQUFLLEVBQUUsQ0FBQztRQUNSLDRCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyx5Q0FBeUMsR0FBRyxVQUFVLENBQUM7SUFDOUQsQ0FBQzs7Ozs7SUFHRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMseUNBQXlDLENBQUM7SUFDeEQsQ0FBQztDQUNGOzs7O0lBWkMsNEVBQTJEOzs7Ozs7Ozs7QUFtQjdELFNBQWdCLHlCQUF5QixDQUFDLFVBQWtCO0lBRTFELE9BQU8sSUFBSSx1QkFBdUIsQ0FBQyxVQUFVLEVBQUUscUJBQVcsQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFIRCw4REFHQzs7Ozs7OztBQU1ELFNBQWdCLHlCQUF5QixDQUFDLEtBQTBCO0lBQ2xFLElBQUksS0FBSyxZQUFZLHVCQUF1QixFQUFFO1FBQzVDLE9BQU8sS0FBSyxDQUFDLHlDQUF5QyxDQUFDO0tBQ3hEO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQU5ELDhEQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuXG4vKiogQSBwcmVmaXggd2l0aCB3aGljaCBhbiBhdHRyaWJ1dGUgaXMgc2FmZSB0byBzZXQgdXNpbmcgcGxhaW4gc3RyaW5ncy4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTYWZlQXR0cmlidXRlUHJlZml4IHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC12YXJpYWJsZVxuICBwcml2YXRlIHJlYWRvbmx5IGJyYW5kPzogbmV2ZXI7ICAvLyBUbyBwcmV2ZW50IHN0cnVjdHVyYWwgdHlwaW5nLlxufVxuXG4vKiogSW1wbGVtZW50YXRpb24gZm9yIGBTYWZlQXR0cmlidXRlUHJlZml4YCAqL1xuY2xhc3MgU2FmZUF0dHJpYnV0ZVByZWZpeEltcGwgZXh0ZW5kcyBTYWZlQXR0cmlidXRlUHJlZml4IHtcbiAgcmVhZG9ubHkgcHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZEF0dHJQcmVmaXg6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhdHRyUHJlZml4OiBzdHJpbmcsIHRva2VuOiBvYmplY3QpIHtcbiAgICBzdXBlcigpO1xuICAgIGVuc3VyZVRva2VuSXNWYWxpZCh0b2tlbik7XG4gICAgdGhpcy5wcml2YXRlRG9Ob3RBY2Nlc3NPckVsc2VXcmFwcGVkQXR0clByZWZpeCA9IGF0dHJQcmVmaXg7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZEF0dHJQcmVmaXg7XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBuZXcgYFNhZmVBdHRyaWJ1dGVgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dCBlbmZvcmNpbmdcbiAqIHNhZmV0eSBndWFyYW50ZWVzLiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZFxuICogbXVzdCBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVBdHRyaWJ1dGVQcmVmaXgoYXR0clByZWZpeDogc3RyaW5nKTpcbiAgICBTYWZlQXR0cmlidXRlUHJlZml4IHtcbiAgcmV0dXJuIG5ldyBTYWZlQXR0cmlidXRlUHJlZml4SW1wbChhdHRyUHJlZml4LCBzZWNyZXRUb2tlbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFNhZmVBdHRyaWJ1dGVQcmVmaXhgIG9iamVjdCB3aGlsZVxuICogZW5zdXJpbmcgaXQgaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBTYWZlQXR0cmlidXRlUHJlZml4KHZhbHVlOiBTYWZlQXR0cmlidXRlUHJlZml4KTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZUF0dHJpYnV0ZVByZWZpeEltcGwpIHtcbiAgICByZXR1cm4gdmFsdWUucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZEF0dHJQcmVmaXg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyB0eXBlJyk7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/implementation/safe_url_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/safe_url_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.safe_url_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/safe_url_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_pure_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.pure");
const tsickle_secrets_2 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const pure_1 = goog.require('google3.javascript.typescript.safevalues.implementation.pure');
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
/**
 * String that is safe to use in URL navigation contexts (`document.location`,
 * `a.href`) and as a reference to resources that do not load in the current
 * origin (`img.src`)
 *
 * See http://go/safehtmltypecontracts#safeurl
 * @abstract
 */
class SafeUrl {
}
exports.SafeUrl = SafeUrl;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    SafeUrl.prototype.brand;
}
/**
 * Implementation for `SafeUrl`
 * @extends {SafeUrl}
 */
class SafeUrlImpl extends SafeUrl {
    /**
     * @param {string} url
     * @param {!Object} token
     */
    constructor(url, token) {
        super();
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedUrl = url;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedUrl;
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {string} */
    SafeUrlImpl.prototype.privateDoNotAccessOrElseWrappedUrl;
}
/**
 * Builds a new `SafeUrl` from the given string, without enforcing safety
 * guarantees. This shouldn't be exposed to application developers, and must
 * only be used as a step towards safe builders or safe constants.
 * @param {string} url
 * @return {!SafeUrl}
 */
function createSafeUrl(url) {
    return new SafeUrlImpl(url, secrets_1.secretToken);
}
exports.createSafeUrl = createSafeUrl;
/**
 * A SafeUrl containing 'about:blank'.
 * @type {!SafeUrl}
 */
exports.ABOUT_BLANK = pure_1.pure((/**
 * @return {!SafeUrl}
 */
() => createSafeUrl('about:blank')));
/**
 * A SafeUrl containing an inert URL, used as an inert return value when
 * an unsafe input was sanitized.
 * @type {!SafeUrl}
 */
exports.INNOCUOUS_URL = pure_1.pure((/**
 * @return {!SafeUrl}
 */
() => createSafeUrl('about:invalid#zTSz')));
/**
 * Returns the string value of the passed `SafeUrl` object while ensuring it
 * has the correct type.
 * @param {!SafeUrl} value
 * @return {string}
 */
function unwrapSafeUrl(value) {
    if (value instanceof SafeUrlImpl) {
        return value.privateDoNotAccessOrElseWrappedUrl;
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapSafeUrl = unwrapSafeUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV91cmxfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3NhZmVfdXJsX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDRGQUE0QjtBQUM1QixrR0FBMEQ7Ozs7Ozs7OztBQVMxRCxNQUFzQixPQUFPO0NBRzVCO0FBSEQsMEJBR0M7Ozs7Ozs7SUFEQyx3QkFBK0I7Ozs7OztBQUlqQyxNQUFNLFdBQVksU0FBUSxPQUFPOzs7OztJQUcvQixZQUFZLEdBQVcsRUFBRSxLQUFhO1FBQ3BDLEtBQUssRUFBRSxDQUFDO1FBQ1IsNEJBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLGtDQUFrQyxHQUFHLEdBQUcsQ0FBQztJQUNoRCxDQUFDOzs7OztJQUdELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQztJQUNqRCxDQUFDO0NBQ0Y7Ozs7SUFaQyx5REFBb0Q7Ozs7Ozs7OztBQW1CdEQsU0FBZ0IsYUFBYSxDQUFDLEdBQVc7SUFDdkMsT0FBTyxJQUFJLFdBQVcsQ0FBQyxHQUFHLEVBQUUscUJBQVcsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFGRCxzQ0FFQzs7Ozs7QUFHWSxRQUFBLFdBQVcsR0FBWSxXQUFJOzs7QUFBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEVBQUM7Ozs7OztBQU0vRCxRQUFBLGFBQWEsR0FDdEIsV0FBSTs7O0FBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLEVBQUM7Ozs7Ozs7QUFPbkQsU0FBZ0IsYUFBYSxDQUFDLEtBQWM7SUFDMUMsSUFBSSxLQUFLLFlBQVksV0FBVyxFQUFFO1FBQ2hDLE9BQU8sS0FBSyxDQUFDLGtDQUFrQyxDQUFDO0tBQ2pEO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQU5ELHNDQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwdXJlfSBmcm9tICcuL3B1cmUnO1xuaW1wb3J0IHtlbnN1cmVUb2tlbklzVmFsaWQsIHNlY3JldFRva2VufSBmcm9tICcuL3NlY3JldHMnO1xuXG4vKipcbiAqIFN0cmluZyB0aGF0IGlzIHNhZmUgdG8gdXNlIGluIFVSTCBuYXZpZ2F0aW9uIGNvbnRleHRzIChgZG9jdW1lbnQubG9jYXRpb25gLFxuICogYGEuaHJlZmApIGFuZCBhcyBhIHJlZmVyZW5jZSB0byByZXNvdXJjZXMgdGhhdCBkbyBub3QgbG9hZCBpbiB0aGUgY3VycmVudFxuICogb3JpZ2luIChgaW1nLnNyY2ApXG4gKlxuICogU2VlIGh0dHA6Ly9nby9zYWZlaHRtbHR5cGVjb250cmFjdHMjc2FmZXVybFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2FmZVVybCB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbiAgcHJpdmF0ZSByZWFkb25seSBicmFuZD86IG5ldmVyOyAgLy8gVG8gcHJldmVudCBzdHJ1Y3R1cmFsIHR5cGluZy5cbn1cblxuLyoqIEltcGxlbWVudGF0aW9uIGZvciBgU2FmZVVybGAgKi9cbmNsYXNzIFNhZmVVcmxJbXBsIGV4dGVuZHMgU2FmZVVybCB7XG4gIHJlYWRvbmx5IHByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRVcmw6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IG9iamVjdCkge1xuICAgIHN1cGVyKCk7XG4gICAgZW5zdXJlVG9rZW5Jc1ZhbGlkKHRva2VuKTtcbiAgICB0aGlzLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRVcmwgPSB1cmw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFVybDtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBgU2FmZVVybGAgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCB3aXRob3V0IGVuZm9yY2luZyBzYWZldHlcbiAqIGd1YXJhbnRlZXMuIFRoaXMgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8gYXBwbGljYXRpb24gZGV2ZWxvcGVycywgYW5kIG11c3RcbiAqIG9ubHkgYmUgdXNlZCBhcyBhIHN0ZXAgdG93YXJkcyBzYWZlIGJ1aWxkZXJzIG9yIHNhZmUgY29uc3RhbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZVVybCh1cmw6IHN0cmluZyk6IFNhZmVVcmwge1xuICByZXR1cm4gbmV3IFNhZmVVcmxJbXBsKHVybCwgc2VjcmV0VG9rZW4pO1xufVxuXG4vKiogQSBTYWZlVXJsIGNvbnRhaW5pbmcgJ2Fib3V0OmJsYW5rJy4gKi9cbmV4cG9ydCBjb25zdCBBQk9VVF9CTEFOSzogU2FmZVVybCA9IHB1cmUoKCkgPT4gY3JlYXRlU2FmZVVybCgnYWJvdXQ6YmxhbmsnKSk7XG5cbi8qKlxuICogQSBTYWZlVXJsIGNvbnRhaW5pbmcgYW4gaW5lcnQgVVJMLCB1c2VkIGFzIGFuIGluZXJ0IHJldHVybiB2YWx1ZSB3aGVuXG4gKiBhbiB1bnNhZmUgaW5wdXQgd2FzIHNhbml0aXplZC5cbiAqL1xuZXhwb3J0IGNvbnN0IElOTk9DVU9VU19VUkw6IFNhZmVVcmwgPVxuICAgIHB1cmUoKCkgPT4gY3JlYXRlU2FmZVVybCgnYWJvdXQ6aW52YWxpZCN6VFN6JykpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFNhZmVVcmxgIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpdFxuICogaGFzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBTYWZlVXJsKHZhbHVlOiBTYWZlVXJsKTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVVybEltcGwpIHtcbiAgICByZXR1cm4gdmFsdWUucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFVybDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHR5cGUnKTtcbiAgfVxufVxuIl19
;return exports;});

//javascript/typescript/safevalues/implementation/trusted_resource_url_impl.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/implementation/trusted_resource_url_impl.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.implementation.trusted_resource_url_impl');
var module = module || { id: 'javascript/typescript/safevalues/implementation/trusted_resource_url_impl.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_secrets_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.secrets");
const tsickle_trusted_types_2 = goog.requireType("google3.javascript.typescript.safevalues.implementation.trusted_types");
const secrets_1 = goog.require('google3.javascript.typescript.safevalues.implementation.secrets');
const trusted_types_1 = goog.require('google3.javascript.typescript.safevalues.implementation.trusted_types');
// BEGIN-INTERNAL
/**
 * String that is safe to use in all URL contexts in DOM APIs and HTML
 * documents; even as a reference to resources that may load in the current
 * origin (e.g. scripts and stylesheets).
 *
 * See http://go/safehtmltypecontracts#trustedresourceurl
 * @abstract
 */
class TrustedResourceUrl {
}
exports.TrustedResourceUrl = TrustedResourceUrl;
/* istanbul ignore if */
if (false) {
    /**
     * @type {undefined}
     * @private
     */
    TrustedResourceUrl.prototype.brand;
}
// END-INTERNAL
/**
 * Implementation for `TrustedResourceUrl`
 * @extends {TrustedResourceUrl}
 */
class TrustedResourceUrlImpl extends TrustedResourceUrl {
    /**
     * @param {(string|!TrustedScriptURL)} url
     * @param {!Object} token
     */
    constructor(url, token) {
        super(); // LINE-INTERNAL
        secrets_1.ensureTokenIsValid(token);
        this.privateDoNotAccessOrElseWrappedResourceUrl = url;
    }
    /**
     * @override
     * @return {string}
     */
    toString() {
        return this.privateDoNotAccessOrElseWrappedResourceUrl.toString();
    }
}
/* istanbul ignore if */
if (false) {
    /** @type {(string|!TrustedScriptURL)} */
    TrustedResourceUrlImpl.prototype.privateDoNotAccessOrElseWrappedResourceUrl;
}
/**
 * Builds a new `TrustedResourceUrl` from the given string, without
 * enforcing safety guarantees. It may cause side effects by creating a Trusted
 * Types policy. This shouldn't be exposed to application developers, and must
 * only be used as a step towards safe builders or safe constants.
 * @param {string} url
 * @return {!TrustedResourceUrl}
 */
function createTrustedResourceUrl(url) {
    var _a;
    /**
     * @noinline
     * @type {string}
     */
    const noinlineUrl = url;
    /** @type {(undefined|!TrustedScriptURL)} */
    const trustedScriptURL = (_a = trusted_types_1.getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(noinlineUrl);
    // BEGIN-INTERNAL
    return new TrustedResourceUrlImpl(trustedScriptURL !== null && trustedScriptURL !== void 0 ? trustedScriptURL : noinlineUrl, secrets_1.secretToken);
    // END-INTERNAL
    // BEGIN-EXTERNAL
    // return (trustedScriptURL ??
    // new TrustedResourceUrlImpl(noinlineUrl, secretToken)) as
    // TrustedResourceUrl;
    // END-EXTERNAL
}
exports.createTrustedResourceUrl = createTrustedResourceUrl;
/**
 * Returns the value of the passed `TrustedResourceUrl` object while ensuring it
 * has the correct type.
 *
 * Returns a native `TrustedScriptURL` or a string if Trusted Types are
 * disabled.
 *
 * The strange return type is to ensure the value can be used at sinks without a
 * cast despite the TypeScript DOM lib not supporting Trusted Types.
 * (https://github.com/microsoft/TypeScript/issues/30024)
 *
 * Note that while the return type is compatible with `string`, you shouldn't
 * use any string functions on the result as that will fail in browsers
 * supporting Trusted Types.
 * @param {!TrustedResourceUrl} value
 * @return {?}
 */
function unwrapTrustedScriptURL(value) {
    var _a;
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(value)) {
        return (/** @type {?} */ (value));
    }
    else if (value instanceof TrustedResourceUrlImpl) {
        /** @type {(string|!TrustedScriptURL)} */
        const unwrapped = value.privateDoNotAccessOrElseWrappedResourceUrl;
        return (/** @type {?} */ (unwrapped));
    }
    else {
        throw new Error('wrong type');
    }
}
exports.unwrapTrustedScriptURL = unwrapTrustedScriptURL;
/**
 * Same as `unwrapTrustedScriptURL`, but returns an actual string
 *
 * Also ensures to return the right string value for `TrustedScriptURL` objects
 * if the `toString` function has been overwritten on the object.
 * @param {!TrustedResourceUrl} value
 * @return {string}
 */
function unwrapTrustedResourceUrlAsString(value) {
    var _a;
    /** @type {?} */
    const unwrapped = unwrapTrustedScriptURL(value);
    if ((_a = trusted_types_1.getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(unwrapped)) {
        // TODO: Remove once the spec freezes instances of `TrustedScriptURL`.
        return TrustedScriptURL.prototype.toString.apply(unwrapped);
    }
    else {
        return unwrapped;
    }
}
exports.unwrapTrustedResourceUrlAsString = unwrapTrustedResourceUrlAsString;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1c3RlZF9yZXNvdXJjZV91cmxfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvdHlwZXNjcmlwdC9zYWZldmFsdWVzL2ltcGxlbWVudGF0aW9uL3RydXN0ZWRfcmVzb3VyY2VfdXJsX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGtHQUEwRDtBQUMxRCw4R0FBdUU7Ozs7Ozs7Ozs7QUFVdkUsTUFBc0Isa0JBQWtCO0NBR3ZDO0FBSEQsZ0RBR0M7Ozs7Ozs7SUFEQyxtQ0FBK0I7Ozs7Ozs7QUFLakMsTUFBTSxzQkFBdUIsU0FBUSxrQkFBa0I7Ozs7O0lBR3JELFlBQVksR0FBNEIsRUFBRSxLQUFhO1FBQ3JELEtBQUssRUFBRSxDQUFDLENBQUUsZ0JBQWdCO1FBQzFCLDRCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQywwQ0FBMEMsR0FBRyxHQUFHLENBQUM7SUFDeEQsQ0FBQzs7Ozs7SUFHRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsMENBQTBDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEUsQ0FBQztDQUNGOzs7O0lBWkMsNEVBQTZFOzs7Ozs7Ozs7O0FBb0IvRSxTQUFnQix3QkFBd0IsQ0FBQyxHQUFXOzs7Ozs7VUFFNUMsV0FBVyxHQUFHLEdBQUc7O1VBQ2pCLGdCQUFnQixHQUNsQixNQUFBLHFDQUFxQixFQUFFLDBDQUFFLGVBQWUsQ0FBQyxXQUFXLENBQUM7SUFDekQsaUJBQWlCO0lBQ2pCLE9BQU8sSUFBSSxzQkFBc0IsQ0FDN0IsZ0JBQWdCLGFBQWhCLGdCQUFnQixjQUFoQixnQkFBZ0IsR0FBSSxXQUFXLEVBQUUscUJBQVcsQ0FBQyxDQUFDO0lBQ2xELGVBQWU7SUFDZixpQkFBaUI7SUFDakIsOEJBQThCO0lBQzlCLDJEQUEyRDtJQUMzRCxzQkFBc0I7SUFDdEIsZUFBZTtBQUNqQixDQUFDO0FBZEQsNERBY0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRCxTQUFnQixzQkFBc0IsQ0FBQyxLQUF5Qjs7SUFFOUQsSUFBSSxNQUFBLCtCQUFlLEVBQUUsMENBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sbUJBQUEsS0FBSyxFQUE2QixDQUFDO0tBQzNDO1NBQU0sSUFBSSxLQUFLLFlBQVksc0JBQXNCLEVBQUU7O2NBQzVDLFNBQVMsR0FBRyxLQUFLLENBQUMsMENBQTBDO1FBQ2xFLE9BQU8sbUJBQUEsU0FBUyxFQUE2QixDQUFDO0tBQy9DO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQy9CO0FBQ0gsQ0FBQztBQVZELHdEQVVDOzs7Ozs7Ozs7QUFRRCxTQUFnQixnQ0FBZ0MsQ0FBQyxLQUF5Qjs7O1VBRWxFLFNBQVMsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLENBQUM7SUFDL0MsSUFBSSxNQUFBLCtCQUFlLEVBQUUsMENBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQzdDLHNFQUFzRTtRQUN0RSxPQUFPLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzdEO1NBQU07UUFDTCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFURCw0RUFTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZW5zdXJlVG9rZW5Jc1ZhbGlkLCBzZWNyZXRUb2tlbn0gZnJvbSAnLi9zZWNyZXRzJztcbmltcG9ydCB7Z2V0VHJ1c3RlZFR5cGVzLCBnZXRUcnVzdGVkVHlwZXNQb2xpY3l9IGZyb20gJy4vdHJ1c3RlZF90eXBlcyc7XG5cbi8vIEJFR0lOLUlOVEVSTkFMXG4vKipcbiAqIFN0cmluZyB0aGF0IGlzIHNhZmUgdG8gdXNlIGluIGFsbCBVUkwgY29udGV4dHMgaW4gRE9NIEFQSXMgYW5kIEhUTUxcbiAqIGRvY3VtZW50czsgZXZlbiBhcyBhIHJlZmVyZW5jZSB0byByZXNvdXJjZXMgdGhhdCBtYXkgbG9hZCBpbiB0aGUgY3VycmVudFxuICogb3JpZ2luIChlLmcuIHNjcmlwdHMgYW5kIHN0eWxlc2hlZXRzKS5cbiAqXG4gKiBTZWUgaHR0cDovL2dvL3NhZmVodG1sdHlwZWNvbnRyYWN0cyN0cnVzdGVkcmVzb3VyY2V1cmxcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRydXN0ZWRSZXNvdXJjZVVybCB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbiAgcHJpdmF0ZSByZWFkb25seSBicmFuZD86IG5ldmVyOyAgLy8gVG8gcHJldmVudCBzdHJ1Y3R1cmFsIHR5cGluZy5cbn1cbi8vIEVORC1JTlRFUk5BTFxuXG4vKiogSW1wbGVtZW50YXRpb24gZm9yIGBUcnVzdGVkUmVzb3VyY2VVcmxgICovXG5jbGFzcyBUcnVzdGVkUmVzb3VyY2VVcmxJbXBsIGV4dGVuZHMgVHJ1c3RlZFJlc291cmNlVXJsIHtcbiAgcmVhZG9ubHkgcHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFJlc291cmNlVXJsOiBUcnVzdGVkU2NyaXB0VVJMfHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih1cmw6IFRydXN0ZWRTY3JpcHRVUkx8c3RyaW5nLCB0b2tlbjogb2JqZWN0KSB7XG4gICAgc3VwZXIoKTsgIC8vIExJTkUtSU5URVJOQUxcbiAgICBlbnN1cmVUb2tlbklzVmFsaWQodG9rZW4pO1xuICAgIHRoaXMucHJpdmF0ZURvTm90QWNjZXNzT3JFbHNlV3JhcHBlZFJlc291cmNlVXJsID0gdXJsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRSZXNvdXJjZVVybC50b1N0cmluZygpO1xuICB9XG59XG5cbi8qKlxuICogQnVpbGRzIGEgbmV3IGBUcnVzdGVkUmVzb3VyY2VVcmxgIGZyb20gdGhlIGdpdmVuIHN0cmluZywgd2l0aG91dFxuICogZW5mb3JjaW5nIHNhZmV0eSBndWFyYW50ZWVzLiBJdCBtYXkgY2F1c2Ugc2lkZSBlZmZlY3RzIGJ5IGNyZWF0aW5nIGEgVHJ1c3RlZFxuICogVHlwZXMgcG9saWN5LiBUaGlzIHNob3VsZG4ndCBiZSBleHBvc2VkIHRvIGFwcGxpY2F0aW9uIGRldmVsb3BlcnMsIGFuZCBtdXN0XG4gKiBvbmx5IGJlIHVzZWQgYXMgYSBzdGVwIHRvd2FyZHMgc2FmZSBidWlsZGVycyBvciBzYWZlIGNvbnN0YW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRydXN0ZWRSZXNvdXJjZVVybCh1cmw6IHN0cmluZyk6IFRydXN0ZWRSZXNvdXJjZVVybCB7XG4gIC8qKiBAbm9pbmxpbmUgKi9cbiAgY29uc3Qgbm9pbmxpbmVVcmwgPSB1cmw7XG4gIGNvbnN0IHRydXN0ZWRTY3JpcHRVUkwgPVxuICAgICAgZ2V0VHJ1c3RlZFR5cGVzUG9saWN5KCk/LmNyZWF0ZVNjcmlwdFVSTChub2lubGluZVVybCk7XG4gIC8vIEJFR0lOLUlOVEVSTkFMXG4gIHJldHVybiBuZXcgVHJ1c3RlZFJlc291cmNlVXJsSW1wbChcbiAgICAgIHRydXN0ZWRTY3JpcHRVUkwgPz8gbm9pbmxpbmVVcmwsIHNlY3JldFRva2VuKTtcbiAgLy8gRU5ELUlOVEVSTkFMXG4gIC8vIEJFR0lOLUVYVEVSTkFMXG4gIC8vIHJldHVybiAodHJ1c3RlZFNjcmlwdFVSTCA/P1xuICAvLyBuZXcgVHJ1c3RlZFJlc291cmNlVXJsSW1wbChub2lubGluZVVybCwgc2VjcmV0VG9rZW4pKSBhc1xuICAvLyBUcnVzdGVkUmVzb3VyY2VVcmw7XG4gIC8vIEVORC1FWFRFUk5BTFxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBwYXNzZWQgYFRydXN0ZWRSZXNvdXJjZVVybGAgb2JqZWN0IHdoaWxlIGVuc3VyaW5nIGl0XG4gKiBoYXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqXG4gKiBSZXR1cm5zIGEgbmF0aXZlIGBUcnVzdGVkU2NyaXB0VVJMYCBvciBhIHN0cmluZyBpZiBUcnVzdGVkIFR5cGVzIGFyZVxuICogZGlzYWJsZWQuXG4gKlxuICogVGhlIHN0cmFuZ2UgcmV0dXJuIHR5cGUgaXMgdG8gZW5zdXJlIHRoZSB2YWx1ZSBjYW4gYmUgdXNlZCBhdCBzaW5rcyB3aXRob3V0IGFcbiAqIGNhc3QgZGVzcGl0ZSB0aGUgVHlwZVNjcmlwdCBET00gbGliIG5vdCBzdXBwb3J0aW5nIFRydXN0ZWQgVHlwZXMuXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMDAyNClcbiAqXG4gKiBOb3RlIHRoYXQgd2hpbGUgdGhlIHJldHVybiB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCBgc3RyaW5nYCwgeW91IHNob3VsZG4ndFxuICogdXNlIGFueSBzdHJpbmcgZnVuY3Rpb25zIG9uIHRoZSByZXN1bHQgYXMgdGhhdCB3aWxsIGZhaWwgaW4gYnJvd3NlcnNcbiAqIHN1cHBvcnRpbmcgVHJ1c3RlZCBUeXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFRydXN0ZWRTY3JpcHRVUkwodmFsdWU6IFRydXN0ZWRSZXNvdXJjZVVybCk6XG4gICAgVHJ1c3RlZFNjcmlwdFVSTCZzdHJpbmcge1xuICBpZiAoZ2V0VHJ1c3RlZFR5cGVzKCk/LmlzU2NyaXB0VVJMKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSBhcyBUcnVzdGVkU2NyaXB0VVJMICYgc3RyaW5nO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHJ1c3RlZFJlc291cmNlVXJsSW1wbCkge1xuICAgIGNvbnN0IHVud3JhcHBlZCA9IHZhbHVlLnByaXZhdGVEb05vdEFjY2Vzc09yRWxzZVdyYXBwZWRSZXNvdXJjZVVybDtcbiAgICByZXR1cm4gdW53cmFwcGVkIGFzIFRydXN0ZWRTY3JpcHRVUkwgJiBzdHJpbmc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyB0eXBlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGB1bndyYXBUcnVzdGVkU2NyaXB0VVJMYCwgYnV0IHJldHVybnMgYW4gYWN0dWFsIHN0cmluZ1xuICpcbiAqIEFsc28gZW5zdXJlcyB0byByZXR1cm4gdGhlIHJpZ2h0IHN0cmluZyB2YWx1ZSBmb3IgYFRydXN0ZWRTY3JpcHRVUkxgIG9iamVjdHNcbiAqIGlmIHRoZSBgdG9TdHJpbmdgIGZ1bmN0aW9uIGhhcyBiZWVuIG92ZXJ3cml0dGVuIG9uIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBUcnVzdGVkUmVzb3VyY2VVcmxBc1N0cmluZyh2YWx1ZTogVHJ1c3RlZFJlc291cmNlVXJsKTpcbiAgICBzdHJpbmcge1xuICBjb25zdCB1bndyYXBwZWQgPSB1bndyYXBUcnVzdGVkU2NyaXB0VVJMKHZhbHVlKTtcbiAgaWYgKGdldFRydXN0ZWRUeXBlcygpPy5pc1NjcmlwdFVSTCh1bndyYXBwZWQpKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIG9uY2UgdGhlIHNwZWMgZnJlZXplcyBpbnN0YW5jZXMgb2YgYFRydXN0ZWRTY3JpcHRVUkxgLlxuICAgIHJldHVybiBUcnVzdGVkU2NyaXB0VVJMLnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh1bndyYXBwZWQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bndyYXBwZWQ7XG4gIH1cbn1cbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/safe_unwrappers.closure.js
goog.loadModule(function(exports) {'use strict';/**
 *
 * @fileoverview Unwrap functions to open safe types and return their inner
 * values. Runtime checks are performed to check that provided objects are
 * indeed objects of the correct safe type to protect against conterfeit safe
 * values.
 *
 * This is mostly intended for internal use as well as external use in security
 * sensitive contexts, e.g. in unchecked conversions, auto-escaping templating
 * languages or other frameworks that expose a DOM-like layer.
 *
 * When assigning to native sinks, use the utilies in the safedom package.
 *
 * For other use cases where a safe type's underlying string representation is
 * required, see the `toString` function of the respective object.
 *
 * Note that the functions are re-exported to ensure that while clients can
 * check the validity of values, they cannot create new ones.
 *
 * Generated from: javascript/typescript/safevalues/safe_unwrappers.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_unwrappers');
var module = module || { id: 'javascript/typescript/safevalues/safe_unwrappers.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_attribute_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_attribute_impl");
const tsickle_safe_html_impl_2 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_html_impl");
const tsickle_safe_script_impl_3 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_script_impl");
const tsickle_safe_style_impl_4 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_style_impl");
const tsickle_safe_style_sheet_impl_5 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_style_sheet_impl");
const tsickle_safe_url_impl_6 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_url_impl");
const tsickle_trusted_resource_url_impl_7 = goog.requireType("google3.javascript.typescript.safevalues.implementation.trusted_resource_url_impl");
const safe_attribute_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_attribute_impl');
exports.unwrapSafeAttributePrefix = safe_attribute_impl_1.unwrapSafeAttributePrefix;
const safe_html_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_html_impl');
exports.unwrapSafeHtml = safe_html_impl_1.unwrapSafeHtmlAsString;
exports.unwrapTrustedHTML = safe_html_impl_1.unwrapTrustedHTML;
const safe_script_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_script_impl');
exports.unwrapSafeScript = safe_script_impl_1.unwrapSafeScriptAsString;
exports.unwrapTrustedScript = safe_script_impl_1.unwrapTrustedScript;
const safe_style_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_style_impl');
exports.unwrapSafeStyle = safe_style_impl_1.unwrapSafeStyle;
const safe_style_sheet_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_style_sheet_impl');
exports.unwrapSafeStyleSheet = safe_style_sheet_impl_1.unwrapSafeStyleSheet;
const safe_url_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_url_impl');
exports.unwrapSafeUrl = safe_url_impl_1.unwrapSafeUrl;
const trusted_resource_url_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.trusted_resource_url_impl');
exports.unwrapTrustedResourceUrl = trusted_resource_url_impl_1.unwrapTrustedResourceUrlAsString;
exports.unwrapTrustedScriptURL = trusted_resource_url_impl_1.unwrapTrustedScriptURL;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV91bndyYXBwZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vamF2YXNjcmlwdC90eXBlc2NyaXB0L3NhZmV2YWx1ZXMvc2FmZV91bndyYXBwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLDBIQUErRTtBQUF2RSwwREFBQSx5QkFBeUIsQ0FBQTtBQUNqQyxnSEFBNEc7QUFBcEcsMENBQUEsc0JBQXNCLENBQWtCO0FBQUUsNkNBQUEsaUJBQWlCLENBQUE7QUFDbkUsb0hBQW9IO0FBQTVHLDhDQUFBLHdCQUF3QixDQUFvQjtBQUFFLGlEQUFBLG1CQUFtQixDQUFBO0FBQ3pFLGtIQUFpRTtBQUF6RCw0Q0FBQSxlQUFlLENBQUE7QUFDdkIsOEhBQTRFO0FBQXBFLHVEQUFBLG9CQUFvQixDQUFBO0FBQzVCLDhHQUE2RDtBQUFyRCx3Q0FBQSxhQUFhLENBQUE7QUFDckIsc0lBQWdKO0FBQXhJLCtEQUFBLGdDQUFnQyxDQUE0QjtBQUFFLDZEQUFBLHNCQUFzQixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVud3JhcCBmdW5jdGlvbnMgdG8gb3BlbiBzYWZlIHR5cGVzIGFuZCByZXR1cm4gdGhlaXIgaW5uZXJcbiAqIHZhbHVlcy4gUnVudGltZSBjaGVja3MgYXJlIHBlcmZvcm1lZCB0byBjaGVjayB0aGF0IHByb3ZpZGVkIG9iamVjdHMgYXJlXG4gKiBpbmRlZWQgb2JqZWN0cyBvZiB0aGUgY29ycmVjdCBzYWZlIHR5cGUgdG8gcHJvdGVjdCBhZ2FpbnN0IGNvbnRlcmZlaXQgc2FmZVxuICogdmFsdWVzLlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2UgYXMgd2VsbCBhcyBleHRlcm5hbCB1c2UgaW4gc2VjdXJpdHlcbiAqIHNlbnNpdGl2ZSBjb250ZXh0cywgZS5nLiBpbiB1bmNoZWNrZWQgY29udmVyc2lvbnMsIGF1dG8tZXNjYXBpbmcgdGVtcGxhdGluZ1xuICogbGFuZ3VhZ2VzIG9yIG90aGVyIGZyYW1ld29ya3MgdGhhdCBleHBvc2UgYSBET00tbGlrZSBsYXllci5cbiAqXG4gKiBXaGVuIGFzc2lnbmluZyB0byBuYXRpdmUgc2lua3MsIHVzZSB0aGUgdXRpbGllcyBpbiB0aGUgc2FmZWRvbSBwYWNrYWdlLlxuICpcbiAqIEZvciBvdGhlciB1c2UgY2FzZXMgd2hlcmUgYSBzYWZlIHR5cGUncyB1bmRlcmx5aW5nIHN0cmluZyByZXByZXNlbnRhdGlvbiBpc1xuICogcmVxdWlyZWQsIHNlZSB0aGUgYHRvU3RyaW5nYCBmdW5jdGlvbiBvZiB0aGUgcmVzcGVjdGl2ZSBvYmplY3QuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBmdW5jdGlvbnMgYXJlIHJlLWV4cG9ydGVkIHRvIGVuc3VyZSB0aGF0IHdoaWxlIGNsaWVudHMgY2FuXG4gKiBjaGVjayB0aGUgdmFsaWRpdHkgb2YgdmFsdWVzLCB0aGV5IGNhbm5vdCBjcmVhdGUgbmV3IG9uZXMuXG4gKi9cblxuZXhwb3J0IHt1bndyYXBTYWZlQXR0cmlidXRlUHJlZml4fSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3NhZmVfYXR0cmlidXRlX2ltcGwnO1xuZXhwb3J0IHt1bndyYXBTYWZlSHRtbEFzU3RyaW5nIGFzIHVud3JhcFNhZmVIdG1sLCB1bndyYXBUcnVzdGVkSFRNTH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9zYWZlX2h0bWxfaW1wbCc7XG5leHBvcnQge3Vud3JhcFNhZmVTY3JpcHRBc1N0cmluZyBhcyB1bndyYXBTYWZlU2NyaXB0LCB1bndyYXBUcnVzdGVkU2NyaXB0fSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3NhZmVfc2NyaXB0X2ltcGwnO1xuZXhwb3J0IHt1bndyYXBTYWZlU3R5bGV9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vc2FmZV9zdHlsZV9pbXBsJztcbmV4cG9ydCB7dW53cmFwU2FmZVN0eWxlU2hlZXR9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vc2FmZV9zdHlsZV9zaGVldF9pbXBsJztcbmV4cG9ydCB7dW53cmFwU2FmZVVybH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9zYWZlX3VybF9pbXBsJztcbmV4cG9ydCB7dW53cmFwVHJ1c3RlZFJlc291cmNlVXJsQXNTdHJpbmcgYXMgdW53cmFwVHJ1c3RlZFJlc291cmNlVXJsLCB1bndyYXBUcnVzdGVkU2NyaXB0VVJMfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3RydXN0ZWRfcmVzb3VyY2VfdXJsX2ltcGwnO1xuIl19
;return exports;});

//javascript/typescript/safevalues/safe_url.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/safe_url.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.safe_url');
var module = module || { id: 'javascript/typescript/safevalues/safe_url.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_safe_url_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.safe_url_impl");
/** Reexport the public type (but not the Impl). */
const safe_url_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.safe_url_impl');
exports.ABOUT_BLANK = safe_url_impl_1.ABOUT_BLANK;
exports.INNOCUOUS_URL = safe_url_impl_1.INNOCUOUS_URL;
exports.SafeUrl = safe_url_impl_1.SafeUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZV91cmwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3R5cGVzY3JpcHQvc2FmZXZhbHVlcy9zYWZlX3VybC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0EsOEdBQW1GO0FBQTNFLHNDQUFBLFdBQVcsQ0FBQTtBQUFFLHdDQUFBLGFBQWEsQ0FBQTtBQUFFLGtDQUFBLE9BQU8sQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBSZWV4cG9ydCB0aGUgcHVibGljIHR5cGUgKGJ1dCBub3QgdGhlIEltcGwpLiAqL1xuZXhwb3J0IHtBQk9VVF9CTEFOSywgSU5OT0NVT1VTX1VSTCwgU2FmZVVybH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9zYWZlX3VybF9pbXBsJztcbiJdfQ==
;return exports;});

//javascript/typescript/safevalues/trusted_resource_url.closure.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview added by tsickle
 * Generated from: javascript/typescript/safevalues/trusted_resource_url.ts
 * @suppress {checkTypes,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
goog.module('google3.javascript.typescript.safevalues.trusted_resource_url');
var module = module || { id: 'javascript/typescript/safevalues/trusted_resource_url.closure.js' };
goog.require('google3.third_party.javascript.tslib.tslib');
const tsickle_trusted_resource_url_impl_1 = goog.requireType("google3.javascript.typescript.safevalues.implementation.trusted_resource_url_impl");
/** Reexport the public type (but not the Impl). */
const trusted_resource_url_impl_1 = goog.require('google3.javascript.typescript.safevalues.implementation.trusted_resource_url_impl');
exports.TrustedResourceUrl = trusted_resource_url_impl_1.TrustedResourceUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ1c3RlZF9yZXNvdXJjZV91cmwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3R5cGVzY3JpcHQvc2FmZXZhbHVlcy90cnVzdGVkX3Jlc291cmNlX3VybC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esc0lBQThFO0FBQXRFLHlEQUFBLGtCQUFrQixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIFJlZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSAoYnV0IG5vdCB0aGUgSW1wbCkuICovXG5leHBvcnQge1RydXN0ZWRSZXNvdXJjZVVybH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi90cnVzdGVkX3Jlc291cmNlX3VybF9pbXBsJztcbiJdfQ==
;return exports;});

//third_party/javascript/closure/i18n/uchar.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Collection of utility functions for Unicode character.
 */

goog.provide('goog.i18n.uChar');


// Constants for handling Unicode supplementary characters (surrogate pairs).


/**
 * The minimum value for Supplementary code points.
 * @type {number}
 * @private
 */
goog.i18n.uChar.SUPPLEMENTARY_CODE_POINT_MIN_VALUE_ = 0x10000;


/**
 * The highest Unicode code point value (scalar value) according to the Unicode
 * Standard.
 * @type {number}
 * @private
 */
goog.i18n.uChar.CODE_POINT_MAX_VALUE_ = 0x10FFFF;


/**
 * Lead surrogate minimum value.
 * @type {number}
 * @private
 */
goog.i18n.uChar.LEAD_SURROGATE_MIN_VALUE_ = 0xD800;


/**
 * Lead surrogate maximum value.
 * @type {number}
 * @private
 */
goog.i18n.uChar.LEAD_SURROGATE_MAX_VALUE_ = 0xDBFF;


/**
 * Trail surrogate minimum value.
 * @type {number}
 * @private
 */
goog.i18n.uChar.TRAIL_SURROGATE_MIN_VALUE_ = 0xDC00;


/**
 * Trail surrogate maximum value.
 * @type {number}
 * @private
 */
goog.i18n.uChar.TRAIL_SURROGATE_MAX_VALUE_ = 0xDFFF;


/**
 * The number of least significant bits of a supplementary code point that in
 * UTF-16 become the least significant bits of the trail surrogate. The rest of
 * the in-use bits of the supplementary code point become the least significant
 * bits of the lead surrogate.
 * @type {number}
 * @private
 */
goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_ = 10;


/**
 * Gets the U+ notation string of a Unicode character. Ex: 'U+0041' for 'A'.
 * @param {string} ch The given character.
 * @return {string} The U+ notation of the given character.
 */
goog.i18n.uChar.toHexString = function(ch) {
  'use strict';
  const chCode = goog.i18n.uChar.toCharCode(ch);
  const chCodeStr = 'U+' +
      goog.i18n.uChar.padString_(chCode.toString(16).toUpperCase(), 4, '0');

  return chCodeStr;
};


/**
 * Gets a string padded with given character to get given size.
 * @param {string} str The given string to be padded.
 * @param {number} length The target size of the string.
 * @param {string} ch The character to be padded with.
 * @return {string} The padded string.
 * @private
 */
goog.i18n.uChar.padString_ = function(str, length, ch) {
  'use strict';
  while (str.length < length) {
    str = ch + str;
  }
  return str;
};


/**
 * Gets Unicode value of the given character.
 * @param {string} ch The given character, which in the case of a supplementary
 * character is actually a surrogate pair. The remainder of the string is
 * ignored.
 * @return {number} The Unicode value of the character.
 */
goog.i18n.uChar.toCharCode = function(ch) {
  'use strict';
  return goog.i18n.uChar.getCodePointAround(ch, 0);
};


/**
 * Gets a character from the given Unicode value. If the given code point is not
 * a valid Unicode code point, null is returned.
 * @param {number} code The Unicode value of the character.
 * @return {?string} The character corresponding to the given Unicode value.
 */
goog.i18n.uChar.fromCharCode = function(code) {
  'use strict';
  if (code == null ||
      !(code >= 0 && code <= goog.i18n.uChar.CODE_POINT_MAX_VALUE_)) {
    return null;
  }
  if (goog.i18n.uChar.isSupplementaryCodePoint(code)) {
    // First, we split the code point into the trail surrogate part (the
    // TRAIL_SURROGATE_BIT_COUNT_ least significant bits) and the lead surrogate
    // part (the rest of the bits, shifted down; note that for now this includes
    // the supplementary offset, also shifted down, to be subtracted off below).
    const leadBits = code >> goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_;
    const trailBits = code &
        // A bit-mask to get the TRAIL_SURROGATE_BIT_COUNT_ (i.e. 10) least
        // significant bits. 1 << 10 = 0x0400. 0x0400 - 1 = 0x03FF.
        ((1 << goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_) - 1);

    // Now we calculate the code point of each surrogate by adding each offset
    // to the corresponding base code point.
    const leadCodePoint = leadBits +
        (goog.i18n.uChar.LEAD_SURROGATE_MIN_VALUE_ -
         // Subtract off the supplementary offset, which had been shifted down
         // with the rest of leadBits. We do this here instead of before the
         // shift in order to save a separate subtraction step.
         (goog.i18n.uChar.SUPPLEMENTARY_CODE_POINT_MIN_VALUE_ >>
          goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_));
    const trailCodePoint =
        trailBits + goog.i18n.uChar.TRAIL_SURROGATE_MIN_VALUE_;

    // Convert the code points into a 2-character long string.
    return String.fromCharCode(leadCodePoint) +
        String.fromCharCode(trailCodePoint);
  }
  return String.fromCharCode(code);
};


/**
 * Returns the Unicode code point at the specified index.
 *
 * If the char value specified at the given index is in the leading-surrogate
 * range, and the following index is less than the length of `string`, and
 * the char value at the following index is in the trailing-surrogate range,
 * then the supplementary code point corresponding to this surrogate pair is
 * returned.
 *
 * If the char value specified at the given index is in the trailing-surrogate
 * range, and the preceding index is not before the start of `string`, and
 * the char value at the preceding index is in the leading-surrogate range, then
 * the negated supplementary code point corresponding to this surrogate pair is
 * returned.
 *
 * The negation allows the caller to differentiate between the case where the
 * given index is at the leading surrogate and the one where it is at the
 * trailing surrogate, and thus deduce where the next character starts and
 * preceding character ends.
 *
 * Otherwise, the char value at the given index is returned. Thus, a leading
 * surrogate is returned when it is not followed by a trailing surrogate, and a
 * trailing surrogate is returned when it is not preceded by a leading
 * surrogate.
 *
 * @param {string} string The string.
 * @param {number} index The index from which the code point is to be retrieved.
 * @return {number} The code point at the given index. If the given index is
 * that of the start (i.e. lead surrogate) of a surrogate pair, returns the code
 * point encoded by the pair. If the given index is that of the end (i.e. trail
 * surrogate) of a surrogate pair, returns the negated code pointed encoded by
 * the pair.
 */
goog.i18n.uChar.getCodePointAround = function(string, index) {
  'use strict';
  const charCode = string.charCodeAt(index);
  if (goog.i18n.uChar.isLeadSurrogateCodePoint(charCode) &&
      index + 1 < string.length) {
    const trail = string.charCodeAt(index + 1);
    if (goog.i18n.uChar.isTrailSurrogateCodePoint(trail)) {
      // Part of a surrogate pair.
      return /** @type {number} */ (
          goog.i18n.uChar.buildSupplementaryCodePoint(charCode, trail));
    }
  } else if (goog.i18n.uChar.isTrailSurrogateCodePoint(charCode) && index > 0) {
    const lead = string.charCodeAt(index - 1);
    if (goog.i18n.uChar.isLeadSurrogateCodePoint(lead)) {
      // Part of a surrogate pair.
      const codepoint = /** @type {number} */ (
          goog.i18n.uChar.buildSupplementaryCodePoint(lead, charCode));
      return -codepoint;
    }
  }
  return charCode;
};


/**
 * Determines the length of the string needed to represent the specified
 * Unicode code point.
 * @param {number} codePoint
 * @return {number} 2 if codePoint is a supplementary character, 1 otherwise.
 */
goog.i18n.uChar.charCount = function(codePoint) {
  'use strict';
  return goog.i18n.uChar.isSupplementaryCodePoint(codePoint) ? 2 : 1;
};


/**
 * Determines whether the specified Unicode code point is in the supplementary
 * Unicode characters range.
 * @param {number} codePoint
 * @return {boolean} Whether then given code point is a supplementary character.
 */
goog.i18n.uChar.isSupplementaryCodePoint = function(codePoint) {
  'use strict';
  return codePoint >= goog.i18n.uChar.SUPPLEMENTARY_CODE_POINT_MIN_VALUE_ &&
      codePoint <= goog.i18n.uChar.CODE_POINT_MAX_VALUE_;
};


/**
 * Gets whether the given code point is a leading surrogate character.
 * @param {number} codePoint
 * @return {boolean} Whether the given code point is a leading surrogate
 * character.
 */
goog.i18n.uChar.isLeadSurrogateCodePoint = function(codePoint) {
  'use strict';
  return codePoint >= goog.i18n.uChar.LEAD_SURROGATE_MIN_VALUE_ &&
      codePoint <= goog.i18n.uChar.LEAD_SURROGATE_MAX_VALUE_;
};


/**
 * Gets whether the given code point is a trailing surrogate character.
 * @param {number} codePoint
 * @return {boolean} Whether the given code point is a trailing surrogate
 * character.
 */
goog.i18n.uChar.isTrailSurrogateCodePoint = function(codePoint) {
  'use strict';
  return codePoint >= goog.i18n.uChar.TRAIL_SURROGATE_MIN_VALUE_ &&
      codePoint <= goog.i18n.uChar.TRAIL_SURROGATE_MAX_VALUE_;
};


/**
 * Composes a supplementary Unicode code point from the given UTF-16 surrogate
 * pair. If leadSurrogate isn't a leading surrogate code point or trailSurrogate
 * isn't a trailing surrogate code point, null is returned.
 * @param {number} lead The leading surrogate code point.
 * @param {number} trail The trailing surrogate code point.
 * @return {?number} The supplementary Unicode code point obtained by decoding
 * the given UTF-16 surrogate pair.
 */
goog.i18n.uChar.buildSupplementaryCodePoint = function(lead, trail) {
  'use strict';
  if (goog.i18n.uChar.isLeadSurrogateCodePoint(lead) &&
      goog.i18n.uChar.isTrailSurrogateCodePoint(trail)) {
    const shiftedLeadOffset =
        (lead << goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_) -
        (goog.i18n.uChar.LEAD_SURROGATE_MIN_VALUE_
         << goog.i18n.uChar.TRAIL_SURROGATE_BIT_COUNT_);
    const trailOffset = trail - goog.i18n.uChar.TRAIL_SURROGATE_MIN_VALUE_ +
        goog.i18n.uChar.SUPPLEMENTARY_CODE_POINT_MIN_VALUE_;
    return shiftedLeadOffset + trailOffset;
  }
  return null;
};

//third_party/javascript/closure/structs/inversionmap.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides inversion and inversion map functionality for storing
 * integer ranges and corresponding values.
 */

goog.provide('goog.structs.InversionMap');

goog.require('goog.array');
goog.require('goog.asserts');



/**
 * Maps ranges to values.
 * @param {Array<number>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {Array<T>} valueArray An array of corresponding values.
 *     Length must be the same as rangeArray.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 * @constructor
 * @template T
 */
goog.structs.InversionMap = function(rangeArray, valueArray, opt_delta) {
  'use strict';
  /**
   * @protected {?Array<number>}
   */
  this.rangeArray = null;

  goog.asserts.assert(
      rangeArray.length == valueArray.length,
      'rangeArray and valueArray must have the same length.');
  this.storeInversion_(rangeArray, opt_delta);

  /** @protected {Array<T>} */
  this.values = valueArray;
};


/**
 * Stores the integers as ranges (half-open).
 * If delta is true, the integers are delta from the previous value and
 * will be restored to the absolute value.
 * When used as a set, even indices are IN, and odd are OUT.
 * @param {Array<number>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 * @private
 */
goog.structs.InversionMap.prototype.storeInversion_ = function(
    rangeArray, opt_delta) {
  'use strict';
  this.rangeArray = rangeArray;

  for (var i = 1; i < rangeArray.length; i++) {
    if (rangeArray[i] == null) {
      rangeArray[i] = rangeArray[i - 1] + 1;
    } else if (opt_delta) {
      rangeArray[i] += rangeArray[i - 1];
    }
  }
};


/**
 * Splices a range -> value map into this inversion map.
 * @param {Array<number>} rangeArray An array of monotonically
 *     increasing integer values, with at least one instance.
 * @param {Array<T>} valueArray An array of corresponding values.
 *     Length must be the same as rangeArray.
 * @param {boolean=} opt_delta If true, saves only delta from previous value.
 */
goog.structs.InversionMap.prototype.spliceInversion = function(
    rangeArray, valueArray, opt_delta) {
  'use strict';
  // By building another inversion map, we build the arrays that we need
  // to splice in.
  var otherMap =
      new goog.structs.InversionMap(rangeArray, valueArray, opt_delta);

  // Figure out where to splice those arrays.
  var startRange = otherMap.rangeArray[0];
  var endRange =
      /** @type {number} */ (goog.array.peek(otherMap.rangeArray));
  var startSplice = this.getLeast(startRange);
  var endSplice = this.getLeast(endRange);

  // The inversion map works by storing the start points of ranges...
  if (startRange != this.rangeArray[startSplice]) {
    // ...if we're splicing in a start point that isn't already here,
    // then we need to insert it after the insertion point.
    startSplice++;
  }  // otherwise we overwrite the insertion point.

  this.rangeArray = this.rangeArray.slice(0, startSplice)
                        .concat(otherMap.rangeArray)
                        .concat(this.rangeArray.slice(endSplice + 1));
  this.values = this.values.slice(0, startSplice)
                    .concat(otherMap.values)
                    .concat(this.values.slice(endSplice + 1));
};


/**
 * Gets the value corresponding to a number from the inversion map.
 * @param {number} intKey The number for which value needs to be retrieved
 *     from inversion map.
 * @return {T|null} Value retrieved from inversion map; null if not found.
 */
goog.structs.InversionMap.prototype.at = function(intKey) {
  'use strict';
  var index = this.getLeast(intKey);
  if (index < 0) {
    return null;
  }
  return this.values[index];
};


/**
 * Gets the largest index such that rangeArray[index] <= intKey from the
 * inversion map.
 * @param {number} intKey The probe for which rangeArray is searched.
 * @return {number} Largest index such that rangeArray[index] <= intKey.
 * @protected
 */
goog.structs.InversionMap.prototype.getLeast = function(intKey) {
  'use strict';
  var arr = this.rangeArray;
  var low = 0;
  var high = arr.length;
  while (high - low > 8) {
    var mid = (high + low) >> 1;
    if (arr[mid] <= intKey) {
      low = mid;
    } else {
      high = mid;
    }
  }
  for (; low < high; ++low) {
    if (intKey < arr[low]) {
      break;
    }
  }
  return low - 1;
};

//third_party/javascript/closure/i18n/graphemebreak.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Detect Grapheme Cluster Break in a pair of codepoints. Follows
 * Unicode 10 UAX#29. Tailoring for Virama × Indic Letters is used.
 *
 * Reference: http://unicode.org/reports/tr29
 */

goog.provide('goog.i18n.GraphemeBreak');

goog.require('goog.asserts');
goog.require('goog.i18n.uChar');
goog.require('goog.structs.InversionMap');

/**
 * Enum for all Grapheme Cluster Break properties.
 * These enums directly corresponds to Grapheme_Cluster_Break property values
 * mentioned in http://unicode.org/reports/tr29 table 2. VIRAMA and
 * INDIC_LETTER are for the Virama × Base tailoring mentioned in the notes.
 *
 * @protected @enum {number}
 */
goog.i18n.GraphemeBreak.property = {
  OTHER: 0,
  CONTROL: 1,
  EXTEND: 2,
  PREPEND: 3,
  SPACING_MARK: 4,
  INDIC_LETTER: 5,
  VIRAMA: 6,
  L: 7,
  V: 8,
  T: 9,
  LV: 10,
  LVT: 11,
  CR: 12,
  LF: 13,
  REGIONAL_INDICATOR: 14,
  ZWJ: 15,
  E_BASE: 16,
  GLUE_AFTER_ZWJ: 17,
  E_MODIFIER: 18,
  E_BASE_GAZ: 19
};


/**
 * Grapheme Cluster Break property values for all codepoints as inversion map.
 * Constructed lazily.
 *
 * @private {?goog.structs.InversionMap}
 */
goog.i18n.GraphemeBreak.inversions_ = null;


/**
 * Indicates if a and b form a grapheme cluster.
 *
 * This implements the rules in:
 * http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
 *
 * @param {number|string} a Code point or string with the first side of
 *     grapheme cluster.
 * @param {number|string} b Code point or string with the second side of
 *     grapheme cluster.
 * @param {boolean} extended If true, indicates extended grapheme cluster;
 *     If false, indicates legacy cluster.
 * @return {boolean} True if a & b do not form a cluster; False otherwise.
 * @private
 */
goog.i18n.GraphemeBreak.applyBreakRules_ = function(a, b, extended) {
  'use strict';
  var prop = goog.i18n.GraphemeBreak.property;

  var aCode = (typeof a === 'string') ?
      goog.i18n.GraphemeBreak.getCodePoint_(a, a.length - 1) :
      a;
  var bCode =
      (typeof b === 'string') ? goog.i18n.GraphemeBreak.getCodePoint_(b, 0) : b;

  var aProp = goog.i18n.GraphemeBreak.getBreakProp_(aCode);
  var bProp = goog.i18n.GraphemeBreak.getBreakProp_(bCode);

  var isString = (typeof a === 'string');

  // GB3.
  if (aProp === prop.CR && bProp === prop.LF) {
    return false;
  }

  // GB4.
  if (aProp === prop.CONTROL || aProp === prop.CR || aProp === prop.LF) {
    return true;
  }

  // GB5.
  if (bProp === prop.CONTROL || bProp === prop.CR || bProp === prop.LF) {
    return true;
  }

  // GB6.
  if (aProp === prop.L &&
      (bProp === prop.L || bProp === prop.V || bProp === prop.LV ||
       bProp === prop.LVT)) {
    return false;
  }

  // GB7.
  if ((aProp === prop.LV || aProp === prop.V) &&
      (bProp === prop.V || bProp === prop.T)) {
    return false;
  }

  // GB8.
  if ((aProp === prop.LVT || aProp === prop.T) && bProp === prop.T) {
    return false;
  }

  // GB9.
  if (bProp === prop.EXTEND || bProp === prop.ZWJ || bProp === prop.VIRAMA) {
    return false;
  }

  // GB9a, GB9b.
  if (extended && (aProp === prop.PREPEND || bProp === prop.SPACING_MARK)) {
    return false;
  }

  // Tailorings for basic aksara support.
  if (extended && aProp === prop.VIRAMA && bProp === prop.INDIC_LETTER) {
    return false;
  }

  var aStr, index, codePoint, codePointProp;

  // GB10.
  if (isString) {
    if (bProp === prop.E_MODIFIER) {
      // If using new API, consume the string's code points starting from the
      // end and test the left side of: (E_Base | EBG) Extend* × E_Modifier.
      aStr = /** @type {string} */ (a);
      index = aStr.length - 1;
      codePoint = aCode;
      codePointProp = aProp;
      while (index > 0 && codePointProp === prop.EXTEND) {
        index -= goog.i18n.uChar.charCount(codePoint);
        codePoint = goog.i18n.GraphemeBreak.getCodePoint_(aStr, index);
        codePointProp = goog.i18n.GraphemeBreak.getBreakProp_(codePoint);
      }
      if (codePointProp === prop.E_BASE || codePointProp === prop.E_BASE_GAZ) {
        return false;
      }
    }
  } else {
    // If using legacy API, return best effort by testing:
    // (E_Base | EBG) × E_Modifier.
    if ((aProp === prop.E_BASE || aProp === prop.E_BASE_GAZ) &&
        bProp === prop.E_MODIFIER) {
      return false;
    }
  }

  // GB11.
  if (aProp === prop.ZWJ &&
      (bProp === prop.GLUE_AFTER_ZWJ || bProp === prop.E_BASE_GAZ)) {
    return false;
  }

  // GB12, GB13.
  if (isString) {
    if (bProp === prop.REGIONAL_INDICATOR) {
      // If using new API, consume the string's code points starting from the
      // end and test the left side of these rules:
      // - sot (RI RI)* RI × RI
      // - [^RI] (RI RI)* RI × RI.
      var numberOfRi = 0;
      aStr = /** @type {string} */ (a);
      index = aStr.length - 1;
      codePoint = aCode;
      codePointProp = aProp;
      while (index > 0 && codePointProp === prop.REGIONAL_INDICATOR) {
        numberOfRi++;
        index -= goog.i18n.uChar.charCount(codePoint);
        codePoint = goog.i18n.GraphemeBreak.getCodePoint_(aStr, index);
        codePointProp = goog.i18n.GraphemeBreak.getBreakProp_(codePoint);
      }
      if (codePointProp === prop.REGIONAL_INDICATOR) {
        numberOfRi++;
      }
      if (numberOfRi % 2 === 1) {
        return false;
      }
    }
  } else {
    // If using legacy API, return best effort by testing: RI × RI.
    if (aProp === prop.REGIONAL_INDICATOR &&
        bProp === prop.REGIONAL_INDICATOR) {
      return false;
    }
  }

  // GB999.
  return true;
};


/**
 * Method to return property enum value of the code point. If it is Hangul LV or
 * LVT, then it is computed; for the rest it is picked from the inversion map.
 *
 * @param {number} codePoint The code point value of the character.
 * @return {number} Property enum value of code point.
 * @private
 */
goog.i18n.GraphemeBreak.getBreakProp_ = function(codePoint) {
  'use strict';
  if (0xAC00 <= codePoint && codePoint <= 0xD7A3) {
    var prop = goog.i18n.GraphemeBreak.property;
    if (codePoint % 0x1C === 0x10) {
      return prop.LV;
    }
    return prop.LVT;
  } else {
    if (!goog.i18n.GraphemeBreak.inversions_) {
      goog.i18n.GraphemeBreak.inversions_ = new goog.structs.InversionMap(
          [
            0,      10,   1,     2,   1,    18,   95,    33,    13,  1,
            594,    112,  275,   7,   263,  45,   1,     1,     1,   2,
            1,      2,    1,     1,   56,   6,    10,    11,    1,   1,
            46,     21,   16,    1,   101,  7,    1,     1,     6,   2,
            2,      1,    4,     33,  1,    1,    1,     30,    27,  91,
            11,     58,   9,     34,  4,    1,    9,     1,     3,   1,
            5,      43,   3,     120, 14,   1,    32,    1,     17,  37,
            1,      1,    1,     1,   3,    8,    4,     1,     2,   1,
            7,      8,    2,     2,   21,   7,    1,     1,     2,   17,
            39,     1,    1,     1,   2,    6,    6,     1,     9,   5,
            4,      2,    2,     12,  2,    15,   2,     1,     17,  39,
            2,      3,    12,    4,   8,    6,    17,    2,     3,   14,
            1,      17,   39,    1,   1,    3,    8,     4,     1,   20,
            2,      29,   1,     2,   17,   39,   1,     1,     2,   1,
            6,      6,    9,     6,   4,    2,    2,     13,    1,   16,
            1,      18,   41,    1,   1,    1,    12,    1,     9,   1,
            40,     1,    3,     17,  31,   1,    5,     4,     3,   5,
            7,      8,    3,     2,   8,    2,    29,    1,     2,   17,
            39,     1,    1,     1,   1,    2,    1,     3,     1,   5,
            1,      8,    9,     1,   3,    2,    29,    1,     2,   17,
            38,     3,    1,     2,   5,    7,    1,     1,     8,   1,
            10,     2,    30,    2,   22,   48,   5,     1,     2,   6,
            7,      1,    18,    2,   13,   46,   2,     1,     1,   1,
            6,      1,    12,    8,   50,   46,   2,     1,     1,   1,
            9,      11,   6,     14,  2,    58,   2,     27,    1,   1,
            1,      1,    1,     4,   2,    49,   14,    1,     4,   1,
            1,      2,    5,     48,  9,    1,    57,    33,    12,  4,
            1,      6,    1,     2,   2,    2,    1,     16,    2,   4,
            2,      2,    4,     3,   1,    3,    2,     7,     3,   4,
            13,     1,    1,     1,   2,    6,    1,     1,     14,  1,
            98,     96,   72,    88,  349,  3,    931,   15,    2,   1,
            14,     15,   2,     1,   14,   15,   2,     15,    15,  14,
            35,     17,   2,     1,   7,    8,    1,     2,     9,   1,
            1,      9,    1,     45,  3,    1,    118,   2,     34,  1,
            87,     28,   3,     3,   4,    2,    9,     1,     6,   3,
            20,     19,   29,    44,  84,   23,   2,     2,     1,   4,
            45,     6,    2,     1,   1,    1,    8,     1,     1,   1,
            2,      8,    6,     13,  48,   84,   1,     14,    33,  1,
            1,      5,    1,     1,   5,    1,    1,     1,     7,   31,
            9,      12,   2,     1,   7,    23,   1,     4,     2,   2,
            2,      2,    2,     11,  3,    2,    36,    2,     1,   1,
            2,      3,    1,     1,   3,    2,    12,    36,    8,   8,
            2,      2,    21,    3,   128,  3,    1,     13,    1,   7,
            4,      1,    4,     2,   1,    3,    2,     198,   64,  523,
            1,      1,    1,     2,   24,   7,    49,    16,    96,  33,
            1324,   1,    34,    1,   1,    1,    82,    2,     98,  1,
            14,     1,    1,     4,   86,   1,    1418,  3,     141, 1,
            96,     32,   554,   6,   105,  2,    30164, 4,     1,   10,
            32,     2,    80,    2,   272,  1,    3,     1,     4,   1,
            23,     2,    2,     1,   24,   30,   4,     4,     3,   8,
            1,      1,    13,    2,   16,   34,   16,    1,     1,   26,
            18,     24,   24,    4,   8,    2,    23,    11,    1,   1,
            12,     32,   3,     1,   5,    3,    3,     36,    1,   2,
            4,      2,    1,     3,   1,    36,   1,     32,    35,  6,
            2,      2,    2,     2,   12,   1,    8,     1,     1,   18,
            16,     1,    3,     6,   1,    1,    1,     3,     48,  1,
            1,      3,    2,     2,   5,    2,    1,     1,     32,  9,
            1,      2,    2,     5,   1,    1,    201,   14,    2,   1,
            1,      9,    8,     2,   1,    2,    1,     2,     1,   1,
            1,      18,   11184, 27,  49,   1028, 1024,  6942,  1,   737,
            16,     16,   16,    207, 1,    158,  2,     89,    3,   513,
            1,      226,  1,     149, 5,    1670, 15,    40,    7,   1,
            165,    2,    1305,  1,   1,    1,    53,    14,    1,   56,
            1,      2,    1,     45,  3,    4,    2,     1,     1,   2,
            1,      66,   3,     36,  5,    1,    6,     2,     62,  1,
            12,     2,    1,     48,  3,    9,    1,     1,     1,   2,
            6,      3,    95,    3,   3,    2,    1,     1,     2,   6,
            1,      160,  1,     3,   7,    1,    21,    2,     2,   56,
            1,      1,    1,     1,   1,    12,   1,     9,     1,   10,
            4,      15,   192,   3,   8,    2,    1,     2,     1,   1,
            105,    1,    2,     6,   1,    1,    2,     1,     1,   2,
            1,      1,    1,     235, 1,    2,    6,     4,     2,   1,
            1,      1,    27,    2,   82,   3,    8,     2,     1,   1,
            1,      1,    106,   1,   1,    1,    2,     6,     1,   1,
            101,    3,    2,     4,   1,    4,    1,     1283,  1,   14,
            1,      1,    82,    23,  1,    7,    1,     2,     1,   2,
            20025,  5,    59,    7,   1050, 62,   4,     19722, 2,   1,
            4,      5313, 1,     1,   3,    3,    1,     5,     8,   8,
            2,      7,    30,    4,   148,  3,    1979,  55,    4,   50,
            8,      1,    14,    1,   22,   1424, 2213,  7,     109, 7,
            2203,   26,   264,   1,   53,   1,    52,    1,     17,  1,
            13,     1,    16,    1,   3,    1,    25,    3,     2,   1,
            2,      3,    30,    1,   1,    1,    13,    5,     66,  2,
            2,      11,   21,    4,   4,    1,    1,     9,     3,   1,
            4,      3,    1,     3,   3,    1,    30,    1,     16,  2,
            106,    1,    4,     1,   71,   2,    4,     1,     21,  1,
            4,      2,    81,    1,   92,   3,    3,     5,     48,  1,
            17,     1,    16,    1,   16,   3,    9,     1,     11,  1,
            587,    5,    1,     1,   7,    1,    9,     10,    3,   2,
            788162, 31
          ],
          [
            1,  13, 1,  12, 1,  0, 1,  0, 1,  0,  2,  0, 2,  0, 2,  0,  2,  0,
            2,  0,  2,  0,  2,  0, 3,  0, 2,  0,  1,  0, 2,  0, 2,  0,  2,  3,
            0,  2,  0,  2,  0,  2, 0,  3, 0,  2,  0,  2, 0,  2, 0,  2,  0,  2,
            0,  2,  0,  2,  0,  2, 0,  2, 0,  2,  3,  2, 4,  0, 5,  2,  4,  2,
            0,  4,  2,  4,  6,  4, 0,  2, 5,  0,  2,  0, 5,  0, 2,  4,  0,  5,
            2,  0,  2,  4,  2,  4, 6,  0, 2,  5,  0,  2, 0,  5, 0,  2,  4,  0,
            5,  2,  4,  2,  6,  2, 5,  0, 2,  0,  2,  4, 0,  5, 2,  0,  4,  2,
            4,  6,  0,  2,  0,  2, 4,  0, 5,  2,  0,  2, 4,  2, 4,  6,  2,  5,
            0,  2,  0,  5,  0,  2, 0,  5, 2,  4,  2,  4, 6,  0, 2,  0,  2,  4,
            0,  5,  0,  5,  0,  2, 4,  2, 6,  2,  5,  0, 2,  0, 2,  4,  0,  5,
            2,  0,  4,  2,  4,  2, 4,  2, 4,  2,  6,  2, 5,  0, 2,  0,  2,  4,
            0,  5,  0,  2,  4,  2, 4,  6, 3,  0,  2,  0, 2,  0, 4,  0,  5,  6,
            2,  4,  2,  4,  2,  0, 4,  0, 5,  0,  2,  0, 4,  2, 6,  0,  2,  0,
            5,  0,  2,  0,  4,  2, 0,  2, 0,  5,  0,  2, 0,  2, 0,  2,  0,  2,
            0,  4,  5,  2,  4,  2, 6,  0, 2,  0,  2,  0, 2,  0, 5,  0,  2,  4,
            2,  0,  6,  4,  2,  5, 0,  5, 0,  4,  2,  5, 2,  5, 0,  5,  0,  5,
            2,  5,  2,  0,  4,  2, 0,  2, 5,  0,  2,  0, 7,  8, 9,  0,  2,  0,
            5,  2,  6,  0,  5,  2, 6,  0, 5,  2,  0,  5, 2,  5, 0,  2,  4,  2,
            4,  2,  4,  2,  6,  2, 0,  2, 0,  2,  1,  0, 2,  0, 2,  0,  5,  0,
            2,  4,  2,  4,  2,  4, 2,  0, 5,  0,  5,  0, 5,  2, 4,  2,  0,  5,
            0,  5,  4,  2,  4,  2, 6,  0, 2,  0,  2,  4, 2,  0, 2,  4,  0,  5,
            2,  4,  2,  4,  2,  4, 2,  4, 6,  5,  0,  2, 0,  2, 4,  0,  5,  4,
            2,  4,  2,  6,  2,  5, 0,  5, 0,  5,  0,  2, 4,  2, 4,  2,  4,  2,
            6,  0,  5,  4,  2,  4, 2,  0, 5,  0,  2,  0, 2,  4, 2,  0,  2,  0,
            4,  2,  0,  2,  0,  2, 0,  1, 2,  15, 1,  0, 1,  0, 1,  0,  2,  0,
            16, 0,  17, 0,  17, 0, 17, 0, 16, 0,  17, 0, 16, 0, 17, 0,  2,  0,
            6,  0,  2,  0,  2,  0, 2,  0, 2,  0,  2,  0, 2,  0, 2,  0,  2,  0,
            6,  5,  2,  5,  4,  2, 4,  0, 5,  0,  5,  0, 5,  0, 5,  0,  4,  0,
            5,  4,  6,  2,  0,  2, 0,  5, 0,  2,  0,  5, 2,  4, 6,  0,  7,  2,
            4,  0,  5,  0,  5,  2, 4,  2, 4,  2,  4,  6, 0,  2, 0,  5,  2,  4,
            2,  4,  2,  0,  2,  0, 2,  4, 0,  5,  0,  5, 0,  5, 0,  2,  0,  5,
            2,  0,  2,  0,  2,  0, 2,  0, 2,  0,  5,  4, 2,  4, 0,  4,  6,  0,
            5,  0,  5,  0,  5,  0, 4,  2, 4,  2,  4,  0, 4,  6, 0,  11, 8,  9,
            0,  2,  0,  2,  0,  2, 0,  2, 0,  1,  0,  2, 0,  1, 0,  2,  0,  2,
            0,  2,  0,  2,  0,  2, 6,  0, 2,  0,  4,  2, 4,  0, 2,  6,  0,  6,
            2,  4,  0,  4,  2,  4, 6,  2, 0,  3,  0,  2, 0,  2, 4,  2,  6,  0,
            2,  0,  2,  4,  0,  4, 2,  4, 6,  0,  3,  0, 2,  0, 4,  2,  4,  2,
            6,  2,  0,  2,  0,  2, 4,  2, 6,  0,  2,  4, 0,  2, 0,  2,  4,  2,
            4,  6,  0,  2,  0,  4, 2,  0, 4,  2,  4,  6, 2,  4, 2,  0,  2,  4,
            2,  4,  2,  4,  2,  4, 2,  4, 6,  2,  0,  2, 4,  2, 4,  2,  4,  6,
            2,  0,  2,  0,  4,  2, 4,  2, 4,  6,  2,  0, 2,  4, 2,  4,  2,  6,
            2,  0,  2,  4,  2,  4, 2,  6, 0,  4,  2,  4, 6,  0, 2,  4,  2,  4,
            2,  4,  2,  0,  2,  0, 2,  0, 4,  2,  0,  2, 0,  1, 0,  2,  4,  2,
            0,  4,  2,  1,  2,  0, 2,  0, 2,  0,  2,  0, 2,  0, 2,  0,  2,  0,
            2,  0,  2,  0,  2,  0, 2,  0, 14, 0,  17, 0, 17, 0, 17, 0,  16, 0,
            17, 0,  17, 0,  17, 0, 16, 0, 16, 0,  16, 0, 17, 0, 17, 0,  18, 0,
            16, 0,  16, 0,  19, 0, 16, 0, 16, 0,  16, 0, 16, 0, 16, 0,  17, 0,
            16, 0,  17, 0,  17, 0, 17, 0, 16, 0,  16, 0, 16, 0, 16, 0,  17, 0,
            16, 0,  16, 0,  17, 0, 17, 0, 16, 0,  16, 0, 16, 0, 16, 0,  16, 0,
            16, 0,  16, 0,  16, 0, 16, 0, 1,  2
          ],
          true);
    }
    return /** @type {number} */ (
        goog.i18n.GraphemeBreak.inversions_.at(codePoint));
  }
};

/**
 * Extracts a code point from a string at the specified index.
 *
 * @param {string} str
 * @param {number} index
 * @return {number} Extracted code point.
 * @private
 */
goog.i18n.GraphemeBreak.getCodePoint_ = function(str, index) {
  'use strict';
  var codePoint = goog.i18n.uChar.getCodePointAround(str, index);
  return (codePoint < 0) ? -codePoint : codePoint;
};

/**
 * Indicates if there is a grapheme cluster boundary between a and b.
 *
 * Legacy function. Does not cover cases where a sequence of code points is
 * required in order to decide if there is a grapheme cluster boundary, such as
 * emoji modifier sequences and emoji flag sequences. To cover all cases please
 * use `hasGraphemeBreakStrings`.
 *
 * There are two kinds of grapheme clusters: 1) Legacy 2) Extended. This method
 * is to check for both using a boolean flag to switch between them. If no flag
 * is provided rules for the extended clusters will be used by default.
 *
 * @param {number} a The code point value of the first character.
 * @param {number} b The code point value of the second character.
 * @param {boolean=} opt_extended If true, indicates extended grapheme cluster;
 *     If false, indicates legacy cluster. Default value is true.
 * @return {boolean} True if there is a grapheme cluster boundary between
 *     a and b; False otherwise.
 */
goog.i18n.GraphemeBreak.hasGraphemeBreak = function(a, b, opt_extended) {
  'use strict';
  return goog.i18n.GraphemeBreak.applyBreakRules_(a, b, opt_extended !== false);
};

/**
 * Indicates if there is a grapheme cluster boundary between a and b.
 *
 * There are two kinds of grapheme clusters: 1) Legacy 2) Extended. This method
 * is to check for both using a boolean flag to switch between them. If no flag
 * is provided rules for the extended clusters will be used by default.
 *
 * @param {string} a String with the first sequence of characters.
 * @param {string} b String with the second sequence of characters.
 * @param {boolean=} opt_extended If true, indicates extended grapheme cluster;
 *     If false, indicates legacy cluster. Default value is true.
 * @return {boolean} True if there is a grapheme cluster boundary between
 *     a and b; False otherwise.
 */
goog.i18n.GraphemeBreak.hasGraphemeBreakStrings = function(a, b, opt_extended) {
  'use strict';
  goog.asserts.assert(a !== undefined, 'First string should be defined.');
  goog.asserts.assert(b !== undefined, 'Second string should be defined.');

  // Break if any of the strings is empty.
  if (a.length === 0 || b.length === 0) {
    return true;
  }

  return goog.i18n.GraphemeBreak.applyBreakRules_(a, b, opt_extended !== false);
};

//third_party/javascript/closure/format/format.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides utility functions for formatting strings, numbers etc.
 */

goog.provide('goog.format');

goog.require('goog.i18n.GraphemeBreak');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Formats a number of bytes in human readable form.
 * 54, 450K, 1.3M, 5G etc.
 * @param {number} bytes The number of bytes to show.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @return {string} The human readable form of the byte size.
 */
goog.format.fileSize = function(bytes, opt_decimals) {
  'use strict';
  return goog.format.numBytesToString(bytes, opt_decimals, false);
};


/**
 * Checks whether string value containing scaling units (K, M, G, T, P, m,
 * u, n) can be converted to a number.
 *
 * Where there is a decimal, there must be a digit to the left of the
 * decimal point.
 *
 * Negative numbers are valid.
 *
 * Examples:
 *   0, 1, 1.0, 10.4K, 2.3M, -0.3P, 1.2m
 *
 * @param {string} val String value to check.
 * @return {boolean} True if string could be converted to a numeric value.
 */
goog.format.isConvertableScaledNumber = function(val) {
  'use strict';
  return goog.format.SCALED_NUMERIC_RE_.test(val);
};


/**
 * Converts a string to numeric value, taking into account the units.
 * If string ends in 'B', use binary conversion.
 * @param {string} stringValue String to be converted to numeric value.
 * @return {number} Numeric value for string.
 */
goog.format.stringToNumericValue = function(stringValue) {
  'use strict';
  if (goog.string.endsWith(stringValue, 'B')) {
    return goog.format.stringToNumericValue_(
        stringValue, goog.format.NUMERIC_SCALES_BINARY_);
  }
  return goog.format.stringToNumericValue_(
      stringValue, goog.format.NUMERIC_SCALES_SI_);
};


/**
 * Converts a string to number of bytes, taking into account the units.
 * Binary conversion.
 * @param {string} stringValue String to be converted to numeric value.
 * @return {number} Numeric value for string.
 */
goog.format.stringToNumBytes = function(stringValue) {
  'use strict';
  return goog.format.stringToNumericValue_(
      stringValue, goog.format.NUMERIC_SCALES_BINARY_);
};


/**
 * Converts a numeric value to string representation. SI conversion.
 * @param {number} val Value to be converted.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @return {string} String representation of number.
 */
goog.format.numericValueToString = function(val, opt_decimals) {
  'use strict';
  return goog.format.numericValueToString_(
      val, goog.format.NUMERIC_SCALES_SI_, opt_decimals);
};


/**
 * Converts number of bytes to string representation. Binary conversion.
 * Default is to return the additional 'B' suffix only for scales greater than
 * 1K, e.g. '10.5KB' to minimize confusion with counts that are scaled by powers
 * of 1000. Otherwise, suffix is empty string.
 * @param {number} val Value to be converted.
 * @param {number=} opt_decimals The number of decimals to use.  Defaults to 2.
 * @param {boolean=} opt_suffix If true, include trailing 'B' in returned
 *     string.  Default is true.
 * @param {boolean=} opt_useSeparator If true, number and scale will be
 *     separated by a no break space. Default is false.
 * @return {string} String representation of number of bytes.
 */
goog.format.numBytesToString = function(
    val, opt_decimals, opt_suffix, opt_useSeparator) {
  'use strict';
  var suffix = '';
  if (opt_suffix === undefined || opt_suffix) {
    suffix = 'B';
  }
  return goog.format.numericValueToString_(
      val, goog.format.NUMERIC_SCALES_BINARY_, opt_decimals, suffix,
      opt_useSeparator);
};


/**
 * Converts a string to numeric value, taking into account the units.
 * @param {string} stringValue String to be converted to numeric value.
 * @param {Object} conversion Dictionary of conversion scales.
 * @return {number} Numeric value for string.  If it cannot be converted,
 *    returns NaN.
 * @private
 */
goog.format.stringToNumericValue_ = function(stringValue, conversion) {
  'use strict';
  var match = stringValue.match(goog.format.SCALED_NUMERIC_RE_);
  if (!match) {
    // Parse signed `Infinity`, `NaN`, or scientific notation.
    return Number(stringValue);
  }
  var val = Number(match[1]) * conversion[match[2]];
  return val;
};


/**
 * Converts a numeric value to string, using specified conversion
 * scales.
 * @param {number} val Value to be converted.
 * @param {Object} conversion Dictionary of scaling factors.
 * @param {number=} opt_decimals The number of decimals to use.  Default is 2.
 * @param {string=} opt_suffix Optional suffix to append.
 * @param {boolean=} opt_useSeparator If true, number and scale will be
 *     separated by a space. Default is false.
 * @return {string} The human readable form of the byte size.
 * @private
 */
goog.format.numericValueToString_ = function(
    val, conversion, opt_decimals, opt_suffix, opt_useSeparator) {
  'use strict';
  var prefixes = goog.format.NUMERIC_SCALE_PREFIXES_;
  var origVal = val;
  var symbol = '';
  var separator = '';
  var scale = 1;
  if (val < 0) {
    val = -val;
  }
  if (val === Infinity) return (Infinity * Math.sign(origVal)).toString();
  for (var i = 0; i < prefixes.length; i++) {
    var unit = prefixes[i];
    scale = conversion[unit];
    if (val >= scale || (scale <= 1 && val > 0.1 * scale)) {
      // Treat values less than 1 differently, allowing 0.5 to be "0.5" rather
      // than "500m"
      symbol = unit;
      break;
    }
  }
  if (!symbol) {
    scale = 1;
  } else {
    if (opt_suffix) {
      symbol += opt_suffix;
    }
    if (opt_useSeparator) {
      separator = ' ';
    }
  }
  var ex = Math.pow(10, opt_decimals !== undefined ? opt_decimals : 2);
  return Math.round(origVal / scale * ex) / ex + separator + symbol;
};


/**
 * Regular expression for detecting scaling units, such as K, M, G, etc. for
 * converting a string representation to a numeric value.
 *
 * Also allow 'k' to be aliased to 'K'.  These could be used for SI (powers
 * of 1000) or Binary (powers of 1024) conversions.
 *
 * Also allow final 'B' to be interpreted as byte-count, implicitly triggering
 * binary conversion (e.g., '10.2MB').
 *
 * @type {RegExp}
 * @private
 */
goog.format.SCALED_NUMERIC_RE_ = /^(-?\d+\.?\d*)([KMGTPEZYkmun]?)B?$/;


/**
 * Ordered list of scaling prefixes in decreasing order.
 * @private {Array<string>}
 */
goog.format.NUMERIC_SCALE_PREFIXES_ =
    ['Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'K', '', 'm', 'u', 'n'];


/**
 * Scaling factors for conversion of numeric value to string.  SI conversion.
 * @type {Object}
 * @private
 */
goog.format.NUMERIC_SCALES_SI_ = {
  '': 1,
  'n': 1e-9,
  'u': 1e-6,
  'm': 1e-3,
  'k': 1e3,
  'K': 1e3,
  'M': 1e6,
  'G': 1e9,
  'T': 1e12,
  'P': 1e15,
  'E': 1e18,
  'Z': 1e21,
  'Y': 1e24
};


/**
 * Scaling factors for conversion of numeric value to string.  Binary
 * conversion.
 * @type {Object}
 * @private
 */
goog.format.NUMERIC_SCALES_BINARY_ = {
  '': 1,
  'n': Math.pow(1024, -3),
  'u': Math.pow(1024, -2),
  'm': 1.0 / 1024,
  'k': 1024,
  'K': 1024,
  'M': Math.pow(1024, 2),
  'G': Math.pow(1024, 3),
  'T': Math.pow(1024, 4),
  'P': Math.pow(1024, 5),
  'E': Math.pow(1024, 6),
  'Z': Math.pow(1024, 7),
  'Y': Math.pow(1024, 8)
};


/**
 * First Unicode code point that has the Mark property.
 * @type {number}
 * @private
 */
goog.format.FIRST_GRAPHEME_EXTEND_ = 0x300;


/**
 * Returns true if and only if given character should be treated as a breaking
 * space. All ASCII control characters, the main Unicode range of spacing
 * characters (U+2000 to U+200B inclusive except for U+2007), and several other
 * Unicode space characters are treated as breaking spaces.
 * @param {number} charCode The character code under consideration.
 * @return {boolean} True if the character is a breaking space.
 * @private
 */
goog.format.isTreatedAsBreakingSpace_ = function(charCode) {
  'use strict';
  return (charCode <= goog.format.WbrToken_.SPACE) ||
      (charCode >= 0x1000 &&
       ((charCode >= 0x2000 && charCode <= 0x2006) ||
        (charCode >= 0x2008 && charCode <= 0x200B) || charCode == 0x1680 ||
        charCode == 0x180E || charCode == 0x2028 || charCode == 0x2029 ||
        charCode == 0x205f || charCode == 0x3000));
};


/**
 * Returns true if and only if given character is an invisible formatting
 * character.
 * @param {number} charCode The character code under consideration.
 * @return {boolean} True if the character is an invisible formatting character.
 * @private
 */
goog.format.isInvisibleFormattingCharacter_ = function(charCode) {
  'use strict';
  // See: http://unicode.org/charts/PDF/U2000.pdf
  return (charCode >= 0x200C && charCode <= 0x200F) ||
      (charCode >= 0x202A && charCode <= 0x202E);
};


/**
 * Inserts word breaks into an HTML string at a given interval.  The counter is
 * reset if a space or a character which behaves like a space is encountered,
 * but it isn't incremented if an invisible formatting character is encountered.
 * WBRs aren't inserted into HTML tags or entities.  Entities count towards the
 * character count, HTML tags do not.
 *
 * With common strings aliased, objects allocations are constant based on the
 * length of the string: N + 3. This guarantee does not hold if the string
 * contains an element >= U+0300 and hasGraphemeBreak is non-trivial.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {function(number, number, boolean): boolean} hasGraphemeBreak A
 *     function determining if there is a grapheme break between two characters,
 *     in the same signature as goog.i18n.GraphemeBreak.hasGraphemeBreak.
 * @param {number=} opt_maxlen Maximum length after which to ensure
 *     there is a break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 * @private
 */
goog.format.insertWordBreaksGeneric_ = function(
    str, hasGraphemeBreak, opt_maxlen) {
  'use strict';
  var maxlen = opt_maxlen || 10;
  if (maxlen > str.length) return str;

  var rv = [];
  var n = 0;  // The length of the current token

  // This will contain the ampersand or less-than character if one of the
  // two has been seen; otherwise, the value is zero.
  var nestingCharCode = 0;

  // First character position from input string that has not been outputted.
  var lastDumpPosition = 0;

  var charCode = 0;
  for (var i = 0; i < str.length; i++) {
    // Using charCodeAt versus charAt avoids allocating new string objects.
    var lastCharCode = charCode;
    charCode = str.charCodeAt(i);

    // Don't add a WBR before characters that might be grapheme extending.
    var isPotentiallyGraphemeExtending =
        charCode >= goog.format.FIRST_GRAPHEME_EXTEND_ &&
        !hasGraphemeBreak(lastCharCode, charCode, true);

    // Don't add a WBR at the end of a word. For the purposes of determining
    // work breaks, all ASCII control characters and some commonly encountered
    // Unicode spacing characters are treated as breaking spaces.
    if (n >= maxlen && !goog.format.isTreatedAsBreakingSpace_(charCode) &&
        !isPotentiallyGraphemeExtending) {
      // Flush everything seen so far, and append a word break.
      rv.push(str.substring(lastDumpPosition, i), goog.format.WORD_BREAK_HTML);
      lastDumpPosition = i;
      n = 0;
    }

    if (!nestingCharCode) {
      // Not currently within an HTML tag or entity

      if (charCode == goog.format.WbrToken_.LT ||
          charCode == goog.format.WbrToken_.AMP) {
        // Entering an HTML Entity '&' or open tag '<'
        nestingCharCode = charCode;
      } else if (goog.format.isTreatedAsBreakingSpace_(charCode)) {
        // A space or control character -- reset the token length
        n = 0;
      } else if (!goog.format.isInvisibleFormattingCharacter_(charCode)) {
        // A normal flow character - increment.  For grapheme extending
        // characters, this is not *technically* a new character.  However,
        // since the grapheme break detector might be overly conservative,
        // we have to continue incrementing, or else we won't even be able
        // to add breaks when we get to things like punctuation.  For the
        // case where we have a full grapheme break detector, it is okay if
        // we occasionally break slightly early.
        n++;
      }
    } else if (
        charCode == goog.format.WbrToken_.GT &&
        nestingCharCode == goog.format.WbrToken_.LT) {
      // Leaving an HTML tag, treat the tag as zero-length
      nestingCharCode = 0;
    } else if (
        charCode == goog.format.WbrToken_.SEMI_COLON &&
        nestingCharCode == goog.format.WbrToken_.AMP) {
      // Leaving an HTML entity, treat it as length one
      nestingCharCode = 0;
      n++;
    }
  }

  // Take care of anything we haven't flushed so far.
  rv.push(str.substr(lastDumpPosition));

  return rv.join('');
};


/**
 * Inserts word breaks into an HTML string at a given interval.
 *
 * This method is as aggressive as possible, using a full table of Unicode
 * characters where it is legal to insert word breaks; however, this table
 * comes at a 2.5k pre-gzip (~1k post-gzip) size cost.  Consider using
 * insertWordBreaksBasic to minimize the size impact.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {number=} opt_maxlen Maximum length after which to ensure there is a
 *     break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 * @deprecated Prefer wrapping with CSS word-wrap: break-word.
 */
goog.format.insertWordBreaks = function(str, opt_maxlen) {
  'use strict';
  return goog.format.insertWordBreaksGeneric_(
      str, goog.i18n.GraphemeBreak.hasGraphemeBreak, opt_maxlen);
};


/**
 * Determines conservatively if a character has a Grapheme break.
 *
 * Conforms to a similar signature as goog.i18n.GraphemeBreak, but is overly
 * conservative, returning true only for characters in common scripts that
 * are simple to account for.
 *
 * @param {number} lastCharCode The previous character code.  Ignored.
 * @param {number} charCode The character code under consideration.  It must be
 *     at least \u0300 as a precondition -- this case is covered by
 *     insertWordBreaksGeneric_.
 * @param {boolean=} opt_extended Ignored, to conform with the interface.
 * @return {boolean} Whether it is one of the recognized subsets of characters
 *     with a grapheme break.
 * @private
 */
goog.format.conservativelyHasGraphemeBreak_ = function(
    lastCharCode, charCode, opt_extended) {
  'use strict';
  // Return false for everything except the most common Cyrillic characters.
  // Don't worry about Latin characters, because insertWordBreaksGeneric_
  // itself already handles those.
  // TODO(gboyer): Also account for Greek, Armenian, and Georgian if it is
  // simple to do so.
  return charCode >= 0x400 && charCode < 0x523;
};


// TODO(gboyer): Consider using a compile-time flag to switch implementations
// rather than relying on the developers to toggle implementations.
/**
 * Inserts word breaks into an HTML string at a given interval.
 *
 * This method is less aggressive than insertWordBreaks, only inserting
 * breaks next to punctuation and between Latin or Cyrillic characters.
 * However, this is good enough for the common case of URLs.  It also
 * works for all Latin and Cyrillic languages, plus CJK has no need for word
 * breaks.  When this method is used, goog.i18n.GraphemeBreak may be dead
 * code eliminated.
 *
 * @param {string} str HTML to insert word breaks into.
 * @param {number=} opt_maxlen Maximum length after which to ensure there is a
 *     break.  Default is 10 characters.
 * @return {string} The string including word breaks.
 * @deprecated Prefer wrapping with CSS word-wrap: break-word.
 */
goog.format.insertWordBreaksBasic = function(str, opt_maxlen) {
  'use strict';
  return goog.format.insertWordBreaksGeneric_(
      str, goog.format.conservativelyHasGraphemeBreak_, opt_maxlen);
};


/**
 * True iff the current userAgent is IE8 or above.
 * @type {boolean}
 * @private
 */
goog.format.IS_IE8_OR_ABOVE_ = goog.userAgent.IE;


/**
 * Constant for the WBR replacement used by insertWordBreaks.  Safari requires
 * &lt;wbr&gt;&lt;/wbr&gt;, Opera needs the &shy; entity, though this will give
 * a visible hyphen at breaks.  IE8 uses a zero width space. Other browsers just
 * use &lt;wbr&gt;.
 * @type {string}
 */
goog.format.WORD_BREAK_HTML = goog.userAgent.WEBKIT ? '<wbr></wbr>' :
    goog.format.IS_IE8_OR_ABOVE_                    ? '&#8203;' :
                                                      '<wbr>';


/**
 * Tokens used within insertWordBreaks.
 * @private
 * @enum {number}
 */
goog.format.WbrToken_ = {
  LT: 60,          // '<'.charCodeAt(0)
  GT: 62,          // '>'.charCodeAt(0)
  AMP: 38,         // '&'.charCodeAt(0)
  SEMI_COLON: 59,  // ';'.charCodeAt(0)
  SPACE: 32        // ' '.charCodeAt(0)
};

//third_party/javascript/closure/i18n/bidiformatter.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utility for formatting text for display in a potentially
 * opposite-directionality context without garbling.
 * Mostly a port of http://go/formatter.cc.
 */


goog.provide('goog.i18n.BidiFormatter');

goog.require('goog.html.SafeHtml');
goog.require('goog.i18n.bidi');
goog.require('goog.i18n.bidi.Dir');
goog.require('goog.i18n.bidi.Format');



/**
 * Utility class for formatting text for display in a potentially
 * opposite-directionality context without garbling. Provides the following
 * functionality:
 *
 * 1. BiDi Wrapping
 * When text in one language is mixed into a document in another, opposite-
 * directionality language, e.g. when an English business name is embedded in a
 * Hebrew web page, both the inserted string and the text following it may be
 * displayed incorrectly unless the inserted string is explicitly separated
 * from the surrounding text in a "wrapper" that declares its directionality at
 * the start and then resets it back at the end. This wrapping can be done in
 * HTML mark-up (e.g. a 'span dir="rtl"' tag) or - only in contexts where
 * mark-up can not be used - in Unicode BiDi formatting codes (LRE|RLE and PDF).
 * Providing such wrapping services is the basic purpose of the BiDi formatter.
 *
 * 2. Directionality estimation
 * How does one know whether a string about to be inserted into surrounding
 * text has the same directionality? Well, in many cases, one knows that this
 * must be the case when writing the code doing the insertion, e.g. when a
 * localized message is inserted into a localized page. In such cases there is
 * no need to involve the BiDi formatter at all. In the remaining cases, e.g.
 * when the string is user-entered or comes from a database, the language of
 * the string (and thus its directionality) is not known a priori, and must be
 * estimated at run-time. The BiDi formatter does this automatically.
 *
 * 3. Escaping
 * When wrapping plain text - i.e. text that is not already HTML or HTML-
 * escaped - in HTML mark-up, the text must first be HTML-escaped to prevent XSS
 * attacks and other nasty business. This of course is always true, but the
 * escaping can not be done after the string has already been wrapped in
 * mark-up, so the BiDi formatter also serves as a last chance and includes
 * escaping services.
 *
 * Thus, in a single call, the formatter will escape the input string as
 * specified, determine its directionality, and wrap it as necessary. It is
 * then up to the caller to insert the return value in the output.
 *
 * See http://wiki/Main/TemplatesAndBiDi for more information.
 *
 * @param {goog.i18n.bidi.Dir|number|boolean|null} contextDir The context
 *     directionality, in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant. NEUTRAL is treated the same as null,
 *        i.e. unknown, for backward compatibility with legacy calls.
 *     2. A number (positive = LTR, negative = RTL, 0 = unknown).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 * @param {boolean=} opt_alwaysSpan Whether {@link #spanWrap} should always
 *     use a 'span' tag, even when the input directionality is neutral or
 *     matches the context, so that the DOM structure of the output does not
 *     depend on the combination of directionalities. Default: false.
 * @constructor
 * @final
 */
goog.i18n.BidiFormatter = function(contextDir, opt_alwaysSpan) {
  'use strict';
  /**
   * The overall directionality of the context in which the formatter is being
   * used.
   * @type {?goog.i18n.bidi.Dir}
   * @private
   */
  this.contextDir_ = goog.i18n.bidi.toDir(contextDir, true /* opt_noNeutral */);

  /**
   * Whether {@link #spanWrap} and similar methods should always use the same
   * span structure, regardless of the combination of directionalities, for a
   * stable DOM structure.
   * @type {boolean}
   * @private
   */
  this.alwaysSpan_ = !!opt_alwaysSpan;
};


/**
 * @return {?goog.i18n.bidi.Dir} The context directionality.
 */
goog.i18n.BidiFormatter.prototype.getContextDir = function() {
  'use strict';
  return this.contextDir_;
};


/**
 * @return {boolean} Whether alwaysSpan is set.
 */
goog.i18n.BidiFormatter.prototype.getAlwaysSpan = function() {
  'use strict';
  return this.alwaysSpan_;
};


/**
 * @param {goog.i18n.bidi.Dir|number|boolean|null} contextDir The context
 *     directionality, in one of the following formats:
 *     1. A goog.i18n.bidi.Dir constant. NEUTRAL is treated the same as null,
 *        i.e. unknown.
 *     2. A number (positive = LTR, negative = RTL, 0 = unknown).
 *     3. A boolean (true = RTL, false = LTR).
 *     4. A null for unknown directionality.
 */
goog.i18n.BidiFormatter.prototype.setContextDir = function(contextDir) {
  'use strict';
  this.contextDir_ = goog.i18n.bidi.toDir(contextDir, true /* opt_noNeutral */);
};


/**
 * @param {boolean} alwaysSpan Whether {@link #spanWrap} should always use a
 *     'span' tag, even when the input directionality is neutral or matches the
 *     context, so that the DOM structure of the output does not depend on the
 *     combination of directionalities.
 */
goog.i18n.BidiFormatter.prototype.setAlwaysSpan = function(alwaysSpan) {
  'use strict';
  this.alwaysSpan_ = alwaysSpan;
};


/**
 * Returns the directionality of input argument `str`.
 * Identical to {@link goog.i18n.bidi.estimateDirection}.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of `str`.
 */
goog.i18n.BidiFormatter.prototype.estimateDirection =
    goog.i18n.bidi.estimateDirection;


/**
 * Returns true if two given directionalities are opposite.
 * Note: the implementation is based on the numeric values of the Dir enum.
 *
 * @param {?goog.i18n.bidi.Dir} dir1 1st directionality.
 * @param {?goog.i18n.bidi.Dir} dir2 2nd directionality.
 * @return {boolean} Whether the directionalities are opposite.
 * @private
 */
goog.i18n.BidiFormatter.prototype.areDirectionalitiesOpposite_ = function(
    dir1, dir2) {
  'use strict';
  return Number(dir1) * Number(dir2) < 0;
};


/**
 * Returns a unicode BiDi mark matching the context directionality (LRM or
 * RLM) if `opt_dirReset`, and if either the directionality or the exit
 * directionality of `str` is opposite to the context directionality.
 * Otherwise returns the empty string.
 *
 * @param {string} str The input text.
 * @param {goog.i18n.bidi.Dir} dir `str`'s overall directionality.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to perform the reset. Default: false.
 * @return {string} A unicode BiDi mark or the empty string.
 * @private
 */
goog.i18n.BidiFormatter.prototype.dirResetIfNeeded_ = function(
    str, dir, opt_isHtml, opt_dirReset) {
  'use strict';
  // endsWithRtl and endsWithLtr are called only if needed (short-circuit).
  if (opt_dirReset &&
      (this.areDirectionalitiesOpposite_(dir, this.contextDir_) ||
       (this.contextDir_ == goog.i18n.bidi.Dir.LTR &&
        goog.i18n.bidi.endsWithRtl(str, opt_isHtml)) ||
       (this.contextDir_ == goog.i18n.bidi.Dir.RTL &&
        goog.i18n.bidi.endsWithLtr(str, opt_isHtml)))) {
    return this.contextDir_ == goog.i18n.bidi.Dir.LTR ?
        goog.i18n.bidi.Format.LRM :
        goog.i18n.bidi.Format.RLM;
  } else {
    return '';
  }
};


/**
 * Returns "rtl" if `str`'s estimated directionality is RTL, and "ltr" if
 * it is LTR. In case it's NEUTRAL, returns "rtl" if the context directionality
 * is RTL, and "ltr" otherwise.
 * Needed for GXP, which can't handle dirAttr.
 * Example use case:
 * &lt;td expr:dir='bidiFormatter.dirAttrValue(foo)'&gt;
 *   &lt;gxp:eval expr='foo'&gt;
 * &lt;/td&gt;
 *
 * @param {string} str Text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} "rtl" or "ltr", according to the logic described above.
 */
goog.i18n.BidiFormatter.prototype.dirAttrValue = function(str, opt_isHtml) {
  'use strict';
  return this.knownDirAttrValue(this.estimateDirection(str, opt_isHtml));
};


/**
 * Returns "rtl" if the given directionality is RTL, and "ltr" if it is LTR. In
 * case it's NEUTRAL, returns "rtl" if the context directionality is RTL, and
 * "ltr" otherwise.
 *
 * @param {goog.i18n.bidi.Dir} dir A directionality.
 * @return {string} "rtl" or "ltr", according to the logic described above.
 */
goog.i18n.BidiFormatter.prototype.knownDirAttrValue = function(dir) {
  'use strict';
  var resolvedDir = dir == goog.i18n.bidi.Dir.NEUTRAL ? this.contextDir_ : dir;
  return resolvedDir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on `str`'s estimated
 * directionality, if it is not the same as the context directionality.
 * Otherwise, returns the empty string.
 *
 * @param {string} str Text whose directionality is to be estimated.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} 'dir="rtl"' for RTL text in non-RTL context; 'dir="ltr"' for
 *     LTR text in non-LTR context; else, the empty string.
 */
goog.i18n.BidiFormatter.prototype.dirAttr = function(str, opt_isHtml) {
  'use strict';
  return this.knownDirAttr(this.estimateDirection(str, opt_isHtml));
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on the given directionality, if
 * it is not the same as the context directionality. Otherwise, returns the
 * empty string.
 *
 * @param {goog.i18n.bidi.Dir} dir A directionality.
 * @return {string} 'dir="rtl"' for RTL text in non-RTL context; 'dir="ltr"' for
 *     LTR text in non-LTR context; else, the empty string.
 */
goog.i18n.BidiFormatter.prototype.knownDirAttr = function(dir) {
  'use strict';
  if (dir != this.contextDir_) {
    return dir == goog.i18n.bidi.Dir.RTL ?
        'dir="rtl"' :
        dir == goog.i18n.bidi.Dir.LTR ? 'dir="ltr"' : '';
  }
  return '';
};


/**
 * Formats a string of unknown directionality for use in HTML output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * The algorithm: estimates the directionality of input argument `html`.
 * In case its directionality doesn't match the context directionality, wraps it
 * with a 'span' tag and adds a "dir" attribute (either 'dir="rtl"' or
 * 'dir="ltr"'). If setAlwaysSpan(true) was used, the input is always wrapped
 * with 'span', skipping just the dir attribute when it's not needed.
 *
 * If `opt_dirReset`, and if the overall directionality or the exit
 * directionality of `str` are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appened
 * (LRM or RLM).
 *
 * @param {!goog.html.SafeHtml} html The input HTML.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `html`. Default: true.
 * @return {!goog.html.SafeHtml} Input text after applying the processing.
 */
goog.i18n.BidiFormatter.prototype.spanWrapSafeHtml = function(
    html, opt_dirReset) {
  'use strict';
  return this.spanWrapSafeHtmlWithKnownDir(null, html, opt_dirReset);
};


/**
 * Formats a string of given directionality for use in HTML output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * The algorithm: If `dir` doesn't match the context directionality, wraps
 * `html` with a 'span' tag and adds a "dir" attribute (either 'dir="rtl"'
 * or 'dir="ltr"'). If setAlwaysSpan(true) was used, the input is always wrapped
 * with 'span', skipping just the dir attribute when it's not needed.
 *
 * If `opt_dirReset`, and if `dir` or the exit directionality of
 * `html` are opposite to the context directionality, a trailing unicode
 * BiDi mark matching the context directionality is appened (LRM or RLM).
 *
 * @param {?goog.i18n.bidi.Dir} dir `html`'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {!goog.html.SafeHtml} html The input HTML.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `html`. Default: true.
 * @return {!goog.html.SafeHtml} Input text after applying the processing.
 */
goog.i18n.BidiFormatter.prototype.spanWrapSafeHtmlWithKnownDir = function(
    dir, html, opt_dirReset) {
  'use strict';
  if (dir == null) {
    dir = this.estimateDirection(goog.html.SafeHtml.unwrap(html), true);
  }
  return this.spanWrapWithKnownDir_(dir, html, opt_dirReset);
};


/**
 * The internal implementation of spanWrapSafeHtmlWithKnownDir for non-null dir,
 * to help the compiler optimize.
 *
 * @param {goog.i18n.bidi.Dir} dir `str`'s overall directionality.
 * @param {!goog.html.SafeHtml} html The input HTML.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `str`. Default: true.
 * @return {!goog.html.SafeHtml} Input text after applying the above processing.
 * @private
 */
goog.i18n.BidiFormatter.prototype.spanWrapWithKnownDir_ = function(
    dir, html, opt_dirReset) {
  'use strict';
  opt_dirReset = opt_dirReset || (opt_dirReset == undefined);

  var result;
  // Whether to add the "dir" attribute.
  var dirCondition =
      dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_;
  if (this.alwaysSpan_ || dirCondition) {  // Wrap is needed
    var dirAttribute;
    if (dirCondition) {
      dirAttribute = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
    }
    result = goog.html.SafeHtml.create('span', {'dir': dirAttribute}, html);
  } else {
    result = html;
  }
  var str = goog.html.SafeHtml.unwrap(html);
  result = goog.html.SafeHtml.concatWithDir(
      goog.i18n.bidi.Dir.NEUTRAL, result,
      this.dirResetIfNeeded_(str, dir, true, opt_dirReset));
  return result;
};


/**
 * Formats a string of unknown directionality for use in plain-text output of
 * the context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * As opposed to {@link #spanWrap}, this makes use of unicode BiDi formatting
 * characters. In HTML, its *only* valid use is inside of elements that do not
 * allow mark-up, e.g. an 'option' tag.
 * The algorithm: estimates the directionality of input argument `str`.
 * In case it doesn't match  the context directionality, wraps it with Unicode
 * BiDi formatting characters: RLE`str`PDF for RTL text, and
 * LRE`str`PDF for LTR text.
 *
 * If `opt_dirReset`, and if the overall directionality or the exit
 * directionality of `str` are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appended
 * (LRM or RLM).
 *
 * Does *not* do HTML-escaping regardless of the value of `opt_isHtml`.
 * The return value can be HTML-escaped as necessary.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `str`. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.unicodeWrap = function(
    str, opt_isHtml, opt_dirReset) {
  'use strict';
  return this.unicodeWrapWithKnownDir(null, str, opt_isHtml, opt_dirReset);
};


/**
 * Formats a string of given directionality for use in plain-text output of the
 * context directionality, so an opposite-directionality string is neither
 * garbled nor garbles what follows it.
 * As opposed to {@link #spanWrapWithKnownDir}, makes use of unicode BiDi
 * formatting characters. In HTML, its *only* valid use is inside of elements
 * that do not allow mark-up, e.g. an 'option' tag.
 * The algorithm: If `dir` doesn't match the context directionality, wraps
 * `str` with Unicode BiDi formatting characters: RLE`str`PDF for
 * RTL text, and LRE`str`PDF for LTR text.
 *
 * If `opt_dirReset`, and if the overall directionality or the exit
 * directionality of `str` are opposite to the context directionality, a
 * trailing unicode BiDi mark matching the context directionality is appended
 * (LRM or RLM).
 *
 * Does *not* do HTML-escaping regardless of the value of `opt_isHtml`.
 * The return value can be HTML-escaped as necessary.
 *
 * @param {?goog.i18n.bidi.Dir} dir `str`'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `str`. Default: true.
 * @return {string} Input text after applying the above processing.
 */
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir = function(
    dir, str, opt_isHtml, opt_dirReset) {
  'use strict';
  if (dir == null) {
    dir = this.estimateDirection(str, opt_isHtml);
  }
  return this.unicodeWrapWithKnownDir_(dir, str, opt_isHtml, opt_dirReset);
};


/**
 * The internal implementation of unicodeWrapWithKnownDir for non-null dir, to
 * help the compiler optimize.
 *
 * @param {goog.i18n.bidi.Dir} dir `str`'s overall directionality.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @param {boolean=} opt_dirReset Whether to append a trailing unicode bidi mark
 *     matching the context directionality, when needed, to prevent the possible
 *     garbling of whatever may follow `str`. Default: true.
 * @return {string} Input text after applying the above processing.
 * @private
 */
goog.i18n.BidiFormatter.prototype.unicodeWrapWithKnownDir_ = function(
    dir, str, opt_isHtml, opt_dirReset) {
  'use strict';
  opt_dirReset = opt_dirReset || (opt_dirReset == undefined);
  var result = [];
  if (dir != goog.i18n.bidi.Dir.NEUTRAL && dir != this.contextDir_) {
    result.push(
        dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.Format.RLE :
                                        goog.i18n.bidi.Format.LRE);
    result.push(str);
    result.push(goog.i18n.bidi.Format.PDF);
  } else {
    result.push(str);
  }

  result.push(this.dirResetIfNeeded_(str, dir, opt_isHtml, opt_dirReset));
  return result.join('');
};


/**
 * Returns a Unicode BiDi mark matching the context directionality (LRM or RLM)
 * if the directionality or the exit directionality of `str` are opposite
 * to the context directionality. Otherwise returns the empty string.
 *
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching the global directionality or
 *     the empty string.
 */
goog.i18n.BidiFormatter.prototype.markAfter = function(str, opt_isHtml) {
  'use strict';
  return this.markAfterKnownDir(null, str, opt_isHtml);
};


/**
 * Returns a Unicode BiDi mark matching the context directionality (LRM or RLM)
 * if the given directionality or the exit directionality of `str` are
 * opposite to the context directionality. Otherwise returns the empty string.
 *
 * @param {?goog.i18n.bidi.Dir} dir `str`'s overall directionality, or
 *     null if unknown and needs to be estimated.
 * @param {string} str The input text.
 * @param {boolean=} opt_isHtml Whether `str` is HTML / HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching the global directionality or
 *     the empty string.
 */
goog.i18n.BidiFormatter.prototype.markAfterKnownDir = function(
    dir, str, opt_isHtml) {
  'use strict';
  if (dir == null) {
    dir = this.estimateDirection(str, opt_isHtml);
  }
  return this.dirResetIfNeeded_(str, dir, opt_isHtml, true);
};


/**
 * Returns the Unicode BiDi mark matching the context directionality (LRM for
 * LTR context directionality, RLM for RTL context directionality), or the
 * empty string for neutral / unknown context directionality.
 *
 * @return {string} LRM for LTR context directionality and RLM for RTL context
 *     directionality.
 */
goog.i18n.BidiFormatter.prototype.mark = function() {
  'use strict';
  switch (this.contextDir_) {
    case (goog.i18n.bidi.Dir.LTR):
      return goog.i18n.bidi.Format.LRM;
    case (goog.i18n.bidi.Dir.RTL):
      return goog.i18n.bidi.Format.RLM;
    default:
      return '';
  }
};


/**
 * Returns 'right' for RTL context directionality. Otherwise (LTR or neutral /
 * unknown context directionality) returns 'left'.
 *
 * @return {string} 'right' for RTL context directionality and 'left' for other
 *     context directionality.
 */
goog.i18n.BidiFormatter.prototype.startEdge = function() {
  'use strict';
  return this.contextDir_ == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT :
                                                      goog.i18n.bidi.LEFT;
};


/**
 * Returns 'left' for RTL context directionality. Otherwise (LTR or neutral /
 * unknown context directionality) returns 'right'.
 *
 * @return {string} 'left' for RTL context directionality and 'right' for other
 *     context directionality.
 */
goog.i18n.BidiFormatter.prototype.endEdge = function() {
  'use strict';
  return this.contextDir_ == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.LEFT :
                                                      goog.i18n.bidi.RIGHT;
};

//javascript/template/soy/soyutils_usegoog.js
goog.loadModule(function(exports) {'use strict';/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview
 * Utility functions and classes for Soy gencode
 *
 * <p>
 * This file contains utilities that should only be called by Soy-generated
 * JS code. Please do not use these functions directly from
 * your hand-written code. Their names all start with '$$'
 *
 * @author Garrett Boyer
 * @author Mike Samuel
 * @author Kai Huang
 * @author Aharon Lanin
 */
goog.module('soy');
goog.module.declareLegacyNamespace();

const BidiFormatter = goog.require('goog.i18n.BidiFormatter');
const Const = goog.require('goog.string.Const');
const SafeHtml = goog.require('goog.html.SafeHtml');
const SafeScript = goog.require('goog.html.SafeScript');
const SafeStyle = goog.require('goog.html.SafeStyle');
const SafeStyleSheet = goog.require('goog.html.SafeStyleSheet');
const SafeUrl = goog.require('goog.html.SafeUrl');
const TrustedResourceUrl = goog.require('goog.html.TrustedResourceUrl');
const asserts = goog.require('goog.asserts');
const bidi = goog.require('goog.i18n.bidi');
const googArray = goog.require('goog.array');
const googDebug = goog.require('goog.debug');
const googFormat = goog.require('goog.format');
const googString = goog.require('goog.string');
const soyChecks = goog.require('soy.checks');
const tsSafeUnwrappers = goog.require('google3.javascript.typescript.safevalues.safe_unwrappers');  // MOE:strip_line
const uncheckedconversions = goog.require('goog.html.uncheckedconversions');
const {SafeHtml: TsSafeHtml} = goog.require('google3.javascript.typescript.safevalues.safe_html');  // MOE:strip_line
const {SafeScript: TsSafeScript} = goog.require('google3.javascript.typescript.safevalues.safe_script');  // MOE:strip_line
const {SafeStyle: TsSafeStyle} = goog.require('google3.javascript.typescript.safevalues.safe_style');  // MOE:strip_line
const {SafeStyleSheet: TsSafeStyleSheet} = goog.require('google3.javascript.typescript.safevalues.safe_style_sheet');  // MOE:strip_line
const {SafeUrl: TsSafeUrl} = goog.require('google3.javascript.typescript.safevalues.safe_url');  // MOE:strip_line
const {SanitizedContent, SanitizedContentKind, SanitizedCss, SanitizedHtml, SanitizedHtmlAttribute, SanitizedJs, SanitizedTrustedResourceUri, SanitizedUri} = goog.require('goog.soy.data');
const {TrustedResourceUrl: TsTrustedResourceUrl} = goog.require('google3.javascript.typescript.safevalues.trusted_resource_url');  // MOE:strip_line

// -----------------------------------------------------------------------------
// soydata: Defines typed strings, e.g. an HTML string `"a<b>c"` is
// semantically distinct from the plain text string `"a<b>c"` and smart
// templates can take that distinction into account.


/** @typedef {!SanitizedContent|{isInvokableFn: boolean}} */
let IdomFunction;

/**
 * Checks whether a given value is of a given content kind.
 *
 * @param {?} value The value to be examined.
 * @param {!SanitizedContentKind} contentKind The desired content
 *     kind.
 * @return {boolean} Whether the given value is of the given kind.
 * @package
 */
const isContentKind_ = function(value, contentKind) {
  // TODO(aharon): This function should really include the assert on
  // value.constructor that is currently sprinkled at most of the call sites.
  // Unfortunately, that would require a (debug-mode-only) switch statement.
  // TODO(aharon): Perhaps we should get rid of the contentKind property
  // altogether and only at the constructor.
  return value != null && value.contentKind === contentKind;
};

/**
 * Returns a given value's contentDir property, constrained to a
 * bidi.Dir value or null. Returns null if the value is null,
 * undefined, a primitive or does not have a contentDir property, or the
 * property's value is not 1 (for LTR), -1 (for RTL), or 0 (for neutral).
 *
 * @param {?} value The value whose contentDir property, if any, is to
 *     be returned.
 * @return {?bidi.Dir} The contentDir property.
 */
const getContentDir = function(value) {
  if (value != null) {
    switch (value.contentDir) {
      case bidi.Dir.LTR:
        return bidi.Dir.LTR;
      case bidi.Dir.RTL:
        return bidi.Dir.RTL;
      case bidi.Dir.NEUTRAL:
        return bidi.Dir.NEUTRAL;
    }
  }
  return null;
};

/**
 * Returns a SanitizedHtml object for a particular value. The content direction
 * is preserved.
 *
 * This HTML-escapes the value unless it is already SanitizedHtml or SafeHtml.
 *
 * @param {?} value The value to convert. If it is already a SanitizedHtml
 *     object, it is left alone.
 * @return {!SanitizedHtml} A SanitizedHtml object derived from
 *     the stringified value. It is escaped unless the input is SanitizedHtml or
 *     SafeHtml.
 */
const createSanitizedHtml = function(value) {
  if (soyChecks.isHtml(value)) {
    return /** @type {!SanitizedHtml} */ (value);
  }
  if (value instanceof SafeHtml) {
    return VERY_UNSAFE.ordainSanitizedHtml(
        SafeHtml.unwrap(value), value.getDirection());
  }
  // MOE:begin_strip
  if (value instanceof TsSafeHtml) {
    return VERY_UNSAFE.ordainSanitizedHtml(
        tsSafeUnwrappers.unwrapSafeHtml(value));
  }
  // MOE:end_strip
  return VERY_UNSAFE.ordainSanitizedHtml(
      $$escapeHtmlHelper(String(value)), getContentDir(value));
};


/**
 * Empty string, used as a type in Soy templates.
 * TODO(lukes): this should not be private! it interferes with typechecking in
 * typescript.
 * @enum {string}
 * @private
 */
const $$EMPTY_STRING_ = {
  VALUE: '',
};


/**
 * Creates a factory for SanitizedContent types.
 *
 * This is a hack so that the VERY_UNSAFE.ordainSanitized* can
 * instantiate Sanitized* classes, without making the Sanitized* constructors
 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
 * helps callers and their reviewers easily tell that creating SanitizedContent
 * is not always safe and calls for careful review.
 *
 * @param {function(new: T)} ctor A constructor.
 * @return {function(*, ?bidi.Dir=): T} A factory that takes
 *     content and an optional content direction and returns a new instance. If
 *     the content direction is undefined, ctor.prototype.contentDir is used.
 * @template T
 * @private
 */
const $$makeSanitizedContentFactory_ = function(ctor) {
  /**
   * @param {string} content
   * @constructor
   * @extends {SanitizedContent}
   */
  function InstantiableCtor(content) {
    /** @override */
    this.content = content;
  }
  InstantiableCtor.prototype = ctor.prototype;
  /**
   * Creates a ctor-type SanitizedContent instance.
   *
   * @param {?} content The content to put in the instance.
   * @param {?bidi.Dir=} contentDir The content direction. If
   *     undefined, ctor.prototype.contentDir is used.
   * @return {!SanitizedContent} The new instance. It is actually
   *     of type T above (ctor's type, a descendant of SanitizedContent), but
   *     there is no way to express that here.
   */
  function sanitizedContentFactory(content, contentDir) {
    const result = new InstantiableCtor(String(content));
    if (contentDir !== undefined) {
      result.contentDir = contentDir;
    }
    return result;
  }
  return sanitizedContentFactory;
};


/**
 * Creates a factory for SanitizedContent types that should always have their
 * default directionality.
 *
 * This is a hack so that the VERY_UNSAFE.ordainSanitized* can
 * instantiate Sanitized* classes, without making the Sanitized* constructors
 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
 * helps callers and their reviewers easily tell that creating SanitizedContent
 * is not always safe and calls for careful review.
 *
 * @param {function(new: T, string)} ctor A constructor.
 * @return {function(*): T} A factory that takes content and returns a new
 *     instance (with default directionality, i.e. ctor.prototype.contentDir).
 * @template T
 */
const $$makeSanitizedContentFactoryWithDefaultDirOnly_ = function(ctor) {
  /**
   * @param {string} content
   * @constructor
   * @extends {SanitizedContent}
   */
  function InstantiableCtor(content) {
    /** @override */
    this.content = content;
  }
  InstantiableCtor.prototype = ctor.prototype;
  /**
   * Creates a ctor-type SanitizedContent instance.
   *
   * @param {?} content The content to put in the instance.
   * @return {!SanitizedContent} The new instance. It is actually
   *     of type T above (ctor's type, a descendant of SanitizedContent), but
   *     there is no way to express that here.
   */
  function sanitizedContentFactory(content) {
    const result = new InstantiableCtor(String(content));
    return result;
  }
  return sanitizedContentFactory;
};


// -----------------------------------------------------------------------------
// Sanitized content ordainers. Please use these with extreme caution. A good
// recommendation is to limit usage of these to just a handful of files in your
// source tree where usages can be carefully audited.

/** @struct */
const VERY_UNSAFE = {};

/**
 * Takes a leap of faith that the provided content is "safe" HTML.
 *
 * @param {?} content A string of HTML that can safely be embedded in
 *     a PCDATA context in your app. If you would be surprised to find that an
 *     HTML sanitizer produced `s` (e.g. it runs code or fetches bad URLs)
 *     and you wouldn't write a template that produces `s` on security or
 *     privacy grounds, then don't pass `s` here.
 * @param {?bidi.Dir=} contentDir The content direction; null if
 *     unknown and thus to be estimated when necessary. Default: null.
 * @return {!SanitizedHtml} Sanitized content wrapper that
 *     indicates to Soy not to escape when printed as HTML.
 */
VERY_UNSAFE.ordainSanitizedHtml = $$makeSanitizedContentFactory_(SanitizedHtml);


/**
 * Takes a leap of faith that the provided content is "safe" (non-attacker-
 * controlled, XSS-free) Javascript.
 *
 * @param {?} content Javascript source that when evaluated does not
 *     execute any attacker-controlled scripts.
 * @return {!SanitizedJs} Sanitized content wrapper that indicates
 *     to Soy not to escape when printed as Javascript source.
 */
VERY_UNSAFE.ordainSanitizedJs =
    $$makeSanitizedContentFactoryWithDefaultDirOnly_(SanitizedJs);


/**
 * Takes a leap of faith that the provided content is "safe" to use as a URI
 * in a Soy template.
 *
 * This creates a Soy SanitizedContent object which indicates to Soy there is
 * no need to escape it when printed as a URI (e.g. in an href or src
 * attribute), such as if it's already been encoded or  if it's a Javascript:
 * URI.
 *
 * @param {?} content A chunk of URI that the caller knows is safe to
 *     emit in a template.
 * @return {!SanitizedUri} Sanitized content wrapper that
 *     indicates to Soy not to escape or filter when printed in URI context.
 */
VERY_UNSAFE.ordainSanitizedUri =
    $$makeSanitizedContentFactoryWithDefaultDirOnly_(SanitizedUri);


/**
 * Takes a leap of faith that the provided content is "safe" to use as a
 * TrustedResourceUri in a Soy template.
 *
 * This creates a Soy SanitizedContent object which indicates to Soy there is
 * no need to filter it when printed as a TrustedResourceUri.
 *
 * @param {?} content A chunk of TrustedResourceUri such as that the caller
 *     knows is safe to emit in a template.
 * @return {!SanitizedTrustedResourceUri} Sanitized content
 *     wrapper that indicates to Soy not to escape or filter when printed in
 *     TrustedResourceUri context.
 */
VERY_UNSAFE.ordainSanitizedTrustedResourceUri =
    $$makeSanitizedContentFactoryWithDefaultDirOnly_(
        SanitizedTrustedResourceUri);


/**
 * Takes a leap of faith that the provided content is "safe" to use as an
 * HTML attribute.
 *
 * @param {?} content An attribute name and value, such as
 *     `dir="ltr"`.
 * @return {!SanitizedHtmlAttribute} Sanitized content wrapper
 *     that indicates to Soy not to escape when printed as an HTML attribute.
 */
VERY_UNSAFE.ordainSanitizedHtmlAttribute =
    $$makeSanitizedContentFactoryWithDefaultDirOnly_(SanitizedHtmlAttribute);


/**
 * Takes a leap of faith that the provided content is "safe" to use as CSS
 * in a style block.
 *
 * @param {?} content CSS, such as `color:#c3d9ff`.
 * @return {!SanitizedCss} Sanitized CSS wrapper that indicates to
 *     Soy there is no need to escape or filter when printed in CSS context.
 */
VERY_UNSAFE.ordainSanitizedCss =
    $$makeSanitizedContentFactoryWithDefaultDirOnly_(SanitizedCss);

// Utilities related to defining and stubbing soy templates


/**
 * A map that allows us to dynamically replace templates.
 *
 * The key is the fully qualified template name and the value is a replacement
 * to call instead.
 *
 * @type {?Object<string, !Function>}
 * @const
 */
const $$stubsMap = goog.DEBUG ? {} : null;


// -----------------------------------------------------------------------------
// Soy-generated utilities in the soy namespace.  Contains implementations for
// common soyfunctions (e.g. keys()) and escaping/print directives.


/**
 * Provides a compact serialization format for the key structure.
 * @param {?} item
 * @return {string}
 */
const $$serializeKey = function(item) {
  const stringified = String(item);
  let delimiter;
  if (item == null) {
    delimiter = '_';
  } else if (typeof item === 'number') {
    delimiter = '#';
  } else {
    delimiter = ':';
  }
  return `${stringified.length}${delimiter}${stringified}`;
};



/**
 * Whether the locale is right-to-left.
 *
 * @type {boolean}
 */
const $$IS_LOCALE_RTL = bidi.IS_RTL;



/**
 * Copies extra properties into an object if they do not already exist. The
 * destination object is mutated in the process.
 *
 * @param {?} obj The destination object to update.
 * @param {?} defaults An object with default properties to apply.
 * @return {?} The destination object for convenience.
 */
const $$assignDefaults = function(obj, defaults) {
  for (let key in defaults) {
    if (!(key in obj)) {
      obj[key] = defaults[key];
    }
  }

  return obj;
};


/**
 * Gets the keys in a map as an array. There are no guarantees on the order.
 * @param {!Object} map The map to get the keys of.
 * @return {!Array<string>} The array of keys in the given map.
 */
const $$getMapKeys = function(map) {
  const mapKeys = [];
  for (let key in map) {
    mapKeys.push(key);
  }
  return mapKeys;
};


/**
 * Returns the argument if it is not null.
 *
 * @param {T} val The value to check
 * @return {T} val if is isn't null
 * @template T
 */
const $$checkNotNull = function(val) {
  if (val == null) {
    throw Error('unexpected null value');
  }
  return val;
};


/**
 * Parses the given string into a base 10 integer. Returns null if parse is
 * unsuccessful.
 * @param {?string} str The string to parse
 * @return {?number} The string parsed as a base 10 integer, or null if
 * unsuccessful
 */
const $$parseInt = function(str) {
  const parsed = parseInt(String(str), 10);
  return isNaN(parsed) ? null : parsed;
};

/**
 * When equals comparison cannot be expressed using JS runtime semantics for ==,
 * bail out to a runtime function. In practice, this only means comparisons
 * of boolean, string and number are valid for equals, and everything else needs
 * this function. Some sanitized content may be functions or objects that need
 * to be coerced to a string.
 * @param {?} valueOne
 * @param {?} valueTwo
 * @return {boolean}
 */
const $$equals = function(valueOne, valueTwo) {
  // Incremental DOM functions have to be coerced to a string. At runtime
  // they are tagged with a type for ATTR or HTML. They both need to be
  // the same to be considered structurally equal. Beware, as this is a
  // very expensive function.
  if ((valueOne && valueTwo) &&
      (valueOne.isInvokableFn && valueTwo.isInvokableFn)) {
    if ((/** @type {?} */ (valueOne)).contentKind !==
        (/** @type {?} */ (valueTwo)).contentKind) {
      return false;
    } else {
      return valueOne.toString() === valueTwo.toString();
    }
  }

  // Likewise for sanitized content.
  if (valueOne instanceof SanitizedContent &&
      valueTwo instanceof SanitizedContent) {
    if (valueOne.contentKind != valueTwo.contentKind) {
      return false;
    } else {
      return valueOne.toString() == valueTwo.toString();
    }
  }

  // Rely on javascript semantics for comparing two objects.
  return valueOne == valueTwo;
};


/**
 * @param {?} value
 * @return {boolean}
 */
const $$isFunction = function(value) {
  return typeof value === 'function';
};

/**
 * Parses the given string into a float. Returns null if parse is unsuccessful.
 * @param {?string} str The string to parse
 * @return {?number} The string parsed as a float, or null if unsuccessful.
 */
const $$parseFloat = function(str) {
  const parsed = parseFloat(str);
  return isNaN(parsed) ? null : parsed;
};

/**
 * Returns a random integer.
 * @return {number} a random integer between 0 and num
 */
const $$randomInt = function(/** number */ num) {
  return Math.floor(Math.random() * num);
};

/**
 * Rounds the given value to the closest decimal point left (negative numbers)
 * or right (positive numbers) of the decimal point
 *
 * TODO(b/112835292): This is probably not something that anyone should use,
 * instead they should use an i18n friendly number formatting routine.
 *
 * @return {number} the rounded value
 */
const $$round = function(/** number */ num, /** number */ numDigitsAfterPt) {
  const shift = Math.pow(10, numDigitsAfterPt);
  return Math.round(num * shift) / shift;
};

/** @return {boolean} returns whether the needle was found in the haystack */
const $$strContains = function(/** string */ haystack, /** string */ needle) {
  return haystack.indexOf(needle) != -1;
};

/**
 * Coerce the given value into a bool.
 *
 * For objects of type `SanitizedContent`, the contents are used to determine
 * the boolean value; this is because the outer `SanitizedContent` object
 * instance is always truthy (unless it's null).
 *
 * @param {*} arg The argument to coerce.
 * @return {boolean}
 */
const $$coerceToBoolean = function(arg) {
  if (arg instanceof SanitizedContent) {
    return !!arg.getContent();
  }
  return !!arg;
};


/**
 * Gets a consistent unique id for the given delegate template name. Two calls
 * to this function will return the same id if and only if the input names are
 * the same.
 *
 * <p> Important: This function must always be called with a string constant.
 *
 * <p> If Closure Compiler is not being used, then this is just this identity
 * function. If Closure Compiler is being used, then each call to this function
 * will be replaced with a short string constant, which will be consistent per
 * input name.
 *
 * @param {string} delTemplateName The delegate template name for which to get a
 *     consistent unique id.
 * @return {string} A unique id that is consistent per input name.
 *
 * @idGenerator {consistent}
 */
const $$getDelTemplateId = function(delTemplateName) {
  return delTemplateName;
};


/**
 * Map from registered delegate template key to the priority of the
 * implementation.
 * @const {!Object<number>}
 */
const DELEGATE_REGISTRY_PRIORITIES_ = {};

/**
 * Map from registered delegate template key to the implementation function.
 * @const {!Object<!Function>}
 */
const DELEGATE_REGISTRY_FUNCTIONS_ = {};


/**
 * Registers a delegate implementation. If the same delegate template key (id
 * and variant) has been registered previously, then priority values are
 * compared and only the higher priority implementation is stored (if
 * priorities are equal, an error is thrown).
 *
 * @param {string} delTemplateId The delegate template id.
 * @param {string} delTemplateVariant The delegate template variant (can be
 *     empty string).
 * @param {number} delPriority The implementation's priority value.
 * @param {!Function} delFn The implementation function.
 */
const $$registerDelegateFn = function(
    delTemplateId, delTemplateVariant, delPriority, delFn) {
  const mapKey = 'key_' + delTemplateId + ':' + delTemplateVariant;
  const currPriority = DELEGATE_REGISTRY_PRIORITIES_[mapKey];
  if (currPriority === undefined || delPriority > currPriority) {
    // Registering new or higher-priority function: replace registry entry.
    DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority;
    DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
  } else if (delPriority == currPriority) {
    // Registering same-priority function: error.
    throw Error(
        'Encountered two active delegates with the same priority ("' +
        delTemplateId + ':' + delTemplateVariant + '").');
  } else {
    // Registering lower-priority function: do nothing.
  }
};


/**
 * Retrieves the (highest-priority) implementation that has been registered for
 * a given delegate template key (id and variant). If no implementation has
 * been registered for the key, then the fallback is the same id with empty
 * variant. If the fallback is also not registered, and allowsEmptyDefault is
 * true, then returns an implementation that is equivalent to an empty template
 * (i.e. rendered output would be empty string).
 *
 * @param {string} delTemplateId The delegate template id.
 * @param {string} delTemplateVariant The delegate template variant (can be
 *     empty string).
 * @param {boolean} allowsEmptyDefault Whether to default to the empty template
 *     function if there's no active implementation.
 * @return {!Function} The retrieved implementation function.
 */
const $$getDelegateFn = function(
    delTemplateId, delTemplateVariant, allowsEmptyDefault) {
  let delFn =
      DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':' + delTemplateVariant];
  if (!delFn && delTemplateVariant !== '') {
    // Fallback to empty variant.
    delFn = DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':'];
  }

  if (delFn) {
    return delFn;
  } else if (allowsEmptyDefault) {
    return $$EMPTY_TEMPLATE_FN_;
  } else {
    throw Error(
        'Found no active impl for delegate call to "' + delTemplateId +
        (delTemplateVariant ? ':' + delTemplateVariant : '') +
        '" (and delcall does not set allowemptydefault="true").');
  }
};


/**
 * Private helper soy.$$getDelegateFn(). This is the empty template function
 * that is returned whenever there's no delegate implementation found.
 *
 * Note: This is also used for idom.
 *
 * @return {string}
 */
const $$EMPTY_TEMPLATE_FN_ = function() {
  return '';
};


// -----------------------------------------------------------------------------
// Internal sanitized content wrappers.


/**
 * Creates a SanitizedContent factory for SanitizedContent types for internal
 * Soy let and param blocks.
 *
 * This is a hack within Soy so that SanitizedContent objects created via let
 * and param blocks will truth-test as false if they are empty string.
 * Tricking the Javascript runtime to treat empty SanitizedContent as falsey is
 * not possible, and changing the Soy compiler to wrap every boolean statement
 * for just this purpose is impractical.  Instead, we just avoid wrapping empty
 * string as SanitizedContent, since it's a no-op for empty strings anyways.
 *
 * @param {function(new: T)} ctor A constructor.
 * @return {function(*, ?bidi.Dir=): (T|!$$EMPTY_STRING_)}
 *     A factory that takes content and an optional content direction and
 *     returns a new instance, or an empty string. If the content direction is
 *     undefined, ctor.prototype.contentDir is used.
 * @template T
 */
const $$makeSanitizedContentFactoryForInternalBlocks_ = function(ctor) {
  /**
   * @param {string} content
   * @constructor
   * @extends {SanitizedContent}
   */
  function InstantiableCtor(content) {
    /** @override */
    this.content = content;
  }
  InstantiableCtor.prototype = ctor.prototype;
  /**
   * Creates a ctor-type SanitizedContent instance.
   *
   * @param {?} content The content to put in the instance.
   * @param {?bidi.Dir=} contentDir The content direction. If
   *     undefined, ctor.prototype.contentDir is used.
   * @return {!SanitizedContent|!$$EMPTY_STRING_} The new
   *     instance, or an empty string. A new instance is actually of type T
   *     above (ctor's type, a descendant of SanitizedContent), but there's no
   *     way to express that here.
   */
  function sanitizedContentFactory(content, contentDir) {
    const contentString = String(content);
    if (!contentString) {
      return $$EMPTY_STRING_.VALUE;
    }
    const result = new InstantiableCtor(contentString);
    if (contentDir !== undefined) {
      result.contentDir = contentDir;
    }
    return result;
  }
  return sanitizedContentFactory;
};


/**
 * Creates a SanitizedContent factory for SanitizedContent types that should
 * always have their default directionality for internal Soy let and param
 * blocks.
 *
 * This is a hack within Soy so that SanitizedContent objects created via let
 * and param blocks will truth-test as false if they are empty string.
 * Tricking the Javascript runtime to treat empty SanitizedContent as falsey is
 * not possible, and changing the Soy compiler to wrap every boolean statement
 * for just this purpose is impractical.  Instead, we just avoid wrapping empty
 * string as SanitizedContent, since it's a no-op for empty strings anyways.
 *
 * @param {function(new: T)} ctor A constructor.
 * @return {function(*): (T|!$$EMPTY_STRING_)} A
 *     factory that takes content and returns a
 *     new instance (with default directionality, i.e.
 *     ctor.prototype.contentDir), or an empty string.
 * @template T
 */
const $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_ =
    function(ctor) {
  /**
   * @param {string} content
   * @constructor
   * @extends {SanitizedContent}
   */
  function InstantiableCtor(content) {
    /** @override */
    this.content = content;
  }
  InstantiableCtor.prototype = ctor.prototype;
  /**
   * Creates a ctor-type SanitizedContent instance.
   *
   * @param {?} content The content to put in the instance.
   * @return {!SanitizedContent|!$$EMPTY_STRING_} The new
   *     instance, or an empty string. A new instance is actually of type T
   *     above (ctor's type, a descendant of SanitizedContent), but there's no
   *     way to express that here.
   */
  function sanitizedContentFactory(content) {
    const contentString = String(content);
    if (!contentString) {
      return $$EMPTY_STRING_.VALUE;
    }
    const result = new InstantiableCtor(contentString);
    return result;
  }
  return sanitizedContentFactory;
};


/**
 * Creates kind="html" block contents (internal use only).
 *
 * @param {?} content Text.
 * @param {?bidi.Dir=} contentDir The content direction; null if
 *     unknown and thus to be estimated when necessary. Default: null.
 * @return {!SanitizedHtml|!$$EMPTY_STRING_} Wrapped
 *     result.
 */
VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks =
    $$makeSanitizedContentFactoryForInternalBlocks_(SanitizedHtml);


/**
 * Creates kind="js" block contents (internal use only).
 *
 * @param {?} content Text.
 * @return {!SanitizedJs|!$$EMPTY_STRING_} Wrapped result.
 */
VERY_UNSAFE.$$ordainSanitizedJsForInternalBlocks =
    $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(
        SanitizedJs);


/**
 * Creates kind="trustedResourceUri" block contents (internal use only).
 *
 * @param {?} content Text.
 * @return {!SanitizedTrustedResourceUri|!$$EMPTY_STRING_}
 *     Wrapped result.
 */
VERY_UNSAFE.$$ordainSanitizedTrustedResourceUriForInternalBlocks =
    $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(
        SanitizedTrustedResourceUri);


/**
 * Creates kind="uri" block contents (internal use only).
 *
 * @param {?} content Text.
 * @return {!SanitizedUri|!$$EMPTY_STRING_} Wrapped
 *     result.
 */
VERY_UNSAFE.$$ordainSanitizedUriForInternalBlocks =
    $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(
        SanitizedUri);


/**
 * Creates kind="attributes" block contents (internal use only).
 *
 * @param {?} content Text.
 * @return {!SanitizedHtmlAttribute|!$$EMPTY_STRING_}
 *     Wrapped result.
 */
VERY_UNSAFE.$$ordainSanitizedAttributesForInternalBlocks =
    $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(
        SanitizedHtmlAttribute);


/**
 * Creates kind="css" block contents (internal use only).
 *
 * @param {?} content Text.
 * @return {!SanitizedCss|!$$EMPTY_STRING_} Wrapped
 *     result.
 */
VERY_UNSAFE.$$ordainSanitizedCssForInternalBlocks =
    $$makeSanitizedContentFactoryWithDefaultDirOnlyForInternalBlocks_(
        SanitizedCss);


// -----------------------------------------------------------------------------
// Escape/filter/normalize.


/**
 * Returns a SanitizedHtml object for a particular value. The content direction
 * is preserved.
 *
 * This HTML-escapes the value unless it is already SanitizedHtml. Escapes
 * double quote '"' in addition to '&', '<', and '>' so that a string can be
 * included in an HTML tag attribute value within double quotes.
 *
 * @param {?} value The value to convert. If it is already a SanitizedHtml
 *     object, it is left alone.
 * @return {!SanitizedHtml} An escaped version of value.
 */
const $$escapeHtml = function(value) {
  return createSanitizedHtml(value);
};


/**
 * Strips unsafe tags to convert a string of untrusted HTML into HTML that
 * is safe to embed. The content direction is preserved.
 *
 * @param {?} value The string-like value to be escaped. May not be a string,
 *     but the value will be coerced to a string.
 * @param {?Array<string>=} safeTags Additional tag names to whitelist.
 * @return {!SanitizedHtml} A sanitized and normalized version of
 *     value.
 */
const $$cleanHtml = function(value, safeTags) {
  if (soyChecks.isHtml(value)) {
    return /** @type {!SanitizedHtml} */ (value);
  }
  let tagWhitelist;
  if (safeTags) {
    tagWhitelist = Object.fromEntries(safeTags.map((tag) => [tag, true]));
    Object.assign(tagWhitelist, $$SAFE_TAG_WHITELIST_);
  } else {
    tagWhitelist = $$SAFE_TAG_WHITELIST_;
  }
  return VERY_UNSAFE.ordainSanitizedHtml(
      $$stripHtmlTags(value, tagWhitelist), getContentDir(value));
};


// LINT.IfChange(htmlToText)
/**
 * Converts HTML to plain text by removing tags, normalizing spaces and
 * converting entities.
 *
 * The last two parameters are idom functions.
 * @param {string|?SanitizedHtml|?SafeHtml|
 *     ?IdomFunction|?Function|undefined} value
 * @return {string}
 */
const $$htmlToText = function(value) {
  if (value == null) {
    return '';
  }
  let html;
  if (value instanceof SafeHtml) {
    html = SafeHtml.unwrap(value);
  } else if (isContentKind_(value, SanitizedContentKind.HTML)) {
    html = value.toString();
    // MOE:begin_strip
  } else if (value instanceof TsSafeHtml) {
    html = tsSafeUnwrappers.unwrapSafeHtml(value);
    // MOE:end_strip
  } else {
    return asserts.assertString(value);
  }
  let text = '';
  let start = 0;
  // Tag name to stop removing contents, e.g. '/script'.
  let removingUntil = '';
  // Tag name to stop preserving whitespace, e.g. '/pre'.
  let wsPreservingUntil = '';
  const tagRe =
      /<(?:!--.*?--|(?:!|(\/?[a-z][\w:-]*))(?:[^>'"]|"[^"]*"|'[^']*')*)>|$/gi;
  for (let match; match = tagRe.exec(html);) {
    const tag = match[1];
    const offset = match.index;
    if (!removingUntil) {
      let chunk = html.substring(start, offset);
      chunk = googString.unescapeEntities(chunk);
      if (!wsPreservingUntil) {
        // We are not inside <pre>, normalize spaces.
        chunk = chunk.replace(/\s+/g, ' ');
        if (!/\S$/.test(text)) {
          // Strip leading space unless after non-whitespace.
          chunk = chunk.replace(/^ /, '');
        }
      }
      text += chunk;
      if (/^(script|style|textarea|title)$/i.test(tag)) {
        removingUntil = '/' + tag.toLowerCase();
      } else if (/^br$/i.test(tag)) {
        // <br> adds newline even after newline.
        text += '\n';
      } else if (BLOCK_TAGS_RE_.test(tag)) {
        if (/[^\n]$/.test(text)) {
          // Block tags don't add more consecutive newlines.
          text += '\n';
        }
        if (/^pre$/i.test(tag)) {
          wsPreservingUntil = '/' + tag.toLowerCase();
        } else if (tag.toLowerCase() == wsPreservingUntil) {
          wsPreservingUntil = '';
        }
      } else if (/^(td|th)$/i.test(tag)) {
        // We add \t even after newline to support more leading <td>.
        text += '\t';
      }
    } else if (removingUntil == tag.toLowerCase()) {
      removingUntil = '';
    }
    if (!match[0]) {
      break;
    }
    start = offset + match[0].length;
  }
  return text;
};


/** @const */
const BLOCK_TAGS_RE_ =
    /^\/?(address|blockquote|dd|div|dl|dt|h[1-6]|hr|li|ol|p|pre|table|tr|ul)$/i;
// LINT.ThenChange(
//     ../../../third_party/java_src/soy/java/com/google/template/soy/basicfunctions/HtmlToText.java,
//     ../../../third_party/java_src/soy/python/runtime/sanitize.py:htmlToText)


/**
 * Escapes HTML, except preserves entities.
 *
 * Used mainly internally for escaping message strings in attribute and rcdata
 * context, where we explicitly want to preserve any existing entities.
 *
 * @param {?} value Value to normalize.
 * @return {string} A value safe to insert in HTML without any quotes or angle
 *     brackets.
 */
const $$normalizeHtml = function(value) {
  return $$normalizeHtmlHelper(value);
};


/**
 * Escapes HTML special characters in a string so that it can be embedded in
 * RCDATA.
 * <p>
 * Escapes HTML special characters so that the value will not prematurely end
 * the body of a tag like `<textarea>` or `<title>`. RCDATA tags
 * cannot contain other HTML entities, so it is not strictly necessary to escape
 * HTML special characters except when part of that text looks like an HTML
 * entity or like a close tag : `</textarea>`.
 * <p>
 * Will normalize known safe HTML to make sure that sanitized HTML (which could
 * contain an innocuous `</textarea>` don't prematurely end an RCDATA
 * element.
 *
 * @param {?} value The string-like value to be escaped. May not be a string,
 *     but the value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeHtmlRcdata = function(value) {
  if (soyChecks.isHtml(value)) {
    return $$normalizeHtmlHelper(value.getContent());
  }
  return $$escapeHtmlHelper(value);
};


/**
 * Matches any/only HTML5 void elements' start tags.
 * See http://www.w3.org/TR/html-markup/syntax.html#syntax-elements
 * @const {!RegExp}
 */
const $$HTML5_VOID_ELEMENTS_ = new RegExp(
    '^<(?:area|base|br|col|command|embed|hr|img|input' +
    '|keygen|link|meta|param|source|track|wbr)\\b');


/**
 * Removes HTML tags from a string of known safe HTML.
 * If opt_tagWhitelist is not specified or is empty, then
 * the result can be used as an attribute value.
 *
 * @param {?} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @param {?Object<string, boolean>=} tagWhitelist Has an own property whose
 *     name is a lower-case tag name and whose value is `1` for
 *     each element that is allowed in the output.
 * @return {string} A representation of value without disallowed tags,
 *     HTML comments, or other non-text content.
 */
const $$stripHtmlTags = function(value, tagWhitelist) {
  if (!tagWhitelist) {
    // If we have no white-list, then use a fast track which elides all tags.
    return String(value)
        .replace($$HTML_TAG_REGEX_, '')
        // This is just paranoia since callers should normalize the result
        // anyway, but if they didn't, it would be necessary to ensure that
        // after the first replace non-tag uses of < do not recombine into
        // tags as in "<<foo>script>alert(1337)</<foo>script>".
        .replace($$LT_REGEX_, '&lt;');
  }

  // Escapes '[' so that we can use [123] below to mark places where tags
  // have been removed.
  let html = String(value).replace(/\[/g, '&#91;');

  // Consider all uses of '<' and replace whitelisted tags with markers like
  // [1] which are indices into a list of approved tag names.
  // Replace all other uses of < and > with entities.
  const tags = [];
  const attrs = [];
  html = html.replace($$HTML_TAG_REGEX_, function(tok, tagName) {
    if (tagName) {
      tagName = tagName.toLowerCase();
      if (tagWhitelist.hasOwnProperty(tagName) && tagWhitelist[tagName]) {
        const isClose = tok.charAt(1) == '/';
        const index = tags.length;
        let start = '</';
        let attributes = '';
        if (!isClose) {
          start = '<';
          let match;
          while ((match = $$HTML_ATTRIBUTE_REGEX_.exec(tok))) {
            if (match[1] && match[1].toLowerCase() == 'dir') {
              let dir = match[2];
              if (dir) {
                if (dir.charAt(0) == '\'' || dir.charAt(0) == '"') {
                  dir = dir.substr(1, dir.length - 2);
                }
                dir = dir.toLowerCase();
                if (dir == 'ltr' || dir == 'rtl' || dir == 'auto') {
                  attributes = ' dir="' + dir + '"';
                }
              }
              break;
            }
          }
          $$HTML_ATTRIBUTE_REGEX_.lastIndex = 0;
        }
        tags[index] = start + tagName + '>';
        attrs[index] = attributes;
        return '[' + index + ']';
      }
    }
    return '';
  });

  // Escape HTML special characters. Now there are no '<' in html that could
  // start a tag.
  html = $$normalizeHtmlHelper(html);

  const finalCloseTags = $$balanceTags_(tags);

  // Now html contains no tags or less-than characters that could become
  // part of a tag via a replacement operation and tags only contains
  // approved tags.
  // Reinsert the white-listed tags.
  html = html.replace(/\[(\d+)\]/g, function(_, index) {
    if (attrs[index] && tags[index]) {
      return tags[index].substr(0, tags[index].length - 1) + attrs[index] + '>';
    }
    return tags[index];
  });

  // Close any still open tags.
  // This prevents unclosed formatting elements like <ol> and <table> from
  // breaking the layout of containing HTML.
  return html + finalCloseTags;
};


/**
 * Make sure that tag boundaries are not broken by Safe CSS when embedded in a
 * `<style>` element.
 * @param {string} css
 * @return {string}
 */
const $$embedCssIntoHtml_ = function(css) {
  // Port of a method of the same name in
  // com.google.template.soy.shared.restricted.Sanitizers
  return css.replace(/<\//g, '<\\/').replace(/\]\]>/g, ']]\\>');
};


/**
 * Throw out any close tags that don't correspond to start tags.
 * If `<table>` is used for formatting, embedded HTML shouldn't be able
 * to use a mismatched `</table>` to break page layout.
 *
 * @param {!Array<string>} tags Array of open/close tags (e.g. '<p>', '</p>')
 *    that will be modified in place to be either an open tag, one or more close
 *    tags concatenated, or the empty string.
 * @return {string} zero or more closed tags that close all elements that are
 *    opened in tags but not closed.
 * @package
 */
const $$balanceTags_ = function(tags) {
  const open = [];
  for (let i = 0, n = tags.length; i < n; ++i) {
    const tag = tags[i];
    if (tag.charAt(1) == '/') {
      const openTagIndex = open.lastIndexOf(tag);
      if (openTagIndex < 0) {
        tags[i] = '';  // Drop close tag with no corresponding open tag.
      } else {
        tags[i] = open.slice(openTagIndex).reverse().join('');
        open.length = openTagIndex;
      }
    } else if (
        tag == '<li>' && open.lastIndexOf('</ol>') < 0 &&
        open.lastIndexOf('</ul>') < 0) {
      // Drop <li> if it isn't nested in a parent <ol> or <ul>.
      tags[i] = '';
    } else if (!$$HTML5_VOID_ELEMENTS_.test(tag)) {
      open.push('</' + tag.substring(1));
    }
  }
  return open.reverse().join('');
};


/**
 * Escapes HTML special characters in an HTML attribute value.
 *
 * @param {?} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeHtmlAttribute = function(value) {
  // NOTE: We don't accept ATTRIBUTES here because ATTRIBUTES is actually not
  // the attribute value context, but instead k/v pairs.
  if (soyChecks.isHtml(value)) {
    // NOTE: After removing tags, we also escape quotes ("normalize") so that
    // the HTML can be embedded in attribute context.
    return $$normalizeHtmlHelper($$stripHtmlTags(value.getContent()));
  }
  return $$escapeHtmlHelper(value);
};


/**
 * Escapes HTML special characters in an HTML attribute value containing HTML
 * code, such as <iframe srcdoc>.
 *
 * @param {?} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeHtmlHtmlAttribute = function(value) {
  return String($$escapeHtml(value));
};


/**
 * Escapes HTML special characters in a string including space and other
 * characters that can end an unquoted HTML attribute value.
 *
 * @param {?} value The HTML to be escaped. May not be a string, but the
 *     value will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeHtmlAttributeNospace = function(value) {
  if (soyChecks.isHtml(value)) {
    return $$normalizeHtmlNospaceHelper($$stripHtmlTags(value.getContent()));
  }
  return $$escapeHtmlNospaceHelper(value);
};

/**
 * Filters out strings that cannot be valid content in a <script> tag with
 * non-JS content.
 *
 * This disallows `<script`, `</script`, and `<!--` as substrings as well as
 * prefixes of those strings that occur at the end of the value.  This combined
 * with a similar rule enforced in the parser ensures that these substrings
 * cannot occur.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} The value coerced to a string or `"zSoyz"` if the input is
 *    invalid.
 */
const $$filterHtmlScriptPhrasingData = function(value) {
  const valueAsString = String(value);
  /**
   * Returns whether there is a case insensitive match for needle within
   * haystack starting at offset, or if haystack ends with a non empty prefix of
   * needle.
   * @return {boolean}
   */
  const matchPrefixIgnoreCasePastEnd =
      (/** string */ needle, /** string */ haystack, /** number */ offset) => {
        asserts.assert(
            offset >= 0 && offset < haystack.length,
            'offset must point at a valid character of haystack');
        asserts.assert(
            needle === $$strToAsciiLowerCase(needle),
            'needle must be lowercase');
        const charsLeft = haystack.length - offset;
        const charsToScan = Math.min(charsLeft, needle.length);
        for (let i = 0; i < charsToScan; i++) {
          if (needle[i] !== $$charToAsciiLowerCase_(haystack[offset + i])) {
            return false;
          }
        }
        return true;
      };
  let start = 0;
  let indexOfLt;
  while ((indexOfLt = valueAsString.indexOf('<', start)) != -1) {
    if (matchPrefixIgnoreCasePastEnd('<script', valueAsString, indexOfLt) ||
        matchPrefixIgnoreCasePastEnd('</script', valueAsString, indexOfLt) ||
        matchPrefixIgnoreCasePastEnd('<!--', valueAsString, indexOfLt)) {
      asserts.fail(
          'Bad value `%s` for |filterHtmlScriptPhrasingData', [valueAsString]);
      return 'zSoyz';
    }
    start = indexOfLt + 1;
  }
  return valueAsString;
};

/**
 * Filters out strings that cannot be a substring of a valid HTML attribute.
 *
 * Note the input is expected to be key=value pairs.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A valid HTML attribute name part or name/value pair.
 *     `"zSoyz"` if the input is invalid.
 */
const $$filterHtmlAttributes = function(value) {
  // NOTE: Explicitly no support for SanitizedContentKind.HTML, since that is
  // meaningless in this context, which is generally *between* html attributes.
  if (soyChecks.isAttribute(value)) {
    return value.getContent();
  }
  // TODO: Dynamically inserting attributes that aren't marked as trusted is
  // probably unnecessary.  Any filtering done here will either be inadequate
  // for security or not flexible enough.  Having clients use kind="attributes"
  // in parameters seems like a wiser idea.
  return $$filterHtmlAttributesHelper(value);
};

/**
 * Conditionally prepends a single space if value is not empty.
 *
 * @param {?} value The value.
 * @return {string} value, possibly with an extra leading space.
 */
const $$whitespaceHtmlAttributes = function(value) {
  if (soyChecks.isAttribute(value)) {
    value = value.getContent();
  }
  return (value && !$$strStartsWith(value, ' ') ? ' ' : '') + value;
};

/**
 * Allows only decimal and floating-point numbers.
 * @param {?} value
 * @return {number} The number.
 */
const $$filterNumber = function(value) {
  return /^\d*\.?\d+$/.test(value) ? value : 'zSoyz';
};


/**
 * Filters out strings that cannot be a substring of a valid HTML element name.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A valid HTML element name part.
 *     `"zSoyz"` if the input is invalid.
 */
const $$filterHtmlElementName = function(value) {
  // NOTE: We don't accept any SanitizedContent here. HTML indicates valid
  // PCDATA, not tag names. A sloppy developer shouldn't be able to cause an
  // exploit:
  // ... {let userInput}script src=http://evil.com/evil.js{/let} ...
  // ... {param tagName kind="html"}{$userInput}{/param} ...
  // ... <{$tagName}>Hello World</{$tagName}>
  return $$filterHtmlElementNameHelper(value);
};


/**
 * Escapes characters in the value to make it valid content for a JS string
 * literal.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeJsString = function(value) {
  return $$escapeJsStringHelper(value);
};


/**
 * Encodes a value as a JavaScript literal.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A JavaScript code representation of the input.
 */
const $$escapeJsValue = function(value) {
  // We surround values with spaces so that they can't be interpolated into
  // identifiers by accident.
  // We could use parentheses but those might be interpreted as a function call.
  if (value == null) {  // Intentionally matches undefined.
    // Java returns null from maps where there is no corresponding key while
    // JS returns undefined.
    // We always output null for compatibility with Java which does not have a
    // distinct undefined value.
    return ' null ';
  }
  if (soyChecks.isJS(value)) {
    return value.getContent();
  }
  if (value instanceof SafeScript) {
    return SafeScript.unwrap(value);
  }
  // MOE:begin_strip
  if (value instanceof TsSafeScript) {
    return tsSafeUnwrappers.unwrapSafeScript(value);
  }
  // MOE:end_strip
  switch (typeof value) {
    case 'boolean':
    case 'number':
      return ' ' + value + ' ';
    default:
      return '\'' + $$escapeJsStringHelper(String(value)) + '\'';
  }
};


/**
 * Escapes characters in the string to make it valid content for a JS regular
 * expression literal.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeJsRegex = function(value) {
  return $$escapeJsRegexHelper(value);
};


/**
 * Matches all URI mark characters that conflict with HTML attribute delimiters
 * or that cannot appear in a CSS uri.
 * From <a href="http://www.w3.org/TR/CSS2/grammar.html">G.2: CSS grammar</a>
 * <pre>
 *     url        ([!#$%&*-~]|{nonascii}|{escape})*
 * </pre>
 *
 * @const {!RegExp}
 */
const $$problematicUriMarks_ = /['()]/g;

/**
 * @param {string} ch A single character in {@link $$problematicUriMarks_}.
 * @return {string}
 */
const $$pctEncode_ = function(ch) {
  return '%' + ch.charCodeAt(0).toString(16);
};

/**
 * Escapes a string so that it can be safely included in a URI.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeUri = function(value) {
  // NOTE: We don't check for SanitizedUri or SafeUri, because just because
  // something is already a valid complete URL doesn't mean we don't want to
  // encode it as a component.  For example, it would be bad if
  // ?redirect={$url} didn't escape ampersands, because in that template, the
  // continue URL should be treated as a single unit.

  // Apostophes and parentheses are not matched by encodeURIComponent.
  // They are technically special in URIs, but only appear in the obsolete mark
  // production in Appendix D.2 of RFC 3986, so can be encoded without changing
  // semantics.
  const encoded = $$escapeUriHelper(value);
  $$problematicUriMarks_.lastIndex = 0;
  if ($$problematicUriMarks_.test(encoded)) {
    return encoded.replace($$problematicUriMarks_, $$pctEncode_);
  }
  return encoded;
};


/**
 * Removes rough edges from a URI by escaping any raw HTML/JS string delimiters.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$normalizeUri = function(value) {
  return $$normalizeUriHelper(value);
};


/**
 * Vets a URI's protocol and removes rough edges from a URI by escaping
 * any raw HTML/JS string delimiters.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$filterNormalizeUri = function(value) {
  if (soyChecks.isURI(value)) {
    return $$normalizeUri(value);
  }
  if (soyChecks.isTrustedResourceURI(value)) {
    return $$normalizeUri(value);
  }
  if (value instanceof SafeUrl) {
    return $$normalizeUri(SafeUrl.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsSafeUrl) {
    return soy.$$normalizeUri(tsSafeUnwrappers.unwrapSafeUrl(value));
  }
  // MOE:end_strip
  if (value instanceof TrustedResourceUrl) {
    return $$normalizeUri(TrustedResourceUrl.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsTrustedResourceUrl) {
    return soy.$$normalizeUri(tsSafeUnwrappers.unwrapTrustedResourceUrl(value));
  }
  // MOE:end_strip
  return $$filterNormalizeUriHelper(value);
};


/**
 * Vets a URI for usage as an image source.
 *
 * @param {?} value The value to filter. Might not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$filterNormalizeMediaUri = function(value) {
  // Image URIs are filtered strictly more loosely than other types of URIs.
  // TODO(shwetakarwa): Add tests for this in soyutils_test_helper while adding
  // tests for filterTrustedResourceUri.
  if (soyChecks.isURI(value)) {
    return $$normalizeUri(value);
  }
  if (soyChecks.isTrustedResourceURI(value)) {
    return $$normalizeUri(value);
  }
  if (value instanceof SafeUrl) {
    return $$normalizeUri(SafeUrl.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsSafeUrl) {
    return soy.$$normalizeUri(tsSafeUnwrappers.unwrapSafeUrl(value));
  }
  // MOE:end_strip
  if (value instanceof TrustedResourceUrl) {
    return $$normalizeUri(TrustedResourceUrl.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsTrustedResourceUrl) {
    return soy.$$normalizeUri(tsSafeUnwrappers.unwrapTrustedResourceUrl(value));
  }
  // MOE:end_strip
  return $$filterNormalizeMediaUriHelper(value);
};


/**
 * Like filterNormalizeUri but also escapes ';'.
 * @param {?} value The value to filter.
 * @return {string} An escaped version of value.
 */
const $$filterNormalizeRefreshUri = function(value) {
  return $$filterNormalizeUri(value).replace(/;/g, '%3B');
};


/**
 * Vets a URI for usage as a resource. Makes sure the input value is a compile
 * time constant or a TrustedResource not in attacker's control.
 *
 * @param {?} value The value to filter.
 * @return {string} The value content.
 */
const $$filterTrustedResourceUri = function(value) {
  if (soyChecks.isTrustedResourceURI(value)) {
    return value.getContent();
  }
  if (value instanceof TrustedResourceUrl) {
    return TrustedResourceUrl.unwrap(value);
  }
  // MOE:begin_strip
  if (value instanceof TsTrustedResourceUrl) {
    return soy.$$normalizeUri(tsSafeUnwrappers.unwrapTrustedResourceUrl(value));
  }
  // MOE:end_strip
  asserts.fail('Bad value `%s` for |filterTrustedResourceUri', [String(value)]);
  return 'about:invalid#zSoyz';
};


/**
 * Allows only data-protocol image URI's.
 *
 * @param {?} value The value to process. May not be a string, but the value
 *     will be coerced to a string.
 * @return {!SanitizedUri} An escaped version of value.
 */
const $$filterImageDataUri = function(value) {
  // NOTE: Even if it's a SanitizedUri, we will still filter it.
  return VERY_UNSAFE.ordainSanitizedUri($$filterImageDataUriHelper(value));
};


/**
 * Allows only sip URIs.
 *
 * @param {?} value The value to process. May not be a string, but the value
 *     will be coerced to a string.
 * @return {!SanitizedUri} An escaped version of value.
 */
const $$filterSipUri = function(value) {
  // NOTE: Even if it's a SanitizedUri, we will still filter it.
  return VERY_UNSAFE.ordainSanitizedUri($$filterSipUriHelper(value));
};

/**
 * Function that converts sms uri string to a sanitized uri
 *
 * @param {string} value sms uri
 * @return {!SanitizedUri} An sanitized version of the sms uri.
 */
const $$strSmsUriToUri = function(value) {
  // NOTE: Even if it's a SanitizedUri, we will still filter it.
  return VERY_UNSAFE.ordainSanitizedUri($$filterSmsUriHelper(value));
};


/**
 * Allows only tel URIs.
 *
 * @param {?} value The value to process. May not be a string, but the value
 *     will be coerced to a string.
 * @return {!SanitizedUri} An escaped version of value.
 */
const $$filterTelUri = function(value) {
  // NOTE: Even if it's a SanitizedUri, we will still filter it.
  return VERY_UNSAFE.ordainSanitizedUri($$filterTelUriHelper(value));
};


/**
 * Escapes a string so it can safely be included inside a quoted CSS string.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} An escaped version of value.
 */
const $$escapeCssString = function(value) {
  return $$escapeCssStringHelper(value);
};


/**
 * Encodes a value as a CSS identifier part, keyword, or quantity.
 *
 * @param {?} value The value to escape. May not be a string, but the value
 *     will be coerced to a string.
 * @return {string} A safe CSS identifier part, keyword, or quanitity.
 */
const $$filterCssValue = function(value) {
  if (soyChecks.isCss(value)) {
    return $$embedCssIntoHtml_(value.getContent());
  }
  // Uses == to intentionally match null and undefined for Java compatibility.
  if (value == null) {
    return '';
  }
  if (value instanceof SafeStyle) {
    return $$embedCssIntoHtml_(SafeStyle.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsSafeStyle) {
    return $$embedCssIntoHtml_(tsSafeUnwrappers.unwrapSafeStyle(value));
  }
  // MOE:end_strip
  // Note: SoyToJsSrcCompiler uses $$filterCssValue both for the contents of
  // <style> (list of rules) and for the contents of style="" (one set of
  // declarations). We support SafeStyleSheet here to be used inside <style> but
  // it also wrongly allows it inside style="". We should instead change
  // SoyToJsSrcCompiler to use a different function inside <style>.
  if (value instanceof SafeStyleSheet) {
    return $$embedCssIntoHtml_(SafeStyleSheet.unwrap(value));
  }
  // MOE:begin_strip
  if (value instanceof TsSafeStyleSheet) {
    return $$embedCssIntoHtml_(tsSafeUnwrappers.unwrapSafeStyleSheet(value));
  }
  // MOE:end_strip
  return $$filterCssValueHelper(value);
};

/**
 * Encodes a value as a CSP nonce value.
 *
 * @param {?} value The value to escape. Does not have to be a string, but the
 *     value will be coerced to a string.
 * @return {string} A safe CSP nonce value.
 */
const $$filterCspNonceValue = function(value) {
  return $$filterCspNonceValueHelper(value);
};


// -----------------------------------------------------------------------------
// Basic directives/functions.


/**
 * Converts \r\n, \r, and \n to <br>s
 * @param {?} value The string in which to convert newlines.
 * @return {string|!SanitizedHtml} A copy of `value` with
 *     converted newlines. If `value` is SanitizedHtml, the return value
 *     is also SanitizedHtml, of the same known directionality.
 */
const $$changeNewlineToBr = function(value) {
  const result = googString.newLineToBr(String(value), false);
  if (isContentKind_(value, SanitizedContentKind.HTML)) {
    return VERY_UNSAFE.ordainSanitizedHtml(result, getContentDir(value));
  }
  return result;
};


/**
 * Inserts word breaks ('wbr' tags) into a HTML string at a given interval. The
 * counter is reset if a space is encountered. Word breaks aren't inserted into
 * HTML tags or entities. Entities count towards the character count; HTML tags
 * do not.
 *
 * @param {?} value The HTML string to insert word breaks into. Can be other
 *     types, but the value will be coerced to a string.
 * @param {number} maxCharsBetweenWordBreaks Maximum number of non-space
 *     characters to allow before adding a word break.
 * @return {string|!SanitizedHtml} The string including word
 *     breaks. If `value` is SanitizedHtml, the return value
 *     is also SanitizedHtml, of the same known directionality.
 * @deprecated The |insertWordBreaks directive is deprecated.
 *     Prefer wrapping with CSS white-space: break-word.
 */
const $$insertWordBreaks = function(value, maxCharsBetweenWordBreaks) {
  const result =
      googFormat.insertWordBreaks(String(value), maxCharsBetweenWordBreaks);
  if (isContentKind_(value, SanitizedContentKind.HTML)) {
    return VERY_UNSAFE.ordainSanitizedHtml(result, getContentDir(value));
  }
  return result;
};

/**
 * Conditionally concatenates two attribute values with a delimiter if they are
 * both non-empty.
 *
 * @param {string} l
 * @param {string} r
 * @param {string} delimiter
 * @return {string}
 */
const $$concatAttributeValues = function(l, r, delimiter) {
  if (!l) {
    return r;
  }
  if (!r) {
    return l;
  }
  return l + delimiter + r;
};


/**
 * Conditionally concatenates two attribute values with a delimiter if they are
 * both non-empty.
 *
 * @param {string} l
 * @param {string} r
 * @return {!SanitizedCss|!$$EMPTY_STRING_}
 */
const $$concatCssValues = function(l, r) {
  if (l !== $$EMPTY_STRING_.VALUE) {
    asserts.assertInstanceof(l, SanitizedCss);
  }
  if (r !== $$EMPTY_STRING_.VALUE) {
    asserts.assertInstanceof(r, SanitizedCss);
  }
  return VERY_UNSAFE.$$ordainSanitizedCssForInternalBlocks(
      $$concatAttributeValues(l, r, ';'));
};


/**
 * Truncates a string to a given max length (if it's currently longer),
 * optionally adding ellipsis at the end.
 *
 * @param {?} str The string to truncate. Can be other types, but the value will
 *     be coerced to a string.
 * @param {number} maxLen The maximum length of the string after truncation
 *     (including ellipsis, if applicable).
 * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
 *     truncation.
 * @return {string} The string after truncation.
 */
const $$truncate = function(str, maxLen, doAddEllipsis) {
  str = String(str);
  if (str.length <= maxLen) {
    return str;  // no need to truncate
  }

  // If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
  // too small, just turn off doAddEllipsis.
  if (doAddEllipsis) {
    if (maxLen > 3) {
      maxLen -= 3;
    } else {
      doAddEllipsis = false;
    }
  }

  // Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
  if ($$isHighSurrogate_(str.charCodeAt(maxLen - 1)) &&
      $$isLowSurrogate_(str.charCodeAt(maxLen))) {
    maxLen -= 1;
  }

  // Truncate.
  str = str.substring(0, maxLen);

  // Add ellipsis.
  if (doAddEllipsis) {
    str += '...';
  }

  return str;
};

/**
 * Private helper for $$truncate() to check whether a char is a high surrogate.
 * @param {number} cc The codepoint to check.
 * @return {boolean} Whether the given codepoint is a unicode high surrogate.
 */
const $$isHighSurrogate_ = function(cc) {
  return 0xD800 <= cc && cc <= 0xDBFF;
};

/**
 * Private helper for $$truncate() to check whether a char is a low surrogate.
 * @param {number} cc The codepoint to check.
 * @return {boolean} Whether the given codepoint is a unicode low surrogate.
 */
const $$isLowSurrogate_ = function(cc) {
  return 0xDC00 <= cc && cc <= 0xDFFF;
};


/**
 * Checks if the list contains the given element.
 * @param {!Array<?>} list
 * @param {*} val
 * @return {boolean}
 */
const $$listContains = function(list, val) {
  return $$listIndexOf(list, val) >= 0;
};


/**
 * Returns the index of val in list or -1
 * @param {!Array<?>} list
 * @param {*} val
 * @return {number}
 */
const $$listIndexOf = function(list, val) {
  return googArray.findIndex(list, (el) => $$equals(val, el));
};


/**
 * Returns an array slice of list.
 * @param {!Array<T>} list
 * @param {number} from
 * @param {?number} to
 * @return {!Array<T>}
 * @template T
 */
const $$listSlice = function(list, from, to) {
  return to == null ? list.slice(from) : list.slice(from, to);
};


/**
 * Reverses a list and returns it. The original list passed is unaffected.
 * @param {!Array<T>} list
 * @return {!Array<T>}
 * @template T
 */
const $$listReverse = function(list) {
  let listCopy = [...list];
  return listCopy.reverse();
};

/**
 * A helper function to provide tight type inference on array literals.
 * @param {...T} args
 * @return {!Array<T>}
 * @template T
 */
const $$makeArray = function(...args) {
  return args;
};

/**
 * A helper for list comprehension.
 * @param {!IArrayLike<T>} list
 * @param {function(T,number):boolean} filter
 * @param {function(T,number):V} map
 * @return {!IArrayLike<V>}
 * @template T, V
 */
const $$filterAndMap = function(list, filter, map) {
  let array = [];
  for (let i = 0; i < list.length; i++) {
    if (filter(list[i], i)) {
      array.push(map(list[i], i));
    }
  }
  return array;
};

/**
 * Sorts a list of numbers in numerical order.
 * @param {!IArrayLike<T>} list
 * @return {!Array<T>}
 * @template T extends number
 */
const $$numberListSort = function(list) {
  return googArray.toArray(list).sort((a, b) => a - b);
};


/**
 * Sorts a list of strings in lexicographic order.
 * @param {!IArrayLike<string>} list
 * @return {!Array<string>}
 */
const $$stringListSort = function(list) {
  return googArray.toArray(list).sort();
};


/**
 * Converts the ASCII characters in the given string to lower case.
 * @param {string} s
 * @return {string}
 */
const $$strToAsciiLowerCase = function(s) {
  return googArray.map(s, $$charToAsciiLowerCase_).join('');
};

/**
 * Lowercases a single character string.
 * @return {string}
 */
const $$charToAsciiLowerCase_ = (/** string */ c) => {
  asserts.assert(c.length === 1);
  return 'A' <= c && c <= 'Z' ? c.toLowerCase() : c;
};

/**
 * Uppercases a single character string.
 * @return {string}
 */
const $$charToAsciiUpperCase_ = (/** string */ c) => {
  asserts.assert(c.length === 1);
  return 'a' <= c && c <= 'z' ? c.toUpperCase() : c;
};

/**
 * Converts the ASCII characters in the given string to upper case.
 * @param {string} s
 * @return {string}
 */
const $$strToAsciiUpperCase = function(s) {
  return googArray.map(s, $$charToAsciiUpperCase_).join('');
};


/**
 * Trims a string.
 * @param {string} s
 * @return {string}
 */
const $$strTrim = function(s) {
  return s.trim();
};

/**
 * Returns whether s starts with val.
 * @param {string} s
 * @param {string} val
 * @return {boolean}
 */
const $$strStartsWith = function(s, val) {
  return s.length >= val.length && s.substring(0, val.length) === val;
};


/**
 * Returns whether s ends with val.
 * @param {string} s
 * @param {string} val
 * @return {boolean}
 */
const $$strEndsWith = function(s, val) {
  return s.length >= val.length && s.substring(s.length - val.length) === val;
};


/**
 * Splits a string.
 * @param {string} s
 * @param {string} sep
 * @return {!Array<string>}
 */
const $$strSplit = function(s, sep) {
  return s.split(sep);
};


/**
 * Replaces all occurrences in s of match with token.
 * @param {string} s
 * @param {string} match
 * @param {string} token
 * @return {string}
 */
const $$strReplaceAll = function(s, match, token) {
  return googString.replaceAll(s, match, token);
};


// -----------------------------------------------------------------------------
// Bidi directives/functions.


/**
 * Cache of bidi formatter by context directionality, so we don't keep on
 * creating new objects.
 * @type {!Object<!BidiFormatter>}
 */
const bidiFormatterCache_ = {};


/**
 * Returns cached bidi formatter for bidiGlobalDir, or creates a new one.
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @return {!BidiFormatter} A formatter for bidiGlobalDir.
 */
const getBidiFormatterInstance_ = function(bidiGlobalDir) {
  return bidiFormatterCache_[bidiGlobalDir] ||
      (bidiFormatterCache_[bidiGlobalDir] = new BidiFormatter(bidiGlobalDir));
};


/**
 * Estimate the overall directionality of text. If opt_isHtml, makes sure to
 * ignore the LTR nature of the mark-up and escapes in text, making the logic
 * suitable for HTML and HTML-escaped text.
 * If text has a bidi.Dir-valued contentDir, this is used instead of
 * estimating the directionality.
 *
 * @param {?} text The content whose directionality is to be estimated.
 * @param {boolean=} isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {number} 1 if text is LTR, -1 if it is RTL, and 0 if it is neutral.
 */
const $$bidiTextDir = function(text, isHtml) {
  const contentDir = getContentDir(text);
  if (contentDir != null) {
    return contentDir;
  }
  isHtml = isHtml || isContentKind_(text, SanitizedContentKind.HTML);
  return bidi.estimateDirection(text + '', isHtml);
};


/**
 * Returns 'dir="ltr"' or 'dir="rtl"', depending on text's estimated
 * directionality, if it is not the same as bidiGlobalDir.
 * Otherwise, returns the empty string.
 * If opt_isHtml, makes sure to ignore the LTR nature of the mark-up and escapes
 * in text, making the logic suitable for HTML and HTML-escaped text.
 * If text has a bidi.Dir-valued contentDir, this is used instead of
 * estimating the directionality.
 *
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {?} text The content whose directionality is to be estimated.
 * @param {boolean=} isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {!SanitizedHtmlAttribute} 'dir="rtl"' for RTL text in
 *     non-RTL context; 'dir="ltr"' for LTR text in non-LTR context;
 *     else, the empty string.
 */
const $$bidiDirAttr = function(bidiGlobalDir, text, isHtml) {
  const formatter = getBidiFormatterInstance_(bidiGlobalDir);
  let contentDir = getContentDir(text);
  if (contentDir == null) {
    isHtml = isHtml || isContentKind_(text, SanitizedContentKind.HTML);
    contentDir = bidi.estimateDirection(text + '', isHtml);
  }
  return VERY_UNSAFE.ordainSanitizedHtmlAttribute(
      formatter.knownDirAttr(contentDir));
};

/**
 * Returns the name of the start edge ('left' or 'right') for the current global
 * bidi directionality.
 *
 * @return {string}
 */
const $$bidiStartEdge = function(/** number */ dir) {
  return dir < 0 ? 'right' : 'left';
};

/**
 * Returns the name of the end edge ('left' or 'right') for the current global
 * bidi directionality.
 *
 * @return {string}
 */
const $$bidiEndEdge = function(/** number */ dir) {
  return dir < 0 ? 'left' : 'right';
};

/**
 * Returns a bidi mark character (LRM or RLM) for the given bidi directionality.
 *
 * @return {string}
 */
const $$bidiMark = function(/** number */ dir) {
  return dir < 0 ? '\u200F' /*RLM*/ : '\u200E' /*LRM*/;
};


/**
 * Returns a Unicode BiDi mark matching bidiGlobalDir (LRM or RLM) if the
 * directionality or the exit directionality of text are opposite to
 * bidiGlobalDir. Otherwise returns the empty string.
 * If opt_isHtml, makes sure to ignore the LTR nature of the mark-up and escapes
 * in text, making the logic suitable for HTML and HTML-escaped text.
 * If text has a bidi.Dir-valued contentDir, this is used instead of
 * estimating the directionality.
 *
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {?} text The content whose directionality is to be estimated.
 * @param {boolean=} isHtml Whether text is HTML/HTML-escaped.
 *     Default: false.
 * @return {string} A Unicode bidi mark matching bidiGlobalDir, or the empty
 *     string when text's overall and exit directionalities both match
 *     bidiGlobalDir, or bidiGlobalDir is 0 (unknown).
 */
const $$bidiMarkAfter = function(bidiGlobalDir, text, isHtml) {
  const formatter = getBidiFormatterInstance_(bidiGlobalDir);
  isHtml = isHtml || isContentKind_(text, SanitizedContentKind.HTML);
  return formatter.markAfterKnownDir(getContentDir(text), text + '', isHtml);
};


/**
 * Returns text wrapped in a <span dir="ltr|rtl"> according to its
 * directionality - but only if that is neither neutral nor the same as the
 * global context. Otherwise, returns text unchanged.
 * Always treats text as HTML/HTML-escaped, i.e. ignores mark-up and escapes
 * when estimating text's directionality.
 * If text has a bidi.Dir-valued contentDir, this is used instead of
 * estimating the directionality.
 *
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {?} text The string to be wrapped. Can be other types, but the value
 *     will be coerced to a string.
 * @return {string} The wrapped text.
 */
const $$bidiSpanWrap = function(bidiGlobalDir, text) {
  const formatter = getBidiFormatterInstance_(bidiGlobalDir);

  // We always treat the value as HTML, because span-wrapping is only useful
  // when its output will be treated as HTML (without escaping), and because
  // |bidiSpanWrap is not itself specified to do HTML escaping in Soy. (Both
  // explicit and automatic HTML escaping, if any, is done before calling
  // |bidiSpanWrap because the BidiSpanWrapDirective Java class implements
  // SanitizedContentOperator, but this does not mean that the input has to be
  // HTML SanitizedContent.
  const html =
      uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(
          Const.from('Soy |bidiSpanWrap is applied on an autoescaped text.'),
          String(text));
  const wrappedHtml =
      formatter.spanWrapSafeHtmlWithKnownDir(getContentDir(text), html);

  // Like other directives whose Java class implements SanitizedContentOperator,
  // |bidiSpanWrap is called after the escaping (if any) has already been done,
  // and thus there is no need for it to produce actual SanitizedContent.
  return SafeHtml.unwrap(wrappedHtml);
};


/**
 * Returns text wrapped in Unicode BiDi formatting characters according to its
 * directionality, i.e. either LRE or RLE at the beginning and PDF at the end -
 * but only if text's directionality is neither neutral nor the same as the
 * global context. Otherwise, returns text unchanged.
 * Only treats SanitizedHtml as HTML/HTML-escaped, i.e. ignores mark-up
 * and escapes when estimating text's directionality.
 * If text has a bidi.Dir-valued contentDir, this is used instead of
 * estimating the directionality.
 *
 * @param {number} bidiGlobalDir The global directionality context: 1 if ltr, -1
 *     if rtl, 0 if unknown.
 * @param {?} text The string to be wrapped. Can be other types, but the value
 *     will be coerced to a string.
 * @return {!SanitizedHtml|string} The wrapped string.
 */
const $$bidiUnicodeWrap = function(bidiGlobalDir, text) {
  const formatter = getBidiFormatterInstance_(bidiGlobalDir);

  // We treat the value as HTML if and only if it says it's HTML.
  const isHtml = isContentKind_(text, SanitizedContentKind.HTML);
  const wrappedText =
      formatter.unicodeWrapWithKnownDir(getContentDir(text), text + '', isHtml);

  // Bidi-wrapping a value converts it to the context directionality. Since it
  // does not cost us anything, we will indicate this known direction in the
  // output SanitizedContent, even though the intended consumer of that
  // information - a bidi wrapping directive - has already been run.
  const wrappedTextDir = formatter.getContextDir();

  // Unicode-wrapping safe HTML string data gives valid, safe HTML string data.
  // ATTENTION: Do these need to be ...ForInternalBlocks()?
  if (isHtml) {
    return VERY_UNSAFE.ordainSanitizedHtml(wrappedText, wrappedTextDir);
  }

  // Unicode-wrapping does not conform to the syntax of the other types of
  // content. For lack of anything better to do, we do not declare a content
  // kind at all by falling through to the non-SanitizedContent case below.
  // TODO(aharon): Consider throwing a runtime error on receipt of
  // SanitizedContent other than HTML.

  // The input was not SanitizedContent, so our output isn't SanitizedContent
  // either.
  return wrappedText;
};

// -----------------------------------------------------------------------------
// Assertion methods used by runtime.

/**
 * Checks if the type assertion is true if asserts.ENABLE_ASSERTS is
 * true. Report errors on runtime types if goog.DEBUG is true.
 * @param {boolean} condition The type check condition.
 * @param {string} paramName The Soy name of the parameter.
 * @param {?} param The JS object for the parameter.
 * @param {string} paramKind Whether it is a normal parameter, an injected
 *     parameter, or a state variable.
 * @param {string} jsDocTypeStr SoyDoc type str.
 * @return {?} the param value
 * @throws {!asserts.AssertionError} When the condition evaluates to false.
 */
const assertParamType = function(
    condition, paramName, param, paramKind, jsDocTypeStr) {
  if (asserts.ENABLE_ASSERTS && !condition) {
    const msg = 'expected ' + paramKind + ' ' + paramName + ' of type ' +
        jsDocTypeStr +
        (goog.DEBUG ? (', but got ' + googDebug.runtimeType(param)) : '') + '.';
    asserts.fail(msg);
  }
  return param;
};

/**
 * An object to mark internal callsites with, this should make accidentally
 * calling these things less likely.
 * @const
 * @type {!Object}
 */
const $$internalCallMarkerDoNotUse = {};

/**
 * A debug time check that our internal call sites are only called by other soy
 * templates.
 *
 * @param {?} marker
 * @return {void}
 */
const $$areYouAnInternalCaller = (marker) =>{
  asserts.assert(
      marker === $$internalCallMarkerDoNotUse,
      'found an incorrect call marker, was an internal function called from the top level?');
};

// -----------------------------------------------------------------------------
// Used for inspecting Soy template information from rendered pages.

/**
 * Whether we should generate additional HTML comments.
 * @type {boolean}
 */
let $$debugSoyTemplateInfo = false;

/**
 * Configures whether we should generate additional HTML comments for
 * inspecting Soy template information from rendered pages.
 */
function setDebugSoyTemplateInfo(/** boolean */ debugSoyTemplateInfo) {
  $$debugSoyTemplateInfo = debugSoyTemplateInfo;
}

/** @return {boolean}  Whether we should generate additional debugging data */
function $$getDebugSoyTemplateInfo() {
  return $$debugSoyTemplateInfo;
}

// -----------------------------------------------------------------------------
// Generated code.


// START GENERATED CODE FOR ESCAPERS.

/**
 * @type {function (*) : string}
 */
const $$escapeUriHelper = function(v) {
  return encodeURIComponent(String(v));
};

/**
 * Maps characters to the escaped versions for the named escape directives.
 * @type {!Object<string, string>}
 */
const $$ESCAPE_MAP_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = {
  '\x00': '\x26#0;',
  '\x09': '\x26#9;',
  '\x0a': '\x26#10;',
  '\x0b': '\x26#11;',
  '\x0c': '\x26#12;',
  '\x0d': '\x26#13;',
  ' ': '\x26#32;',
  '\x22': '\x26quot;',
  '\x26': '\x26amp;',
  '\x27': '\x26#39;',
  '-': '\x26#45;',
  '\/': '\x26#47;',
  '\x3c': '\x26lt;',
  '\x3d': '\x26#61;',
  '\x3e': '\x26gt;',
  '`': '\x26#96;',
  '\x85': '\x26#133;',
  '\xa0': '\x26#160;',
  '\u2028': '\x26#8232;',
  '\u2029': '\x26#8233;',
};

/**
 * A function that can be used with String.replace.
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 */
const $$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_ = function(ch) {
  return $$ESCAPE_MAP_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_[ch];
};

/**
 * Maps characters to the escaped versions for the named escape directives.
 * @type {!Object<string, string>}
 */
const $$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = {
  '\x00': '\\x00',
  '\x08': '\\x08',
  '\x09': '\\t',
  '\x0a': '\\n',
  '\x0b': '\\x0b',
  '\x0c': '\\f',
  '\x0d': '\\r',
  '\x22': '\\x22',
  '$': '\\x24',
  '\x26': '\\x26',
  '\x27': '\\x27',
  '(': '\\x28',
  ')': '\\x29',
  '*': '\\x2a',
  '+': '\\x2b',
  ',': '\\x2c',
  '-': '\\x2d',
  '.': '\\x2e',
  '\/': '\\\/',
  ':': '\\x3a',
  '\x3c': '\\x3c',
  '\x3d': '\\x3d',
  '\x3e': '\\x3e',
  '?': '\\x3f',
  '\x5b': '\\x5b',
  '\\': '\\\\',
  '\x5d': '\\x5d',
  '^': '\\x5e',
  '\x7b': '\\x7b',
  '|': '\\x7c',
  '\x7d': '\\x7d',
  '\x85': '\\x85',
  '\u2028': '\\u2028',
  '\u2029': '\\u2029',
};

/**
 * A function that can be used with String.replace.
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 */
const $$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_ = function(ch) {
  return $$ESCAPE_MAP_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_[ch];
};

/**
 * Maps characters to the escaped versions for the named escape directives.
 * @type {!Object<string, string>}
 */
const $$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_ = {
  '\x00': '\\0 ',
  '\x08': '\\8 ',
  '\x09': '\\9 ',
  '\x0a': '\\a ',
  '\x0b': '\\b ',
  '\x0c': '\\c ',
  '\x0d': '\\d ',
  '\x22': '\\22 ',
  '\x26': '\\26 ',
  '\x27': '\\27 ',
  '(': '\\28 ',
  ')': '\\29 ',
  '*': '\\2a ',
  '\/': '\\2f ',
  ':': '\\3a ',
  ';': '\\3b ',
  '\x3c': '\\3c ',
  '\x3d': '\\3d ',
  '\x3e': '\\3e ',
  '@': '\\40 ',
  '\\': '\\5c ',
  '\x7b': '\\7b ',
  '\x7d': '\\7d ',
  '\x85': '\\85 ',
  '\xa0': '\\a0 ',
  '\u2028': '\\2028 ',
  '\u2029': '\\2029 ',
};

/**
 * A function that can be used with String.replace.
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 */
const $$REPLACER_FOR_ESCAPE_CSS_STRING_ = function(ch) {
  return $$ESCAPE_MAP_FOR_ESCAPE_CSS_STRING_[ch];
};

/**
 * Maps characters to the escaped versions for the named escape directives.
 * @type {!Object<string, string>}
 */
const $$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_ = {
  '\x00': '%00',
  '\x01': '%01',
  '\x02': '%02',
  '\x03': '%03',
  '\x04': '%04',
  '\x05': '%05',
  '\x06': '%06',
  '\x07': '%07',
  '\x08': '%08',
  '\x09': '%09',
  '\x0a': '%0A',
  '\x0b': '%0B',
  '\x0c': '%0C',
  '\x0d': '%0D',
  '\x0e': '%0E',
  '\x0f': '%0F',
  '\x10': '%10',
  '\x11': '%11',
  '\x12': '%12',
  '\x13': '%13',
  '\x14': '%14',
  '\x15': '%15',
  '\x16': '%16',
  '\x17': '%17',
  '\x18': '%18',
  '\x19': '%19',
  '\x1a': '%1A',
  '\x1b': '%1B',
  '\x1c': '%1C',
  '\x1d': '%1D',
  '\x1e': '%1E',
  '\x1f': '%1F',
  ' ': '%20',
  '\x22': '%22',
  '\x27': '%27',
  '(': '%28',
  ')': '%29',
  '\x3c': '%3C',
  '\x3e': '%3E',
  '\\': '%5C',
  '\x7b': '%7B',
  '\x7d': '%7D',
  '\x7f': '%7F',
  '\x85': '%C2%85',
  '\xa0': '%C2%A0',
  '\u2028': '%E2%80%A8',
  '\u2029': '%E2%80%A9',
  '\uff01': '%EF%BC%81',
  '\uff03': '%EF%BC%83',
  '\uff04': '%EF%BC%84',
  '\uff06': '%EF%BC%86',
  '\uff07': '%EF%BC%87',
  '\uff08': '%EF%BC%88',
  '\uff09': '%EF%BC%89',
  '\uff0a': '%EF%BC%8A',
  '\uff0b': '%EF%BC%8B',
  '\uff0c': '%EF%BC%8C',
  '\uff0f': '%EF%BC%8F',
  '\uff1a': '%EF%BC%9A',
  '\uff1b': '%EF%BC%9B',
  '\uff1d': '%EF%BC%9D',
  '\uff1f': '%EF%BC%9F',
  '\uff20': '%EF%BC%A0',
  '\uff3b': '%EF%BC%BB',
  '\uff3d': '%EF%BC%BD',
};

/**
 * A function that can be used with String.replace.
 * @param {string} ch A single character matched by a compatible matcher.
 * @return {string} A token in the output language.
 */
const $$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_ = function(ch) {
  return $$ESCAPE_MAP_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_[ch];
};

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_ESCAPE_HTML_ = /[\x00\x22\x26\x27\x3c\x3e]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_NORMALIZE_HTML_ = /[\x00\x22\x27\x3c\x3e]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_ESCAPE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x26\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_ = /[\x00\x09-\x0d \x22\x27\x2d\/\x3c-\x3e`\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_ESCAPE_JS_STRING_ = /[\x00\x08-\x0d\x22\x26\x27\/\x3c-\x3e\x5b-\x5d\x7b\x7d\x85\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_ESCAPE_JS_REGEX_ = /[\x00\x08-\x0d\x22\x24\x26-\/\x3a\x3c-\x3f\x5b-\x5e\x7b-\x7d\x85\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_ESCAPE_CSS_STRING_ = /[\x00\x08-\x0d\x22\x26-\x2a\/\x3a-\x3e@\\\x7b\x7d\x85\xa0\u2028\u2029]/g;

/**
 * Matches characters that need to be escaped for the named directives.
 * @type {!RegExp}
 */
const $$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_ = /[\x00- \x22\x27-\x29\x3c\x3e\\\x7b\x7d\x7f\x85\xa0\u2028\u2029\uff01\uff03\uff04\uff06-\uff0c\uff0f\uff1a\uff1b\uff1d\uff1f\uff20\uff3b\uff3d]/g;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_CSS_VALUE_ = /^(?!-*(?:expression|(?:moz-)?binding))(?:(?:[.#]?-?(?:[_a-z0-9-]+)(?:-[_a-z0-9-]+)*-?|(?:rgb|hsl)a?\([0-9.%,\u0020]+\)|[-+]?(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)(?:e-?[0-9]+)?(?:[a-z]{1,4}|%)?|!important)(?:\s*[,\u0020]\s*|$))*$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_NORMALIZE_URI_ = /^(?:(?:https?|mailto):|[^&:\/?#]*(?:[\/?#]|$))/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_NORMALIZE_MEDIA_URI_ = /^[^&:\/?#]*(?:[\/?#]|$)|^https?:|^data:image\/[a-z0-9+]+;base64,[a-z0-9+\/]+=*$|^blob:/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_IMAGE_DATA_URI_ = /^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_SIP_URI_ = /^sip:[0-9a-z;=\-+._!~*'\u0020\/():&$#?@,]+$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_SMS_URI_ = /^sms:[0-9a-z;=\-+._!~*'\u0020\/():&$#?@,]+$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_TEL_URI_ = /^tel:[0-9a-z;=\-+._!~*'\u0020\/():&$#?@,]+$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_HTML_ATTRIBUTES_ = /^(?!on|src|(?:action|archive|background|cite|classid|codebase|content|data|dsync|href|http-equiv|longdesc|style|usemap)\s*$)(?:[a-z0-9_$:-]*)$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_ = /^(?!base|iframe|link|noframes|noscript|object|script|style|textarea|title|xmp)[a-z0-9_$:-]*$/i;

/**
 * A pattern that vets values produced by the named directives.
 * @type {!RegExp}
 */
const $$FILTER_FOR_FILTER_CSP_NONCE_VALUE_ = /^[a-zA-Z0-9+\/_-]+={0,2}$/;

/**
 * A helper for the Soy directive |escapeHtml
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$escapeHtmlHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_ESCAPE_HTML_,
      $$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |normalizeHtml
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$normalizeHtmlHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_NORMALIZE_HTML_,
      $$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |escapeHtmlNospace
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$escapeHtmlNospaceHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_ESCAPE_HTML_NOSPACE_,
      $$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |normalizeHtmlNospace
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$normalizeHtmlNospaceHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_NORMALIZE_HTML_NOSPACE_,
      $$REPLACER_FOR_ESCAPE_HTML__AND__NORMALIZE_HTML__AND__ESCAPE_HTML_NOSPACE__AND__NORMALIZE_HTML_NOSPACE_);
};

/**
 * A helper for the Soy directive |escapeJsString
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$escapeJsStringHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_ESCAPE_JS_STRING_,
      $$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};

/**
 * A helper for the Soy directive |escapeJsRegex
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$escapeJsRegexHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_ESCAPE_JS_REGEX_,
      $$REPLACER_FOR_ESCAPE_JS_STRING__AND__ESCAPE_JS_REGEX_);
};

/**
 * A helper for the Soy directive |escapeCssString
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$escapeCssStringHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_ESCAPE_CSS_STRING_,
      $$REPLACER_FOR_ESCAPE_CSS_STRING_);
};

/**
 * A helper for the Soy directive |filterCssValue
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterCssValueHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_CSS_VALUE_.test(str)) {
    asserts.fail('Bad value `%s` for |filterCssValue', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |normalizeUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$normalizeUriHelper = function(value) {
  const str = String(value);
  return str.replace(
      $$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_,
      $$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_);
};

/**
 * A helper for the Soy directive |filterNormalizeUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterNormalizeUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_NORMALIZE_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterNormalizeUri', [str]);
    return 'about:invalid#zSoyz';
  }
  return str.replace(
      $$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_,
      $$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_);
};

/**
 * A helper for the Soy directive |filterNormalizeMediaUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterNormalizeMediaUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_NORMALIZE_MEDIA_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterNormalizeMediaUri', [str]);
    return 'about:invalid#zSoyz';
  }
  return str.replace(
      $$MATCHER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_,
      $$REPLACER_FOR_NORMALIZE_URI__AND__FILTER_NORMALIZE_URI__AND__FILTER_NORMALIZE_MEDIA_URI_);
};

/**
 * A helper for the Soy directive |filterImageDataUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterImageDataUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterImageDataUri', [str]);
    return 'data:image/gif;base64,zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterSipUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterSipUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_SIP_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterSipUri', [str]);
    return 'about:invalid#zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterSmsUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterSmsUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_SMS_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterSmsUri', [str]);
    return 'about:invalid#zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterTelUri
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterTelUriHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_TEL_URI_.test(str)) {
    asserts.fail('Bad value `%s` for |filterTelUri', [str]);
    return 'about:invalid#zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterHtmlAttributes
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterHtmlAttributesHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_HTML_ATTRIBUTES_.test(str)) {
    asserts.fail('Bad value `%s` for |filterHtmlAttributes', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterHtmlElementName
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterHtmlElementNameHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_HTML_ELEMENT_NAME_.test(str)) {
    asserts.fail('Bad value `%s` for |filterHtmlElementName', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * A helper for the Soy directive |filterCspNonceValue
 * @param {?} value Can be of any type but will be coerced to a string.
 * @return {string} The escaped text.
 */
const $$filterCspNonceValueHelper = function(value) {
  const str = String(value);
  if (!$$FILTER_FOR_FILTER_CSP_NONCE_VALUE_.test(str)) {
    asserts.fail('Bad value `%s` for |filterCspNonceValue', [str]);
    return 'zSoyz';
  }
  return str;
};

/**
 * Matches all tags, HTML comments, and DOCTYPEs in tag soup HTML.
 * By removing these, and replacing any '<' or '>' characters with
 * entities we guarantee that the result can be embedded into a
 * an attribute without introducing a tag boundary.
 *
 * @type {!RegExp}
 */
const $$HTML_TAG_REGEX_ = /<(?:!|\/?([a-zA-Z][a-zA-Z0-9:\-]*))(?:[^>'"]|"[^"]*"|'[^']*')*>/g;

/**
 * Matches all occurrences of '<'.
 *
 * @type {!RegExp}
 */
const $$LT_REGEX_ = /</g;

/**
 * Maps lower-case names of innocuous tags to true.
 *
 * @type {!Object<string, boolean>}
 */
const $$SAFE_TAG_WHITELIST_ = {'b': true, 'br': true, 'em': true, 'i': true, 's': true, 'strong': true, 'sub': true, 'sup': true, 'u': true};

/**
 * Pattern for matching attribute name and value, where value is single-quoted
 * or double-quoted.
 * See http://www.w3.org/TR/2011/WD-html5-20110525/syntax.html#attributes-0
 *
 * @type {!RegExp}
 */
const $$HTML_ATTRIBUTE_REGEX_ = /([a-zA-Z][a-zA-Z0-9:\-]*)[\t\n\r\u0020]*=[\t\n\r\u0020]*("[^"]*"|'[^']*')/g;

// END GENERATED CODE


exports = {
  $$serializeKey,
  $$IS_LOCALE_RTL,
  $$assignDefaults,
  $$getMapKeys,
  $$checkNotNull,
  $$parseInt,
  $$equals,
  $$isFunction,
  $$parseFloat,
  $$randomInt,
  $$round,
  $$strContains,
  $$coerceToBoolean,
  $$registerDelegateFn,
  $$getDelTemplateId,
  $$getDelegateFn,
  $$escapeHtml,
  $$cleanHtml,
  $$htmlToText,
  $$normalizeHtml,
  $$escapeHtmlRcdata,
  $$stripHtmlTags,
  $$escapeHtmlAttribute,
  $$escapeHtmlHtmlAttribute,
  $$escapeHtmlAttributeNospace,
  $$filterHtmlScriptPhrasingData,
  $$filterHtmlAttributes,
  $$whitespaceHtmlAttributes,
  $$filterNumber,
  $$filterHtmlElementName,
  $$escapeJsString,
  $$escapeJsValue,
  $$escapeJsRegex,
  $$escapeUri,
  $$normalizeUri,
  $$filterNormalizeUri,
  $$filterNormalizeMediaUri,
  $$filterNormalizeRefreshUri,
  $$filterTrustedResourceUri,
  $$filterImageDataUri,
  $$filterSipUri,
  $$strSmsUriToUri,
  $$filterTelUri,
  $$escapeCssString,
  $$filterCssValue,
  $$filterCspNonceValue,
  $$changeNewlineToBr,
  $$insertWordBreaks,
  $$concatAttributeValues,
  $$concatCssValues,
  $$truncate,
  $$listContains,
  $$listIndexOf,
  $$listSlice,
  $$listReverse,
  $$makeArray,
  $$filterAndMap,
  $$numberListSort,
  $$stringListSort,
  $$strToAsciiLowerCase,
  $$strToAsciiUpperCase,
  $$strTrim,
  $$strStartsWith,
  $$strEndsWith,
  $$strSplit,
  $$strReplaceAll,
  $$bidiDirAttr,
  $$bidiTextDir,
  $$bidiStartEdge,
  $$bidiEndEdge,
  $$bidiMark,
  $$bidiMarkAfter,
  $$bidiSpanWrap,
  $$bidiUnicodeWrap,
  assertParamType,
  setDebugSoyTemplateInfo,
  $$getDebugSoyTemplateInfo,
  $$EMPTY_STRING_,
  getContentDir,
  VERY_UNSAFE,
  IdomFunction,
  createSanitizedHtml,
  $$stubsMap,
  $$internalCallMarkerDoNotUse,
  $$areYouAnInternalCaller,
  // The following are exported just for tests
  $$balanceTags_,
  isContentKind_,
};

;return exports;});

//third_party/javascript/closure/soy/soy.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Provides utility methods to render soy template.
 */

goog.provide('goog.soy');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.safe');
goog.require('goog.html.SafeHtml');
goog.require('goog.soy.data.SanitizedContent');
goog.requireType('goog.soy.data.SanitizedHtml');

/**
 * A structural interface for injected data.
 *
 * <p>Soy generated code contributes optional properties.
 *
 * @record
 */
goog.soy.IjData = function() {};

/**
 * Helper typedef for ij parameters.  This is what soy generates.
 * @typedef {!goog.soy.IjData|!Object<string, *>}
 */
goog.soy.CompatibleIj;

/**
 * Type definition for strict Soy templates. Very useful when passing a template
 * as an argument.
 * @typedef {function(?=,
 * ?goog.soy.CompatibleIj=):(string|!goog.soy.data.SanitizedContent)}
 */
goog.soy.StrictTemplate;

/**
 * Type definition for strict Soy HTML templates. Very useful when passing
 * a template as an argument.
 * @typedef {function(?=, ?goog.soy.CompatibleIj=):!goog.soy.data.SanitizedHtml}
 */
goog.soy.StrictHtmlTemplate;


/**
 * Type definition for text templates.
 * @typedef {function(?=, ?goog.soy.CompatibleIj=):string}
 */
goog.soy.TextTemplate;


/**
 * Sets the processed template as the innerHTML of an element. It is recommended
 * to use this helper function instead of directly setting innerHTML in your
 * hand-written code, so that it will be easier to audit the code for cross-site
 * scripting vulnerabilities.
 *
 * @param {?Element|?ShadowRoot} element The element whose content we are
 *     rendering into.
 * @param {!goog.soy.data.SanitizedContent} templateResult The processed
 *     template of kind HTML or TEXT (which will be escaped).
 * @template ARG_TYPES
 */
goog.soy.renderHtml = function(element, templateResult) {
  'use strict';
  goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(
      goog.asserts.assert(element),
      goog.soy.ensureTemplateOutputHtml_(templateResult));
};


/**
 * Renders a Soy template and then set the output string as
 * the innerHTML of an element. It is recommended to use this helper function
 * instead of directly setting innerHTML in your hand-written code, so that it
 * will be easier to audit the code for cross-site scripting vulnerabilities.
 *
 * @param {?Element|?ShadowRoot} element The element whose content we are
 *     rendering into.
 * @param {function(ARG_TYPES, ?goog.soy.CompatibleIj=): *} template The Soy
 *     template defining the element's content.
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @template ARG_TYPES
 */
goog.soy.renderElement = function(
    element, template, opt_templateData, opt_injectedData) {
  'use strict';
  const html = goog.soy.ensureTemplateOutputHtml_(template(
      opt_templateData || goog.soy.defaultTemplateData_, opt_injectedData));
  goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(
      goog.asserts.assert(element), html);
};

/**
 * Renders a Soy template into a single node or a document
 * fragment. If the rendered HTML string represents a single node, then that
 * node is returned (note that this is *not* a fragment, despite the name of the
 * method). Otherwise a document fragment is returned containing the rendered
 * nodes.
 *
 * @param {function(ARG_TYPES, ?goog.soy.CompatibleIj=): *} template The Soy
 *     template defining the element's content. The kind of the template must be
 *     "html" or "text".
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @param {goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to `goog.dom.getDomHelper`.
 * @return {!Node} The resulting node or document fragment.
 * @template ARG_TYPES
 */
goog.soy.renderAsFragment = function(
    template, opt_templateData, opt_injectedData, opt_domHelper) {
  'use strict';
  const dom = opt_domHelper || goog.dom.getDomHelper();
  const output = template(
      opt_templateData || goog.soy.defaultTemplateData_, opt_injectedData);
  const html = goog.soy.ensureTemplateOutputHtml_(output);
  goog.soy.assertFirstTagValid_(html.getTypedStringValue());
  return dom.safeHtmlToNode(html);
};

/**
 * Renders a Soy template into a single node. If the rendered
 * HTML string represents a single node, then that node is returned. Otherwise,
 * a DIV element is returned containing the rendered nodes.
 *
 * @param {function(ARG_TYPES, ?goog.soy.CompatibleIj=): *} template
 *     The Soy template defining the element's content.
 * @param {ARG_TYPES=} opt_templateData The data for the template.
 * @param {Object=} opt_injectedData The injected data for the template.
 * @param {goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to `goog.dom.getDomHelper`.
 * @return {!Element} Rendered template contents, wrapped in a parent DIV
 *     element if necessary.
 * @template ARG_TYPES
 */
goog.soy.renderAsElement = function(
    template, opt_templateData, opt_injectedData, opt_domHelper) {
  'use strict';
  return goog.soy.convertToElement_(
      template(
          opt_templateData || goog.soy.defaultTemplateData_, opt_injectedData),
      opt_domHelper);
};


/**
 * Converts a processed Soy template into a single node. If the rendered
 * HTML string represents a single node, then that node is returned. Otherwise,
 * a DIV element is returned containing the rendered nodes.
 *
 * @param {!goog.soy.data.SanitizedContent} templateResult The processed
 *     template of kind HTML or TEXT (which will be escaped).
 * @param {?goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to `goog.dom.getDomHelper`.
 * @return {!Element} Rendered template contents, wrapped in a parent DIV
 *     element if necessary.
 */
goog.soy.convertToElement = function(templateResult, opt_domHelper) {
  'use strict';
  return goog.soy.convertToElement_(templateResult, opt_domHelper);
};


/**
 * Non-strict version of `goog.soy.convertToElement`.
 *
 * @param {*} templateResult The processed template.
 * @param {?goog.dom.DomHelper=} opt_domHelper The DOM helper used to
 *     create DOM nodes; defaults to `goog.dom.getDomHelper`.
 * @return {!Element} Rendered template contents, wrapped in a parent DIV
 *     element if necessary.
 * @private
 */
goog.soy.convertToElement_ = function(templateResult, opt_domHelper) {
  'use strict';
  const dom = opt_domHelper || goog.dom.getDomHelper();
  const wrapper = dom.createElement(goog.dom.TagName.DIV);
  const html = goog.soy.ensureTemplateOutputHtml_(templateResult);
  goog.soy.assertFirstTagValid_(html.getTypedStringValue());
  goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(wrapper, html);

  // If the template renders as a single element, return it.
  if (wrapper.childNodes.length == 1) {
    const firstChild = wrapper.firstChild;
    if (firstChild.nodeType == goog.dom.NodeType.ELEMENT) {
      return /** @type {!Element} */ (firstChild);
    }
  }

  // Otherwise, return the wrapper DIV.
  return wrapper;
};


/**
 * Ensures the result is "safe" to insert as HTML.
 *
 * In the case the argument is a SanitizedContent object, it either must
 * already be of kind HTML, or if it is kind="text", the output will be HTML
 * escaped.
 *
 * @param {*} templateResult The template result.
 * @return {!goog.html.SafeHtml} The assumed-safe HTML output string.
 * @private
 */
goog.soy.ensureTemplateOutputHtml_ = function(templateResult) {
  'use strict';
  // Note we allow everything that isn't an object, because some non-escaping
  // templates end up returning non-strings if their only print statement is a
  // non-escaped argument, plus some unit tests spoof templates.
  // TODO(gboyer): Track down and fix these cases.
  if (!goog.isObject(templateResult)) {
    return goog.html.SafeHtml.htmlEscape(String(templateResult));
  }

  // Allow SanitizedContent of kind HTML.
  if (templateResult instanceof goog.soy.data.SanitizedContent) {
    return templateResult.toSafeHtml();
  }

  goog.asserts.fail(
      'Soy template output is unsafe for use as HTML: ' + templateResult);

  // In production, return a safe string, rather than failing hard.
  return goog.html.SafeHtml.htmlEscape('zSoyz');
};


/**
 * Checks that the rendered HTML does not start with an invalid tag that would
 * likely cause unexpected output from renderAsElement or renderAsFragment.
 * See {@link http://www.w3.org/TR/html5/semantics.html#semantics} for reference
 * as to which HTML elements can be parents of each other.
 * @param {string} html The output of a template.
 * @private
 */
goog.soy.assertFirstTagValid_ = function(html) {
  'use strict';
  if (goog.asserts.ENABLE_ASSERTS) {
    const matches = html.match(goog.soy.INVALID_TAG_TO_RENDER_);
    goog.asserts.assert(
        !matches, 'This template starts with a %s, which ' +
            'cannot be a child of a <div>, as required by soy internals. ' +
            'Consider using goog.soy.renderElement instead.\nTemplate output: %s',
        matches && matches[0], html);
  }
};


/**
 * A pattern to find templates that cannot be rendered by renderAsElement or
 * renderAsFragment, as these elements cannot exist as the child of a <div>.
 * @type {!RegExp}
 * @private
 */
goog.soy.INVALID_TAG_TO_RENDER_ =
    /^<(body|caption|col|colgroup|head|html|tr|td|th|tbody|thead|tfoot)>/i;


/**
 * Immutable object that is passed into templates that are rendered
 * without any data.
 * @private @const
 */
goog.soy.defaultTemplateData_ = {};

//javascript/jfk/bubble/bubble.soy.js
// This file was automatically generated by the Soy compiler.
// Please don't edit this file by hand.
// source: javascript/jfk/bubble/bubble.soy

/**
 * @fileoverview Templates in namespace jfk.templates.bubble.
 * @suppress {missingRequire} TODO(b/152440355)
 * @requirecss {jfk.bubble}
 * @public
 */

goog.provide('jfk.templates.bubble');

goog.require('goog.soy');
goog.require('soy');


/**
 * @param {!jfk.templates.bubble.main.Params} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 */
jfk.templates.bubble.main = function(opt_data, opt_ijData) {
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.bubble.main$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.showCloseBox, opt_data.uid);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?} showCloseBox
 * @param {?=} uid
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.bubble.main$ = function($$areYouAnInternalCaller, $ijData, showCloseBox, uid) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.bubble.main']) {
    return soy.$$stubsMap['jfk.templates.bubble.main']({showCloseBox: showCloseBox, uid: uid}, $ijData);
  }
  let $output = '<div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble')) + '" role="alertdialog"' + (uid ? ' aria-describedby="' + soy.$$escapeHtmlAttribute(uid) + '"' : '') + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.bubble.main javascript/jfk/bubble/bubble.soy:14"' : '') + '><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-content-id')) + '"' + (uid ? ' id="' + soy.$$escapeHtmlAttribute(uid) + '"' : '') + '></div>';
  if (showCloseBox) {
    $output += '<div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-closebtn-id')) + ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-closebtn')) + '" aria-label="';
    /**
     * @meaning MSG_JFK_BUBBLE_CLOSE
     * @desc Close button label for bubble widget.
     */
    const MSG_UNNAMED = goog.getMsg('Close');
    $output += soy.$$normalizeHtml(MSG_UNNAMED);
    $output += '" role="button" tabindex=0></div>';
  }
  $output += '<div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-arrow-id')) + ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-arrow')) + '"><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-arrowimplbefore')) + '"></div><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-bubble-arrowimplafter')) + '"></div></div></div>';
  return soy.VERY_UNSAFE.ordainSanitizedHtml($output);
};
/**
 * @typedef {{
 *  showCloseBox: ?,
 *  uid: (?|undefined),
 * }}
 */
jfk.templates.bubble.main.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.bubble.main.soyTemplateName = 'jfk.templates.bubble.main';
}

//javascript/jfk/position/arrowalignment.js
goog.loadModule(function(exports) {'use strict';// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Arrow alignment for bubble.
 * @author chrishenry@google.com (Chris Henry)
 */

goog.module('jfk.ArrowAlignment');
goog.module.declareLegacyNamespace();

/**
 * Enumeration for different arrow alignment.
 * @enum {number}
 */
const ArrowAlignment = {
  LEFT_OR_TOP: 0,
  RIGHT_OR_BOTTOM: 1,
  CENTER: 2
};

exports = ArrowAlignment;

;return exports;});

//third_party/javascript/closure/positioning/abstractposition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Abstract base class for positioning implementations.
 */

goog.provide('goog.positioning.AbstractPosition');

goog.requireType('goog.math.Box');
goog.requireType('goog.math.Size');
goog.requireType('goog.positioning.Corner');



/**
 * Abstract position object. Encapsulates position and overflow handling.
 *
 * @constructor
 */
goog.positioning.AbstractPosition = function() {};


/**
 * Repositions the element. Abstract method, should be overloaded.
 *
 * @param {Element} movableElement Element to position.
 * @param {goog.positioning.Corner} corner Corner of the movable element that
 *     should be positioned adjacent to the anchored element.
 * @param {goog.math.Box=} opt_margin A margin specified in pixels.
 * @param {goog.math.Size=} opt_preferredSize PreferredSize of the
 *     movableElement.
 */
goog.positioning.AbstractPosition.prototype.reposition = function(
    movableElement, corner, opt_margin, opt_preferredSize) {};

//javascript/jfk/position/arrowposition.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Provides a positioning algorithm to place an arrow on
 * a box correctly to create an arrowed box (such as bubble and
 * tooltip). Also provides a positioning algorithm to place the box
 * with respect to an anchor.
 * @author chrishenry@google.com (Chris Henry)
 */

goog.provide('jfk.ArrowPosition');

goog.require('goog.asserts');
goog.require('goog.dom.classlist');
goog.require('goog.i18n.bidi');
goog.require('goog.math');
goog.require('goog.math.Coordinate');
goog.require('goog.object');
goog.require('goog.positioning');
goog.require('goog.positioning.AbstractPosition');
goog.require('goog.positioning.Corner');
goog.require('goog.positioning.CornerBit');
goog.require('goog.positioning.Overflow');
goog.require('goog.positioning.OverflowStatus');
goog.require('goog.style');
goog.require('jfk.ArrowAlignment');
goog.require('jfk.PopupPosition');
goog.requireType('goog.math.Box');



/**
 * A positioning algorithm that position a call-out arrow on a box
 * element. It also doubles up as a positioning algorithm to position
 * the box element (movableElement) with respect to the given anchor.
 * Examples of arrowed boxes are bubbles and call-out tooltips.
 * NOTE(chrishenry): This class is internal to jfk, do not use outside
 * //javascript/jfk!
 * @unrestricted
 */
jfk.ArrowPosition = class extends goog.positioning.AbstractPosition {
  /**
   * @param {string} className The class name prefix for the arrows.
   * @param {boolean=} opt_disableSubpixels If true, do all positioning at
   *     integer pixel values only.
   */
  constructor(className, opt_disableSubpixels) {
    super();
    /**
     * @type {string}
     * @private
     */
    this.className_ = className;

    /**
     * Whether to constrain positioning to integer pixel values.
     * @type {boolean}
     * @private
     */
    this.disableSubpixels_ = !!opt_disableSubpixels;

    /**
     * Mapping from popup position to arrow class names.
     * @private
     */
    this.arrowClassMap_ = goog.object.create(
        jfk.PopupPosition.LEFT, goog.getCssName(this.className_, 'arrowright'),
        jfk.PopupPosition.BOTTOM, goog.getCssName(this.className_, 'arrowup'),
        jfk.PopupPosition.TOP, goog.getCssName(this.className_, 'arrowdown'),
        jfk.PopupPosition.RIGHT, goog.getCssName(this.className_, 'arrowleft'));
  }

  /**
   * Sets the anchor element. May be null, in which case, the box will
   * stay in its original rendered position (no positioning is done at all).
   * @param {Element} anchor The anchor element.
   */
  setAnchorElement(anchor) {
    this.anchorElement_ = anchor;
  }

  /**
   * Sets viewport for the box. The viewport is specified relative to
   * the offset parent for `boxElement_`.
   * See documentation for `opt_viewport` at
   * `goog.positioning.positionAtAnchor` for more details.
   * @param {!goog.math.Box} viewport Viewport size.
   */
  setViewport(viewport) {
    this.viewport_ = viewport;
  }

  /**
   * Sets the position of the box. By default, it is located on the right of
   * the anchor and the arrow is centered.
   * @param {!jfk.PopupPosition=} opt_boxPosition Position of
   *     the box relative to the anchor (e.g. left means the box will be
   *     at the left of the anchor). Defaults to RIGHT.
   * @param {jfk.ArrowAlignment=} opt_arrowAlignment Arrow
   *     alignment on the side of the box. Defaults to CENTER.
   * @param {number=} opt_arrowOffset Optional offset (in px) for the arrow.
   *     Ignored if Alignment is CENTER. Defaults to 20px.
   * @param {number=} opt_offsetFromAnchor Optional offset (in px) for the
   *     movable box with respect to the anchor. Positive value brings the box
   *     closer to the center of the anchor. Defaults to -5px.
   */
  setPosition(
      opt_boxPosition, opt_arrowAlignment, opt_arrowOffset,
      opt_offsetFromAnchor) {
    if (opt_boxPosition != null) {
      this.boxPosition_ = opt_boxPosition;
    }

    if (opt_arrowAlignment != null) {
      this.arrowAlignment_ = opt_arrowAlignment;
    }

    if (typeof opt_arrowOffset === 'number') {
      this.arrowOffset_ =
          Math.max(opt_arrowOffset, jfk.ArrowPosition.MIN_ARROW_OFFSET_);
    }

    if (typeof opt_offsetFromAnchor === 'number') {
      this.offsetFromAnchor_ = opt_offsetFromAnchor;
    }
  }

  /**
   * Sets box and arrow element to be decorated. The arrow element will then
   * be positioned appropriately with respect to the box element depending
   * on the positioning setting. Need to be called before using
   * `reposition`.
   * @param {!Element} boxElement The box element.
   * @param {!Element} arrowElement The arrow element.
   */
  setElements(boxElement, arrowElement) {
    // TODO(chrishenry): Now that positionArrow is called from reposition,
    // this should really be setArrowElement. We can get box element directly
    // from reposition's arguments list.
    this.boxElement_ = boxElement;
    this.arrowElement_ = arrowElement;
  }

  /**
   * @param {boolean} allowBoxOverflowOnPositioningFail Whether the box element
   *     should be allowed to overflow when failing to position it in the
   *     available space in both the original orientation as well as the flipped
   *     orientation. Setting this to false will cause the box element to be
   *     positioned in a corner when failing in both directions.
   */
  setBoxOverflowAllowedOnPositioningFail(allowBoxOverflowOnPositioningFail) {
    this.allowBoxOverflowOnPositioningFail_ = allowBoxOverflowOnPositioningFail;
  }

  /** @override */
  reposition(
      movableElement /* unused */, movableCorner /* unused */, opt_margin,
      opt_preferredSize /* unused */) {
    goog.asserts.assert(this.arrowElement_, 'Must call setElements first.');

    var boxPosition = this.boxPosition_;
    var arrowAlignment =
        this.getEffectiveAlignment_(this.boxPosition_, this.arrowAlignment_);
    var arrowOffset = this.getEffectiveArrowOffset_();
    this.reposition_(
        boxPosition, arrowAlignment, arrowOffset,
        jfk.ArrowPosition.RetryStatus_.INITIAL_TRY, opt_margin);
  }

  /**
   * Calculates the effective arrow offset. For CENTER-aligned box, the
   * offset is calculated as if LEFT_OR_TOP applies.
   * @return {number} Effective arrow offset from the pinned corner of
   *     the box element.
   * @private
   */
  getEffectiveArrowOffset_() {
    if (this.arrowAlignment_ == jfk.ArrowAlignment.CENTER) {
      return jfk.ArrowPosition.isLeftOrRight_(this.boxPosition_) ?
          this.boxElement_.offsetHeight / 2 :
          this.boxElement_.offsetWidth / 2;
    }
    return this.arrowOffset_;
  }

  /**
   * Calculates the effective arrow alignment. CENTER alignment will
   * be resolved to LEFT_OR_TOP. The resulting arrow alignment will then
   * be recomputed (flipped) for RTL.
   * @param {!jfk.PopupPosition} boxPosition The effective box position.
   * @param {!jfk.ArrowAlignment} arrowAlignment Initial arrow alignment.
   * @return {!jfk.ArrowAlignment} Effective arrow alignment, after
   *     considering rtl.
   * @private
   */
  getEffectiveAlignment_(boxPosition, arrowAlignment) {
    if (arrowAlignment == jfk.ArrowAlignment.CENTER) {
      arrowAlignment = jfk.ArrowAlignment.LEFT_OR_TOP;
    }

    if (!jfk.ArrowPosition.isLeftOrRight_(boxPosition) &&
        goog.i18n.bidi.IS_RTL) {
      return /** @type {jfk.ArrowAlignment} */ (
          arrowAlignment ^ jfk.ArrowPosition.FLIP_ALIGNMENT_);
    } else {
      return arrowAlignment;
    }
  }

  /**
   * @param {boolean} auto Whether to use auto re-position.
   */
  setAutoReposition(auto) {
    this.isAutoReposition_ = auto;
  }

  /**
   * Actually repositions the box, respecting the given parameters.
   * @param {!jfk.PopupPosition} boxPosition The effective box position.
   * @param {!jfk.ArrowAlignment} arrowAlignment The effective arrow alignment.
   * @param {number} arrowOffset The effective arrow offset.
   * @param {jfk.ArrowPosition.RetryStatus_} retryStatus The descriptor for the
   *     current positioning attempt. This describes the strategy being used to
   *     reposition the box. If FINAL is used, no more further tries will
   *     be attempted.
   * @param {goog.math.Box=} opt_margin A margin specified in pixels.
   * @private
   */
  reposition_(
      boxPosition, arrowAlignment, arrowOffset, retryStatus, opt_margin) {
    if (this.anchorElement_) {
      var movableCorner =
          jfk.ArrowPosition.getCorner_(boxPosition, arrowAlignment);

      var centeringOffset = jfk.ArrowPosition.getCenteringOffset_(
          this.anchorElement_, boxPosition, arrowOffset, movableCorner,
          this.boxElement_, this.viewport_);
      var offset = jfk.ArrowPosition.isLeftOrRight_(boxPosition) ?
          new goog.math.Coordinate(this.offsetFromAnchor_, centeringOffset) :
          new goog.math.Coordinate(centeringOffset, this.offsetFromAnchor_);

      // If box position is on the left/right of anchor, we allow adjusting
      // on y, but not on x. And vice versa for position on top/bottom of
      // anchor.
      var overflow = jfk.ArrowPosition.isLeftOrRight_(boxPosition) ?
          goog.positioning.Overflow.ADJUST_Y |
              goog.positioning.Overflow.FAIL_X :
          goog.positioning.Overflow.ADJUST_X | goog.positioning.Overflow.FAIL_Y;

      // If overflow is allowed on positioning fail and it is the final attempt,
      // the failure overflow cases are removed in order to allow the box
      // element to keep the assigned position instead of being positioned in a
      // corner.
      if (this.allowBoxOverflowOnPositioningFail_ &&
          retryStatus == jfk.ArrowPosition.RetryStatus_.FINAL) {
        overflow = jfk.ArrowPosition.isLeftOrRight_(boxPosition) ?
            goog.positioning.Overflow.ADJUST_Y :
            goog.positioning.Overflow.ADJUST_X;
      }

      // Logically, anchor position (the side of the box which the arrow is
      // attached to) is the opposite of box position (the side of the anchor
      // the box is on). However, if the anchor's directionality is opposite of
      // the directionality of the locale, and the box position is left or
      // right, then the anchor position is mirrored. For example, if we are in
      // a RTL locale, but the anchor contains LTR text (such as an English name
      // for a business in an otherwise Arabic UI), we want to treat the anchor
      // as if it contained RTL text for the purposes of positioning the bubble,
      // to match the overall UI.  Note that if dir is not set, we assume that
      // the anchor has the same directionality as the locale.
      var anchorPosition = jfk.PopupPosition.flip(boxPosition);
      if (jfk.ArrowPosition.isLeftOrRight_(boxPosition) &&
          ((goog.i18n.bidi.IS_RTL && this.anchorElement_.dir == 'ltr') ||
           (!goog.i18n.bidi.IS_RTL && this.anchorElement_.dir == 'rtl'))) {
        anchorPosition = boxPosition;
      }

      var result = goog.positioning.positionAtAnchor(
          this.anchorElement_,
          jfk.ArrowPosition.getCorner_(anchorPosition, arrowAlignment),
          this.boxElement_, movableCorner, offset, opt_margin,
          this.isAutoReposition_ ? overflow : goog.positioning.Overflow.IGNORE,
          undefined, this.viewport_);

      if (retryStatus != jfk.ArrowPosition.RetryStatus_.FINAL &&
          (result & goog.positioning.OverflowStatus.FAILED)) {
        // If box overflow is allowed on fail, we first need to try the flipped
        // orientation and, if that does not succeed, do a final attempt which
        // allows overflow. If it is not allowed, then the flipped attempt is
        // the final attempt.
        var nextRetryStatus = this.allowBoxOverflowOnPositioningFail_ &&
                retryStatus == jfk.ArrowPosition.RetryStatus_.INITIAL_TRY ?
            jfk.ArrowPosition.RetryStatus_.FLIPPED :
            jfk.ArrowPosition.RetryStatus_.FINAL;
        this.reposition_(
            jfk.PopupPosition.flip(boxPosition), arrowAlignment, arrowOffset,
            nextRetryStatus, opt_margin);
        return;
      }

      if (this.disableSubpixels_ &&
          !(result & goog.positioning.OverflowStatus.FAILED)) {
        var boxLeft = parseFloat(this.boxElement_.style.left);
        var boxTop = parseFloat(this.boxElement_.style.top);
        goog.asserts.assert(
            !isNaN(boxLeft) && !isNaN(boxTop), 'Could not parse position.');
        if (!goog.math.isInt(boxLeft) || !goog.math.isInt(boxTop)) {
          goog.style.setPosition(
              this.boxElement_, Math.round(boxLeft), Math.round(boxTop));
        }
      }
    }
    this.positionArrow_(boxPosition, arrowAlignment, arrowOffset);
  }

  /**
   * Positions the arrow with respect to the box element.
   * @param {!jfk.PopupPosition} boxPosition The box position.
   * @param {!jfk.ArrowAlignment} arrowAlignment Effective arrow alignment.
   * @param {number} arrowOffset Effective arrow offset.
   * @private
   */
  positionArrow_(boxPosition, arrowAlignment, arrowOffset) {
    // Reset class name and offset first.
    var arrow = this.arrowElement_;
    goog.object.forEach(this.arrowClassMap_, function(val) {
      goog.dom.classlist.enable(arrow, val, false);
    }, this);
    goog.dom.classlist.add(arrow, this.arrowClassMap_[boxPosition]);
    arrow.style.top = arrow.style.left = arrow.style.right =
        arrow.style.bottom = '';

    if (this.anchorElement_) {
      // Here, we re-calculate the arrow offset to attempt to center the
      // arrow positioning to the center of the anchor.
      var relativePos =
          goog.style.getRelativePosition(this.anchorElement_, this.boxElement_);
      var offset = jfk.ArrowPosition.getAnchorPointOffsetFromAnchorTopLeft_(
          this.anchorElement_, boxPosition);

      // We make sure to clamp the arrow offset so that the arrow is always
      // part of the bubble.
      if (jfk.ArrowPosition.isLeftOrRight_(boxPosition)) {
        var offsetTop = jfk.ArrowPosition.clamp_(
            relativePos.y + offset.y, jfk.ArrowPosition.MIN_ARROW_OFFSET_,
            this.boxElement_.offsetHeight -
                jfk.ArrowPosition.MIN_ARROW_OFFSET_);
        arrow.style.top = offsetTop + 'px';
      } else {
        var offsetLeft = jfk.ArrowPosition.clamp_(
            relativePos.x + offset.x, jfk.ArrowPosition.MIN_ARROW_OFFSET_,
            this.boxElement_.offsetWidth - jfk.ArrowPosition.MIN_ARROW_OFFSET_);
        arrow.style.left = offsetLeft + 'px';
      }
    } else {
      // TODO(chrishenry): We should really remove this inline bubble hack.
      // It is now required because folks want arrowed panel but without the
      // popup function of a bubble. So, if we provide an alternate way
      // to easily style an arrowed panel, we can get rid of this.
      var side;
      if (arrowAlignment == jfk.ArrowAlignment.LEFT_OR_TOP) {
        side = jfk.ArrowPosition.isLeftOrRight_(boxPosition) ? 'top' : 'left';
      } else {  // Must be RIGHT_OR_BOTTOM since CENTER is excluded above.
        side =
            jfk.ArrowPosition.isLeftOrRight_(boxPosition) ? 'bottom' : 'right';
      }
      arrow.style[side] = arrowOffset + 'px';
    }
  }

  /**
   * Clamps a given value to within the [min, max] range. If min > max,
   * this will always return min value.
   * @param {number} value The value to clamp.
   * @param {number} min The min value.
   * @param {number} max The max value.
   * @return {number} The clamped value.
   * @private
   */
  static clamp_(value, min, max) {
    if (min > max) {
      return min;
    }
    return goog.math.clamp(value, min, max);
  }

  /**
   * Gets the corner corresponding to the given position and the box
   * internal arrow alignment.
   * @param {jfk.PopupPosition} position The side of the box/anchor.
   * @param {jfk.ArrowAlignment} arrowAlignment Effective arrow alignment.
   * @return {!goog.positioning.Corner} The corner of this box that should be
   *     positioned next to the anchor corner.
   * @private
   */
  static getCorner_(position, arrowAlignment) {
    // NOTE: arrowAlignment is normalized wrt LTR/RTL while position is not.
    // Make sure to use LEFT/RIGHT, START/END correctly here.
    switch (position) {
      case jfk.PopupPosition.TOP:
        return arrowAlignment == jfk.ArrowAlignment.LEFT_OR_TOP ?
            goog.positioning.Corner.BOTTOM_LEFT :
            goog.positioning.Corner.BOTTOM_RIGHT;
      case jfk.PopupPosition.BOTTOM:
        return arrowAlignment == jfk.ArrowAlignment.LEFT_OR_TOP ?
            goog.positioning.Corner.TOP_LEFT :
            goog.positioning.Corner.TOP_RIGHT;
      case jfk.PopupPosition.LEFT:
        return arrowAlignment == jfk.ArrowAlignment.LEFT_OR_TOP ?
            goog.positioning.Corner.TOP_END :
            goog.positioning.Corner.BOTTOM_END;
      default:
        return arrowAlignment == jfk.ArrowAlignment.LEFT_OR_TOP ?
            goog.positioning.Corner.TOP_START :
            goog.positioning.Corner.BOTTOM_START;
    }
  }

  /**
   * Gets centering offset, adjusted for anchor out of bounds if necessary.
   * @param {!Element} anchor The anchor element.
   * @param {!jfk.PopupPosition} boxPosition Effective box position.
   * @param {number} arrowOffset The effective arrow offset.
   * @param {goog.positioning.Corner} movableCorner The movable/box position
   *     corner.
   * @param {!Element=} opt_viewportOffsetParentElement Refer to documentation
   *     of `normalizeCenteringOffset_` for details.
   * @param {goog.math.Box=} opt_viewport Refer to documentation of
   *     `normalizeCenteringOffset_` for details.
   * @return {number} The positioning offset requires to center the
   *     arrow to the center of the anchor.
   * @private
   */
  static getCenteringOffset_(
      anchor, boxPosition, arrowOffset, movableCorner,
      opt_viewportOffsetParentElement, opt_viewport) {
    var size = goog.style.getSize(anchor);
    var anchorCenterOffset = jfk.ArrowPosition.isLeftOrRight_(boxPosition) ?
        size.height / 2 :
        size.width / 2;
    var centeringOffset = anchorCenterOffset - arrowOffset;
    return jfk.ArrowPosition.normalizeCenteringOffset_(
        centeringOffset, anchor, boxPosition, movableCorner,
        opt_viewportOffsetParentElement, opt_viewport);
  }

  /**
   * Adjust the given centering offset if the anchor is out of bounds of
   * the viewport. This is needed because positionAtAnchor measures offset
   * from the anchor boundary this is actually visible in the viewport.
   * @param {number} centeringOffset The unadjusted centering offset.
   * @param {!Element} anchor The anchor element.
   * @param {!jfk.PopupPosition} boxPosition Effective box position.
   * @param {goog.positioning.Corner} movableCorner The movable/box position
   *     corner.
   * @param {!Element=} opt_viewportOffsetParentElement Refer to documentation
   *     for `opt_viewport`.
   * @param {goog.math.Box=} opt_viewport Viewport box should be specified
   *     relative to offset parent of `opt_viewportOffsetParentElement`.
   *     If `opt_viewportOffsetParentElement` is not specified, it is
   *     assumed relative to page. `opt_viewport`
   *     defaults to visible portion of nearest scrollable ancestor
   *     (see `goog.style.getVisibleRectForElement`).
   * @return {number} The adjusted centering offset.
   * @private
   */
  static normalizeCenteringOffset_(
      centeringOffset, anchor, boxPosition, movableCorner,
      opt_viewportOffsetParentElement, opt_viewport) {
    var corner = goog.positioning.getEffectiveCorner(anchor, movableCorner);
    var viewportBox;
    if (opt_viewport) {
      viewportBox = opt_viewport.clone();
      if (opt_viewportOffsetParentElement) {
        // Translate the viewport coordinates relative to page.
        var parentTopLeft = goog.positioning.getOffsetParentPageOffset(
            opt_viewportOffsetParentElement);
        viewportBox.left += parentTopLeft.x;
        viewportBox.right += parentTopLeft.x;
        viewportBox.top += parentTopLeft.y;
        viewportBox.bottom += parentTopLeft.y;
      }
    } else {
      viewportBox = goog.style.getVisibleRectForElement(anchor);
      if (!viewportBox) {
        // Visible rectangle is outside the viewport, don't try to normalize.
        return centeringOffset;
      }
    }

    var anchorBox = goog.style.getBounds(anchor).toBox();

    // We only attempt to adjust the offset if the effective corner
    // being used to pivot the positioning is out of bounds.
    if (jfk.ArrowPosition.isLeftOrRight_(boxPosition)) {
      if (anchorBox.top < viewportBox.top &&
          !(corner & goog.positioning.CornerBit.BOTTOM)) {
        centeringOffset -= viewportBox.top - anchorBox.top;
      } else if (
          anchorBox.bottom > viewportBox.bottom &&
          (corner & goog.positioning.CornerBit.BOTTOM)) {
        centeringOffset -= anchorBox.bottom - viewportBox.bottom;
      }
    } else {
      if (anchorBox.left < viewportBox.left &&
          !(corner & goog.positioning.CornerBit.RIGHT)) {
        centeringOffset -= viewportBox.left - anchorBox.left;
      } else if (
          anchorBox.right > viewportBox.right &&
          (corner & goog.positioning.CornerBit.RIGHT)) {
        centeringOffset -= anchorBox.right - viewportBox.right;
      }
    }

    return centeringOffset;
  }

  /**
   * Gets anchor point offset from anchor's top left.
   * @param {!Element} anchor The anchor element.
   * @param {!jfk.PopupPosition} boxPosition The effective box position.
   * @return {!goog.math.Coordinate} Anchor offset coordinate from anchor's
   *     top left.
   * @private
   */
  static getAnchorPointOffsetFromAnchorTopLeft_(anchor, boxPosition) {
    var offsetX = 0;
    var offsetY = 0;
    var anchorSize = goog.style.getSize(anchor);
    switch (boxPosition) {
      case jfk.PopupPosition.TOP:
        offsetX = anchorSize.width / 2;
        break;
      case jfk.PopupPosition.BOTTOM:
        offsetX = anchorSize.width / 2;
        offsetY = anchorSize.height;
        break;
      case jfk.PopupPosition.LEFT:
        offsetY = anchorSize.height / 2;
        break;
      case jfk.PopupPosition.RIGHT:
        offsetX = anchorSize.width;
        offsetY = anchorSize.height / 2;
        break;
    }
    return new goog.math.Coordinate(offsetX, offsetY);
  }

  /**
   * Whether the given box position is LEFT or RIGHT.
   * @param {!jfk.PopupPosition} boxPosition The effective box position.
   * @return {boolean} True if the position is left or right.
   * @private
   */
  static isLeftOrRight_(boxPosition) {
    return (boxPosition == jfk.PopupPosition.LEFT) ||
        (boxPosition == jfk.PopupPosition.RIGHT);
  }
};



/**
 * When positioning the element, based on the overflow status we might need to
 * attempt positioning in a different orientation. This enum allows us to
 * specify the strategy being used in the current positioning attempt. A FINAL
 * status is required as the repositioning algorithm can go into infinite loops
 * in degenerate cases.
 * @enum {number}
 * @private
 */
jfk.ArrowPosition.RetryStatus_ = {
  INITIAL_TRY: 0,
  FLIPPED: 1,
  FINAL: 2
};


/**
 * Bit sequence used to flip LEFT_OR_TOP to RIGHT_OR_BOTTOM and vice versa.
 * To use this, apply bitwise xor (^) against ArrowAlignment.
 * @type {number}
 * @const
 * @private
 */
jfk.ArrowPosition.FLIP_ALIGNMENT_ = 1;


/**
 * Minimum arrow offset.
 * @type {number}
 * @const
 * @private
 */
jfk.ArrowPosition.MIN_ARROW_OFFSET_ = 15;


/**
 * Whether to automatically reposition the boxElement_.
 * @type {boolean}
 * @private
 */
jfk.ArrowPosition.prototype.isAutoReposition_ = false;


/**
 * @type {Element}
 * @private
 */
jfk.ArrowPosition.prototype.anchorElement_;


/**
 * The arrow element.
 * @type {!Element}
 * @private
 */
jfk.ArrowPosition.prototype.arrowElement_;


/**
 * The box element.
 * @type {!Element}
 * @private
 */
jfk.ArrowPosition.prototype.boxElement_;


/**
 * Alignment of the arrow on the side of the box.
 * @type {!jfk.ArrowAlignment}
 * @private
 */
jfk.ArrowPosition.prototype.arrowAlignment_ = jfk.ArrowAlignment.CENTER;


/**
 * Optional explicit offset (in px) for the arrow from the side of the box.
 * @type {number}
 * @private
 */
jfk.ArrowPosition.prototype.arrowOffset_ = 20;


/**
 * Position of the box relative to the anchor.
 * @type {!jfk.PopupPosition}
 * @private
 */
jfk.ArrowPosition.prototype.boxPosition_ = jfk.PopupPosition.RIGHT;


/**
 * Viewport for the box.
 * @type {?goog.math.Box}
 * @private
 */
jfk.ArrowPosition.prototype.viewport_ = null;


/**
 * Additional offset from anchor to the box element. A negative value places
 * the box element further from the anchor.
 * @type {number}
 * @private
 */
jfk.ArrowPosition.prototype.offsetFromAnchor_ = -5;


/**
 * Whether the box element should be allowed to overflow when failing to
 * position it in the available space in both the original orientation as well
 * as the flipped orientation. By default this is false, and will cause the box
 * element to be positioned in a corner when failing in both directions. The box
 * element can use the word-wrap CSS property to make its contents span multiple
 * lines instead of overflowing when this is set to true.
 * @type {boolean}
 * @private
 */
jfk.ArrowPosition.prototype.allowBoxOverflowOnPositioningFail_ = false;

//third_party/javascript/closure/events/eventwrapper.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of the goog.events.EventWrapper interface.
 */

goog.provide('goog.events.EventWrapper');

goog.requireType('goog.events.EventHandler');
goog.requireType('goog.events.ListenableType');



/**
 * Interface for event wrappers.
 * @interface
 */
goog.events.EventWrapper = function() {};


/**
 * Adds an event listener using the wrapper on a DOM Node or an object that has
 * implemented {@link goog.events.EventTarget}. A listener can only be added
 * once to an object.
 *
 * @param {goog.events.ListenableType} src The node to listen to events on.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @param {goog.events.EventHandler=} opt_eventHandler Event handler to add
 *     listener to.
 */
goog.events.EventWrapper.prototype.listen = function(
    src, listener, opt_capt, opt_scope, opt_eventHandler) {};


/**
 * Removes an event listener added using goog.events.EventWrapper.listen.
 *
 * @param {goog.events.ListenableType} src The node to remove listener from.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @param {goog.events.EventHandler=} opt_eventHandler Event handler to remove
 *     listener from.
 */
goog.events.EventWrapper.prototype.unlisten = function(
    src, listener, opt_capt, opt_scope, opt_eventHandler) {};

//third_party/javascript/closure/events/actioneventwrapper.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Action event wrapper implementation.
 */

goog.provide('goog.events.actionEventWrapper');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.dom');
goog.require('goog.events');
/** @suppress {extraRequire} */
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.events.EventWrapper');
goog.require('goog.events.KeyCodes');



/**
 * Event wrapper for action handling. Fires when an element is activated either
 * by clicking it or by focusing it and pressing Enter.
 *
 * @constructor
 * @implements {goog.events.EventWrapper}
 * @private
 */
goog.events.ActionEventWrapper_ = function() {};

/**
 * @interface
 * @private
 */
goog.events.ActionEventWrapper_.FunctionExtension_ = function() {};

/** @private {!Object|undefined} */
goog.events.ActionEventWrapper_.FunctionExtension_.prototype.scope_;

/** @private {function(?):?|{handleEvent:function(?):?}|null} */
goog.events.ActionEventWrapper_.FunctionExtension_.prototype.listener_;


/**
 * Singleton instance of ActionEventWrapper_.
 * @type {goog.events.ActionEventWrapper_}
 */
goog.events.actionEventWrapper = new goog.events.ActionEventWrapper_();


/**
 * Event types used by the wrapper.
 *
 * @type {Array<goog.events.EventType>}
 * @private
 */
goog.events.ActionEventWrapper_.EVENT_TYPES_ = [
  goog.events.EventType.CLICK, goog.events.EventType.KEYDOWN,
  goog.events.EventType.KEYUP
];


/**
 * Adds an event listener using the wrapper on a DOM Node or an object that has
 * implemented {@link goog.events.EventTarget}. A listener can only be added
 * once to an object.
 *
 * @param {goog.events.ListenableType} target The target to listen to events on.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @param {goog.events.EventHandler=} opt_eventHandler Event handler to add
 *     listener to.
 * @override
 */
goog.events.ActionEventWrapper_.prototype.listen = function(
    target, listener, opt_capt, opt_scope, opt_eventHandler) {
  'use strict';
  var callback = function(e) {
    'use strict';
    var listenerFn = goog.events.wrapListener(listener);
    var role = goog.dom.isElement(e.target) ?
        goog.a11y.aria.getRole(/** @type {!Element} */ (e.target)) :
        null;
    if (e.type == goog.events.EventType.CLICK && e.isMouseActionButton()) {
      listenerFn.call(opt_scope, e);
    } else if (
        (e.keyCode == goog.events.KeyCodes.ENTER ||
         e.keyCode == goog.events.KeyCodes.MAC_ENTER) &&
        e.type != goog.events.EventType.KEYUP) {
      // convert keydown to keypress for backward compatibility.
      e.type = goog.events.EventType.KEYPRESS;
      listenerFn.call(opt_scope, e);
    } else if (
        e.keyCode == goog.events.KeyCodes.SPACE &&
        e.type == goog.events.EventType.KEYUP &&
        (role == goog.a11y.aria.Role.BUTTON ||
         role == goog.a11y.aria.Role.TAB ||
         role == goog.a11y.aria.Role.RADIO)) {
      listenerFn.call(opt_scope, e);
      e.preventDefault();
    }
  };
  callback.listener_ = listener;
  callback.scope_ = opt_scope;

  if (opt_eventHandler) {
    opt_eventHandler.listen(
        target, goog.events.ActionEventWrapper_.EVENT_TYPES_, callback,
        opt_capt);
  } else {
    goog.events.listen(
        target, goog.events.ActionEventWrapper_.EVENT_TYPES_, callback,
        opt_capt);
  }
};


/**
 * Removes an event listener added using goog.events.EventWrapper.listen.
 *
 * @param {goog.events.ListenableType} target The node to remove listener from.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback
 *     method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_scope Element in whose scope to call the listener.
 * @param {goog.events.EventHandler=} opt_eventHandler Event handler to remove
 *     listener from.
 * @override
 */
goog.events.ActionEventWrapper_.prototype.unlisten = function(
    target, listener, opt_capt, opt_scope, opt_eventHandler) {
  'use strict';
  for (var type, j = 0; type = goog.events.ActionEventWrapper_.EVENT_TYPES_[j];
       j++) {
    var listeners = goog.events.getListeners(target, type, !!opt_capt);
    for (var obj, i = 0; obj = listeners[i]; i++) {
      var objListener =
          /** @type {!goog.events.ActionEventWrapper_.FunctionExtension_} */ (
              obj.listener);
      if (objListener.listener_ == listener &&
          objListener.scope_ == opt_scope) {
        if (opt_eventHandler) {
          opt_eventHandler.unlisten(
              target, type, obj.listener, opt_capt, opt_scope);
        } else {
          goog.events.unlisten(target, type, obj.listener, opt_capt, opt_scope);
        }
        break;
      }
    }
  }
};

//third_party/javascript/closure/style/transition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Utility methods to deal with CSS3 transitions
 * programmatically.
 */

goog.provide('goog.style.transition');
goog.provide('goog.style.transition.Css3Property');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.safe');
goog.require('goog.dom.vendor');
goog.require('goog.functions');
goog.require('goog.html.SafeHtml');
goog.require('goog.style');
goog.require('goog.userAgent');


/**
 * A typedef to represent a CSS3 transition property. Duration and delay
 * are both in seconds. Timing is CSS3 timing function string, such as
 * 'easein', 'linear'.
 *
 * Alternatively, specifying string in the form of '[property] [duration]
 * [timing] [delay]' as specified in CSS3 transition is fine too.
 *
 * @typedef { {
 *   property: string,
 *   duration: number,
 *   timing: string,
 *   delay: number
 * } | string }
 */
goog.style.transition.Css3Property;


/**
 * Sets the element CSS3 transition to properties.
 * @param {Element} element The element to set transition on.
 * @param {goog.style.transition.Css3Property|
 *     Array<goog.style.transition.Css3Property>} properties A single CSS3
 *     transition property or array of properties.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.style.transition.set = function(element, properties) {
  'use strict';
  if (!Array.isArray(properties)) {
    properties = [properties];
  }
  goog.asserts.assert(
      properties.length > 0, 'At least one Css3Property should be specified.');

  var values = properties.map(function(p) {
    'use strict';
    if (typeof p === 'string') {
      return p;
    } else {
      goog.asserts.assertObject(p, 'Expected css3 property to be an object.');
      var propString =
          p.property + ' ' + p.duration + 's ' + p.timing + ' ' + p.delay + 's';
      goog.asserts.assert(
          p.property && typeof p.duration === 'number' && p.timing &&
              typeof p.delay === 'number',
          'Unexpected css3 property value: %s', propString);
      return propString;
    }
  });
  goog.style.transition.setPropertyValue_(element, values.join(','));
};


/**
 * Removes any programmatically-added CSS3 transition in the given element.
 * @param {Element} element The element to remove transition from.
 */
goog.style.transition.removeAll = function(element) {
  'use strict';
  goog.style.transition.setPropertyValue_(element, '');
};


/**
 * @return {boolean} Whether CSS3 transition is supported.
 */
goog.style.transition.isSupported = goog.functions.cacheReturnValue(function() {
  'use strict';
  // Since IE would allow any attribute, we need to explicitly check the
  // browser version here instead.
  if (goog.userAgent.IE) {
    return goog.userAgent.isVersionOrHigher('10.0');
  }

  // We create a test element with style=-vendor-transition
  // We then detect whether those style properties are recognized and
  // available from js.
  var el = goog.dom.createElement(goog.dom.TagName.DIV);
  var transition = 'opacity 1s linear';
  var vendorPrefix = goog.dom.vendor.getVendorPrefix();
  var style = {'transition': transition};
  if (vendorPrefix) {
    style[vendorPrefix + '-transition'] = transition;
  }
  goog.dom.safe.setInnerHtml(
      el, goog.html.SafeHtml.create('div', {'style': style}));

  var testElement = /** @type {Element} */ (el.firstChild);
  goog.asserts.assert(testElement.nodeType == Node.ELEMENT_NODE);

  return goog.style.getStyle(testElement, 'transition') != '';
});


/**
 * Sets CSS3 transition property value to the given value.
 * @param {Element} element The element to set transition on.
 * @param {string} transitionValue The CSS3 transition property value.
 * @private
 */
goog.style.transition.setPropertyValue_ = function(element, transitionValue) {
  'use strict';
  goog.style.setStyle(element, 'transition', transitionValue);
};

//third_party/javascript/closure/fx/css3/transition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview CSS3 transition base library.
 */

goog.provide('goog.fx.css3.Transition');

goog.require('goog.Timer');
goog.require('goog.asserts');
goog.require('goog.fx.TransitionBase');
goog.require('goog.style');
goog.require('goog.style.transition');



/**
 * A class to handle targeted CSS3 transition. This class
 * handles common features required for targeted CSS3 transition.
 *
 * Browser that does not support CSS3 transition will still receive all
 * the events fired by the transition object, but will not have any transition
 * played. If the browser supports the final state as set in setFinalState
 * method, the element will ends in the final state.
 *
 * Transitioning multiple properties with the same setting is possible
 * by setting Css3Property's property to 'all'. Performing multiple
 * transitions can be done via setting multiple initialStyle,
 * finalStyle and transitions. Css3Property's delay can be used to
 * delay one of the transition. Here is an example for a transition
 * that expands on the width and then followed by the height:
 *
 * <pre>
 *   var animation = new goog.fx.css3.Transition(
 *     element,
 *     duration,
 *     {width: 10px, height: 10px},
 *     {width: 100px, height: 100px},
 *     [
 *       {property: width, duration: 1, timing: 'ease-in', delay: 0},
 *       {property: height, duration: 1, timing: 'ease-in', delay: 1}
 *     ]
 *   );
 * </pre>
 *
 * @param {Element} element The element to be transitioned.
 * @param {number} duration The duration of the transition in seconds.
 *     This should be the longest of all transitions, including any delay.
 * @param {Object} initialStyle Initial style properties of the element before
 *     animating. Set using `goog.style.setStyle`.
 * @param {Object} finalStyle Final style properties of the element after
 *     animating. Set using `goog.style.setStyle`.
 * @param {goog.style.transition.Css3Property|
 *     Array<goog.style.transition.Css3Property>} transitions A single CSS3
 *     transition property or an array of it.
 * @extends {goog.fx.TransitionBase}
 * @constructor
 * @struct
 */
goog.fx.css3.Transition = function(
    element, duration, initialStyle, finalStyle, transitions) {
  'use strict';
  goog.fx.css3.Transition.base(this, 'constructor');

  /**
   * Timer id to be used to cancel animation part-way.
   * @private {number}
   */
  this.timerId_;

  /**
   * @type {Element}
   * @private
   */
  this.element_ = element;

  /**
   * @type {number}
   * @private
   */
  this.duration_ = duration;

  /**
   * @type {Object}
   * @private
   */
  this.initialStyle_ = initialStyle;

  /**
   * @type {Object}
   * @private
   */
  this.finalStyle_ = finalStyle;

  /**
   * @type {Array<goog.style.transition.Css3Property>}
   * @private
   */
  this.transitions_ = Array.isArray(transitions) ? transitions : [transitions];
};
goog.inherits(goog.fx.css3.Transition, goog.fx.TransitionBase);


/** @override */
goog.fx.css3.Transition.prototype.play = function() {
  'use strict';
  if (this.isPlaying()) {
    return false;
  }

  this.onBegin();
  this.onPlay();

  this.startTime = goog.now();
  this.setStatePlaying();

  if (goog.style.transition.isSupported()) {
    goog.style.setStyle(this.element_, this.initialStyle_);
    // Allow element to get updated to its initial state before installing
    // CSS3 transition.
    this.timerId_ = goog.Timer.callOnce(this.play_, undefined, this);
    return true;
  } else {
    this.stop_(false);
    return false;
  }
};


/**
 * Helper method for play method. This needs to be executed on a timer.
 * @private
 */
goog.fx.css3.Transition.prototype.play_ = function() {
  'use strict';
  // This measurement of the DOM element causes the browser to recalculate its
  // initial state before the transition starts.
  goog.style.getSize(this.element_);
  goog.style.transition.set(this.element_, this.transitions_);
  goog.style.setStyle(this.element_, this.finalStyle_);
  this.timerId_ = goog.Timer.callOnce(
      goog.bind(this.stop_, this, false), this.duration_ * 1000);
};


/** @override */
goog.fx.css3.Transition.prototype.stop = function() {
  'use strict';
  if (!this.isPlaying()) return;

  this.stop_(true);
};


/**
 * Helper method for stop method.
 * @param {boolean} stopped If the transition was stopped.
 * @private
 */
goog.fx.css3.Transition.prototype.stop_ = function(stopped) {
  'use strict';
  goog.style.transition.removeAll(this.element_);

  // Clear the timer.
  goog.Timer.clear(this.timerId_);

  // Make sure that we have reached the final style.
  goog.style.setStyle(this.element_, this.finalStyle_);

  this.endTime = goog.now();
  this.setStateStopped();

  if (stopped) {
    this.onStop();
  } else {
    this.onFinish();
  }
  this.onEnd();
};


/** @override */
goog.fx.css3.Transition.prototype.disposeInternal = function() {
  'use strict';
  this.stop();
  goog.fx.css3.Transition.base(this, 'disposeInternal');
};


/**
 * Pausing CSS3 Transitions in not supported.
 * @override
 */
goog.fx.css3.Transition.prototype.pause = function() {
  'use strict';
  goog.asserts.assert(false, 'Css3 transitions does not support pause action.');
};

//third_party/javascript/closure/fx/css3/fx.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A collection of CSS3 targeted animation, based on
 * `goog.fx.css3.Transition`.
 */

goog.provide('goog.fx.css3');

goog.require('goog.fx.css3.Transition');


/**
 * Creates a transition to fade the element.
 * @param {Element} element The element to fade.
 * @param {number} duration Duration in seconds.
 * @param {string} timing The CSS3 timing function.
 * @param {number} startOpacity Starting opacity.
 * @param {number} endOpacity Ending opacity.
 * @return {!goog.fx.css3.Transition} The transition object.
 */
goog.fx.css3.fade = function(
    element, duration, timing, startOpacity, endOpacity) {
  'use strict';
  return new goog.fx.css3.Transition(
      element, duration, {'opacity': startOpacity}, {'opacity': endOpacity},
      {property: 'opacity', duration: duration, timing: timing, delay: 0});
};


/**
 * Creates a transition to fade in the element.
 * @param {Element} element The element to fade in.
 * @param {number} duration Duration in seconds.
 * @return {!goog.fx.css3.Transition} The transition object.
 */
goog.fx.css3.fadeIn = function(element, duration) {
  'use strict';
  return goog.fx.css3.fade(element, duration, 'ease-out', 0, 1);
};


/**
 * Creates a transition to fade out the element.
 * @param {Element} element The element to fade out.
 * @param {number} duration Duration in seconds.
 * @return {!goog.fx.css3.Transition} The transition object.
 */
goog.fx.css3.fadeOut = function(element, duration) {
  'use strict';
  return goog.fx.css3.fade(element, duration, 'ease-in', 1, 0);
};

//third_party/javascript/closure/ui/popupbase.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of the PopupBase class.
 */

goog.provide('goog.ui.PopupBase');
goog.provide('goog.ui.PopupBase.EventType');
goog.provide('goog.ui.PopupBase.Type');

goog.require('goog.Timer');
goog.require('goog.array');
goog.require('goog.dispose');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.events');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.fx.Transition');
goog.require('goog.style');
goog.require('goog.userAgent');
goog.requireType('goog.events.BrowserEvent');



/**
 * The PopupBase class provides functionality for showing and hiding a generic
 * container element. It also provides the option for hiding the popup element
 * if the user clicks outside the popup or the popup loses focus.
 *
 * @constructor
 * @extends {goog.events.EventTarget}
 * @param {Element=} opt_element A DOM element for the popup.
 * @param {goog.ui.PopupBase.Type=} opt_type Type of popup.
 */
goog.ui.PopupBase = function(opt_element, opt_type) {
  'use strict';
  goog.events.EventTarget.call(this);

  /**
   * An event handler to manage the events easily
   * @type {goog.events.EventHandler<!goog.ui.PopupBase>}
   * @private
   */
  this.handler_ = new goog.events.EventHandler(this);

  this.setElement(opt_element || null);
  if (opt_type) {
    this.setType(opt_type);
  }
};
goog.inherits(goog.ui.PopupBase, goog.events.EventTarget);


/**
 * Constants for type of Popup
 * @enum {string}
 */
goog.ui.PopupBase.Type = {
  TOGGLE_DISPLAY: 'toggle_display',
  MOVE_OFFSCREEN: 'move_offscreen'
};


/**
 * The popup dom element that this Popup wraps.
 * @type {?Element}
 * @private
 */
goog.ui.PopupBase.prototype.element_ = null;


/**
 * Whether the Popup dismisses itself it the user clicks outside of it or the
 * popup loses focus
 * @type {boolean}
 * @private
 */
goog.ui.PopupBase.prototype.autoHide_ = true;


/**
 * Mouse events without auto hide partner elements will not dismiss the popup.
 * @type {?Array<?Element>}
 * @private
 */
goog.ui.PopupBase.prototype.autoHidePartners_ = null;


/**
 * Clicks outside the popup but inside this element will cause the popup to
 * hide if autoHide_ is true. If this is null, then the entire document is used.
 * For example, you can use a body-size div so that clicks on the browser
 * scrollbar do not dismiss the popup.
 * @type {?Element}
 * @private
 */
goog.ui.PopupBase.prototype.autoHideRegion_ = null;


/**
 * Whether the popup is currently being shown.
 * @type {boolean}
 * @private
 */
goog.ui.PopupBase.prototype.isVisible_ = false;


/**
 * Whether the popup should hide itself asynchrously. This was added because
 * there are cases where hiding the element in mouse down handler in IE can
 * cause textinputs to get into a bad state if the element that had focus is
 * hidden.
 * @type {boolean}
 * @private
 */
goog.ui.PopupBase.prototype.shouldHideAsync_ = false;


/**
 * The time when the popup was last shown.
 * @type {number}
 * @private
 */
goog.ui.PopupBase.prototype.lastShowTime_ = -1;


/**
 * The time when the popup was last hidden.
 * @type {number}
 * @private
 */
goog.ui.PopupBase.prototype.lastHideTime_ = -1;


/**
 * Whether to hide when the escape key is pressed.
 * @type {boolean}
 * @private
 */
goog.ui.PopupBase.prototype.hideOnEscape_ = false;


/**
 * Whether to enable cross-iframe dismissal.
 * @type {boolean}
 * @private
 */
goog.ui.PopupBase.prototype.enableCrossIframeDismissal_ = true;


/**
 * The type of popup
 * @type {goog.ui.PopupBase.Type}
 * @private
 */
goog.ui.PopupBase.prototype.type_ = goog.ui.PopupBase.Type.TOGGLE_DISPLAY;


/**
 * Transition to play on showing the popup.
 * @type {goog.fx.Transition|undefined}
 * @private
 */
goog.ui.PopupBase.prototype.showTransition_;


/**
 * Transition to play on hiding the popup.
 * @type {goog.fx.Transition|undefined}
 * @private
 */
goog.ui.PopupBase.prototype.hideTransition_;


/**
 * Constants for event type fired by Popup
 *
 * @enum {string}
 */
goog.ui.PopupBase.EventType = {
  BEFORE_SHOW: 'beforeshow',
  SHOW: 'show',
  BEFORE_HIDE: 'beforehide',
  HIDE: 'hide'
};


/**
 * A time in ms used to debounce events that happen right after each other.
 *
 * A note about why this is necessary. There are two cases to consider.
 * First case, a popup will usually see a focus event right after it's launched
 * because it's typical for it to be launched in a mouse-down event which will
 * then move focus to the launching button. We don't want to think this is a
 * separate user action moving focus. Second case, a user clicks on the
 * launcher button to close the menu. In that case, we'll close the menu in the
 * focus event and then show it again because of the mouse down event, even
 * though the intention is to just close the menu. This workaround appears to
 * be the least intrusive fix.
 *
 * @type {number}
 */
goog.ui.PopupBase.DEBOUNCE_DELAY_MS = 150;


/**
 * @return {goog.ui.PopupBase.Type} The type of popup this is.
 */
goog.ui.PopupBase.prototype.getType = function() {
  'use strict';
  return this.type_;
};


/**
 * Specifies the type of popup to use.
 *
 * @param {goog.ui.PopupBase.Type} type Type of popup.
 */
goog.ui.PopupBase.prototype.setType = function(type) {
  'use strict';
  this.type_ = type;
};


/**
 * Returns whether the popup should hide itself asynchronously using a timeout
 * instead of synchronously.
 * @return {boolean} Whether to hide async.
 */
goog.ui.PopupBase.prototype.shouldHideAsync = function() {
  'use strict';
  return this.shouldHideAsync_;
};


/**
 * Sets whether the popup should hide itself asynchronously using a timeout
 * instead of synchronously.
 * @param {boolean} b Whether to hide async.
 */
goog.ui.PopupBase.prototype.setShouldHideAsync = function(b) {
  'use strict';
  this.shouldHideAsync_ = b;
};


/**
 * Returns the dom element that should be used for the popup.
 *
 * @return {Element} The popup element.
 */
goog.ui.PopupBase.prototype.getElement = function() {
  'use strict';
  return this.element_;
};


/**
 * Specifies the dom element that should be used for the popup.
 *
 * @param {Element} elt A DOM element for the popup.
 */
goog.ui.PopupBase.prototype.setElement = function(elt) {
  'use strict';
  this.ensureNotVisible_();
  this.element_ = elt;
};


/**
 * Returns whether the Popup dismisses itself when the user clicks outside of
 * it.
 * @return {boolean} Whether the Popup autohides on an external click.
 */
goog.ui.PopupBase.prototype.getAutoHide = function() {
  'use strict';
  return this.autoHide_;
};


/**
 * Sets whether the Popup dismisses itself when the user clicks outside of it.
 * @param {boolean} autoHide Whether to autohide on an external click.
 */
goog.ui.PopupBase.prototype.setAutoHide = function(autoHide) {
  'use strict';
  this.ensureNotVisible_();
  this.autoHide_ = autoHide;
};


/**
 * Mouse events that occur within an autoHide partner will not hide a popup
 * set to autoHide.
 * @param {!Element} partner The auto hide partner element.
 */
goog.ui.PopupBase.prototype.addAutoHidePartner = function(partner) {
  'use strict';
  if (!this.autoHidePartners_) {
    this.autoHidePartners_ = [];
  }

  goog.array.insert(this.autoHidePartners_, partner);
};


/**
 * Removes a previously registered auto hide partner.
 * @param {!Element} partner The auto hide partner element.
 */
goog.ui.PopupBase.prototype.removeAutoHidePartner = function(partner) {
  'use strict';
  if (this.autoHidePartners_) {
    goog.array.remove(this.autoHidePartners_, partner);
  }
};


/**
 * @return {boolean} Whether the Popup autohides on the escape key.
 */
goog.ui.PopupBase.prototype.getHideOnEscape = function() {
  'use strict';
  return this.hideOnEscape_;
};


/**
 * Sets whether the Popup dismisses itself on the escape key.
 * @param {boolean} hideOnEscape Whether to autohide on the escape key.
 */
goog.ui.PopupBase.prototype.setHideOnEscape = function(hideOnEscape) {
  'use strict';
  this.ensureNotVisible_();
  this.hideOnEscape_ = hideOnEscape;
};


/**
 * @return {boolean} Whether cross iframe dismissal is enabled.
 */
goog.ui.PopupBase.prototype.getEnableCrossIframeDismissal = function() {
  'use strict';
  return this.enableCrossIframeDismissal_;
};


/**
 * Sets whether clicks in other iframes should dismiss this popup.  In some
 * cases it should be disabled, because it can cause spurious
 * @param {boolean} enable Whether to enable cross iframe dismissal.
 */
goog.ui.PopupBase.prototype.setEnableCrossIframeDismissal = function(enable) {
  'use strict';
  this.enableCrossIframeDismissal_ = enable;
};


/**
 * Returns the region inside which the Popup dismisses itself when the user
 * clicks, or null if it's the entire document.
 * @return {Element} The DOM element for autohide, or null if it hasn't been
 *     set.
 */
goog.ui.PopupBase.prototype.getAutoHideRegion = function() {
  'use strict';
  return this.autoHideRegion_;
};


/**
 * Sets the region inside which the Popup dismisses itself when the user
 * clicks.
 * @param {Element} element The DOM element for autohide.
 */
goog.ui.PopupBase.prototype.setAutoHideRegion = function(element) {
  'use strict';
  this.autoHideRegion_ = element;
};


/**
 * Sets transition animation on showing and hiding the popup.
 * @param {goog.fx.Transition=} opt_showTransition Transition to play on
 *     showing the popup.
 * @param {goog.fx.Transition=} opt_hideTransition Transition to play on
 *     hiding the popup.
 */
goog.ui.PopupBase.prototype.setTransition = function(
    opt_showTransition, opt_hideTransition) {
  'use strict';
  this.showTransition_ = opt_showTransition;
  this.hideTransition_ = opt_hideTransition;
};


/**
 * Returns the time when the popup was last shown.
 *
 * @return {number} time in ms since epoch when the popup was last shown, or
 * -1 if the popup was never shown.
 */
goog.ui.PopupBase.prototype.getLastShowTime = function() {
  'use strict';
  return this.lastShowTime_;
};


/**
 * Returns the time when the popup was last hidden.
 *
 * @return {number} time in ms since epoch when the popup was last hidden, or
 * -1 if the popup was never hidden or is currently showing.
 */
goog.ui.PopupBase.prototype.getLastHideTime = function() {
  'use strict';
  return this.lastHideTime_;
};


/**
 * Returns the event handler for the popup. All event listeners belonging to
 * this handler are removed when the tooltip is hidden. Therefore,
 * the recommended usage of this handler is to listen on events in
 * {@link #onShow}.
 * @return {goog.events.EventHandler<T>} Event handler for this popup.
 * @protected
 * @this {T}
 * @template T
 */
goog.ui.PopupBase.prototype.getHandler = function() {
  'use strict';
  // As the template type is unbounded, narrow the "this" type
  var self = /** @type {!goog.ui.PopupBase} */ (this);

  return self.handler_;
};


/**
 * Helper to throw exception if the popup is showing.
 * @private
 */
goog.ui.PopupBase.prototype.ensureNotVisible_ = function() {
  'use strict';
  if (this.isVisible_) {
    throw new Error('Can not change this state of the popup while showing.');
  }
};


/**
 * Returns whether the popup is currently visible.
 *
 * @return {boolean} whether the popup is currently visible.
 */
goog.ui.PopupBase.prototype.isVisible = function() {
  'use strict';
  return this.isVisible_;
};


/**
 * Returns whether the popup is currently visible or was visible within about
 * 150 ms ago. This is used by clients to handle a very specific, but common,
 * popup scenario. The button that launches the popup should close the popup
 * on mouse down if the popup is already open. The problem is that the popup
 * closes itself during the capture phase of the mouse down and thus the button
 * thinks it's hidden and this should show it again. This method provides a
 * good heuristic for clients. Typically in their event handler they will have
 * code that is:
 *
 * if (menu.isOrWasRecentlyVisible()) {
 *   menu.setVisible(false);
 * } else {
 *   ... // code to position menu and initialize other state
 *   menu.setVisible(true);
 * }
 * @return {boolean} Whether the popup is currently visible or was visible
 *     within about 150 ms ago.
 */
goog.ui.PopupBase.prototype.isOrWasRecentlyVisible = function() {
  'use strict';
  return this.isVisible_ ||
      (Date.now() - this.lastHideTime_ < goog.ui.PopupBase.DEBOUNCE_DELAY_MS);
};


/**
 * Sets whether the popup should be visible. After this method
 * returns, isVisible() will always return the new state, even if
 * there is a transition.
 *
 * @param {boolean} visible Desired visibility state.
 */
goog.ui.PopupBase.prototype.setVisible = function(visible) {
  'use strict';
  // Make sure that any currently running transition is stopped.
  if (this.showTransition_) this.showTransition_.stop();
  if (this.hideTransition_) this.hideTransition_.stop();

  if (visible) {
    this.show_();
  } else {
    this.hide_();
  }
};


/**
 * Repositions the popup according to the current state.
 * Should be overriden by subclases.
 */
goog.ui.PopupBase.prototype.reposition = goog.nullFunction;


/**
 * Does the work to show the popup.
 * @private
 */
goog.ui.PopupBase.prototype.show_ = function() {
  'use strict';
  // Ignore call if we are already showing.
  if (this.isVisible_) {
    return;
  }

  // Give derived classes and handlers a chance to customize popup.
  if (!this.onBeforeShow()) {
    return;
  }

  // Allow callers to set the element in the BEFORE_SHOW event.
  if (!this.element_) {
    throw new Error(
        'Caller must call setElement before trying to show the popup');
  }

  // Call reposition after onBeforeShow, as it may change the style and/or
  // content of the popup and thereby affecting the size which is used for the
  // viewport calculation.
  this.reposition();

  var doc = goog.dom.getOwnerDocument(this.element_);

  if (this.hideOnEscape_) {
    // Handle the escape keys.  Listen in the capture phase so that we can
    // stop the escape key from propagating to other elements.  For example,
    // if there is a popup within a dialog box, we want the popup to be
    // dismissed first, rather than the dialog.
    this.handler_.listen(
        doc, goog.events.EventType.KEYDOWN, this.onDocumentKeyDown_, true);
  }

  // Set up event handlers.
  if (this.autoHide_) {
    // Even if the popup is not in the focused document, we want to
    // close it on mousedowns in the document it's in.
    this.handler_.listen(
        doc, goog.events.EventType.MOUSEDOWN, this.onDocumentMouseDown_, true);

    if (goog.userAgent.IE) {
      // We want to know about deactivates/mousedowns on the document with focus
      // The top-level document won't get a deactivate event if the focus is
      // in an iframe and the deactivate fires within that iframe.
      // The active element in the top-level document will remain the iframe
      // itself.
      var activeElement;

      try {
        activeElement = doc.activeElement;
      } catch (e) {
        // There is an IE browser bug which can cause just the reading of
        // document.activeElement to throw an Unspecified Error.  This
        // may have to do with loading a popup within a hidden iframe.
      }
      while (activeElement &&
             activeElement.nodeName == goog.dom.TagName.IFRAME) {

        try {
          var tempDoc = goog.dom.getFrameContentDocument(activeElement);
        } catch (e) {
          // The frame is on a different domain that its parent document
          // This way, we grab the lowest-level document object we can get
          // a handle on given cross-domain security.
          break;
        }
        doc = tempDoc;
        activeElement = doc.activeElement;
      }

      // Handle mousedowns in the focused document in case the user clicks
      // on the activeElement (in which case the popup should hide).
      this.handler_.listen(
          doc, goog.events.EventType.MOUSEDOWN, this.onDocumentMouseDown_,
          true);

      // If the active element inside the focused document changes, then
      // we probably need to hide the popup.
      this.handler_.listen(
          doc, goog.events.EventType.DEACTIVATE, this.onDocumentBlur_);

    } else {
      this.handler_.listen(
          doc, goog.events.EventType.BLUR, this.onDocumentBlur_);
    }
  }

  // Make the popup visible.
  if (this.type_ == goog.ui.PopupBase.Type.TOGGLE_DISPLAY) {
    this.showPopupElement();
  } else if (this.type_ == goog.ui.PopupBase.Type.MOVE_OFFSCREEN) {
    this.reposition();
  }
  this.isVisible_ = true;

  this.lastShowTime_ = Date.now();
  this.lastHideTime_ = -1;

  // If there is transition to play, we play it and fire SHOW event after
  // the transition is over.
  if (this.showTransition_) {
    goog.events.listenOnce(
        /** @type {!goog.events.EventTarget} */ (this.showTransition_),
        goog.fx.Transition.EventType.END, this.onShow, false, this);
    this.showTransition_.play();
  } else {
    // Notify derived classes and handlers.
    this.onShow();
  }
};


/**
 * Hides the popup. This call is idempotent.
 *
 * @param {?Node=} opt_target Target of the event causing the hide.
 * @return {boolean} Whether the popup was hidden and not cancelled.
 * @private
 */
goog.ui.PopupBase.prototype.hide_ = function(opt_target) {
  'use strict';
  // Give derived classes and handlers a chance to cancel hiding.
  if (!this.isVisible_ || !this.onBeforeHide(opt_target)) {
    return false;
  }

  // Remove any listeners we attached when showing the popup.
  if (this.handler_) {
    this.handler_.removeAll();
  }

  // Set visibility to hidden even if there is a transition.
  this.isVisible_ = false;
  this.lastHideTime_ = Date.now();

  // If there is transition to play, we play it and only hide the element
  // (and fire HIDE event) after the transition is over.
  if (this.hideTransition_) {
    goog.events.listenOnce(
        /** @type {!goog.events.EventTarget} */ (this.hideTransition_),
        goog.fx.Transition.EventType.END,
        goog.partial(this.continueHidingPopup_, opt_target), false, this);
    this.hideTransition_.play();
  } else {
    this.continueHidingPopup_(opt_target);
  }

  return true;
};


/**
 * Continues hiding the popup. This is a continuation from hide_. It is
 * a separate method so that we can add a transition before hiding.
 * @param {?Node=} opt_target Target of the event causing the hide.
 * @private
 */
goog.ui.PopupBase.prototype.continueHidingPopup_ = function(opt_target) {
  'use strict';
  // Hide the popup.
  if (this.type_ == goog.ui.PopupBase.Type.TOGGLE_DISPLAY) {
    if (this.shouldHideAsync_) {
      goog.Timer.callOnce(this.hidePopupElement, 0, this);
    } else {
      this.hidePopupElement();
    }
  } else if (this.type_ == goog.ui.PopupBase.Type.MOVE_OFFSCREEN) {
    this.moveOffscreen_();
  }

  // Notify derived classes and handlers.
  this.onHide(opt_target);
};


/**
 * Shows the popup element.
 * @protected
 */
goog.ui.PopupBase.prototype.showPopupElement = function() {
  'use strict';
  this.element_.style.visibility = 'visible';
  goog.style.setElementShown(this.element_, true);
};


/**
 * Hides the popup element.
 * @protected
 */
goog.ui.PopupBase.prototype.hidePopupElement = function() {
  'use strict';
  this.element_.style.visibility = 'hidden';
  goog.style.setElementShown(this.element_, false);
};


/**
 * Hides the popup by moving it offscreen.
 *
 * @private
 */
goog.ui.PopupBase.prototype.moveOffscreen_ = function() {
  'use strict';
  this.element_.style.top = '-10000px';
};


/**
 * Called before the popup is shown. Derived classes can override to hook this
 * event but should make sure to call the parent class method.
 *
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false this will also return false.
 * @protected
 */
goog.ui.PopupBase.prototype.onBeforeShow = function() {
  'use strict';
  return this.dispatchEvent(goog.ui.PopupBase.EventType.BEFORE_SHOW);
};


/**
 * Called after the popup is shown. Derived classes can override to hook this
 * event but should make sure to call the parent class method.
 * @protected
 */
goog.ui.PopupBase.prototype.onShow = function() {
  'use strict';
  this.dispatchEvent(goog.ui.PopupBase.EventType.SHOW);
};


/**
 * Called before the popup is hidden. Derived classes can override to hook this
 * event but should make sure to call the parent class method.
 *
 * @param {?Node=} opt_target Target of the event causing the hide.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false this will also return false.
 * @protected
 */
goog.ui.PopupBase.prototype.onBeforeHide = function(opt_target) {
  'use strict';
  return this.dispatchEvent(
      {type: goog.ui.PopupBase.EventType.BEFORE_HIDE, target: opt_target});
};


/**
 * Called after the popup is hidden. Derived classes can override to hook this
 * event but should make sure to call the parent class method.
 * @param {?Node=} opt_target Target of the event causing the hide.
 * @protected
 */
goog.ui.PopupBase.prototype.onHide = function(opt_target) {
  'use strict';
  this.dispatchEvent(
      {type: goog.ui.PopupBase.EventType.HIDE, target: opt_target});
};


/**
 * Mouse down handler for the document on capture phase. Used to hide the
 * popup for auto-hide mode.
 *
 * @param {goog.events.BrowserEvent} e The event object.
 * @private
 */
goog.ui.PopupBase.prototype.onDocumentMouseDown_ = function(e) {
  'use strict';
  var target = e.target;

  if (!goog.dom.contains(this.element_, target) &&
      !this.isOrWithinAutoHidePartner_(target) &&
      this.isWithinAutoHideRegion_(target) && !this.shouldDebounce_()) {
    // Mouse click was outside popup and partners, so hide.
    this.hide_(target);
  }
};


/**
 * Handles key-downs on the document to handle the escape key.
 *
 * @param {goog.events.BrowserEvent} e The event object.
 * @private
 */
goog.ui.PopupBase.prototype.onDocumentKeyDown_ = function(e) {
  'use strict';
  if (e.keyCode == goog.events.KeyCodes.ESC) {
    if (this.hide_(e.target)) {
      // Eat the escape key, but only if this popup was actually closed.
      e.preventDefault();
      e.stopPropagation();
    }
  }
};


/**
 * Deactivate handler(IE) and blur handler (other browsers) for document.
 * Used to hide the popup for auto-hide mode.
 *
 * @param {goog.events.BrowserEvent} e The event object.
 * @private
 */
goog.ui.PopupBase.prototype.onDocumentBlur_ = function(e) {
  'use strict';
  if (!this.enableCrossIframeDismissal_) {
    return;
  }

  var doc = goog.dom.getOwnerDocument(this.element_);

  // Ignore blur events if either the active element is still inside the popup
  // or one of its partner elements, or if there is no longer an active element.
  // For example, a widget like a goog.ui.Button might programmatically blur
  // itself before losing tabIndex.
  if (typeof document.activeElement != 'undefined') {
    var activeElement = doc.activeElement;
    if (!activeElement || goog.dom.contains(this.element_, activeElement) ||
        activeElement.tagName == goog.dom.TagName.BODY) {
      return;
    }

    // IE10 differs from other browsers in that it sets the active element to
    // the element being focused while the blur event is being handled.
    // In this case, check if the focused element is one of this popup element's
    // auto-hide partners. If so, do not hide the popup.
    // Reference:
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event
    if (this.isOrWithinAutoHidePartner_(activeElement)) {
      return;
    }

    // Ignore blur events not for the document itself in non-IE browsers.
  } else if (e.target != doc) {
    return;
  }

  // Debounce the initial focus move.
  if (this.shouldDebounce_()) {
    return;
  }

  this.hide_();
};


/**
 * @param {Node} element The element to inspect.
 * @return {boolean} Returns true if the given element is one of the auto hide
 *     partners or is a child of an auto hide partner.
 * @private
 */
goog.ui.PopupBase.prototype.isOrWithinAutoHidePartner_ = function(element) {
  'use strict';
  return goog.array.some(this.autoHidePartners_ || [], function(partner) {
    'use strict';
    return element === partner || goog.dom.contains(partner, element);
  });
};


/**
 * @param {Node} element The element to inspect.
 * @return {boolean} Returns true if the element is contained within
 *     the autohide region. If unset, the autohide region is the entire
 *     entire document.
 * @private
 */
goog.ui.PopupBase.prototype.isWithinAutoHideRegion_ = function(element) {
  'use strict';
  return this.autoHideRegion_ ?
      goog.dom.contains(this.autoHideRegion_, element) :
      true;
};


/**
 * @return {boolean} Whether the time since last show is less than the debounce
 *     delay.
 * @private
 */
goog.ui.PopupBase.prototype.shouldDebounce_ = function() {
  'use strict';
  return Date.now() - this.lastShowTime_ < goog.ui.PopupBase.DEBOUNCE_DELAY_MS;
};


/** @override */
goog.ui.PopupBase.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.PopupBase.base(this, 'disposeInternal');
  this.handler_.dispose();
  goog.dispose(this.showTransition_);
  goog.dispose(this.hideTransition_);
  delete this.element_;
  delete this.handler_;
  delete this.autoHidePartners_;
};

//third_party/javascript/closure/ui/popup.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Definition of the Popup class.
 *
 * @see ../demos/popup.html
 */

goog.provide('goog.ui.Popup');

goog.require('goog.math.Box');
goog.require('goog.positioning.AbstractPosition');
goog.require('goog.positioning.Corner');
goog.require('goog.style');
goog.require('goog.ui.PopupBase');



/**
 * The Popup class provides functionality for displaying an absolutely
 * positioned element at a particular location in the window. It's designed to
 * be used as the foundation for building controls like a menu or tooltip. The
 * Popup class includes functionality for displaying a Popup near adjacent to
 * an anchor element.
 *
 * This works cross browser and thus does not use IE's createPopup feature
 * which supports extending outside the edge of the brower window.
 *
 * @param {Element=} opt_element A DOM element for the popup.
 * @param {goog.positioning.AbstractPosition=} opt_position A positioning helper
 *     object.
 * @constructor
 * @extends {goog.ui.PopupBase}
 */
goog.ui.Popup = function(opt_element, opt_position) {
  'use strict';
  /**
   * Corner of the popup to used in the positioning algorithm.
   *
   * @type {goog.positioning.Corner}
   * @private
   */
  this.popupCorner_ = goog.positioning.Corner.TOP_START;

  /**
   * Positioning helper object.
   *
   * @private {goog.positioning.AbstractPosition|undefined}
   */
  this.position_ = opt_position || undefined;
  goog.ui.PopupBase.call(this, opt_element);
};
goog.inherits(goog.ui.Popup, goog.ui.PopupBase);


/**
 * Margin for the popup used in positioning algorithms.
 *
 * @type {goog.math.Box|undefined}
 * @private
 */
goog.ui.Popup.prototype.margin_;


/**
 * Returns the corner of the popup to used in the positioning algorithm.
 *
 * @return {goog.positioning.Corner} The popup corner used for positioning.
 */
goog.ui.Popup.prototype.getPinnedCorner = function() {
  'use strict';
  return this.popupCorner_;
};


/**
 * Sets the corner of the popup to used in the positioning algorithm.
 *
 * @param {goog.positioning.Corner} corner The popup corner used for
 *     positioning.
 */
goog.ui.Popup.prototype.setPinnedCorner = function(corner) {
  'use strict';
  this.popupCorner_ = corner;
  if (this.isVisible()) {
    this.reposition();
  }
};


/**
 * @return {goog.positioning.AbstractPosition} The position helper object
 *     associated with the popup.
 */
goog.ui.Popup.prototype.getPosition = function() {
  'use strict';
  return this.position_ || null;
};


/**
 * Sets the position helper object associated with the popup.
 *
 * @param {goog.positioning.AbstractPosition} position A position helper object.
 */
goog.ui.Popup.prototype.setPosition = function(position) {
  'use strict';
  this.position_ = position || undefined;
  if (this.isVisible()) {
    this.reposition();
  }
};


/**
 * Returns the margin to place around the popup.
 *
 * @return {goog.math.Box?} The margin.
 */
goog.ui.Popup.prototype.getMargin = function() {
  'use strict';
  return this.margin_ || null;
};


/**
 * Sets the margin to place around the popup.
 *
 * @param {goog.math.Box|number|null} arg1 Top value or Box.
 * @param {number=} opt_arg2 Right value.
 * @param {number=} opt_arg3 Bottom value.
 * @param {number=} opt_arg4 Left value.
 */
goog.ui.Popup.prototype.setMargin = function(
    arg1, opt_arg2, opt_arg3, opt_arg4) {
  'use strict';
  if (arg1 == null || arg1 instanceof goog.math.Box) {
    this.margin_ = arg1;
  } else {
    this.margin_ = new goog.math.Box(
        arg1,
        /** @type {number} */ (opt_arg2),
        /** @type {number} */ (opt_arg3),
        /** @type {number} */ (opt_arg4));
  }
  if (this.isVisible()) {
    this.reposition();
  }
};


/**
 * Repositions the popup according to the current state.
 * @override
 */
goog.ui.Popup.prototype.reposition = function() {
  'use strict';
  if (!this.position_) {
    return;
  }

  var hideForPositioning = !this.isVisible() &&
      this.getType() != goog.ui.PopupBase.Type.MOVE_OFFSCREEN;
  var el = this.getElement();
  if (hideForPositioning) {
    el.style.visibility = 'hidden';
    goog.style.setElementShown(el, true);
  }

  this.position_.reposition(el, this.popupCorner_, this.margin_);

  if (hideForPositioning) {
    // NOTE(eae): The visibility property is reset to 'visible' by the show_
    // method in PopupBase. Resetting it here causes flickering in some
    // situations, even if set to visible after the display property has been
    // set to none by the call below.
    goog.style.setElementShown(el, false);
  }
};

//javascript/jfk/bubble/bubble.js
goog.loadModule(function(exports) {'use strict';// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Renders a bubble with an arrow relative to an anchor
 * position. The bubble supports various positioning and arrow
 * alignments, and an optional close button (enabled by default).
 *
 * @author tdebroc@google.com (Thibaut de Broca)
 * @author ecattell@google.com (Eric Cattell)
 * @author chrishenry@google.com (Chris Henry)
 * @see bubble_demo.html
 */

goog.module('jfk.Bubble');
goog.module.declareLegacyNamespace();

const ArrowAlignment = goog.requireType('jfk.ArrowAlignment');
const ArrowPosition = goog.require('jfk.ArrowPosition');
const Box = goog.requireType('goog.math.Box');
const BrowserEvent = goog.requireType('goog.events.BrowserEvent');
const Component = goog.require('goog.ui.Component');
const EventType = goog.require('goog.events.EventType');
const GoogEvent = goog.requireType('goog.events.Event');
const Popup = goog.require('goog.ui.Popup');
const PopupBase = goog.require('goog.ui.PopupBase');
const PopupPosition = goog.requireType('jfk.PopupPosition');
const SafeHtml = goog.require('goog.html.SafeHtml');
const SanitizedHtml = goog.require('goog.soy.data.SanitizedHtml');
const actionEventWrapper = goog.require('goog.events.actionEventWrapper');
const asserts = goog.require('goog.asserts');
const bubble = goog.require('jfk.templates.bubble');
const classlist = goog.require('goog.dom.classlist');
const css3 = goog.require('goog.fx.css3');
const dom = goog.require('goog.dom');
const safe = goog.require('goog.dom.safe');
const soy = goog.require('goog.soy');
const style = goog.require('goog.style');
const userAgent = goog.require('goog.userAgent');

//==============================================================================
// Initialization.
//==============================================================================

/**
 * Simple popup/bubble with configurable position and an arrow
 * pointing towards its anchor element. The bubble disposes itself
 * automatically when hidden.
 *
 * Bubble fires the following events:
 * PopupBase.EventType.BEFORE_SHOW,
 * PopupBase.EventType.SHOW,
 * PopupBase.EventType.BEFORE_HIDE,
 * PopupBase.EventType.HIDE
 *
 * NOTE: This class differ from goog.ui.Bubble in that it does not use
 * tables and looks and behaves differently. It is a shadowed box with
 * an arrow rather than a round thought bubble.
 *
 * @param {dom.DomHelper=} opt_domHelper Optional DomHelper.
 * @extends {Component}
 * @constructor
 */
function Bubble(opt_domHelper) {
  Bubble.base(this, 'constructor', opt_domHelper);

  /**
   * @type {!ArrowPosition}
   * @private
   */
  this.arrowPosition_ =
      new ArrowPosition(this.className_, true /* disableSubpixels */);

  /**
   * @type {!Popup}
   * @private
   */
  this.popup_ = new Popup();

  /**
   * This value is used to hide the bubble when we scroll so it
   * doesn't overlap a fixed header if present; we hide the bubble
   * when scrolling if its position is less than the value.
   * @type {number}
   * @private
   */
  this.hideYPosition_ = 0;

  /**
   * Optional additional CSS classes for the outer 'bubble area' div.
   * @type {!Array.<string>}
   * @private
   */
  this.extraCssClasses_ = [];
}
goog.inherits(Bubble, Component);

/**
 * CSS class name for the bubble element, also used as a class name prefix for
 * related elements.
 * @type {string}
 * @private
 */
Bubble.prototype.className_ = goog.getCssName('jfk-bubble');

/**
 * Whether the close box is enabled.
 * @type {boolean}
 * @private
 */
Bubble.prototype.showCloseButton_ = true;

/**
 * @private {Element|string|SanitizedHtml|SafeHtml}
 */
Bubble.prototype.content_;

/**
 * @type {boolean}
 * @private
 */
Bubble.prototype.disposeOnHide_ = false;

//==============================================================================
// Getters & Setters.
//==============================================================================

/**
 * Sets the anchor element. May be null, in which case, we do not
 * reposition the box element with respect to anchor. This may be called
 * at any time.
 * @param {Element} anchor The anchor element.
 */
Bubble.prototype.setAnchorElement = function(anchor) {
  this.arrowPosition_.setAnchorElement(anchor);
  this.reposition();
};

/**
 * Sets the position of the bubble. By default, the bubble is on the right of
 * the anchor and the arrow point is centered. Must be called before
 * the element is rendered.
 * @param {PopupPosition=} opt_position Position of the bubble
 *     relative to the anchor (e.g. left means the bubble will be at the left
 *     of the anchor).
 * @param {ArrowAlignment=} opt_alignment Arrow Alignment
 *     on the side of the bubble.
 * @param {number=} opt_arrowOffset Optional offset (in px) for the arrow.
 *     Ignored if Alignment is CENTER.
 * @param {number=} opt_offsetFromAnchor Optional offset (in px) for the
 *     movable box with respect to the anchor. Defaults to -5px.
 * @param {boolean=} opt_allowOverflow Optional boolean, if set to true will
 *     allow the arrow position to setBoxOverflow if positioning
 *     the bubble fails. This may trigger with exceptionally large text content
 *     in the bubbles on smaller screens.
 */
Bubble.prototype.setPosition = function(
    opt_position, opt_alignment, opt_arrowOffset, opt_offsetFromAnchor,
    opt_allowOverflow) {
  asserts.assert(
      !this.isInDocument(), 'Must call setPosition() before rendering');
  this.arrowPosition_.setBoxOverflowAllowedOnPositioningFail(
      !!opt_allowOverflow);
  this.arrowPosition_.setPosition(
      opt_position, opt_alignment, opt_arrowOffset, opt_offsetFromAnchor);
};

/**
 * Shows the close button. Must be called before rendering.
 * @param {boolean} show Whether the close box is enabled.
 */
Bubble.prototype.showCloseButton = function(show) {
  asserts.assert(
      !this.isInDocument(), 'Must call showCloseButton() before rendering');
  this.showCloseButton_ = show;
};

/**
 * Adds an extra CSS class to the outer 'bubble area' div. Must be
 * called before rendering.
 * @param {string} className The class name to add.
 */
Bubble.prototype.addClassName = function(className) {
  asserts.assert(
      !this.isInDocument(), 'Must call addClassName() before rendering');
  this.extraCssClasses_.push(className);
};

/**
 * Sets the content of the bubble. Alternatively, if the element has
 * already been rendered, you can set the content of
 * `getContentElement()` directly.
 *
 * @param {Element|string|SanitizedHtml|SafeHtml}
 *     content The content to set. The string type is treated as a plain text
 *     and will be HTML-escaped.
 */
Bubble.prototype.setContent = function(content) {
  asserts.assert(
      typeof content === 'string' || content.nodeType ||
          content instanceof SanitizedHtml || content instanceof SafeHtml,
      'Content must be a string or HTML.');
  this.content_ = content;
  this.setContentInternal_(content);
};

/**
 * Sets content implementation.
 * @param {Element|string|SanitizedHtml|SafeHtml}
 *     content The content to set. The string type is treated as a plain text
 *     and will be HTML-escaped.
 * @private
 */
Bubble.prototype.setContentInternal_ = function(content) {
  var element = this.getContentElement();
  if (content && element) {
    if (typeof content === 'string') {
      dom.setTextContent(element, content);
    } else if (content instanceof SanitizedHtml) {
      safe.setInnerHtml(element, content.toSafeHtml());
    } else if (content instanceof SafeHtml) {
      safe.setInnerHtml(element, content);
    } else {
      safe.setInnerHtml(element, SafeHtml.EMPTY);
      dom.appendChild(element, content);
    }
  }
};

/**
 * @return {boolean} Whether the bubble dismisses itself when the user clicks
 *     outside of it.
 */
Bubble.prototype.getAutoHide = function() {
  return this.popup_.getAutoHide();
};

/**
 * Sets whether the bubble hides when a click happens somewhere else on the
 * page. Defaults to true.
 * @param {boolean} autoHide Whether auto hide should be enabled.
 */
Bubble.prototype.setAutoHide = function(autoHide) {
  this.popup_.setAutoHide(autoHide);
};

/**
 * Sets the region inside which the bubble dismisses itself when the user
 * clicks.
 * @param {Element} element The DOM element for autohide.
 */
Bubble.prototype.setAutoHideRegion = function(element) {
  this.popup_.setAutoHideRegion(element);
};

/**
 * Sets whether to prevent the bubble from going outside the browser or frame
 * viewport.
 * @param {boolean} auto Whether to use auto re-position.
 */
Bubble.prototype.setAutoReposition = function(auto) {
  this.arrowPosition_.setAutoReposition(auto);
};

/**
 * Adds an auto hide partner. Mouse events that occur within an auto hide
 * partner will not hide a popup set to auto hide.
 * @param {!Element} partner The auto hide partner element.
 */
Bubble.prototype.addAutoHidePartner = function(partner) {
  this.popup_.addAutoHidePartner(partner);
};

/**
 * Removes a previously registered auto hide partner.
 * @param {!Element} partner The auto hide partner element.
 */
Bubble.prototype.removeAutoHidePartner = function(partner) {
  this.popup_.removeAutoHidePartner(partner);
};

/**
 * Sets whether the bubble should be automatically disposed on hiding.
 * @param {boolean} disposeOnHide Whether to autmatically dispose
 *     itself on hiding.
 */
Bubble.prototype.setDisposeOnHide = function(disposeOnHide) {
  this.disposeOnHide_ = disposeOnHide;
};

/** @override */
Bubble.prototype.getContentElement = function() {
  return this.getElementByClass(goog.getCssName(this.className_, 'content-id'));
};

/**
 * Sets the value of the y position at which we hide the button when scrolling.
 * @param {number} hideYPos The value of the position for hiding.
 */
Bubble.prototype.setHideYPosition = function(hideYPos) {
  this.hideYPosition_ = hideYPos;
};

//==============================================================================
// DOM & Rendering.
//==============================================================================

/** @override */
Bubble.prototype.createDom = function() {
  // The Html structure of the bubble is:
  // Element        Function                 Class-name
  // ---------------------------------------------------------------------------
  // - div          Bubble area              jfk-bubble
  //   - div        Content area             jfk-bubble-content
  //     - ??       User specified content   N/A
  //   - div        Close button             jfk-bubble-closebtn
  //   - div        Arrow                    jfk-bubble-arrow-%direction%

  // Render the main popup content element.
  this.setElementInternal(soy.renderAsElement(
      bubble.main, {
        showCloseBox: this.showCloseButton_,
        uid: ('bubble-' + goog.getUid(this))
      },
      undefined, this.getDomHelper()));
  this.setContentInternal_(this.content_);
  style.setElementShown(this.getElement(), false);

  this.popup_.setElement(this.getElement());

  this.configurePopupTransition(this.popup_);

  classlist.addAll(this.getElement(), this.extraCssClasses_);
};

/**
 * Configures the popup transition.
 * @param {!Popup} popup
 * @protected
 */
Bubble.prototype.configurePopupTransition = function(popup) {
  // Do not enable transition on mobile devices as they are not played smoothly.
  if (!userAgent.MOBILE) {
    popup.setTransition(
        css3.fadeIn(this.getElement(), Bubble.TRANSITION_DURATION_),
        css3.fadeOut(this.getElement(), Bubble.TRANSITION_DURATION_));
  }
};

/**
 * Sets the viewport for the bubble.The viewport is specified relative to the
 * offset parent.
 * See documentation for `opt_viewport` at
 * `goog.positioning.positionAtAnchor` for more details.
 * @param {!Box} viewport Viewport for the box.
 */
Bubble.prototype.setViewport = function(viewport) {
  this.arrowPosition_.setViewport(viewport);
};

/**
 * Animation duration (in seconds). The value is as defined in go/kennedyspec.
 * @type {number}
 * @const
 * @private
 */
Bubble.TRANSITION_DURATION_ = 0.218;

/** @override */
Bubble.prototype.enterDocument = function() {
  Bubble.base(this, 'enterDocument');

  this.getHandler().listen(
      this.popup_,
      [
        PopupBase.EventType.BEFORE_SHOW, PopupBase.EventType.SHOW,
        PopupBase.EventType.BEFORE_HIDE, PopupBase.EventType.HIDE
      ],
      this.handlePopupEvent_);

  if (this.showCloseButton_) {
    this.getHandler().listenWithWrapper(
        this.getElementByClass(goog.getCssName(this.className_, 'closebtn-id')),
        actionEventWrapper, goog.partial(this.setVisible, false));
  }

  var element = this.getElement();
  asserts.assert(element, 'getElement() returns null.');

  var arrow = this.getElementByClass(
      goog.getCssName(this.className_, 'arrow-id'));
  asserts.assert(arrow, 'No arrow element is found!');

  // Must be in document and visible before calling positionArrow.
  this.arrowPosition_.setElements(element, arrow);
  // Position the bubble using the ArrowPosition positioning abstraction.
  this.popup_.setPosition(this.arrowPosition_);
};

/**
 * Sets the bubble visibility.
 * @param {boolean} visible Whether the bubble should be visible or not.
 */
Bubble.prototype.setVisible = function(visible) {
  this.popup_.setVisible(visible);
};

/**
 * @return {boolean} Whether the popup is visible.
 */
Bubble.prototype.isVisible = function() {
  return this.popup_.isVisible();
};

/**
 * Returns whether the popup is currently visible or was visible within about
 * 150ms ago. This is used to handle the scenario where the same button is used
 * to open and close the popup. See details at {@link
 * PopupBase#isOrWasRecentlyVisible}.
 * @return {boolean} Whether the popup is or was recently visible.
 */
Bubble.prototype.isOrWasRecentlyVisible = function() {
  return this.popup_.isOrWasRecentlyVisible();
};

/**
 * Repositions the bubble popup if needed.
 */
Bubble.prototype.reposition = function() {
  if (this.isVisible()) this.popup_.reposition();
};

/** @override */
Bubble.prototype.disposeInternal = function() {
  this.popup_.dispose();
  delete this.popup_;
  Bubble.base(this, 'disposeInternal');
};

/**
 * Handle scroll events on the document body by dismissing
 * the bubble.
 * @param {BrowserEvent} event The scroll event.
 * @return {boolean} Return false since we handled event.
 * @private
 */
Bubble.prototype.handleScroll_ = function(event) {
  // Hide the bubble if its position is less than the hide position.
  var position = style.getClientPosition(this.getElement());
  if (this.hideYPosition_ && position.y < this.hideYPosition_) {
    this.setVisible(false);
  }
  return false;
};

/**
 * Handles popup event and fires them as Bubble owns.
 * @param {GoogEvent} e The event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false) this will also return false.
 * @private
 */
Bubble.prototype.handlePopupEvent_ = function(e) {
  if (e.type == PopupBase.EventType.SHOW ||
      e.type == PopupBase.EventType.HIDE) {
    // Listen or unlisten for scroll events so we can dismiss the bubble when
    // the page scrolls, so the bubble won't overlap the fixed header if it's
    // present.
    var handler = this.getHandler();
    var domHelper = this.getDomHelper();
    var scrollElement =
        userAgent.IE ? domHelper.getWindow() : domHelper.getDocument();
    if (e.type == PopupBase.EventType.SHOW) {
      handler.listen(scrollElement, EventType.SCROLL, this.handleScroll_);
    } else {
      handler.unlisten(scrollElement, EventType.SCROLL, this.handleScroll_);
    }
  }

  var shouldCancel = this.dispatchEvent(e.type);

  // Dispose-on-hide is really part of hiding the popup and should be
  // cancelled via BEFORE_HIDE. So we should ignore the value of shouldCancel
  // and dispose the bubble here.
  if (this.disposeOnHide_ && e.type == PopupBase.EventType.HIDE) {
    this.dispose();
  }

  return shouldCancel;
};

exports = Bubble;

;return exports;});

//javascript/jfk/bubble/promobubble.js
goog.loadModule(function(exports) {'use strict';// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Promotional bubble is a bubble that is automatically
 * displayed on render and automatically disposed when dismissed.
 * Otherwise, it behaves similarly to `Bubble`.
 * @author chrishenry@google.com (Chris Henry)
 */

goog.module('jfk.PromoBubble');
goog.module.declareLegacyNamespace();

const Bubble = goog.require('jfk.Bubble');
const DomHelper = goog.requireType('goog.dom.DomHelper');

/**
 * Promotional bubble. This bubble is automatically displayed on
 * render and automatically dispose itself when it is dismissed. Users
 * of this bubble should simply need to set its content and call
 * render().
 * @param {Element} anchor The anchor element for the promotional bubble.
 * @param {DomHelper=} opt_domHelper Optional DomHelper.
 * @extends {Bubble}
 * @constructor
 */
function PromoBubble(anchor, opt_domHelper) {
  PromoBubble.base(this, 'constructor', opt_domHelper);
  this.setAnchorElement(anchor);
  this.setDisposeOnHide(true);
  this.addClassName(PromoBubble.EXTRA_CSS_CLASS_);
}
goog.inherits(PromoBubble, Bubble);

/**
 * @type {string}
 * @const
 * @private
 */
PromoBubble.EXTRA_CSS_CLASS_ = goog.getCssName('jfk-bubble-promo');

/** @override */
PromoBubble.prototype.enterDocument = function() {
  PromoBubble.base(this, 'enterDocument');
  this.setVisible(true);
};

exports = PromoBubble;

;return exports;});

//javascript/angular/jfkwrappers/bubble/bubble.js
/**
 * @fileoverview Implements directives/services for jfk-bubble and promo-bubble.
 *
 * Usage example for jfk-bubble:
 * <pre>
 * &lt;span ng-mouseover="pointHere.show()">Point here
 * &lt;span jfk-bubble="pointHere">{{msg}}&lt;/span>
 * &lt;/span>
 * </pre>
 * <p>
 * </pre>
 * When using jfk-bubble an object is injected into the scope for you that
 * provides a show function and a hide function to show/hide the bubble with the
 * content defined by the contents of the jfk-bubble. jfk-bubbles can also take
 * a jfk-bubble-show-close-button attribute at compile time.
 * <p>
 * Second example (direct use of jfk-shared-bubble and the service):
 * <pre>
 * &lt;div jfk-shared-bubble>&lt;/div>
 * &lt;span
 * ng-click="jfkBubbleService.showBubbleMessage('msg', $event.target)">
 * &lt;/span>
 * </pre>
 * <p>
 * In this case jfkBubbleService should be injected into the scope and the
 * method call is slightly longer as it requires the element to be passed in.
 * Also, the jfk-shared-bubble directive allows you to register one specific
 * bubble with specific styling options; otherwise a default one is added to the
 * document.
 * <p>
 * Usage example for jfk-promo-bubble:
 * <pre>
 * &lt;span>&lt;span jfk-promo-bubble="pointHere">My promotion"&lt;/span>
 * &lt;/span>
 * &lt;script>
 * pointHere.show();
 * </script>
 * <p>
 * In this case a promo bubble is attached to the parent node of the
 * jfk-promo-bubble span.
 * </pre>
 */

goog.provide('ng.jfk.Bubble');

goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.ui.PopupBase.EventType');
goog.require('jfk.ArrowAlignment');
goog.require('jfk.Bubble');
goog.require('jfk.PopupPosition');
goog.require('jfk.PromoBubble');
goog.require('ng.jfk.Common');
goog.require('ng.jfk.Position');

/**
 * For instances of angular.Module that are used as a namespace, like in this
 * file, we delcare a subtype of angular.Module to make it clear that other
 * angular.Module instances cannot have these properties.
 * @interface @extends {angular.Module}
 * */
ng.jfk.BubbleModuleType = function() {};

/**
 * Angular module for the jfk-bubble directive and corresponding service.
 * @type {!ng.jfk.BubbleModuleType}
 */
ng.jfk.Bubble = /** @type {!ng.jfk.BubbleModuleType} */ (
    angular.module('jfkBubble', [ng.jfk.Common.name]));


/**
 * Static map of possible arrow alignments.
 * @type {!Object.<jfk.ArrowAlignment>}
 * @const
 * @private
 */
ng.jfk.Bubble.ALIGNMENT_MAP_ = {
  'LEFT_OR_TOP': jfk.ArrowAlignment.LEFT_OR_TOP,
  'RIGHT_OR_BOTTOM': jfk.ArrowAlignment.RIGHT_OR_BOTTOM,
  'CENTER': jfk.ArrowAlignment.CENTER
};


ng.jfk.Bubble.service('jfkBubbleService', function() {
  return new ng.jfk.Bubble.Service();
});

/**
 * The service for the jfk-bubble directive.
 * @constructor
 */
ng.jfk.Bubble.Service = function() {
  /**
   * The bubble component registered with the service.
   * @type {jfk.Bubble}
   * @private
   */
  this.bubble_ = null;
};

/**
 * Creates, renders and registers a new bubble.
 * @param {!Element} contentElement Element to set as the content of the bubble.
 * @param {function(!jfk.Bubble)} renderCallback A callback that invokes one
 *     of the render methods on the jfk.Bubble instance being created.
 * @return {!jfk.Bubble} The newly-created and registered bubble.
 * @private
 */
ng.jfk.Bubble.Service.prototype.registerNewBubble_ = function(
    contentElement, renderCallback) {
      if (this.bubble_) {
        throw new Error('Only one bubble component allowed to be registered.');
      }
      var bubble = new jfk.Bubble();
      bubble.showCloseButton(true);
      bubble.setContent(contentElement);
      renderCallback(bubble);
      this.bubble_ = bubble;
      return bubble;
    };

/**
 * Shows a message on the registered bubble or on a lazy-init default bubble.
 * @param {string} message The text of the message.
 * @param {!Element} element The HTML element to which to anchor the bubble.
 * @export
 */
ng.jfk.Bubble.Service.prototype.showBubbleMessage = function(message, element) {
  if (message) {
    if (!this.bubble_) {
      this.registerNewBubble_(
          goog.dom.createDom(goog.dom.TagName.DIV),
          function(bubble) { bubble.render(document.body); });
    }
    var bubbleElement =
        /** @type {!Element} */ (this.bubble_.getContentElement().firstChild);
    goog.dom.setTextContent(bubbleElement, message);
    this.bubble_.setAnchorElement(element);
    this.bubble_.setVisible(true);
  }
};

/**
 * Creates and shows a new promoBubble. Unlike the shared singleton bubble
 * multiple of these can be created simultaneously - they show on creation
 * and are auto-disposed on hide.
 * @param {!string|Element} content The text or HTML element content of the
 *     message.
 * @param {!Element} element The HTML element to which to anchor the bubble.
 * @param {boolean=} opt_showClose Whether the promo bubble should show a close
 *     button.
 * @param {jfk.PopupPosition=} opt_position Position to show the bubble in.
 * @param {boolean=} opt_autoReposition Sets whether bubble should be prevented
 *     from going outside the browser or frame viewport.
 * @param {string=} opt_cssClass Css class that will be additionally added to
 *     the bubble content element.
 * @return {!jfk.PromoBubble} The created promo bubble.
 * @export
 */
ng.jfk.Bubble.Service.prototype.showPromoBubble =
    function(content, element, opt_showClose, opt_position, opt_autoReposition,
        opt_cssClass) {
  // All promo bubbles are disposed on hide, and are hidden on first click.
  // Therefore this code does not have to manage .dispose() explicitly.
  var bubble = new jfk.PromoBubble(element);
  if (goog.dom.isElement(content)) {
    bubble.setContent(content);
  } else {
    // WARNING: Changing this could lead to XSS security issues.
    var innerElement = goog.dom.createDom(goog.dom.TagName.DIV);
    goog.dom.setTextContent(innerElement, /** @type {string} */ (content));
    bubble.setContent(innerElement);
  }
  bubble.showCloseButton(!!opt_showClose);
  bubble.setAutoReposition(!!opt_autoReposition);
  if (opt_position) {
    bubble.setPosition(opt_position);
  }
  if (opt_cssClass) {
    bubble.addClassName(opt_cssClass);
  }
  bubble.render(document.body);
  return bubble;
};

ng.jfk.Bubble.directive('jfkSharedBubble', [
  'jfkBubbleService', function(bubbleService) {
    return {
      'restrict': 'A',
      /**
       * The link function.
       * @param {!angular.Scope} $scope The scope used by the directive for
       *     registering watches.
       * @param {!angular.JQLite} $element The content element selector for the
       *     directive.
       */
      'link': function($scope, $element) {
        var content = $element[0];
        var sibling = content.nextSibling;
        bubbleService.registerNewBubble_(content, function(bubble) {
          sibling ? bubble.renderBefore(sibling) :
              bubble.render(content.parent);
        });
      }
    };
  }
]);

ng.jfk.Bubble.directive('jfkBubble', [
  'jfkCommon', function(jfkCommon) {
    return {
      'restrict': 'A',
      /**
       * The link function.
       * @param {!angular.Scope} $scope The scope used by the directive for
       *     registering watches.
       * @param {!angular.JQLite} $element The content element selector for the
       *     directive.
       * @param {!angular.Attributes} $attrs Attributes of the content
       *     element.
       */
      'link': function($scope, $element, $attrs) {
        var content = $element[0];
        var parent = $element.parent()[0];
        if (!parent) {
          throw new Error('The bubble element must have a parent.');
        }

        var bubble = new jfk.Bubble();
        bubble.setContent(content);
        bubble.setAnchorElement(parent);

        bubble.showCloseButton(
            $attrs.hasOwnProperty('jfkBubbleShowCloseButton') ?
            $attrs['jfkBubbleShowCloseButton'].toLowerCase() == 'true' : true);

        bubble.setAutoReposition(
            $attrs.hasOwnProperty('jfkBubbleAutoReposition') ?
            $attrs['jfkBubbleAutoReposition'].toLowerCase() == 'true' : true);

        if ($attrs.hasOwnProperty('jfkBubblePosition') ||
            $attrs.hasOwnProperty('jfkBubbleAlignment')) {
          bubble.setPosition(
              $attrs.hasOwnProperty('jfkBubblePosition') ?
                  ng.jfk.Position.POSITION_MAP[$attrs['jfkBubblePosition']] :
                  undefined,
              $attrs.hasOwnProperty('jfkBubbleAlignment') ?
                  ng.jfk.Bubble.ALIGNMENT_MAP_[$attrs['jfkBubbleAlignment']] :
                  undefined);
        }

        if ($attrs.hasOwnProperty('jfkBubbleCssClass')) {
          bubble.addClassName($attrs['jfkBubbleCssClass']);
        }

        if ($attrs.hasOwnProperty('jfkAutoHide')) {
          bubble.setAutoHide(
              $attrs['jfkAutoHide'].toLowerCase() == 'true');
        }

        function callDigest() {
          jfkCommon.evalInDigest($scope, function() {
            // no-op - we just need to ensure $digest is called
          });
        }

        bubble.listen(goog.ui.PopupBase.EventType.SHOW, callDigest);
        bubble.listen(goog.ui.PopupBase.EventType.HIDE, callDigest);

        // The bubble is rendered to the document body to avoid b/8377231.
        // The actual bubble display placement is impacted more by the anchor
        // element.
        bubble.render(document.body);
        jfkCommon.componentLink($scope, $attrs, bubble);

        jfkCommon.register($scope, $attrs['jfkBubble'],
            new ng.jfk.Bubble.BubbleHandle(bubble));
      }
    };
  }
]);

/**
 * Handle to manipulate a jfk bubble.
 * @param {!jfk.Bubble} bubble
 * @constructor
 * @export
 */
ng.jfk.Bubble.BubbleHandle = function(bubble) {
  this.bubble_ = bubble;
};

/**
 * Shows the bubble.
 * @export
 */
ng.jfk.Bubble.BubbleHandle.prototype.show = function() {
  this.bubble_.setVisible(true);
};

/**
 * Shows the bubble.
 * @export
 */
ng.jfk.Bubble.BubbleHandle.prototype.hide = function() {
  this.bubble_.setVisible(false);
};

/**
 * Toggles bubble state, shows if it's hidden, hides otherwise.
 * @param {boolean=} opt_toggle A boolean value to determine whether bubble
 *     should be shown or hidden.
 * @export
 */
ng.jfk.Bubble.BubbleHandle.prototype.toggle = function(opt_toggle) {
  this.bubble_.setVisible(
      opt_toggle !== undefined ? opt_toggle :
                                 !this.bubble_.isOrWasRecentlyVisible());
};

/**
 * Sets the bubble's anchor element.
 * @param {Element|Event} element or an event. If an event is used then the
 *     event's target is used as the anchor element. Both types are accepted due
 *     to Angular 1.2's sercurity policy of not allowing DOM element references
 *     in Angular expressions. See
 *     https://docs.angularjs.org/error/$parse/isecdom
 * @export
 */
ng.jfk.Bubble.BubbleHandle.prototype.setAnchorElement = function(element) {
  var anchor = /** @type {Element} */
      (element && element.target ? element.target : element);
  this.bubble_.setAnchorElement(anchor);
};

/**
 * @return {boolean} Whether the bubble is or was recently visible.
 * @export
 */
ng.jfk.Bubble.BubbleHandle.prototype.isOrWasRecentlyVisible = function() {
  return this.bubble_.isOrWasRecentlyVisible();
};

ng.jfk.Bubble.directive('jfkPromoBubble', [
  'jfkBubbleService', 'jfkCommon',
  function(jfkBubbleService, jfkCommon) {
    return {
      'restrict': 'A',
      /**
       * The link function.
       * @param {!angular.Scope} $scope The scope used by the directive for
       *     registering watches.
       * @param {!angular.JQLite} $element The content element selector for the
       *     directive.
       * @param {!angular.Attributes} $attrs Attributes of the content element.
       */
      'link': function($scope, $element, $attrs) {
        var parent = $element.parent()[0];
        if (!parent) {
          throw new Error('The promo bubble element must have a parent.');
        }
        parent.removeChild($element[0]);

        $scope.$on('$destroy', function() {
          // Since we remove $element[0] from its parent above and it is only
          // included temporarily in the bubble while it is shown, it will not
          // be subject to normal cleanup during scope destruction as specified
          // in jfkCommon#componentLink(). To ensure any data previously
          // associated with it in jQuery is properly released for garbage
          // collection, we register our own handler for cleanup here.
          angular.element($element[0]).remove();
        });

        var showClose = $attrs.hasOwnProperty('jfkPromoBubbleShowCloseButton') ?
            $attrs['jfkPromoBubbleShowCloseButton'].toLowerCase() == 'true' :
            true;

        var autoReposition =
            $attrs.hasOwnProperty('jfkPromoBubbleAutoReposition') ?
                $attrs['jfkPromoBubbleAutoReposition'].toLowerCase() == 'true' :
                true;

        var position;
        if ($attrs.hasOwnProperty('jfkPromoBubblePosition')) {
          position = ng.jfk.Position.POSITION_MAP[
              $attrs['jfkPromoBubblePosition']];
        }

        var cssClass;
        if ($attrs.hasOwnProperty('jfkPromoBubbleCssClass')) {
          cssClass = $attrs['jfkPromoBubbleCssClass'];
        }

        function bubbleConstructor() {
          var bubble = jfkBubbleService.showPromoBubble($element[0], parent,
              showClose, position, autoReposition, cssClass);
          jfkCommon.componentLink($scope, $attrs, bubble);
          return bubble;
        }

        jfkCommon.register($scope, $attrs['jfkPromoBubble'],
            new ng.jfk.Bubble.PromoBubbleHandle(bubbleConstructor));
      }
    };
  }
]);

/**
 * Handle to manipulate a jfk bubble.
 * @param {!function(): jfk.Bubble} bubbleConstructor
 * @constructor
 * @export
 */
ng.jfk.Bubble.PromoBubbleHandle = function(bubbleConstructor) {
  this.bubble_ = null;
  this.bubbleConstructor_ = bubbleConstructor;
};

/**
 * Shows the bubble.
 * @export
 */
ng.jfk.Bubble.PromoBubbleHandle.prototype.show = function() {
  if (this.bubble_) {
    this.bubble_.dispose();
  }
  this.bubble_ = this.bubbleConstructor_();
};

/**
 * Hides the bubble.
 * @export
 */
ng.jfk.Bubble.PromoBubbleHandle.prototype.hide = function() {
  this.bubble_.setVisible(false);
};

/**
 * @return {boolean} Whether the bubble is or was recently visible.
 * @export
 */
ng.jfk.Bubble.PromoBubbleHandle.prototype.isOrWasRecentlyVisible = function() {
  return !!this.bubble_ && !this.bubble_.isDisposed() &&
      this.bubble_.isOrWasRecentlyVisible();
};

//third_party/javascript/closure/ui/buttonside.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Enum for button side constants. In its own file so as to not
 * cause a circular dependency with {@link goog.ui.ButtonRenderer}.
 */

goog.provide('goog.ui.ButtonSide');


/**
 * Constants for button sides, see {@link goog.ui.Button.prototype.setCollapsed}
 * for details.
 * @enum {number}
 */
goog.ui.ButtonSide = {
  /** Neither side. */
  NONE: 0,
  /** Left for LTR, right for RTL. */
  START: 1,
  /** Right for LTR, left for RTL. */
  END: 2,
  /** Both sides. */
  BOTH: 3
};

//javascript/angular/jfkwrappers/buttonside.js
goog.loadModule(function(exports) {'use strict';goog.module('ng.jfk.ButtonSide');
goog.module.declareLegacyNamespace();

const UiButtonSide = goog.require('goog.ui.ButtonSide');

/**
 * Constants for button sides. This is necessary so the code can be compiled
 * with property renaming and users don't have to put numeric values into
 * their templates. They can, for example, use 'START' in the template files
 * instead.
 * @enum {number}
 */
const ButtonSide = {
  'NONE': UiButtonSide.NONE,
  'START': UiButtonSide.START,
  'END': UiButtonSide.END,
  'BOTH': UiButtonSide.BOTH
};

exports = ButtonSide;

;return exports;});

//javascript/jfk/button/button.soy.js
// This file was automatically generated by the Soy compiler.
// Please don't edit this file by hand.
// source: javascript/jfk/button/button.soy

/**
 * @fileoverview Templates in namespace jfk.templates.button.
 * @suppress {missingRequire} TODO(b/152440355)
 * @public
 */

goog.provide('jfk.templates.button');

goog.require('goog.soy');
goog.require('soy');


/**
 * @param {?jfk.templates.button.strict.Params=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.button.strict = function(opt_data, opt_ijData) {
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.button.strict']) {
    return soy.$$stubsMap['jfk.templates.button.strict'](opt_data, $ijData);
  }
  opt_data = opt_data || {};
  /** @type {?} */
  const attributes = opt_data.attributes;
  /** @type {?} */
  const classes = opt_data.classes;
  /** @type {?} */
  const content = opt_data.content;
  /** @type {?} */
  const disabled = opt_data.disabled;
  /** @type {?} */
  const checked = opt_data.checked;
  /** @type {?} */
  const id = opt_data.id;
  /** @type {?} */
  const style = opt_data.style;
  /** @type {?} */
  const tabindex = opt_data.tabindex;
  /** @type {?} */
  const title = opt_data.title;
  /** @type {?} */
  const usingKennedyTooltip = opt_data.usingKennedyTooltip;
  /** @type {?} */
  const value = opt_data.value;
  /** @type {?} */
  const width = opt_data.width;
  return soy.VERY_UNSAFE.ordainSanitizedHtml('<div role="button"' + (id ? ' id="' + soy.$$escapeHtmlAttribute(id) + '"' : '') + ' class="' + soy.$$escapeHtmlAttribute(jfk.templates.button.classes_(/** @type {?} */ (opt_data), $ijData)) + '"' + (disabled ? ' aria-disabled="true"' : ' tabindex="' + (tabindex ? soy.$$escapeHtmlAttribute(tabindex) : '0') + '"') + (title ? usingKennedyTooltip ? ' data-tooltip="' + soy.$$escapeHtmlAttribute(title) + '"' : ' title="' + soy.$$escapeHtmlAttribute(title) + '"' : '') + (value ? ' value="' + soy.$$escapeHtmlAttribute(value) + '"' : '') + (attributes ? soy.$$whitespaceHtmlAttributes(soy.$$filterHtmlAttributes(attributes)) : '') + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.button.strict javascript/jfk/button/button.soy:25"' : '') + '>' + soy.$$escapeHtml(content != null ? content : '') + '</div>');
};
/**
 * @typedef {{
 *  attributes: (?|undefined),
 *  classes: (?|undefined),
 *  content: (?|undefined),
 *  disabled: (?|undefined),
 *  checked: (?|undefined),
 *  id: (?|undefined),
 *  style: (?|undefined),
 *  tabindex: (?|undefined),
 *  title: (?|undefined),
 *  usingKennedyTooltip: (?|undefined),
 *  value: (?|undefined),
 *  width: (?|undefined),
 * }}
 */
jfk.templates.button.strict.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.button.strict.soyTemplateName = 'jfk.templates.button.strict';
}


/**
 * @param {?jfk.templates.button.classes_.Params=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {string}
 * @private
 */
jfk.templates.button.classes_ = function(opt_data, opt_ijData) {
  opt_data = opt_data || {};
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.button.classes_$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.classes, opt_data.disabled, opt_data.checked, opt_data.style, opt_data.width);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?=} classes
 * @param {?=} disabled
 * @param {?=} checked
 * @param {?=} style
 * @param {?=} width
 * @return {string}
 * @private
 * @suppress {checkTypes}
 */
jfk.templates.button.classes_$ = function($$areYouAnInternalCaller, $ijData, classes, disabled, checked, style, width) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.button.classes_']) {
    return soy.$$stubsMap['jfk.templates.button.classes_']({classes: classes, disabled: disabled, checked: checked, style: style, width: width}, $ijData);
  }
  let $output = '' + goog.getCssName('goog-inline-block') + ' ' + '' + goog.getCssName('jfk-button') + ' ';
  const $tmp = style;
  switch (goog.isObject($tmp) ? $tmp.toString() : $tmp) {
    case 0:
      $output += '' + goog.getCssName('jfk-button-standard');
      break;
    case 2:
      $output += '' + goog.getCssName('jfk-button-action');
      break;
    case 3:
      $output += '' + goog.getCssName('jfk-button-primary');
      break;
    case 1:
      $output += '' + goog.getCssName('jfk-button-default');
      break;
    case 4:
      $output += '' + goog.getCssName('jfk-button-flat');
      break;
    case 5:
      $output += '' + goog.getCssName('jfk-button-mini');
      break;
    case 6:
      $output += '' + goog.getCssName('jfk-button-contrast');
      break;
    default:
      $output += '' + goog.getCssName('jfk-button-standard');
  }
  $output += (soy.$$equals(width, 1) ? ' ' + '' + goog.getCssName('jfk-button-narrow') : '') + (checked ? ' ' + '' + goog.getCssName('jfk-button-checked') : '') + (classes ? ' ' + '' + classes : '') + (disabled ? ' ' + '' + goog.getCssName('jfk-button-disabled') : '');
  return $output;
};
/**
 * @typedef {{
 *  classes: (?|undefined),
 *  disabled: (?|undefined),
 *  checked: (?|undefined),
 *  style: (?|undefined),
 *  width: (?|undefined),
 * }}
 */
jfk.templates.button.classes_.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.button.classes_.soyTemplateName = 'jfk.templates.button.classes_';
}


/**
 * @param {?jfk.templates.button.search.Params=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 */
jfk.templates.button.search = function(opt_data, opt_ijData) {
  opt_data = opt_data || {};
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.button.search$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.classes, opt_data.tabindex);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?=} classes
 * @param {?=} tabindex
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.button.search$ = function($$areYouAnInternalCaller, $ijData, classes, tabindex) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.button.search']) {
    return soy.$$stubsMap['jfk.templates.button.search']({classes: classes, tabindex: tabindex}, $ijData);
  }
  return soy.VERY_UNSAFE.ordainSanitizedHtml(jfk.templates.button.strict(/** @type {?} */ ({style: 2, content: soy.VERY_UNSAFE.$$ordainSanitizedHtmlForInternalBlocks('' + jfk.templates.button.searchIcon_(null, $ijData)), classes: classes, tabindex: tabindex}), $ijData));
};
/**
 * @typedef {{
 *  classes: (?|undefined),
 *  tabindex: (?|undefined),
 * }}
 */
jfk.templates.button.search.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.button.search.soyTemplateName = 'jfk.templates.button.search';
}


/**
 * @param {?Object<string, *>=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 * @private
 * @suppress {checkTypes}
 */
jfk.templates.button.searchIcon_ = function(opt_data, opt_ijData) {
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.button.searchIcon_']) {
    return soy.$$stubsMap['jfk.templates.button.searchIcon_'](opt_data, $ijData);
  }
  return soy.VERY_UNSAFE.ordainSanitizedHtml('<img src="//ssl.gstatic.com/ui/v1/button/search-white.png" style="width: 21px; height: 21px;" class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-button-img')) + '"' + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.button.searchIcon_ javascript/jfk/button/button.soy:112"' : '') + '>');
};
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.button.searchIcon_.soyTemplateName = 'jfk.templates.button.searchIcon_';
}

//javascript/apps/jspb/binary/const_binary_message.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.ConstBinaryMessage');
goog.module.declareLegacyNamespace();

/**
 * Base interface class for all const messages.
 * @interface
 */
class ConstBinaryMessage {
  /**
   * Generate a debug string for this proto that is in proto2 text format.
   * @return {string} The debug string.
   */
  toDebugString() {}

  /**
   * Helper to generate a debug string for this proto at some indent level. The
   * first line is not indented.
   * @param {number} indentLevel The number of spaces by which to indent lines.
   * @return {string} The debug string.
   * @protected
   */
  toDebugStringInternal(indentLevel) {}

  /**
   * Returns this message as a JSON-compatible array form of go/jspb-wireformat.
   *
   * Generally, `serializeToJspb()` should be called instead, but this may be
   * useful when a JSON stringifiable value is required for compatibility with
   * other APIs.
   * @return {!Array<*>}
   */
  toJsonValue() {}
}

exports = ConstBinaryMessage;

;return exports;});

//javascript/apps/jspb/binary/binary_message.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.BinaryMessage');
goog.module.declareLegacyNamespace();

const ConstBinaryMessage = goog.require('jspb.ConstBinaryMessage');

/**
 * Base interface class for all messages. Does __not__ define any methods, as
 * doing so on a widely-used interface defeats dead-code elimination.
 * @interface
 * @extends {ConstBinaryMessage}
 */
class BinaryMessage {}

exports = BinaryMessage;

;return exports;});

//javascript/apps/jspb/binary/repeated_field_type.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.binary.repeated_field_type');

const BinaryMessage = goog.requireType('jspb.BinaryMessage');
const ConstBinaryMessage = goog.requireType('jspb.ConstBinaryMessage');
const {ScalarFieldType} = goog.requireType('jspb.binary.scalar_field_type');

/**
 * A repeated field in jspb is an array of scalars, blobs, or messages.
 * @typedef {!Array<!ScalarFieldType>|
             !Array<!Uint8Array>|
             !Array<!ConstBinaryMessage>|
             !Array<!BinaryMessage>}
 */
let RepeatedFieldType;

exports = {RepeatedFieldType};

;return exports;});

//javascript/apps/jspb/binary/any_field_type.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.binary.any_field_type');

const BinaryMessage = goog.require('jspb.BinaryMessage');
const ConstBinaryMessage = goog.require('jspb.ConstBinaryMessage');
const {RepeatedFieldType} = goog.require('jspb.binary.repeated_field_type');
const {ScalarFieldType} = goog.requireType('jspb.binary.scalar_field_type');


/**
 * A field in jspb can be a scalar, a block of bytes, another proto, or an
 * array of any of the above.
 * @typedef {?ScalarFieldType|
             ?RepeatedFieldType|
             !Uint8Array|
             !ConstBinaryMessage|
             !BinaryMessage}
 */
let AnyFieldType;

exports = {AnyFieldType};

;return exports;});

//javascript/apps/jspb/binary/binary_constants.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.BinaryConstants');

/**
 * Field type codes, taken from proto2/public/wire_format_lite.h.
 * @enum {number}
 * @package
 */
const FieldType = {
  INVALID: -1,
  DOUBLE: 1,
  FLOAT: 2,
  INT64: 3,
  UINT64: 4,
  INT32: 5,
  FIXED64: 6,
  FIXED32: 7,
  BOOL: 8,
  STRING: 9,
  GROUP: 10,
  MESSAGE: 11,
  BYTES: 12,
  UINT32: 13,
  ENUM: 14,
  SFIXED32: 15,
  SFIXED64: 16,
  SINT32: 17,
  SINT64: 18,
};


/**
 * Wire-format type codes, taken from proto2/public/wire_format_lite.h.
 * @enum {number}
 */
const WireType = {
  INVALID: -1,
  VARINT: 0,
  FIXED64: 1,
  DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5
};


/**
 * Translates field type to wire type.
 * @param {!FieldType} fieldType
 * @return {!WireType}
 */
function FieldTypeToWireType(fieldType) {
  switch (fieldType) {
    case FieldType.INT32:
    case FieldType.INT64:
    case FieldType.UINT32:
    case FieldType.UINT64:
    case FieldType.SINT32:
    case FieldType.SINT64:
    case FieldType.BOOL:
    case FieldType.ENUM:
      return WireType.VARINT;

    case FieldType.DOUBLE:
    case FieldType.FIXED64:
    case FieldType.SFIXED64:
      return WireType.FIXED64;

    case FieldType.STRING:
    case FieldType.MESSAGE:
    case FieldType.BYTES:
      return WireType.DELIMITED;

    case FieldType.FLOAT:
    case FieldType.FIXED32:
    case FieldType.SFIXED32:
      return WireType.FIXED32;

    case FieldType.INVALID:
    case FieldType.GROUP:
    default:
      return WireType.INVALID;
  }
}


/**
 * Flag to indicate a missing field.
 * @const {number}
 */
const INVALID_FIELD_NUMBER = -1;

/**
 * Flag to indicate a missing tag.
 * @const {number}
 */
const INVALID_TAG = -1;


/**
 * The smallest denormal float32 value.
 * @const {number}
 */
const FLOAT32_EPS = 1.401298464324817e-45;


/**
 * The smallest normal float64 value.
 * @const {number}
 */
const FLOAT32_MIN = 1.1754943508222875e-38;


/**
 * The largest finite float32 value.
 * @const {number}
 */
const FLOAT32_MAX = 3.4028234663852886e+38;


/**
 * The smallest denormal float64 value.
 * @const {number}
 */
const FLOAT64_EPS = 5e-324;


/**
 * The smallest normal float64 value.
 * @const {number}
 */
const FLOAT64_MIN = 2.2250738585072014e-308;


/**
 * The largest finite float64 value.
 * @const {number}
 */
const FLOAT64_MAX = 1.7976931348623157e+308;


/**
 * Convenience constant equal to 2^20.
 * @const {number}
 */
const TWO_TO_20 = 1048576;


/**
 * Convenience constant equal to 2^23.
 * @const {number}
 */
const TWO_TO_23 = 8388608;


/**
 * Convenience constant equal to 2^31.
 * @const {number}
 */
const TWO_TO_31 = 2147483648;


/**
 * Convenience constant equal to 2^32.
 * @const {number}
 */
const TWO_TO_32 = 4294967296;


/**
 * Convenience constant equal to 2^52.
 * @const {number}
 */
const TWO_TO_52 = 4503599627370496;


/**
 * Convenience constant equal to 2^63.
 * @const {number}
 */
const TWO_TO_63 = 9223372036854775808;


/**
 * Convenience constant equal to 2^64.
 * @const {number}
 */
const TWO_TO_64 = 18446744073709551616;


/**
 * Eight-character string of zeros, used as the default 64-bit hash value.
 * @const {string}
 */
const ZERO_HASH = '\0\0\0\0\0\0\0\0';

exports = {
  FieldType,
  FieldTypeToWireType,
  FLOAT32_EPS,
  FLOAT32_MIN,
  FLOAT32_MAX,
  FLOAT64_EPS,
  FLOAT64_MIN,
  FLOAT64_MAX,
  INVALID_FIELD_NUMBER,
  INVALID_TAG,
  TWO_TO_20,
  TWO_TO_23,
  TWO_TO_31,
  TWO_TO_32,
  TWO_TO_52,
  TWO_TO_63,
  TWO_TO_64,
  WireType,
  ZERO_HASH,
};

;return exports;});

//javascript/apps/jspb/binary/bytesource.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.binary.bytesource');

/**
 * The types convertible to Uint8Arrays. Strings are assumed to be
 * base64-encoded.
 * @typedef {?ArrayBuffer|?Uint8Array|?Array<number>|string}
 */
let ByteSource;

exports = {ByteSource};

;return exports;});

//javascript/apps/jspb/binary/bytesource_alias.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Legacy alias for the old namespace used by bytesource.js
 */
goog.module('jspb.ByteSource');
goog.module.declareLegacyNamespace();

const {ByteSource} = goog.require('jspb.binary.bytesource');

exports = ByteSource;

;return exports;});

//javascript/apps/jspb/binary/utf8.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview UTF8 encoding and decoding routines
 */
goog.module('jspb.binary.utf8');

const {assert,assertString} = goog.require('goog.asserts');

/**
 * Whether to enforce that string fields are valid utf8.
 *
 * <p>Currently set to `ALWAYS` in debug mode to flag issues early and `NEVER`
 * in prod. In the future it will be changed to `DEFAULT` in production.
 *
 * @define {string}
 */
const ENFORCE_UTF8 =
    goog.define('jspb.binary.ENFORCE_UTF8', goog.DEBUG ? 'ALWAYS' : 'NEVER');

assert(
    ENFORCE_UTF8 === 'NEVER' || ENFORCE_UTF8 === 'DEFAULT' ||
    ENFORCE_UTF8 === 'ALWAYS');


/**
 * Whether to reject unpaired surrogates when encoding strings to utf8.
 *
 * <p>Currently set to `true`, but can be disabled if needed.
 *
 * @define {boolean}
 */
const REJECT_UNPAIRED_SURROGATES =
    goog.define('jspb.binary.REJECT_UNPAIRED_SURROGATES', goog.DEBUG);

/**
 * Whether to use the browser based `TextEncoder` and `TextDecoder` APIs for
 * handling utf8.
 *
 * <p>Enabled by default for `goog.FEATURESET_YEAR >= 2020`.  The code also
 * performs feature detection for this API and will always use it if available,
 * this variable enables us to not ship the polyfill.
 *
 * <p>See http://go/jscompiler-flags#browser-featureset-year-options for the
 * behavior here.
 *
 * @define {boolean}
 */
const USE_TEXT_ENCODING =
    goog.define('jspb.binary.USE_TEXTENCODING', goog.FEATURESET_YEAR >= 2020);

const /** number */ MIN_SURROGATE = 0xD800;
const /** number */ MIN_HIGH_SURROGATE = MIN_SURROGATE;
const /** number */ MAX_HIGH_SURROGATE = 0xDBFF;
const /** number */ MIN_LOW_SURROGATE = 0xDC00;
const /** number */ MAX_LOW_SURROGATE = 0xDFFF;
const /** number */ MAX_SURROGATE = MAX_LOW_SURROGATE;

/**
 * Returns whether the byte is not a valid continuation of the form
 * '10XXXXXX'.
 * @return {boolean}
 */
function isNotTrailingByte(/** number */ byte) {
  // 0xC0 is '11000000' in binary
  // 0x80 is '10000000' in binary
  return (byte & 0xC0) !== 0x80;
}

/** @return {boolean} */
function utf8ErrorsAreFatal(/** boolean */ requireUtf8) {
  if (ENFORCE_UTF8 === 'ALWAYS') {
    return true;
  }
  if (ENFORCE_UTF8 === 'NEVER') {
    return false;
  }
  return requireUtf8;  //  mode is DEFAULT, so it is whatever requireUtf8 is
}

/**
 * Either throws an error or appends a replacement codepoint of invalid utf8
 */
function invalid(/** boolean */ requireUtf8, /** !Array<number> */ codeUnits) {
  if (utf8ErrorsAreFatal(requireUtf8)) {
    throw new Error('Invalid UTF8');
  }
  codeUnits.push(0xFFFD);  // utf8 replacement character
}

/** @return {string} */
function codeUnitsToString(
    /** string? */ accum, /** !Array<number> */ utf16CodeUnits) {
  const suffix = String.fromCharCode.apply(null, utf16CodeUnits);
  return accum == null ? suffix : accum + suffix;
}

/**
 * Our handwritten UTF8 decoder.
 *
 * https://en.wikipedia.org/wiki/UTF-8#Encoding describes the bit layout
 *
 * https://en.wikipedia.org/wiki/UTF-8#Invalid_sequences_and_error_handling
 * describes important cases to check for which are namely:
 * - overlong encodings, meaning a value expressable in N bytes could have been
 * expressed in fewer bytes
 * - invalid bytes, meaning bytes that are generally out of range
 * - surrogate codepoints, utf8 never encodes directly a utf16 surrogate value
 * - underflow where there aren't enough bytes for the sequence we are parsing
 * - out of range codepoints.
 *
 * @return {string}
 */
function polyfillDecodeUtf8(
    /** !Uint8Array */ bytes, /** number */ offset, /** number */ length,
    /** boolean */ requireUtf8) {
  let cursor = offset;
  const end = cursor + length;
  const codeUnits = [];
  let result = null;

  // This is significantly slower than the TextDecoder implementation.
  // Ideas for improving performance:
  // 1. Reduce branching with non-shortcircuting operators, e.g.
  // https://stackoverflow.com/q/5652363
  // 2. improve isNotTrailingByte using xor?
  // 3. consider having a dedicate ascii loop (java impls do this)
  let c1, c2, c3, c4;
  while (cursor < end) {
    c1 = bytes[cursor++];
    if (c1 < 0x80) {  // Regular 7-bit ASCII.
      codeUnits.push(c1);
    } else if (c1 < 0xE0) {  // UTF-8 with two bytes.
      if (cursor >= end) {
        invalid(requireUtf8, codeUnits);
      } else {
        c2 = bytes[cursor++];
        // Make sure that c1 is a valid leading byte and c2 is a valid
        // trailing byte
        // 0xC2 is '11000010', if c1 is less than this then we have an overlong
        // encoding because there would only be 7 significant bits.
        if (c1 < 0xC2 || isNotTrailingByte(c2)) {
          cursor--;  // push c2 back since it isn't 'accepted'
          invalid(requireUtf8, codeUnits);
        } else {
          // The codeUnit is the lower 6 bits from c2 and the lower 5 bits from
          // c1
          const codeUnit = ((c1 & 0x1F) << 6) | (c2 & 0x3F);
          // Consistency check that the computed code is in range for a 2 byte
          // sequence.
          assert(codeUnit >= 0x80 && codeUnit <= 0x07FF);
          codeUnits.push(codeUnit);
        }
      }
    } else if (c1 < 0xF0) {  // UTF-8 with three bytes.
      if (cursor >= end - 1) {
        invalid(requireUtf8, codeUnits);
      } else {
        c2 = bytes[cursor++];
        if (isNotTrailingByte(c2) ||
            // These checks were taken from
            // java/com/google/protobuf/Utf8.java
            // overlong? 5 most significant bits must not all be zero
            (c1 === 0xE0 && c2 < 0xA0)
            // check for illegal surrogate codepoints
            || (c1 === 0xED && c2 >= 0xA0) ||
            // We delay reading c3 until now so than an error in c2 or c1 will
            // preserve c3 for the next loop iteration
            isNotTrailingByte(c3 = bytes[cursor++])) {
          cursor--;  // push back c2 or c3, depending on how far we made it
          invalid(requireUtf8, codeUnits);
        } else {
          // 4 bits from the first byte
          // 6 bits from each of the two lower bytes
          // == 16 bits total
          const codeUnit =
              ((c1 & 0xF) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
          // Consistency check, this is the valid range for a 3 byte character
          assert(codeUnit >= 0x800 && codeUnit <= 0xFFFF);
          // And that Utf16 surrogates are disallowed
          assert(codeUnit < MIN_SURROGATE || codeUnit > MAX_SURROGATE);
          codeUnits.push(codeUnit);
        }
      }
    } else if (c1 <= 0xF4) {  // UTF-8 with 4 bytes.
      // 0xF8 matches the bitpattern for utf8 with 4 bytes, but all leading
      // bytes > 0xF4 are either overlong encodings or exceed the valid range.
      if (cursor >= end - 2) {
        invalid(requireUtf8, codeUnits);
      } else {
        c2 = bytes[cursor++];
        if (isNotTrailingByte(c2) ||
            // This check was inspired by
            // java/com/google/protobuf/Utf8.java
            // Tricky optimized form of:
            //   valid 4-byte leading byte?
            // if (byte1 > (byte) 0xF4 ||
            //   overlong? 4 most significant bits must not all be zero
            //     byte1 == (byte) 0xF0 && byte2 < (byte) 0x90 ||
            //   codepoint larger than the highest code point (U+10FFFF)?
            //     byte1 == (byte) 0xF4 && byte2 > (byte) 0x8F)
            (((c1 << 28) + (c2 - 0x90)) >> 30) !== 0 ||
            // We delay reading c3 and c4 until now so than an error in c2 or c1
            // will preserve them for the next loop iteration.
            isNotTrailingByte(c3 = bytes[cursor++]) ||
            isNotTrailingByte(c4 = bytes[cursor++])) {
          cursor--;  // push back c2, c3 or c4 depending on how far we made it
          invalid(requireUtf8, codeUnits);
        } else {
          // Characters written on 4 bytes have 21 bits for a codepoint.
          // We can't fit that on 16bit characters, so we use surrogates.
          // 3 bits from the uppermost byte, 6 bits from each of the lower 3
          // bytes. This is 21 bits which is too big for a 16 bit utf16 code
          // unit so we use surrogates.
          let codepoint = ((c1 & 0x7) << 18) | ((c2 & 0x3F) << 12) |
              ((c3 & 0x3F) << 6) | (c4 & 0x3F);
          // Consistency check, this is the valid range for a 4 byte character.
          assert(codepoint >= 0x10000 && codepoint <= 0x10FFFF);
          // Surrogates formula from wikipedia.
          // 1. Subtract 0x10000 from codepoint
          codepoint -= 0x10000;
          // 2. Split this into the high 10-bit value and the low 10-bit value
          // 3. Add 0xD800 to the high value to form the high surrogate
          // 4. Add 0xDC00 to the low value to form the low surrogate:
          const low = (codepoint & 0x3FF) + MIN_LOW_SURROGATE;
          const high = ((codepoint >> 10) & 0x3FF) + MIN_HIGH_SURROGATE;
          codeUnits.push(high, low);
        }
      }
    } else {
      // initial byte is too large for utf8
      invalid(requireUtf8, codeUnits);
    }
    // Accumulate as we go to avoid exceeding the maximum stack size when
    // calling `apply`.
    if (codeUnits.length >= 8192) {
      result = codeUnitsToString(result, codeUnits);
      codeUnits.length = 0;
    }
  }
  // ensure we don't overflow or underflow
  assert(cursor === end, `expected ${cursor} === ${end}`);
  return codeUnitsToString(result, codeUnits);
}

/** @type {!TextDecoder|undefined} */
let fatalDecoderInstance;

/** @return {!TextDecoder}*/
function getFatalDecoderInstance() {
  let instance = fatalDecoderInstance;
  if (!instance) {
    instance = fatalDecoderInstance = new TextDecoder('utf-8', {fatal: true});
  }
  return instance;
}

/** @type {!TextDecoder|undefined} */
let nonFatalDecoderInstance;
/** @return {!TextDecoder}*/
function getNonFatalDecoderInstance() {
  let instance = nonFatalDecoderInstance;
  if (!instance) {
    instance = nonFatalDecoderInstance =
        new TextDecoder('utf-8', {fatal: false});
  }
  return instance;
}

/**
 * @return {string}
 */
function textDecoderDecodeUtf8(
    /** !Uint8Array*/ bytes, /** number */ offset, /** number */ length,
    /** boolean*/ requireUtf8) {
  const /** !TextDecoder */ decoder = utf8ErrorsAreFatal(requireUtf8) ?
      getFatalDecoderInstance() :

      getNonFatalDecoderInstance();

  return decoder.decode(bytes.subarray(offset, offset + length));
}

/** @const {boolean} */
const useTextDecoderDecode =
    USE_TEXT_ENCODING || typeof TextDecoder !== 'undefined';

/**
 * A utf8 decoding routine either based upon TextDecoder if available or using
 * our polyfill implementation
 * @return {string}
 */
function decodeUtf8(
    /** !Uint8Array*/ bytes, /** number */ offset, /** number */ length,
    /** boolean*/ requireUtf8) {
  return useTextDecoderDecode ?
      textDecoderDecodeUtf8(bytes, offset, length, requireUtf8) :
      polyfillDecodeUtf8(bytes, offset, length, requireUtf8);
}

/** @type {!TextEncoder|undefined} */
let textEncoderInstance;

/** @return {!Uint8Array} */
function textEncoderEncode(
    /** string */ s, /** boolean= */ rejectUnpairedSurrogates = false) {
  if ((rejectUnpairedSurrogates || REJECT_UNPAIRED_SURROGATES) &&
      /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/
          .test(s)) {
    throw new Error('Found an unpaired surrogate');
  }
  return (textEncoderInstance || (textEncoderInstance = new TextEncoder()))
      .encode(s);
}


/** @return {!Uint8Array} */
function polyfillEncode(
    /** string */ s, /** boolean= */ rejectUnpairedSurrogates = false) {
  let bi = 0;
  // The worse case is that every character requires 3 output bytes, so we
  // allocate for this.  This assumes that the buffer will be short lived.
  // Callers can always `slice` if needed
  const buffer = new Uint8Array(3 * s.length);
  for (let ci = 0; ci < s.length; ci++) {
    let c = s.charCodeAt(ci);
    if (c < 0x80) {
      buffer[bi++] = c;
    } else if (c < 0x800) {
      buffer[bi++] = (c >> 6) | 0xC0;
      buffer[bi++] = (c & 63) | 0x80;
    } else {
      assert(c < 65536);
      // Look for surrogates
      // First check if it is surrogate range
      if (c >= MIN_SURROGATE && c <= MAX_SURROGATE) {
        // is it a high surrogate?
        if (c <= MAX_HIGH_SURROGATE && ci < s.length) {
          const c2 = s.charCodeAt(++ci);
          if (c2 >= MIN_LOW_SURROGATE && c2 <= MAX_LOW_SURROGATE) {
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            const codePoint =
                (c - MIN_SURROGATE) * 0x400 + c2 - MIN_LOW_SURROGATE + 0x10000;
            buffer[bi++] = (codePoint >> 18) | 0xF0;
            buffer[bi++] = ((codePoint >> 12) & 63) | 0x80;
            buffer[bi++] = ((codePoint >> 6) & 63) | 0x80;
            buffer[bi++] = (codePoint & 63) | 0x80;
            continue;
          } else {
            // else c2 not in low surrogate range, treat c as a lone surrogate
            // and back up ci so we process c2 on the next loop as an
            // independent character
            ci--;
          }
        }  // else c not a high surrogate
        if (rejectUnpairedSurrogates || REJECT_UNPAIRED_SURROGATES) {
          throw new Error('Found an unpaired surrogate');
        }
        c = 0xFFFD;  // Error! Unpaired surrogate
      }
      buffer[bi++] = (c >> 12) | 0xE0;
      buffer[bi++] = ((c >> 6) & 63) | 0x80;
      buffer[bi++] = (c & 63) | 0x80;
    }
  }
  return buffer.subarray(0, bi);
}

/** @const {boolean} */
const useTextEncoderEncode =
    (USE_TEXT_ENCODING || typeof TextEncoder !== 'undefined');

/**
 * A utf8 encoding routine either based upon TextEncoder if available or using
 * our polyfill implementation
 * @return {!Uint8Array}
 */
function encodeUtf8(
    /**string*/ string, /** boolean=*/ rejectUnpairedSurrogates) {
  assertString(string);
  return useTextEncoderEncode ?
      textEncoderEncode(string, rejectUnpairedSurrogates) :
      polyfillEncode(string, rejectUnpairedSurrogates);
}


exports = {
  decodeUtf8,
  encodeUtf8,
  // The following are exposed directly for testing/benchmarking purposes only.
  textDecoderDecodeUtf8,
  polyfillDecodeUtf8,
  textEncoderEncode,
  polyfillEncode,
};

;return exports;});

//third_party/javascript/closure/crypt/crypt.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Namespace with crypto related helper functions.
 */

goog.provide('goog.crypt');

goog.require('goog.asserts');


/**
 * Turns a string into an array of bytes; a "byte" being a JS number in the
 * range 0-255. Multi-byte characters are written as little-endian.
 * @param {string} str String value to arrify.
 * @return {!Array<number>} Array of numbers corresponding to the
 *     UCS character codes of each character in str.
 */
goog.crypt.stringToByteArray = function(str) {
  'use strict';
  var output = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    // NOTE: c <= 0xffff since JavaScript strings are UTF-16.
    if (c > 0xff) {
      output[p++] = c & 0xff;
      c >>= 8;
    }
    output[p++] = c;
  }
  return output;
};


/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {!Uint8Array|!Array<number>} bytes Array of numbers representing
 *     characters.
 * @return {string} Stringification of the array.
 */
goog.crypt.byteArrayToString = function(bytes) {
  'use strict';
  var CHUNK_SIZE = 8192;

  // Special-case the simple case for speed's sake.
  if (bytes.length <= CHUNK_SIZE) {
    return String.fromCharCode.apply(null, bytes);
  }

  // The remaining logic splits conversion by chunks since
  // Function#apply() has a maximum parameter count.
  // See discussion: http://goo.gl/LrWmZ9

  var str = '';
  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
    var chunk = Array.prototype.slice.call(bytes, i, i + CHUNK_SIZE);
    str += String.fromCharCode.apply(null, chunk);
  }
  return str;
};


/**
 * Turns an array of numbers into the hex string given by the concatenation of
 * the hex values to which the numbers correspond.
 * @param {Uint8Array|Array<number>} array Array of numbers representing
 *     characters.
 * @param {string=} opt_separator Optional separator between values
 * @return {string} Hex string.
 */
goog.crypt.byteArrayToHex = function(array, opt_separator) {
  'use strict';
  return Array.prototype.map
      .call(
          array,
          function(numByte) {
            'use strict';
            var hexByte = numByte.toString(16);
            return hexByte.length > 1 ? hexByte : '0' + hexByte;
          })
      .join(opt_separator || '');
};


/**
 * Converts a hex string into an integer array.
 * @param {string} hexString Hex string of 16-bit integers (two characters
 *     per integer).
 * @return {!Array<number>} Array of {0,255} integers for the given string.
 */
goog.crypt.hexToByteArray = function(hexString) {
  'use strict';
  goog.asserts.assert(
      hexString.length % 2 == 0, 'Key string length must be multiple of 2');
  var arr = [];
  for (var i = 0; i < hexString.length; i += 2) {
    arr.push(parseInt(hexString.substring(i, i + 2), 16));
  }
  return arr;
};


/**
 * Converts a JS string to a UTF-8 "byte" array.
 * @param {string} str 16-bit unicode string.
 * @return {!Array<number>} UTF-8 byte array.
 */
goog.crypt.stringToUtf8ByteArray = function(str) {
  'use strict';
  // TODO(pupius): Use native implementations if/when available
  var out = [], p = 0;
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = (c >> 6) | 192;
      out[p++] = (c & 63) | 128;
    } else if (
        ((c & 0xFC00) == 0xD800) && (i + 1) < str.length &&
        ((str.charCodeAt(i + 1) & 0xFC00) == 0xDC00)) {
      // Surrogate Pair
      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);
      out[p++] = (c >> 18) | 240;
      out[p++] = ((c >> 12) & 63) | 128;
      out[p++] = ((c >> 6) & 63) | 128;
      out[p++] = (c & 63) | 128;
    } else {
      out[p++] = (c >> 12) | 224;
      out[p++] = ((c >> 6) & 63) | 128;
      out[p++] = (c & 63) | 128;
    }
  }
  return out;
};


/**
 * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
 * @param {Uint8Array|Array<number>} bytes UTF-8 byte array.
 * @return {string} 16-bit Unicode string.
 */
goog.crypt.utf8ByteArrayToString = function(bytes) {
  'use strict';
  // TODO(pupius): Use native implementations if/when available
  var out = [], pos = 0, c = 0;
  while (pos < bytes.length) {
    var c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      var c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      // Surrogate Pair
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      var c4 = bytes[pos++];
      var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) -
          0x10000;
      out[c++] = String.fromCharCode(0xD800 + (u >> 10));
      out[c++] = String.fromCharCode(0xDC00 + (u & 1023));
    } else {
      var c2 = bytes[pos++];
      var c3 = bytes[pos++];
      out[c++] =
          String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join('');
};


/**
 * XOR two byte arrays.
 * @param {!Uint8Array|!Int8Array|!Array<number>} bytes1 Byte array 1.
 * @param {!Uint8Array|!Int8Array|!Array<number>} bytes2 Byte array 2.
 * @return {!Array<number>} Resulting XOR of the two byte arrays.
 */
goog.crypt.xorByteArray = function(bytes1, bytes2) {
  'use strict';
  goog.asserts.assert(
      bytes1.length == bytes2.length, 'XOR array lengths must match');

  var result = [];
  for (var i = 0; i < bytes1.length; i++) {
    result.push(bytes1[i] ^ bytes2[i]);
  }
  return result;
};

//javascript/apps/jspb/binary/utils.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview This file contains helper code used by BinaryReader
 * and BinaryWriter.
 *
 * @author aappleby@google.com (Austin Appleby)
 */

goog.module('jspb.utils');

const BinaryConstants = goog.require('jspb.BinaryConstants');
const crypt = goog.require('goog.crypt');
const gstring = goog.require('goog.string');
const {ByteSource} = goog.require('jspb.binary.bytesource');
const {assert, fail} = goog.require('goog.asserts');

/**
 * Flag for browser support of Uint8Array slicing.
 * @const {boolean}
 */
const SUPPORTS_UINT8ARRAY_SLICING =
    (typeof Uint8Array.prototype.slice === 'function');


/**
 * Returns a copy of a slice of a Uint8Array.
 *
 * @param {!Uint8Array} arr the input array to slice.
 * @param {number} startIdx The starting index of the slice.
 * @param {number} endIdx The ending index of the slice.
 * @return {!Uint8Array} the array slice.
 */
function sliceUint8Array(arr, startIdx, endIdx) {
  return SUPPORTS_UINT8ARRAY_SLICING ?
      arr.slice(startIdx, endIdx) :
      new Uint8Array(arr.subarray(startIdx, endIdx));
}

/**
 * Javascript can't natively handle 64-bit data types, so to manipulate them we
 * have to split them into two 32-bit halves and do the math manually.
 *
 * Instead of instantiating and passing small structures around to do this, we
 * instead just use two global temporary values. This one stores the low 32
 * bits of a split value - for example, if the original value was a 64-bit
 * integer, this temporary value will contain the low 32 bits of that integer.
 * If the original value was a double, this temporary value will contain the
 * low 32 bits of the binary representation of that double, etcetera.
 * @type {number}
 */
let split64Low = 0;


/**
 * And correspondingly, this temporary variable will contain the high 32 bits
 * of whatever value was split.
 * @type {number}
 */
let split64High = 0;


/**
 * Splits an unsigned Javascript integer into two 32-bit halves and stores it
 * in the temp values above.
 * @param {number} value The number to split.
 */
function splitUint64(value) {
  // Extract low 32 bits and high 32 bits as unsigned integers.
  const lowBits = value >>> 0;
  const highBits =
      Math.floor((value - lowBits) / BinaryConstants.TWO_TO_32) >>> 0;

  split64Low = lowBits;
  split64High = highBits;
}


/**
 * Splits a signed Javascript integer into two 32-bit halves and stores it in
 * the temp values above.
 * @param {number} value The number to split.
 */
function splitInt64(value) {
  // Convert to sign-magnitude representation.
  const sign = (value < 0);
  value = Math.abs(value);

  // Extract low 32 bits and high 32 bits as unsigned integers.
  let lowBits = value >>> 0;
  let highBits = Math.floor((value - lowBits) / BinaryConstants.TWO_TO_32);
  highBits = highBits >>> 0;

  // Perform two's complement conversion if the sign bit was set.
  if (sign) {
    highBits = ~highBits >>> 0;
    lowBits = ~lowBits >>> 0;
    lowBits += 1;
    if (lowBits > 0xFFFFFFFF) {
      lowBits = 0;
      highBits++;
      if (highBits > 0xFFFFFFFF) highBits = 0;
    }
  }

  split64Low = lowBits;
  split64High = highBits;
}


/**
 * Convers a signed Javascript integer into zigzag format, splits it into two
 * 32-bit halves, and stores it in the temp values above.
 * @param {number} value The number to split.
 */
function splitZigzag64(value) {
  // Convert to sign-magnitude and scale by 2 before we split the value.
  const sign = (value < 0);
  value = Math.abs(value) * 2;

  splitUint64(value);
  let lowBits = split64Low;
  let highBits = split64High;

  // If the value is negative, subtract 1 from the split representation so we
  // don't lose the sign bit due to precision issues.
  if (sign) {
    if (lowBits == 0) {
      if (highBits == 0) {
        lowBits = 0xFFFFFFFF;
        highBits = 0xFFFFFFFF;
      } else {
        highBits--;
        lowBits = 0xFFFFFFFF;
      }
    } else {
      lowBits--;
    }
  }

  split64Low = lowBits;
  split64High = highBits;
}


/**
 * Converts a floating-point number into 32-bit IEEE representation and stores
 * it in the temp values above.
 * @param {number} value
 */
function splitFloat32(value) {
  const sign = (value < 0) ? 1 : 0;
  value = sign ? -value : value;
  let mant;
  // Handle zeros.
  if (value === 0) {
    if ((1 / value) > 0) {
      // Positive zero.
      split64High = 0;
      split64Low = 0x00000000;
    } else {
      // Negative zero.
      split64High = 0;
      split64Low = 0x80000000;
    }
    return;
  }

  // Handle nans.
  if (isNaN(value)) {
    split64High = 0;
    split64Low = 0x7FFFFFFF;
    return;
  }

  // Handle infinities.
  if (value > BinaryConstants.FLOAT32_MAX) {
    split64High = 0;
    split64Low = ((sign << 31) | (0x7F800000)) >>> 0;
    return;
  }

  // Handle denormals.
  if (value < BinaryConstants.FLOAT32_MIN) {
    // Number is a denormal.
    mant = Math.round(value / Math.pow(2, -149));
    split64High = 0;
    split64Low = ((sign << 31) | mant) >>> 0;
    return;
  }

  const exp = Math.floor(Math.log(value) / Math.LN2);
  mant = value * Math.pow(2, -exp);
  mant = Math.round(mant * BinaryConstants.TWO_TO_23) & 0x7FFFFF;

  split64High = 0;
  split64Low = ((sign << 31) | ((exp + 127) << 23) | mant) >>> 0;
}


/**
 * Converts a floating-point number into 64-bit IEEE representation and stores
 * it in the temp values above.
 * @param {number} value
 */
function splitFloat64(value) {
  const sign = (value < 0) ? 1 : 0;
  value = sign ? -value : value;

  // Handle zeros.
  if (value === 0) {
    if ((1 / value) > 0) {
      // Positive zero.
      split64High = 0x00000000;
      split64Low = 0x00000000;
    } else {
      // Negative zero.
      split64High = 0x80000000;
      split64Low = 0x00000000;
    }
    return;
  }

  // Handle nans.
  if (isNaN(value)) {
    split64High = 0x7FFFFFFF;
    split64Low = 0xFFFFFFFF;
    return;
  }

  // Handle infinities.
  if (value > BinaryConstants.FLOAT64_MAX) {
    split64High = ((sign << 31) | (0x7FF00000)) >>> 0;
    split64Low = 0;
    return;
  }

  // Handle denormals.
  if (value < BinaryConstants.FLOAT64_MIN) {
    // Number is a denormal.
    const mant = value / Math.pow(2, -1074);
    const mantHigh = (mant / BinaryConstants.TWO_TO_32);
    split64High = ((sign << 31) | mantHigh) >>> 0;
    split64Low = (mant >>> 0);
    return;
  }

  // Compute the least significant exponent needed to represent the magnitude of
  // the value by repeadly dividing/multiplying by 2 until the magnitude
  // crosses 2. While tempting to use log math to find the exponent, at the
  // bounadaries of precision, the result can be off by one.
  const maxDoubleExponent = 1023;
  const minDoubleExponent = -1022;
  let x = value;
  let exp = 0;
  if (x >= 2) {
    while (x >= 2 && exp < maxDoubleExponent) {
      exp++;
      x = x / 2;
    }
  } else {
    while (x < 1 && exp > minDoubleExponent) {
      x = x * 2;
      exp--;
    }
  }
  const mant = value * Math.pow(2, -exp);

  const mantHigh = (mant * BinaryConstants.TWO_TO_20) & 0xFFFFF;
  const mantLow = (mant * BinaryConstants.TWO_TO_52) >>> 0;

  split64High = ((sign << 31) | ((exp + 1023) << 20) | mantHigh) >>> 0;
  split64Low = mantLow;
}


/**
 * Converts an 8-byte array into two 32-bit numbers and stores them in the temp
 * values above.
 * @param {!Array<number>} bytes
 */
function splitBytes64(bytes) {
  const [a, b, c, d, e, f, g, h] = bytes;

  split64Low = (a + (b << 8) + (c << 16) + (d << 24)) >>> 0;
  split64High = (e + (f << 8) + (g << 16) + (h << 24)) >>> 0;
}


/**
 * Joins two 32-bit values into a 64-bit unsigned integer. Precision will be
 * lost if the result is greater than 2^52.
 * @param {number} bitsLow
 * @param {number} bitsHigh
 * @return {number}
 */
function joinUint64(bitsLow, bitsHigh) {
  return bitsHigh * BinaryConstants.TWO_TO_32 + (bitsLow >>> 0);
}


/**
 * Joins two 32-bit values into a 64-bit signed integer. Precision will be lost
 * if the result is greater than 2^52.
 * @param {number} bitsLow
 * @param {number} bitsHigh
 * @return {number}
 */
function joinInt64(bitsLow, bitsHigh) {
  // If the high bit is set, do a manual two's complement conversion.
  const sign = (bitsHigh & 0x80000000);
  if (sign) {
    bitsLow = (~bitsLow + 1) >>> 0;
    bitsHigh = ~bitsHigh >>> 0;
    if (bitsLow == 0) {
      bitsHigh = (bitsHigh + 1) >>> 0;
    }
  }

  const result = joinUint64(bitsLow, bitsHigh);
  return sign ? -result : result;
}

/**
 * Converts split 64-bit values from standard two's complement encoding to
 * zig-zag encoding. Invokes the provided function to produce final result.
 *
 * @param {number} bitsLow
 * @param {number} bitsHigh
 * @param {function(number, number): T} convert Conversion function to produce
 *     the result value, takes parameters (lowBits, highBits).
 * @return {T}
 * @template T
 */
function toZigzag64(bitsLow, bitsHigh, convert) {
  // See
  // https://engdoc.corp.google.com/eng/howto/protocolbuffers/developerguide/encoding.shtml?cl=head#types
  // 64-bit math is: (n << 1) ^ (n >> 63)
  //
  // To do this in 32 bits, we can get a 32-bit sign-flipping mask from the
  // high word.
  // Then we can operate on each word individually, with the addition of the
  // "carry" to get the most significant bit from the low word into the high
  // word.
  const signFlipMask = bitsHigh >> 31;
  bitsHigh = (bitsHigh << 1 | bitsLow >>> 31) ^ signFlipMask;
  bitsLow = (bitsLow << 1) ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}


/**
 * Joins two 32-bit values into a 64-bit unsigned integer and applies zigzag
 * decoding. Precision will be lost if the result is greater than 2^52.
 * @param {number} bitsLow
 * @param {number} bitsHigh
 * @return {number}
 */
function joinZigzag64(bitsLow, bitsHigh) {
  return fromZigzag64(bitsLow, bitsHigh, joinInt64);
}


/**
 * Converts split 64-bit values from zigzag encoding to standard two's
 * complement encoding. Invokes the provided function to produce final result.
 *
 * @param {number} bitsLow
 * @param {number} bitsHigh
 * @param {function(number, number): T} convert Conversion function to produce
 *     the result value, takes parameters (lowBits, highBits).
 * @return {T}
 * @template T
 */
function fromZigzag64(bitsLow, bitsHigh, convert) {
  // 64 bit math is:
  //   signmask = (zigzag & 1) ? -1 : 0;
  //   twosComplement = (zigzag >> 1) ^ signmask;
  //
  // To work with 32 bit, we can operate on both but "carry" the lowest bit
  // from the high word by shifting it up 31 bits to be the most significant bit
  // of the low word.
  const signFlipMask = -(bitsLow & 1);
  bitsLow = ((bitsLow >>> 1) | (bitsHigh << 31)) ^ signFlipMask;
  bitsHigh = (bitsHigh >>> 1) ^ signFlipMask;
  return convert(bitsLow, bitsHigh);
}


/**
 * Joins two 32-bit values into a 32-bit IEEE floating point number and
 * converts it back into a Javascript number.
 * @param {number} bitsLow The low 32 bits of the binary number;
 * @param {number} bitsHigh The high 32 bits of the binary number.
 * @return {number}
 */
function joinFloat32(bitsLow, bitsHigh) {
  const sign = ((bitsLow >> 31) * 2 + 1);
  const exp = (bitsLow >>> 23) & 0xFF;
  const mant = bitsLow & 0x7FFFFF;

  if (exp == 0xFF) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }

  if (exp == 0) {
    // Denormal.
    return sign * Math.pow(2, -149) * mant;
  } else {
    return sign * Math.pow(2, exp - 150) * (mant + Math.pow(2, 23));
  }
}


/**
 * Joins two 32-bit values into a 64-bit IEEE floating point number and
 * converts it back into a Javascript number.
 * @param {number} bitsLow The low 32 bits of the binary number;
 * @param {number} bitsHigh The high 32 bits of the binary number.
 * @return {number}
 */
function joinFloat64(bitsLow, bitsHigh) {
  const sign = ((bitsHigh >> 31) * 2 + 1);
  const exp = (bitsHigh >>> 20) & 0x7FF;
  const mant = BinaryConstants.TWO_TO_32 * (bitsHigh & 0xFFFFF) + bitsLow;

  if (exp == 0x7FF) {
    if (mant) {
      return NaN;
    } else {
      return sign * Infinity;
    }
  }

  if (exp == 0) {
    // Denormal.
    return sign * Math.pow(2, -1074) * mant;
  } else {
    return sign * Math.pow(2, exp - 1075) * (mant + BinaryConstants.TWO_TO_52);
  }
}


/**
 * Individual digits for number->string conversion.
 * @const {!Array<string>}
 */
let DIGITS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
];

/** @const {number} '0' */
const ZERO_CHAR_CODE = 48;

/**
 * Losslessly converts a 64-bit unsigned integer in 32:32 split representation
 * into a decimal string.
 * @param {number} bitsLow The low 32 bits of the binary number;
 * @param {number} bitsHigh The high 32 bits of the binary number.
 * @return {string} The binary number represented as a string.
 */
function joinUnsignedDecimalString(bitsLow, bitsHigh) {
  // Skip the expensive conversion if the number is small enough to use the
  // built-in conversions.
  if (bitsHigh <= 0x1FFFFF) {
    return '' + (BinaryConstants.TWO_TO_32 * bitsHigh + bitsLow);
  }

  // What this code is doing is essentially converting the input number from
  // base-2 to base-1e7, which allows us to represent the 64-bit range with
  // only 3 (very large) digits. Those digits are then trivial to convert to
  // a base-10 string.

  // The magic numbers used here are -
  // 2^24 = 16777216 = (1,6777216) in base-1e7.
  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.

  // Split 32:32 representation into 16:24:24 representation so our
  // intermediate digits don't overflow.
  const low = bitsLow & 0xFFFFFF;
  const mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
  const high = (bitsHigh >> 16) & 0xFFFF;

  // Assemble our three base-1e7 digits, ignoring carries. The maximum
  // value in a digit at this step is representable as a 48-bit integer, which
  // can be stored in a 64-bit floating point number.
  let digitA = low + (mid * 6777216) + (high * 6710656);
  let digitB = mid + (high * 8147497);
  let digitC = (high * 2);

  // Apply carries from A to B and from B to C.
  const base = 10000000;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }

  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }

  // Convert base-1e7 digits to base-10, with optional leading zeroes.
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    const partial = digit1e7 ? String(digit1e7) : '';
    if (needLeadingZeros) {
      return '0000000'.slice(partial.length) + partial;
    }
    return partial;
  }

  return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
      decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
      // If the final 1e7 digit didn't need leading zeros, we would have
      // returned via the trivial code path at the top.
      decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}


/**
 * Losslessly converts a 64-bit signed integer in 32:32 split representation
 * into a decimal string.
 * @param {number} bitsLow The low 32 bits of the binary number;
 * @param {number} bitsHigh The high 32 bits of the binary number.
 * @return {string} The binary number represented as a string.
 */
function joinSignedDecimalString(bitsLow, bitsHigh) {
  // If we're treating the input as a signed value and the high bit is set, do
  // a manual two's complement conversion before the decimal conversion.
  const negative = (bitsHigh & 0x80000000);
  if (negative) {
    bitsLow = (~bitsLow + 1) >>> 0;
    const carry = (bitsLow == 0) ? 1 : 0;
    bitsHigh = (~bitsHigh + carry) >>> 0;
  }

  const result = joinUnsignedDecimalString(bitsLow, bitsHigh);
  return negative ? '-' + result : result;
}

/**
 * Converts a signed or unsigned decimal string into 8 bytes.
 * @param {string} dec
 * @return {!Array<number>}
 */
function decimalStringToBytes64(dec) {
  assert(dec.length > 0);

  // Check for minus sign.
  let minus = false;
  if (dec[0] === '-') {
    minus = true;
    dec = dec.slice(1);
  }

  // Store result as a byte array.
  const resultBytes = [0, 0, 0, 0, 0, 0, 0, 0];

  // Set result to m*result + c.
  function muladd(m, c) {
    for (let i = 0; i < 8 && (m !== 1 || c > 0); i++) {
      const r = m * resultBytes[i] + c;
      resultBytes[i] = r & 0xFF;
      c = r >>> 8;
    }
  }

  // Negate the result bits.
  function neg() {
    for (let i = 0; i < 8; i++) {
      resultBytes[i] = (~resultBytes[i]) & 0xFF;
    }
  }

  // For each decimal digit, set result to 10*result + digit.
  for (let i = 0; i < dec.length; i++) {
    muladd(10, dec.charCodeAt(i) - ZERO_CHAR_CODE);
  }

  // If there's a minus sign, convert into two's complement.
  if (minus) {
    neg();
    muladd(1, 1);
  }

  return resultBytes;
}

/**
 * Converts a signed or unsigned decimal string into two 32-bit halves, and
 * stores them in the temp variables listed above.
 * @param {string} value The decimal string to convert.
 */
function splitDecimalString(value) {
  splitBytes64(decimalStringToBytes64(value));
}


/**
 * Counts the number of contiguous varints in a buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @return {number} The number of varints in the buffer.
 */
function countVarints(buffer, start, end) {
  // Count how many high bits of each byte were set in the buffer.
  let count = 0;
  for (let i = start; i < end; i++) {
    count += buffer[i] >> 7;
  }

  // The number of varints in the buffer equals the size of the buffer minus
  // the number of non-terminal bytes in the buffer (those with the high bit
  // set).
  return (end - start) - count;
}


/**
 * Counts the number of contiguous varint fields with the given field number in
 * the buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @param {number} field The field number to count.
 * @return {number} The number of matching fields in the buffer.
 */
function countVarintFields(buffer, start, end, field) {
  let count = 0;
  let cursor = start;
  const tag = field * 8 + BinaryConstants.WireType.VARINT;

  if (tag < 128) {
    // Single-byte field tag, we can use a slightly quicker count.
    while (cursor < end) {
      // Skip the field tag, or exit if we find a non-matching tag.
      if (buffer[cursor++] != tag) return count;

      // Field tag matches, we've found a valid field.
      count++;

      // Skip the varint.
      while (1) {
        const x = buffer[cursor++];
        if ((x & 0x80) == 0) break;
      }
    }
  } else {
    while (cursor < end) {
      // Skip the field tag, or exit if we find a non-matching tag.
      let temp = tag;
      while (temp > 128) {
        if (buffer[cursor] != ((temp & 0x7F) | 0x80)) return count;
        cursor++;
        temp >>= 7;
      }
      if (buffer[cursor++] != temp) return count;

      // Field tag matches, we've found a valid field.
      count++;

      // Skip the varint.
      while (1) {
        const x = buffer[cursor++];
        if ((x & 0x80) == 0) break;
      }
    }
  }
  return count;
}


/**
 * Counts the number of contiguous fixed32 fields with the given tag in the
 * buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @param {number} tag The tag value to count.
 * @param {number} stride The number of bytes to skip per field.
 * @return {number} The number of fields with a matching tag in the buffer.
 * @private
 */
function countFixedFields_(buffer, start, end, tag, stride) {
  let count = 0;
  let cursor = start;

  if (tag < 128) {
    // Single-byte field tag, we can use a slightly quicker count.
    while (cursor < end) {
      // Skip the field tag, or exit if we find a non-matching tag.
      if (buffer[cursor++] != tag) return count;

      // Field tag matches, we've found a valid field.
      count++;

      // Skip the value.
      cursor += stride;
    }
  } else {
    while (cursor < end) {
      // Skip the field tag, or exit if we find a non-matching tag.
      let temp = tag;
      while (temp > 128) {
        if (buffer[cursor++] != ((temp & 0x7F) | 0x80)) return count;
        temp >>= 7;
      }
      if (buffer[cursor++] != temp) return count;

      // Field tag matches, we've found a valid field.
      count++;

      // Skip the value.
      cursor += stride;
    }
  }
  return count;
}


/**
 * Counts the number of contiguous fixed32 fields with the given field number
 * in the buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @param {number} field The field number to count.
 * @return {number} The number of matching fields in the buffer.
 */
function countFixed32Fields(buffer, start, end, field) {
  const tag = field * 8 + BinaryConstants.WireType.FIXED32;
  return countFixedFields_(buffer, start, end, tag, 4);
}


/**
 * Counts the number of contiguous fixed64 fields with the given field number
 * in the buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @param {number} field The field number to count
 * @return {number} The number of matching fields in the buffer.
 */
function countFixed64Fields(buffer, start, end, field) {
  const tag = field * 8 + BinaryConstants.WireType.FIXED64;
  return countFixedFields_(buffer, start, end, tag, 8);
}


/**
 * Counts the number of contiguous delimited fields with the given field number
 * in the buffer.
 * @param {!Uint8Array} buffer The buffer to scan.
 * @param {number} start The starting point in the buffer to scan.
 * @param {number} end The end point in the buffer to scan.
 * @param {number} field The field number to count.
 * @return {number} The number of matching fields in the buffer.
 */
function countDelimitedFields(buffer, start, end, field) {
  let count = 0;
  let cursor = start;
  const tag = field * 8 + BinaryConstants.WireType.DELIMITED;

  while (cursor < end) {
    // Skip the field tag, or exit if we find a non-matching tag.
    let temp = tag;
    while (temp > 128) {
      if (buffer[cursor++] != ((temp & 0x7F) | 0x80)) return count;
      temp >>= 7;
    }
    if (buffer[cursor++] != temp) return count;

    // Field tag matches, we've found a valid field.
    count++;

    // Decode the length prefix.
    let length = 0;
    let shift = 1;
    while (1) {
      temp = buffer[cursor++];
      length += (temp & 0x7f) * shift;
      shift *= 128;
      if ((temp & 0x80) == 0) break;
    }

    // Advance the cursor past the blob.
    cursor += length;
  }
  return count;
}


/**
 * String-ify bytes for text format. Should be optimized away in non-debug.
 * The returned string uses \xXX escapes for all values and is itself quoted.
 * [1, 31] serializes to '"\x01\x1f"'.
 * @param {?ByteSource} byteSource The bytes to serialize.
 * @return {string} Stringified bytes for text format.
 */
function debugBytesToTextFormat(byteSource) {
  let s = '"';
  if (byteSource) {
    const bytes = byteSourceToUint8Array(byteSource);
    for (let i = 0; i < bytes.length; i++) {
      s += '\\x';
      if (bytes[i] < 16) s += '0';
      s += bytes[i].toString(16);
    }
  }
  return s + '"';
}


/**
 * String-ify a scalar for text format. Should be optimized away in non-debug.
 * @param {string|number|boolean} scalar The scalar to stringify.
 * @return {string} Stringified scalar for text format.
 */
function debugScalarToTextFormat(scalar) {
  if (typeof scalar === 'string') {
    return gstring.quote(scalar);
  } else {
    return scalar.toString();
  }
}


/**
 * Utility function: convert a string with codepoints 0--255 inclusive to a
 * Uint8Array. If any codepoints greater than 255 exist in the string, throws an
 * exception.
 * @param {string} str
 * @return {!Uint8Array}
 */
function stringToByteArray(str) {
  const arr = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    const codepoint = str.charCodeAt(i);
    if (codepoint > 255) {
      throw new Error(
          'Conversion error: string contains codepoint ' +
          'outside of byte range');
    }
    arr[i] = codepoint;
  }
  return arr;
}


/**
 * Converts any type defined in ByteSource into a Uint8Array.
 * @param {!ByteSource} data
 * @return {!Uint8Array}
 * @suppress {invalidCasts}
 */
function byteSourceToUint8Array(data) {
  // Comparing a property is much faster than the instanceof test below, so
  // prefer this.
  if (data.constructor === Uint8Array) {
    return /** @type {!Uint8Array} */ (data);
  }

  if (data.constructor === ArrayBuffer) {
    data = /** @type {!ArrayBuffer} */ (data);
    return /** @type {!Uint8Array} */ (new Uint8Array(data));
  }

  if (data.constructor === Array) {
    data = /** @type {!Array<number>} */ (data);
    return /** @type {!Uint8Array} */ (new Uint8Array(data));
  }

  if (data.constructor === String) {
    data = /** @type {string} */ (data);
    return crypt.base64.decodeStringToUint8Array(data);
  }

  if (data instanceof Uint8Array) {
    // Support types like nodejs Buffer (a subclass of Uint8Array).
    data = /** @type {!Uint8Array} */ (data);
    // Make a shallow copy to ensure jspb code only ever deals with Uint8Array
    // exactly to ensure monomorphism.
    return /** @type {!Uint8Array} */ (
        new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
  }

  fail('Type not convertible to Uint8Array.');
  return /** @type {!Uint8Array} */ (new Uint8Array(0));
}

/** @return {number} */
function getSplit64Low() {
  return split64Low;
}
/** @return {number} */
function getSplit64High() {
  return split64High;
}

exports = {
  DIGITS,
  byteSourceToUint8Array,
  countDelimitedFields,
  countFixed32Fields,
  countFixed64Fields,
  countVarintFields,
  countVarints,
  debugBytesToTextFormat,
  debugScalarToTextFormat,
  fromZigzag64,
  getSplit64High,
  getSplit64Low,
  joinFloat32,
  joinFloat64,
  joinInt64,
  joinSignedDecimalString,
  joinUint64,
  joinUnsignedDecimalString,
  joinZigzag64,
  sliceUint8Array,
  splitDecimalString,
  splitFloat32,
  splitFloat64,
  splitInt64,
  splitUint64,
  splitZigzag64,
  stringToByteArray,
  toZigzag64,
};

;return exports;});

//javascript/apps/jspb/binary/decoder.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview This file contains utilities for decoding primitive values
 * (signed and unsigned integers, varints, booleans, enums, hashes, strings,
 * and raw bytes) embedded in Uint8Arrays into their corresponding Javascript
 * types.
 *
 * Major caveat - Javascript is unable to accurately represent integers larger
 * than 2^53 due to its use of a double-precision floating point format or all
 * numbers. If you need to guarantee that 64-bit values survive with all bits
 * intact, you _must_ read them using one of the split methods, which return
 * who numbers.
 *
 * @author aappleby@google.com (Austin Appleby)
 */

goog.module('jspb.binary.decoder');

const ByteSource = goog.require('jspb.ByteSource');
const asserts = goog.require('goog.asserts');
const utils = goog.require('jspb.utils');
const {decodeUtf8} = goog.require('jspb.binary.utf8');


class BinaryDecoder {
  /**
   * BinaryDecoder implements the decoders for all the wire types specified in
   * https://developers.google.com/protocol-buffers/docs/encoding.
   *
   * @param {?ByteSource=} bytes The bytes we're reading from.
   * @param {number=} start The optional offset to start reading at.
   * @param {number=} length The optional length of the block to read -
   *     we'll throw an assertion if we go off the end of the block.
   */
  constructor(bytes, start, length) {
    /**
     * Typed byte-wise view of the source buffer.
     * @private {?Uint8Array}
     */
    this.bytes_ = null;

    /**
     * DataView of the source buffer.
     * @private {?DataView}
     */
    this.dataView_ = null;

    /**
     * Start point of the block to read.
     * @private {number}
     */
    this.start_ = 0;

    /**
     * End point of the block to read.
     * @private {number}
     */
    this.end_ = 0;

    /**
     * Current read location in bytes_.
     * @private {number}
     */
    this.cursor_ = 0;

    /**
     * Set to true if this decoder encountered an error due to corrupt data.
     * @private {boolean}
     */
    this.error_ = false;

    if (bytes) {
      this.setBlock(bytes, start, length);
    }
  }

  /**
   * Pops an instance off the instance cache, or creates one if the cache is
   * empty.
   * @param {?ByteSource=} bytes The bytes we're reading from.
   * @param {number=} start The optional offset to start reading at.
   * @param {number=} length The optional length of the block to read -
   *     we'll throw an assertion if we go off the end of the block.
   * @return {!BinaryDecoder}
   */
  static alloc(bytes, start, length) {
    if (BinaryDecoder.instanceCache_.length) {
      const newDecoder = BinaryDecoder.instanceCache_.pop();
      if (bytes) {
        newDecoder.setBlock(bytes, start, length);
      }
      return newDecoder;
    } else {
      return new BinaryDecoder(bytes, start, length);
    }
  }

  /**
   * Puts this instance back in the instance cache.
   */
  free() {
    this.clear();
    if (BinaryDecoder.instanceCache_.length < 100) {
      BinaryDecoder.instanceCache_.push(this);
    }
  }

  /**
   * Makes a copy of this decoder.
   * @return {!BinaryDecoder}
   */
  clone() {
    return BinaryDecoder.alloc(
        this.bytes_, this.start_, this.end_ - this.start_);
  }

  /**
   * Clears the decoder.
   */
  clear() {
    this.bytes_ = null;
    this.dataView_ = null;
    this.start_ = 0;
    this.end_ = 0;
    this.cursor_ = 0;
    this.error_ = false;
  }

  /**
   * Returns the raw buffer.
   * @return {?Uint8Array} The raw buffer.
   */
  getBuffer() {
    return this.bytes_;
  }

  /**
   * Changes the block of bytes we're decoding.
   * @param {!ByteSource} data The bytes we're reading from.
   * @param {number=} start The optional offset to start reading at.
   * @param {number=} length The optional length of the block to read -
   *     we'll throw an assertion if we go off the end of the block.
   */
  setBlock(data, start, length) {
    this.bytes_ = utils.byteSourceToUint8Array(data);
    if (ASSUME_DATAVIEW_IS_FAST) {
      this.dataView_ = new DataView(
          this.bytes_.buffer, this.bytes_.byteOffset, this.bytes_.byteLength);
    }
    this.start_ = (start !== undefined) ? start : 0;
    this.end_ =
        (length !== undefined) ? this.start_ + length : this.bytes_.length;
    this.cursor_ = this.start_;
  }

  /**
   * @return {number}
   */
  getEnd() {
    return this.end_;
  }


  /**
   * @param {number} end
   */
  setEnd(end) {
    this.end_ = end;
  }

  /**
   * Moves the read cursor back to the start of the block.
   */
  reset() {
    this.cursor_ = this.start_;
  }


  /**
   * Returns the internal read cursor.
   * @return {number} The internal read cursor.
   */
  getCursor() {
    return this.cursor_;
  }

  /**
   * Returns the internal read cursor.
   * @param {number} cursor The new cursor.
   */
  setCursor(cursor) {
    this.cursor_ = cursor;
  }


  /**
   * Advances the stream cursor by the given number of bytes.
   * @param {number} count The number of bytes to advance by.
   */
  advance(count) {
    this.cursor_ += count;
    this.checkCursor();
  }

  /**
   * Returns true if this decoder is at the end of the block.
   * @return {boolean}
   */
  atEnd() {
    return this.cursor_ == this.end_;
  }


  /**
   * Returns true if this decoder is at the end of the block.
   * @return {boolean}
   */
  pastEnd() {
    return this.cursor_ > this.end_;
  }

  /**
   * Returns true if this decoder encountered an error due to corrupt data.
   * @return {boolean}
   */
  getError() {
    return this.error_ || (this.cursor_ < 0) || (this.cursor_ > this.end_);
  }

  /**
   * Reads an unsigned varint from the binary stream and invokes the conversion
   * function with the value in two signed 32 bit integers to produce the
   * result. Since this does not convert the value to a number, no precision is
   * lost.
   *
   * It's possible for an unsigned varint to be incorrectly encoded - more than
   * 64 bits' worth of data could be present. If this happens, this method will
   * throw an error.
   *
   * Decoding varints requires doing some funny base-128 math - for more
   * details on the format, see
   * https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitVarint64(convert) {
    let temp = 128;
    let lowBits = 0;
    let highBits = 0;

    // Read the first four bytes of the varint, stopping at the terminator if we
    // see it.
    for (let i = 0; i < 4 && temp >= 128; i++) {
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 0x7F) << (i * 7);
    }

    if (temp >= 128) {
      // Read the fifth byte, which straddles the low and high dwords.
      temp = this.bytes_[this.cursor_++];
      lowBits |= (temp & 0x7F) << 28;
      highBits |= (temp & 0x7F) >> 4;
    }

    if (temp >= 128) {
      // Read the sixth through tenth byte.
      for (let i = 0; i < 5 && temp >= 128; i++) {
        temp = this.bytes_[this.cursor_++];
        highBits |= (temp & 0x7F) << (i * 7 + 3);
      }
    }

    if (temp < 128) {
      return convert(lowBits >>> 0, highBits >>> 0);
    }

    // If we did not see the terminator, the encoding was invalid.
    asserts.fail('Failed to read varint, encoding is invalid.');
    this.error_ = true;
  }

  /**
   * Reads a signed zigzag encoded varint from the binary stream and invokes
   * the conversion function with the value in two signed 32 bit integers to
   * produce the result. Since this does not convert the value to a number, no
   * precision is lost.
   *
   * It's possible for an unsigned varint to be incorrectly encoded - more than
   * 64 bits' worth of data could be present. If this happens, this method will
   * throw an error.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitZigzagVarint64(convert) {
    return this.readSplitVarint64(
        (low, high) => utils.fromZigzag64(low, high, convert));
  }

  /**
   * Reads a 64-bit fixed-width value from the stream and invokes the conversion
   * function with the value in two signed 32 bit integers to produce the
   * result. Since this does not convert the value to a number, no precision is
   * lost.
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitFixed64(convert) {
    const bytes = this.bytes_;
    const cursor = this.cursor_;
    this.cursor_ += 8;
    let lowBits = 0;
    let highBits = 0;
    for (let i = cursor + 7; i >= cursor; i--) {
      lowBits = (lowBits << 8) | bytes[i];
      highBits = (highBits << 8) | bytes[i + 4];
    }
    return convert(lowBits, highBits);
  }

  /**
   * Skips over a varint in the block without decoding it.
   */
  skipVarint() {
    while (this.bytes_[this.cursor_] & 0x80) {
      this.cursor_++;
    }
    this.cursor_++;
  }

  /**
   * Asserts that our cursor is in bounds.
   *
   * @private
   * @return {void}
   */
  checkCursor() {
    if (this.cursor_ > this.end_) {
      asserts.fail('Read past the end ' + this.cursor_ + ' > ' + this.end_);
    }
  }


  /**
   * Skips backwards over a varint in the block - to do this correctly, we have
   * to know the value we're skipping backwards over or things are ambiguous.
   * @param {number} value The varint value to unskip.
   */
  unskipVarint(value) {
    while (value > 128) {
      this.cursor_--;
      value = value >>> 7;
    }
    this.cursor_--;
  }

  /**
   * Reads a 32-bit varint from the binary stream. Due to a quirk of the
   * encoding format and Javascript's handling of bitwise math, this actually
   * works correctly for both signed and unsigned 32-bit varints.
   *
   * This function is called vastly more frequently than any other in
   * BinaryDecoder, so it has been unrolled and tweaked for performance.
   *
   * If there are more than 32 bits of data in the varint, it _must_ be due to
   * sign-extension. If we're in debug mode and the high 32 bits don't match the
   * expected sign extension, this method will throw an error.
   *
   * Decoding varints requires doing some funny base-128 math - for more
   * details on the format, see
   * https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @return {number} The decoded unsigned 32-bit varint.
   */
  readUnsignedVarint32() {
    const bytes = this.bytes_;


    let temp = bytes[this.cursor_ + 0];
    let x = (temp & 0x7F);
    if (temp < 128) {
      this.cursor_ += 1;

      this.checkCursor();
      return x;
    }

    temp = bytes[this.cursor_ + 1];
    x |= (temp & 0x7F) << 7;
    if (temp < 128) {
      this.cursor_ += 2;

      this.checkCursor();
      return x;
    }

    temp = bytes[this.cursor_ + 2];
    x |= (temp & 0x7F) << 14;
    if (temp < 128) {
      this.cursor_ += 3;

      this.checkCursor();
      return x;
    }

    temp = bytes[this.cursor_ + 3];
    x |= (temp & 0x7F) << 21;
    if (temp < 128) {
      this.cursor_ += 4;

      this.checkCursor();
      return x;
    }

    temp = bytes[this.cursor_ + 4];
    x |= (temp & 0x0F) << 28;
    if (temp < 128) {
      // We're reading the high bits of an unsigned varint. The byte we just
      // read also contains bits 33 through 35, which we're going to discard.
      this.cursor_ += 5;

      this.checkCursor();
      return x >>> 0;
    }

    // If we get here, we need to truncate coming bytes. However we need to make
    // sure cursor place is correct.
    this.cursor_ += 5;
    if (bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 &&
        bytes[this.cursor_++] >= 128 && bytes[this.cursor_++] >= 128 &&
        bytes[this.cursor_++] >= 128) {
      // If we get here, the varint is too long.
      asserts.assert(false);
    }


    this.checkCursor();
    return x;
  }

  /**
   * The readUnsignedVarint32 above deals with signed 32-bit varints correctly,
   * so this is just an alias.
   *
   * @return {number} The decoded signed 32-bit varint.
   */
  readSignedVarint32() {
    return this.readUnsignedVarint32();
  }


  /**
   * Reads a signed, zigzag-encoded 32-bit varint from the binary stream.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @return {number} The decoded signed, zigzag-encoded 32-bit varint.
   */
  readZigzagVarint32() {
    const result = this.readUnsignedVarint32();
    return (result >>> 1) ^ -(result & 1);
  }


  /**
   * Reads an unsigned 64-bit varint from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the varint is larger than 2^53.
   *
   * @return {number} The decoded unsigned varint. Precision will be lost if the
   *     integer exceeds 2^53.
   */
  readUnsignedVarint64() {
    return this.readSplitVarint64(utils.joinUint64);
  }


  /**
   * Reads an unsigned 64-bit varint from the binary stream and returns the
   * value as a decimal string.
   *
   * @return {string} The decoded unsigned varint as a decimal string.
   */
  readUnsignedVarint64String() {
    return this.readSplitVarint64(utils.joinUnsignedDecimalString);
  }


  /**
   * Reads a signed 64-bit varint from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the varint is larger than 2^53.
   *
   * @return {number} The decoded signed varint. Precision will be lost if the
   *     integer exceeds 2^53.
   */
  readSignedVarint64() {
    return this.readSplitVarint64(utils.joinInt64);
  }


  /**
   * Reads an signed 64-bit varint from the binary stream and returns the value
   * as a decimal string.
   *
   * @return {string} The decoded signed varint as a decimal string.
   */
  readSignedVarint64String() {
    return this.readSplitVarint64(utils.joinSignedDecimalString);
  }


  /**
   * Reads a signed, zigzag-encoded 64-bit varint from the binary stream. Note
   * that since Javascript represents all numbers as double-precision floats,
   * there will be precision lost if the absolute value of the varint is larger
   * than 2^53.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @return {number} The decoded zigzag varint. Precision will be lost if the
   *     integer exceeds 2^53.
   */
  readZigzagVarint64() {
    return this.readSplitVarint64(utils.joinZigzag64);
  }


  /**
   * Reads a signed, zigzag-encoded 64-bit varint from the binary stream and
   * returns its value as a string.
   *
   * Zigzag encoding is a modification of varint encoding that reduces the
   * storage overhead for small negative integers - for more details on the
   * format, see https://developers.google.com/protocol-buffers/docs/encoding
   *
   * @return {string} The decoded signed, zigzag-encoded 64-bit varint as a
   * string.
   */
  readZigzagVarint64String() {
    return this.readSplitZigzagVarint64(utils.joinSignedDecimalString);
  }


  /**
   * Reads a raw unsigned 8-bit integer from the binary stream.
   *
   * @return {number} The unsigned 8-bit integer read from the binary stream.
   */
  readUint8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;

    this.checkCursor();
    return a;
  }


  /**
   * Reads a raw unsigned 16-bit integer from the binary stream.
   *
   * @return {number} The unsigned 16-bit integer read from the binary stream.
   */
  readUint16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;

    this.checkCursor();
    return (a << 0) | (b << 8);
  }


  /**
   * Reads a raw unsigned 32-bit integer from the binary stream.
   *
   * @return {number} The unsigned 32-bit integer read from the binary stream.
   */
  readUint32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    this.checkCursor();
    return ((a << 0) | (b << 8) | (c << 16) | (d << 24)) >>> 0;
  }


  /**
   * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   *
   * @return {number} The unsigned 64-bit integer read from the binary stream.
   *     Precision will be lost if the integer exceeds 2^53.
   */
  readUint64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return utils.joinUint64(bitsLow, bitsHigh);
  }


  /**
   * Reads a raw unsigned 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   *
   * @return {string} The unsigned 64-bit integer read from the binary stream.
   */
  readUint64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return utils.joinUnsignedDecimalString(bitsLow, bitsHigh);
  }


  /**
   * Reads a raw signed 8-bit integer from the binary stream.
   *
   * @return {number} The signed 8-bit integer read from the binary stream.
   */
  readInt8() {
    const a = this.bytes_[this.cursor_ + 0];
    this.cursor_ += 1;
    this.checkCursor();
    return (a << 24) >> 24;
  }


  /**
   * Reads a raw signed 16-bit integer from the binary stream.
   *
   * @return {number} The signed 16-bit integer read from the binary stream.
   */
  readInt16() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    this.cursor_ += 2;
    this.checkCursor();
    return (((a << 0) | (b << 8)) << 16) >> 16;
  }


  /**
   * Reads a raw signed 32-bit integer from the binary stream.
   *
   * @return {number} The signed 32-bit integer read from the binary stream.
   */
  readInt32() {
    const a = this.bytes_[this.cursor_ + 0];
    const b = this.bytes_[this.cursor_ + 1];
    const c = this.bytes_[this.cursor_ + 2];
    const d = this.bytes_[this.cursor_ + 3];
    this.cursor_ += 4;
    this.checkCursor();
    return (a << 0) | (b << 8) | (c << 16) | (d << 24);
  }


  /**
   * Reads a raw signed 64-bit integer from the binary stream. Note that since
   * Javascript represents all numbers as double-precision floats, there will be
   * precision lost if the absolute value of the integer is larger than 2^53.
   *
   * @return {number} The signed 64-bit integer read from the binary stream.
   *     Precision will be lost if the integer exceeds 2^53.
   */
  readInt64() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return utils.joinInt64(bitsLow, bitsHigh);
  }


  /**
   * Reads a raw signed 64-bit integer from the binary stream and returns it as
   * a string.
   *
   * @return {string} The signed 64-bit integer read from the binary stream.
   *     Precision will be lost if the integer exceeds 2^53.
   */
  readInt64String() {
    const bitsLow = this.readUint32();
    const bitsHigh = this.readUint32();
    return utils.joinSignedDecimalString(bitsLow, bitsHigh);
  }


  /**
   * Reads a 32-bit floating-point number from the binary stream, using the
   * temporary buffer to realign the data.
   *
   * @return {number} The float read from the binary stream.
   */
  readFloat() {
    const bitsLow = this.readUint32();
    const bitsHigh = 0;
    return utils.joinFloat32(bitsLow, bitsHigh);
  }


  /**
   * Reads a 64-bit floating-point number from the binary stream, using the
   * temporary buffer to realign the data.
   *
   * @return {number} The double read from the binary stream.
   */
  readDouble() {
    if (ASSUME_DATAVIEW_IS_FAST) {
      const result =
          this.dataView_.getFloat64(this.cursor_, true /* little endian */);
      this.cursor_ += 8;
      this.checkCursor();
      return result;
    } else {
      const bitsLow = this.readUint32();
      const bitsHigh = this.readUint32();
      return utils.joinFloat64(bitsLow, bitsHigh);
    }
  }


  /**
   * Reads an array of 64-bit floating-point numbers from the binary stream.
   *
   * @param {number} len The number of doubles to read.
   * @param {!Array<number>} dst Where to append the result to.
   */
  readDoubleArrayInto(len, dst) {
    const cursor = this.cursor_;
    const byteLength = 8 * len;
    asserts.assert(cursor + byteLength <= this.end_);

    const bufferStart = cursor + this.bytes_.byteOffset;

    if (ASSUME_DATAVIEW_IS_FAST) {
      // We create a subview that we'll traverse in its entirety, so that our
      // "end of loop" condition matches the bounds check that the JIT will
      // insert, in the hopes that the JIT only needs to run one of those checks
      // instead of both. This seems to help benchmarks.
      this.cursor_ += byteLength;
      const subView = new DataView(this.bytes_.buffer, bufferStart, byteLength);
      let i = 0;
      while (true) {
        let next_i = i + 8;
        if (next_i > subView.byteLength) {
          break;
        }
        dst.push(subView.getFloat64(i, /*littleEndian=*/ true));
        i = next_i;
      }
    } else if (OPTIMIZE_LITTLE_ENDIAN_MACHINES && isLittleEndian()) {
      // We can use Float64Array to directly interpret the bytes as float64
      // values, since this is a little endian machine. However, Float64Array
      // will reject non-multiple-of-8 byte offsets, so we create a copy of the
      // underlying ArrayBuffer.
      this.cursor_ += byteLength;
      const doubleArray = new Float64Array(
          this.bytes_.buffer.slice(bufferStart, bufferStart + byteLength));
      for (let i = 0; i < doubleArray.length; i++) {
        dst.push(doubleArray[i]);
      }
    } else {
      for (let i = 0; i < len; i++) {
        dst.push(this.readDouble());
      }
    }
  }



  /**
   * Reads a boolean value from the binary stream.
   * @return {boolean} The boolean read from the binary stream.
   */
  readBool() {
    const b = !!this.bytes_[this.cursor_++];
    this.checkCursor();
    return b;
  }


  /**
   * Reads an enum value from the binary stream, which are always encoded as
   * signed varints.
   * @return {number} The enum value read from the binary stream.
   */
  readEnum() {
    return this.readSignedVarint32();
  }


  /**
   * Reads and parses a UTF-8 encoded unicode string from the stream.
   * The code is inspired by maps.vectortown.parse.StreamedDataViewReader.
   * Supports codepoints from U+0000 up to U+10FFFF.
   * (http://en.wikipedia.org/wiki/UTF-8).
   * @param {number} length The length of the string to read.
   * @param {boolean} requireUtf8 Whether to throw when invalid utf8 is found.
   * @return {string} The decoded string.
   */
  readString(length, requireUtf8) {
    const cursor = this.cursor_;
    this.cursor_ += length;
    this.checkCursor();
    const result =
        decodeUtf8(asserts.assert(this.bytes_), cursor, length, requireUtf8);
    return result;
  }


  /**
   * Reads a block of raw bytes from the binary stream.
   *
   * @param {number} length The number of bytes to read.
   * @return {!Uint8Array} The decoded block of bytes, or an empty block if the
   *     length was invalid.
   */
  readBytes(length) {
    if (length < 0 || this.cursor_ + length > this.bytes_.length) {
      this.error_ = true;
      asserts.fail('Invalid byte length!');
      return new Uint8Array(0);
    }

    const result =
        utils.sliceUint8Array(this.bytes_, this.cursor_, this.cursor_ + length);
    this.cursor_ += length;
    this.checkCursor();
    return result;
  }

  /**
   * Visible for testing.
   * @package
   */
  static resetInstanceCache() {
    BinaryDecoder.instanceCache_ = [];
  }

  /**
   * Visible for testing.
   * @return {!Array<!BinaryDecoder>}
   * @package
   */
  static getInstanceCache() {
    return BinaryDecoder.instanceCache_;
  }
}


/**
 * Global pool of BinaryDecoder instances.
 * @private {!Array<!BinaryDecoder>}
 */
BinaryDecoder.instanceCache_ = [];

/**
 * Is this machine little endian?
 * @return {boolean}
 */
function isLittleEndian() {
  if (isLittleEndianCache === undefined) {
    // Do a trial memory load.
    isLittleEndianCache =
        new Uint16Array(new Uint8Array([1, 2]).buffer)[0] == (1 + 256 * 2);
  }
  return asserts.assertBoolean(isLittleEndianCache);
}

/** Global cache of the isLittleEndian check. */
let isLittleEndianCache = undefined;

/**
 * @define {boolean}
 * Whether DataView is known to be present and has a fast implementation.
 * Chrome's implementation was slow until late 2018:
 * https://v8.dev/blog/dataview. Unsure of the performance on other browsers.
 */
const ASSUME_DATAVIEW_IS_FAST = goog.define(
    'jspb.BinaryDecoder.ASSUME_DATAVIEW_IS_FAST', goog.FEATURESET_YEAR >= 2019);

/**
 * @define {boolean} If true, on little endian machines we'll enable the fast
 *   path for float64 decoding.
 *
 *   Only exists for testing.
 */
const OPTIMIZE_LITTLE_ENDIAN_MACHINES =
    goog.define('jspb.BinaryDecoder.OPTIMIZE_LITTLE_ENDIAN_MACHINES', true);


exports = {BinaryDecoder};

;return exports;});

//javascript/apps/jspb/binary/reader.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview This file contains utilities for converting binary,
 * wire-format protocol buffers into Javascript data structures.
 *
 * jspb's BinaryReader class wraps the BinaryDecoder class to add methods
 * that understand the protocol buffer syntax and can do the type checking and
 * bookkeeping necessary to parse trees of nested messages.
 *
 * Major caveat - Users of this library _must_ keep their Javascript proto
 * parsing code in sync with the original .proto file - presumably you'll be
 * using the typed jspb code generator, but if you bypass that you'll need
 * to keep things in sync by hand.
 *
 * @author aappleby@google.com (Austin Appleby)
 */

goog.module('jspb.binary.reader');

const BinaryConstants = goog.require('jspb.BinaryConstants');
const asserts = goog.require('goog.asserts');
const utils = goog.require('jspb.utils');
const {AnyFieldType} = goog.require('jspb.binary.any_field_type');
const {BinaryDecoder} = goog.require('jspb.binary.decoder');
const {ByteSource} = goog.require('jspb.binary.bytesource');


class BinaryReader {
  /**
   * BinaryReader implements the decoders for all the wire types specified in
   * https://developers.google.com/protocol-buffers/docs/encoding.
   *
   * @param {?ByteSource=} bytes The bytes we're reading from.
   * @param {number=} start The optional offset to start reading at.
   * @param {number=} length The optional length of the block to read -
   *     we'll throw an assertion if we go off the end of the block.
   */
  constructor(bytes, start, length) {
    /**
     * Wire-format decoder.
     * @const @private {!BinaryDecoder}
     */
    this.decoder_ = BinaryDecoder.alloc(bytes, start, length);

    /**
     * Cursor immediately before the field tag.
     * @private {number}
     */
    this.fieldCursor_ = this.decoder_.getCursor();

    /**
     * Field number of the next field in the buffer, filled in by nextField().
     * @private {number}
     */
    this.nextField_ = BinaryConstants.INVALID_FIELD_NUMBER;

    /**
     * Field number of the next tag in the buffer, filled in by nextField().
     * @private {number}
     */
    this.nextTag_ = BinaryConstants.INVALID_TAG;

    /**
     * Wire type of the next proto field in the buffer, filled in by
     * nextField().
     * @private {!BinaryConstants.WireType}
     */
    this.nextWireType_ = BinaryConstants.WireType.INVALID;

    /**
     * Set to true if this reader encountered an error due to corrupt data.
     * @private {boolean}
     */
    this.error_ = false;

    /**
     * User-defined reader callbacks.
     * @private {?Object<string, function(!BinaryReader):*>}
     */
    this.readCallbacks_ = null;
  }



  /**
   * Pops an instance off the instance cache, or creates one if the cache is
   * empty.
   * @param {?ByteSource=} bytes The bytes we're reading from.
   * @param {number=} start The optional offset to start reading at.
   * @param {number=} length The optional length of the block to read -
   *     we'll throw an assertion if we go off the end of the block.
   * @return {!BinaryReader}
   */
  static alloc(bytes, start, length) {
    if (BinaryReader.instanceCache_.length) {
      const newReader = BinaryReader.instanceCache_.pop();
      if (bytes) {
        newReader.decoder_.setBlock(bytes, start, length);
      }
      return newReader;
    } else {
      return new BinaryReader(bytes, start, length);
    }
  }



  /**
   * Puts this instance back in the instance cache.
   */
  free() {
    this.decoder_.clear();
    this.nextTag_ = BinaryConstants.INVALID_TAG;
    this.nextField_ = BinaryConstants.INVALID_FIELD_NUMBER;
    this.nextWireType_ = BinaryConstants.WireType.INVALID;
    this.error_ = false;
    this.readCallbacks_ = null;

    if (BinaryReader.instanceCache_.length < 100) {
      BinaryReader.instanceCache_.push(this);
    }
  }


  /**
   * Returns the cursor immediately before the current field's tag.
   * @return {number} The internal read cursor.
   */
  getFieldCursor() {
    return this.fieldCursor_;
  }


  /**
   * Returns the internal read cursor.
   * @return {number} The internal read cursor.
   */
  getCursor() {
    return this.decoder_.getCursor();
  }


  /**
   * Returns the raw buffer.
   * @return {?Uint8Array} The raw buffer.
   */
  getBuffer() {
    return this.decoder_.getBuffer();
  }

  /**
   * @return {number} The field number of the next field in the buffer, or
   *     INVALID_FIELD_NUMBER if there is no next field.
   */
  getTag() {
    return this.nextTag_;
  }

  /**
   * @return {number} The field number of the next field in the buffer, or
   *     INVALID_FIELD_NUMBER if there is no next field.
   */
  getFieldNumber() {
    return this.nextField_;
  }


  /**
   * @return {!BinaryConstants.WireType} The wire type of the next field
   *     in the stream, or WireType.INVALID if there is no next field.
   */
  getWireType() {
    return this.nextWireType_;
  }


  /**
   * @return {boolean} Whether the current wire type is an end-group tag. Used
   *     as
   * an exit condition in decoder loops in generated code.
   */
  isEndGroup() {
    return this.nextWireType_ == BinaryConstants.WireType.END_GROUP;
  }

  /**
   * @return {boolean} Whether the current wire type is a delimited field. Used
   *     to
   * conditionally parse packed repeated fields.
   */
  isDelimited() {
    return this.nextWireType_ == BinaryConstants.WireType.DELIMITED;
  }


  /**
   * Returns true if this reader hit an error due to corrupt data.
   * @return {boolean}
   */
  getError() {
    return this.error_ || this.decoder_.getError();
  }


  /**
   * Points this reader at a new block of bytes.
   * @param {!Uint8Array} bytes The block of bytes we're reading from.
   * @param {number} start The offset to start reading at.
   * @param {number} length The length of the block to read.
   */
  setBlock(bytes, start, length) {
    this.decoder_.setBlock(bytes, start, length);
    this.nextField_ = BinaryConstants.INVALID_FIELD_NUMBER;
    this.nextWireType_ = BinaryConstants.WireType.INVALID;
  }


  /**
   * Rewinds the stream cursor to the beginning of the buffer and resets all
   * internal state.
   */
  reset() {
    this.decoder_.reset();
    this.nextField_ = BinaryConstants.INVALID_FIELD_NUMBER;
    this.nextWireType_ = BinaryConstants.WireType.INVALID;
  }


  /**
   * Advances the stream cursor by the given number of bytes.
   * @param {number} count The number of bytes to advance by.
   */
  advance(count) {
    this.decoder_.advance(count);
  }


  /**
   * Reads the next field header in the stream if there is one, returns true if
   * we saw a valid field header or false if we've read the whole stream.
   * Throws an error if we encountered a deprecated START_GROUP/END_GROUP field.
   * @return {boolean} True if the stream contains more fields.
   */
  nextField() {
    // If we're at the end of the block, there are no more fields.
    if (this.decoder_.atEnd()) {
      return false;
    }

    // If we hit an error decoding the previous field, stop now before we
    // try to decode anything else
    if (this.getError()) {
      asserts.fail('Decoder hit an error');
      return false;
    }

    // Otherwise just read the header of the next field.
    this.fieldCursor_ = this.decoder_.getCursor();
    const header = this.decoder_.readUnsignedVarint32();

    const nextField = header >>> 3;
    const nextWireType = /** @type {!BinaryConstants.WireType} */
        (header & 0x7);

    // If the wire type isn't one of the valid ones, something's broken.
    if (nextWireType != BinaryConstants.WireType.VARINT &&
        nextWireType != BinaryConstants.WireType.FIXED32 &&
        nextWireType != BinaryConstants.WireType.FIXED64 &&
        nextWireType != BinaryConstants.WireType.DELIMITED &&
        nextWireType != BinaryConstants.WireType.START_GROUP &&
        nextWireType != BinaryConstants.WireType.END_GROUP) {
      asserts.fail(
          'Invalid wire type: %s (at position %s)', nextWireType,
          this.fieldCursor_);
      this.error_ = true;
      return false;
    }

    this.nextTag_ = header;
    this.nextField_ = nextField;
    this.nextWireType_ = nextWireType;

    return true;
  }


  /**
   * Winds the reader back to just before this field's header.
   */
  unskipHeader() {
    this.decoder_.unskipVarint(this.nextTag_);
  }


  /**
   * Skips all contiguous fields whose header matches the one we just read.
   */
  skipMatchingFields() {
    const field = this.nextField_;
    this.unskipHeader();

    while (this.nextField() && (this.getFieldNumber() == field)) {
      this.skipField();
    }

    if (!this.decoder_.atEnd()) {
      this.unskipHeader();
    }
  }


  /**
   * Skips over the next varint field in the binary stream.
   */
  skipVarintField() {
    if (this.nextWireType_ != BinaryConstants.WireType.VARINT) {
      asserts.fail('Invalid wire type for skipVarintField');
      this.skipField();
      return;
    }

    this.decoder_.skipVarint();
  }


  /**
   * Skips over the next delimited field in the binary stream.
   */
  skipDelimitedField() {
    if (this.nextWireType_ != BinaryConstants.WireType.DELIMITED) {
      asserts.fail('Invalid wire type for skipDelimitedField');
      this.skipField();
      return;
    }

    const length = this.decoder_.readUnsignedVarint32();
    this.decoder_.advance(length);
  }


  /**
   * Skips over the next fixed32 field in the binary stream.
   */
  skipFixed32Field() {
    if (this.nextWireType_ != BinaryConstants.WireType.FIXED32) {
      asserts.fail('Invalid wire type for skipFixed32Field');
      this.skipField();
      return;
    }

    this.decoder_.advance(4);
  }


  /**
   * Skips over the next fixed64 field in the binary stream.
   */
  skipFixed64Field() {
    if (this.nextWireType_ != BinaryConstants.WireType.FIXED64) {
      asserts.fail('Invalid wire type for skipFixed64Field');
      this.skipField();
      return;
    }

    this.decoder_.advance(8);
  }


  /**
   * Skips over the next group field in the binary stream.
   */
  skipGroup() {
    const previousField = this.nextField_;
    do {
      if (!this.nextField()) {
        asserts.fail('Unmatched start-group tag: stream EOF');
        this.error_ = true;
        return;
      }
      if (this.nextWireType_ == BinaryConstants.WireType.END_GROUP) {
        // Group end: check that it matches top-of-stack.
        if (this.nextField_ != previousField) {
          asserts.fail('Unmatched end-group tag');
          this.error_ = true;
          return;
        }
        return;
      }
      this.skipField();
    } while (true);
  }


  /**
   * Skips over the next field in the binary stream - this is useful if we're
   * decoding a message that contain unknown fields.
   */
  skipField() {
    switch (this.nextWireType_) {
      case BinaryConstants.WireType.VARINT:
        this.skipVarintField();
        break;
      case BinaryConstants.WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case BinaryConstants.WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case BinaryConstants.WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case BinaryConstants.WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        this.error_ = true;
        asserts.fail('Invalid wire encoding for field.');
    }
  }


  /**
   * Registers a user-defined read callback.
   * @param {string} callbackName
   * @param {function(!BinaryReader):*} callback
   */
  registerReadCallback(callbackName, callback) {
    if (this.readCallbacks_ === null) {
      this.readCallbacks_ = {};
    }
    asserts.assert(!this.readCallbacks_[callbackName]);
    this.readCallbacks_[callbackName] = callback;
  }


  /**
   * Runs a registered read callback.
   * @param {string} callbackName The name the callback is registered under.
   * @return {*} The value returned by the callback.
   */
  runReadCallback(callbackName) {
    asserts.assert(this.readCallbacks_ !== null);
    const callback = this.readCallbacks_[callbackName];
    asserts.assert(callback);
    return callback(this);
  }


  /**
   * Reads a field of any valid non-message type from the binary stream.
   * @param {!BinaryConstants.FieldType} fieldType
   * @return {!AnyFieldType}
   */
  readAny(fieldType) {
    this.nextWireType_ = BinaryConstants.FieldTypeToWireType(fieldType);
    const fieldTypes = BinaryConstants.FieldType;
    switch (fieldType) {
      case fieldTypes.DOUBLE:
        return this.readDouble();
      case fieldTypes.FLOAT:
        return this.readFloat();
      case fieldTypes.INT64:
        return this.readInt64();
      case fieldTypes.UINT64:
        return this.readUint64();
      case fieldTypes.INT32:
        return this.readInt32();
      case fieldTypes.FIXED64:
        return this.readFixed64();
      case fieldTypes.FIXED32:
        return this.readFixed32();
      case fieldTypes.BOOL:
        return this.readBool();
      case fieldTypes.STRING:
        return this.readString();
      case fieldTypes.GROUP:
        asserts.fail('Group field type not supported in readAny()');
      case fieldTypes.MESSAGE:
        asserts.fail('Message field type not supported in readAny()');
      case fieldTypes.BYTES:
        return this.readBytes();
      case fieldTypes.UINT32:
        return this.readUint32();
      case fieldTypes.ENUM:
        return this.readEnum();
      case fieldTypes.SFIXED32:
        return this.readSfixed32();
      case fieldTypes.SFIXED64:
        return this.readSfixed64();
      case fieldTypes.SINT32:
        return this.readSint32();
      case fieldTypes.SINT64:
        return this.readSint64();
      default:
        asserts.fail('Invalid field type in readAny()');
    }
    return 0;
  }


  /**
   * Deserialize a proto into the provided message object using the provided
   * reader function. This function is templated as we currently have one client
   * who is using manual deserialization instead of the code-generated versions.
   * @template T
   * @param {T} message
   * @param {function(T, !BinaryReader)} reader
   * @return {T}
   */
  readMessage(message, reader) {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);

    // Save the current endpoint of the decoder and move it to the end of the
    // embedded message.
    const oldEnd = this.decoder_.getEnd();
    const length = this.decoder_.readUnsignedVarint32();
    const newEnd = this.decoder_.getCursor() + length;
    this.decoder_.setEnd(newEnd);

    // Deserialize the embedded message.
    reader(message, this);

    // Advance the decoder past the embedded message and restore the endpoint.
    this.decoder_.setCursor(newEnd);
    this.decoder_.setEnd(oldEnd);
    return message;
  }


  /**
   * Deserialize a proto into the provided message object using the provided
   * reader function, assuming that the message is serialized as a group
   * with the given tag.
   * @template T
   * @param {number} field
   * @param {T} message
   * @param {function(T, !BinaryReader)} reader
   * @return {T}
   */
  readGroup(field, message, reader) {
    // Ensure that the wire type is correct.
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.START_GROUP);
    // Ensure that the field number is correct.
    asserts.assert(this.nextField_ == field);

    // Deserialize the message. The deserialization will stop at an END_GROUP
    // tag.
    reader(message, this);

    if (!this.error_ &&
        this.nextWireType_ != BinaryConstants.WireType.END_GROUP) {
      asserts.fail('Group submessage did not end with an END_GROUP tag');
      this.error_ = true;
    }
    return message;
  }


  /**
   * Return a decoder that wraps the current delimited field.
   * @return {!BinaryDecoder}
   */
  getFieldDecoder() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);

    const length = this.decoder_.readUnsignedVarint32();
    const start = this.decoder_.getCursor();
    const end = start + length;

    const innerDecoder =
        BinaryDecoder.alloc(this.decoder_.getBuffer(), start, length);
    this.decoder_.setCursor(end);
    return innerDecoder;
  }


  /**
   * Reads a signed 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the signed 32-bit integer field.
   */
  readInt32() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSignedVarint32();
  }


  /**
   * Reads a signed 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the signed 64-bit integer field.
   */
  readInt64() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }


  /**
   * Reads a signed 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * Returns the value as a string.
   *
   * @return {string} The value of the signed 64-bit integer field as a decimal
   * string.
   */
  readInt64String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSignedVarint64String();
  }


  /**
   * Reads an unsigned 32-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the unsigned 32-bit integer field.
   */
  readUint32() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readUnsignedVarint32();
  }


  /**
   * Reads an unsigned 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the unsigned 64-bit integer field.
   */
  readUint64() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readUnsignedVarint64();
  }

  /**
   * Reads an unsigned 64-bit integer field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * Returns the value as a string.
   *
   * @return {string} The value of the unsigned 64-bit integer field as a
   *     decimal
   * string.
   */
  readUint64String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readUnsignedVarint64String();
  }


  /**
   * Reads a signed zigzag-encoded 32-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {number} The value of the signed 32-bit integer field.
   */
  readSint32() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readZigzagVarint32();
  }


  /**
   * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {number} The value of the signed 64-bit integer field.
   */
  readSint64() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readZigzagVarint64();
  }


  /**
   * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {string} The value of the signed 64-bit integer field as a decimal
   *     string.
   */
  readSint64String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readZigzagVarint64String();
  }


  /**
   * Reads an unsigned 32-bit fixed-length integer fiield from the binary
   * stream, or throws an error if the next field in the stream is not of the
   * correct wire type.
   *
   * @return {number} The value of the double field.
   */
  readFixed32() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED32);
    return this.decoder_.readUint32();
  }


  /**
   * Reads an unsigned 64-bit fixed-length integer fiield from the binary
   * stream, or throws an error if the next field in the stream is not of the
   * correct wire type.
   *
   * @return {number} The value of the float field.
   */
  readFixed64() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readUint64();
  }


  /**
   * Reads a signed 64-bit integer field from the binary stream as a string, or
   * throws an error if the next field in the stream is not of the correct wire
   * type.
   *
   * Returns the value as a string.
   *
   * @return {string} The value of the unsigned 64-bit integer field as a
   *     decimal
   * string.
   */
  readFixed64String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readUint64String();
  }


  /**
   * Reads a signed 32-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {number} The value of the signed 32-bit integer field.
   */
  readSfixed32() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED32);
    return this.decoder_.readInt32();
  }


  /**
   * Reads a signed 32-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {string} The value of the signed 32-bit integer field as a decimal
   * string.
   */
  readSfixed32String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED32);
    return this.decoder_.readInt32().toString();
  }


  /**
   * Reads a signed 64-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * @return {number} The value of the sfixed64 field.
   */
  readSfixed64() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readInt64();
  }


  /**
   * Reads a signed 64-bit fixed-length integer fiield from the binary stream,
   * or throws an error if the next field in the stream is not of the correct
   * wire type.
   *
   * Returns the value as a string.
   *
   * @return {string} The value of the sfixed64 field as a decimal string.
   */
  readSfixed64String() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readInt64String();
  }


  /**
   * Reads a 32-bit floating-point field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the float field.
   */
  readFloat() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED32);
    return this.decoder_.readFloat();
  }


  /**
   * Reads a 64-bit floating-point field from the binary stream, or throws an
   * error if the next field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the double field.
   */
  readDouble() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readDouble();
  }


  /**
   * Reads a boolean field from the binary stream, or throws an error if the
   * next field in the stream is not of the correct wire type.
   *
   * @return {boolean} The value of the boolean field.
   */
  readBool() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return !!this.decoder_.readUnsignedVarint32();
  }


  /**
   * Reads an enum field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type.
   *
   * @return {number} The value of the enum field.
   */
  readEnum() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSignedVarint64();
  }


  /**
   * Reads a string field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type.
   *
   * @return {string} The value of the string field.
   */
  readString() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(length, /*requireUtf8=*/ false);
  }

  /**
   * Reads a string field from the binary stream, or throws an error if the next
   * field in the stream is not of the correct wire type, or if the string is
   * not valid utf8.
   *
   * @return {string} The value of the string field.
   */
  readStringRequireUtf8() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(length, /*requireUtf8=*/ true);
  }

  /**
   * Reads a length-prefixed block of bytes from the binary stream, or returns
   * null if the next field in the stream has an invalid length value.
   *
   * @return {!Uint8Array} The block of bytes.
   */
  readBytes() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);
    const length = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(length);
  }


  /**
   * Reads a 64-bit varint field from the stream and invokes `convert` to
   * produce the return value, or throws an error if the next field in the
   * stream is not of the correct wire type.
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitVarint64(convert) {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSplitVarint64(convert);
  }


  /**
   * Reads a 64-bit zig-zag varint field from the stream and invokes `convert`
   * to produce the return value, or throws an error if the next field in the
   * stream is not of the correct wire type.
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitZigzagVarint64(convert) {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.VARINT);
    return this.decoder_.readSplitVarint64(
        (lowBits, highBits) => utils.fromZigzag64(lowBits, highBits, convert));
  }


  /**
   * Reads a 64-bit fixed64 field from the stream and invokes `convert`
   * to produce the return value, or throws an error if the next field in the
   * stream is not of the correct wire type.
   *
   * @param {function(number, number): T} convert Conversion function to produce
   *     the result value, takes parameters (lowBits, highBits).
   * @return {T}
   * @template T
   */
  readSplitFixed64(convert) {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.FIXED64);
    return this.decoder_.readSplitFixed64(convert);
  }


  /**
   * Reads a packed scalar field using the supplied raw reader function.
   * @param {function(this:BinaryDecoder):T} decodeMethod
   * @return {!Array<T>}
   * @template T
   * @private
   */
  readPackedField_(decodeMethod) {
    const length = this.readPackedFieldLength_();
    const end = this.decoder_.getCursor() + length;
    const result = [];
    while (this.decoder_.getCursor() < end) {
      result.push(decodeMethod.call(this.decoder_));
    }
    return result;
  }


  /**
   * Reads the length of a packed field.
   * @return {number}
   * @private
   */
  readPackedFieldLength_() {
    asserts.assert(this.nextWireType_ == BinaryConstants.WireType.DELIMITED);
    return this.decoder_.readUnsignedVarint32();
  }


  /**
   * Reads a packed int32 field, which consists of a length header and a list of
   * signed varints.
   * @return {!Array<number>}
   */
  readPackedInt32() {
    return this.readPackedField_(BinaryDecoder.prototype.readSignedVarint32);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<number>}
   */
  readPackableInt32() {
    if (this.isDelimited()) {
      return this.readPackedInt32();
    } else {
      return [this.readInt32()];
    }
  }


  /**
   * Reads a packed int64 field, which consists of a length header and a list of
   * signed varints.
   * @return {!Array<number>}
   */
  readPackedInt64() {
    return this.readPackedField_(BinaryDecoder.prototype.readSignedVarint64);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<number>}
   */
  readPackableInt64() {
    if (this.isDelimited()) {
      return this.readPackedInt64();
    } else {
      return [this.readInt64()];
    }
  }

  /**
   * Reads a packed int64 field, which consists of a length header and a list of
   * signed varints. Returns a list of strings.
   * @return {!Array<string>}
   */
  readPackedInt64String() {
    return this.readPackedField_(
        BinaryDecoder.prototype.readSignedVarint64String);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<string>}
   */
  readPackableInt64String() {
    if (this.isDelimited()) {
      return this.readPackedInt64String();
    } else {
      return [this.readInt64String()];
    }
  }


  /**
   * Reads a packed uint32 field, which consists of a length header and a list
   * of unsigned varints.
   * @return {!Array<number>}
   */
  readPackedUint32() {
    return this.readPackedField_(BinaryDecoder.prototype.readUnsignedVarint32);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<number>}
   */
  readPackableUint32() {
    if (this.isDelimited()) {
      return this.readPackedUint32();
    } else {
      return [this.readUint32()];
    }
  }

  /**
   * Reads a packed uint64 field, which consists of a length header and a list
   * of unsigned varints.
   * @return {!Array<number>}
   */
  readPackedUint64() {
    return this.readPackedField_(BinaryDecoder.prototype.readUnsignedVarint64);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<number>}
   */
  readPackableUint64() {
    if (this.isDelimited()) {
      return this.readPackedUint64();
    } else {
      return [this.readUint64()];
    }
  }

  /**
   * Reads a packed uint64 field, which consists of a length header and a list
   * of unsigned varints. Returns a list of strings.
   * @return {!Array<string>}
   */
  readPackedUint64String() {
    return this.readPackedField_(
        BinaryDecoder.prototype.readUnsignedVarint64String);
  }


  /**
   * Reads an int32 field that might be packed
   * @return {!Array<string>}
   */
  readPackableUint64String() {
    if (this.isDelimited()) {
      return this.readPackedUint64String();
    } else {
      return [this.readUint64String()];
    }
  }

  /**
   * Reads a packed sint32 field, which consists of a length header and a list
   * of zigzag varints.
   * @return {!Array<number>}
   */
  readPackedSint32() {
    return this.readPackedField_(BinaryDecoder.prototype.readZigzagVarint32);
  }


  /**
   * Reads a possibly packed sint32 field,
   * @return {!Array<number>}
   */
  readPackableSint32() {
    if (this.isDelimited()) {
      return this.readPackedSint32();
    } else {
      return [this.readSint32()];
    }
  }


  /**
   * Reads a packed sint64 field, which consists of a length header and a list
   * of zigzag varints.
   * @return {!Array<number>}
   */
  readPackedSint64() {
    return this.readPackedField_(BinaryDecoder.prototype.readZigzagVarint64);
  }


  /**
   * Reads a possibly packed sint64 field,
   * @return {!Array<number>}
   */
  readPackableSint64() {
    if (this.isDelimited()) {
      return this.readPackedSint64();
    } else {
      return [this.readSint64()];
    }
  }

  /**
   * Reads a packed sint64 field, which consists of a length header and a list
   * of zigzag varints.  Returns a list of strings.
   * @return {!Array<string>}
   */
  readPackedSint64String() {
    return this.readPackedField_(
        BinaryDecoder.prototype.readZigzagVarint64String);
  }


  /**
   * Reads a possibly packed sint64 field as an array of strings.
   * @return {!Array<string>}
   */
  readPackableSint64String() {
    if (this.isDelimited()) {
      return this.readPackedSint64String();
    } else {
      return [this.readSint64String()];
    }
  }

  /**
   * Reads a packed fixed32 field, which consists of a length header and a list
   * of unsigned 32-bit ints.
   * @return {!Array<number>}
   */
  readPackedFixed32() {
    return this.readPackedField_(BinaryDecoder.prototype.readUint32);
  }


  /**
   * Reads a possibly packed fixed32 field.
   * @return {!Array<number>}
   */
  readPackableFixed32() {
    if (this.isDelimited()) {
      return this.readPackedFixed32();
    } else {
      return [this.readFixed32()];
    }
  }

  /**
   * Reads a packed fixed64 field, which consists of a length header and a list
   * of unsigned 64-bit ints.
   * @return {!Array<number>}
   */
  readPackedFixed64() {
    return this.readPackedField_(BinaryDecoder.prototype.readUint64);
  }


  /**
   * Reads a possibly packed fixed64 field.
   * @return {!Array<number>}
   */
  readPackableFixed64() {
    if (this.isDelimited()) {
      return this.readPackedFixed64();
    } else {
      return [this.readFixed64()];
    }
  }

  /**
   * Reads a packed fixed64 field, which consists of a length header and a list
   * of unsigned 64-bit ints.  Returns a list of strings.
   * @return {!Array<string>}
   */
  readPackedFixed64String() {
    return this.readPackedField_(BinaryDecoder.prototype.readUint64String);
  }


  /**
   * Reads a possibly packed fixed64 field as an array fo strings
   * @return {!Array<string>}
   */
  readPackableFixed64String() {
    if (this.isDelimited()) {
      return this.readPackedFixed64String();
    } else {
      return [this.readFixed64String()];
    }
  }

  /**
   * Reads a packed sfixed32 field, which consists of a length header and a list
   * of 32-bit ints.
   * @return {!Array<number>}
   */
  readPackedSfixed32() {
    return this.readPackedField_(BinaryDecoder.prototype.readInt32);
  }

  /**
   * Reads a possibly packed sfixed32
   * @return {!Array<number>}
   */
  readPackableSfixed32() {
    if (this.isDelimited()) {
      return this.readPackedSfixed32();
    } else {
      return [this.readSfixed32()];
    }
  }

  /**
   * Reads a packed sfixed64 field, which consists of a length header and a list
   * of 64-bit ints.
   * @return {!Array<number>}
   */
  readPackedSfixed64() {
    return this.readPackedField_(BinaryDecoder.prototype.readInt64);
  }

  /**
   * Reads a possibly packed sfixed64 field.
   * @return {!Array<number>}
   */
  readPackableSfixed64() {
    if (this.isDelimited()) {
      return this.readPackedSfixed64();
    } else {
      return [this.readSfixed64()];
    }
  }

  /**
   * Reads a packed sfixed64 field, which consists of a length header and a list
   * of 64-bit ints.  Returns a list of strings.
   * @return {!Array<string>}
   */
  readPackedSfixed64String() {
    return this.readPackedField_(BinaryDecoder.prototype.readInt64String);
  }

  /**
   * Reads a possibly packed sfixed64 field as an array of strings
   * @return {!Array<string>}
   */
  readPackableSfixed64String() {
    if (this.isDelimited()) {
      return this.readPackedSfixed64String();
    } else {
      return [this.readSfixed64String()];
    }
  }

  /**
   * Reads a packed float field, which consists of a length header and a list of
   * floats.
   * @return {!Array<number>}
   */
  readPackedFloat() {
    return this.readPackedField_(BinaryDecoder.prototype.readFloat);
  }

  /**
   * Reads a possibly packed float field
   * @return {!Array<number>}
   */
  readPackableFloat() {
    if (this.isDelimited()) {
      return this.readPackedFloat();
    } else {
      return [this.readFloat()];
    }
  }

  /**
   * Reads a packed double field, which consists of a length header and a list
   * of doubles.
   * @param {!Array<number>} dst
   */
  readPackedDoubleInto(dst) {
    this.decoder_.readDoubleArrayInto(this.readPackedFieldLength_() / 8, dst);
  }

  /**
   * Reads a possibly packed double field and appends it to `dst`.
   * @param {!Array<number>} dst
   */
  readPackableDoubleInto(dst) {
    if (this.isDelimited()) {
      this.readPackedDoubleInto(dst);
    } else {
      dst.push(this.readDouble());
    }
  }

  /**
   * Reads a possibly packed double field.
   * @return {!Array<number>}
   */
  readPackableDouble() {
    const tmp = [];
    this.readPackableDoubleInto(tmp);
    return tmp;
  }

  /**
   * Reads a packed bool field, which consists of a length header and a list of
   * unsigned varints.
   * @return {!Array<boolean>}
   */
  readPackedBool() {
    // TODO(lukes): this doesn't look right, readBool does readUnsignedInt32
    return this.readPackedField_(BinaryDecoder.prototype.readBool);
  }

  /**
   * Reads a possibly packed bool field
   * @return {!Array<boolean>}
   */
  readPackableBool() {
    if (this.isDelimited()) {
      return this.readPackedBool();
    } else {
      return [this.readBool()];
    }
  }

  /**
   * Reads a packed enum field, which consists of a length header and a list of
   * unsigned varints.
   * @return {!Array<number>}
   */
  readPackedEnum() {
    return this.readPackedField_(BinaryDecoder.prototype.readEnum);
  }

  /**
   * Reads a possibly packed enum field
   * @return {!Array<number>}
   */
  readPackableEnum() {
    if (this.isDelimited()) {
      return this.readPackedEnum();
    } else {
      return [this.readEnum()];
    }
  }

  /**
   * Visible for testing.
   * @package
   */
  static resetInstanceCache() {
    BinaryReader.instanceCache_ = [];
  }

  /**
   * Visible for testing.
   * @return {!Array<!BinaryReader>}
   * @package
   */
  static getInstanceCache() {
    return BinaryReader.instanceCache_;
  }
}

/**
 * Global pool of BinaryReader instances.
 * @private {!Array<!BinaryReader>}
 */
BinaryReader.instanceCache_ = [];

exports = {BinaryReader};

;return exports;});

//javascript/apps/jspb/binary/reader_alias.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Legacy alias for the old namespace used by reader.js
 */
goog.module('jspb.BinaryReader');
goog.module.declareLegacyNamespace();

const {BinaryReader} = goog.require('jspb.binary.reader');

exports = BinaryReader;

;return exports;});

//javascript/apps/jspb/binary/arith.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview This file contains helper code used by jspb.utils to
 * handle 64-bit integer conversion to/from strings.
 *
 * @author cfallin@google.com (Chris Fallin)
 *
 * TODO(haberman): move this to javascript/closure/math?
 */
goog.module('jspb.arith');


/**
 * UInt64 implements some 64-bit arithmetic routines necessary for properly
 * handling 64-bit integer fields. It implements lossless integer arithmetic on
 * top of JavaScript's number type, which has only 53 bits of precision, by
 * representing 64-bit integers as two 32-bit halves.
 * @unrestricted
 */
class UInt64{
  /**
   * @param {number} lo The low 32 bits.
   * @param {number} hi The high 32 bits.
   */
  constructor(lo, hi) {
    /**
     * The low 32 bits.
     * @public {number}
     */
    this.lo = lo;
    /**
     * The high 32 bits.
     * @public {number}
     */
    this.hi = hi;
  }

  /**
   * Compare two 64-bit numbers. Returns -1 if the first is
   * less, +1 if the first is greater, or 0 if both are equal.
   * @param {!UInt64} other
   * @return {number}
   */
  cmp(other) {
    if (this.hi < other.hi || (this.hi == other.hi && this.lo < other.lo)) {
      return -1;
    } else if (this.hi == other.hi && this.lo == other.lo) {
      return 0;
    } else {
      return 1;
    }
  }

  /**
   * Right-shift this number by one bit.
   * @return {!UInt64}
   */
  rightShift() {
    const hi = this.hi >>> 1;
    const lo = (this.lo >>> 1) | ((this.hi & 1) << 31);
    return new UInt64(lo >>> 0, hi >>> 0);
  }

  /**
   * Left-shift this number by one bit.
   * @return {!UInt64}
   */
  leftShift() {
    const lo = this.lo << 1;
    const hi = (this.hi << 1) | (this.lo >>> 31);
    return new UInt64(lo >>> 0, hi >>> 0);
  }

  /**
   * Test the MSB.
   * @return {boolean}
   */
  msb() {
    return !!(this.hi & 0x80000000);
  }

  /**
   * Test the LSB.
   * @return {boolean}
   */
  lsb() {
    return !!(this.lo & 1);
  }

  /**
   * Test whether this number is zero.
   * @return {boolean}
   */
  zero() {
    return this.lo == 0 && this.hi == 0;
  }

  /**
   * Add two 64-bit numbers to produce a 64-bit number.
   * @param {!UInt64} other
   * @return {!UInt64}
   */
  add(other) {
    const lo = ((this.lo + other.lo) & 0xffffffff) >>> 0;
    const hi = (((this.hi + other.hi) & 0xffffffff) >>> 0) +
        (((this.lo + other.lo) >= 0x100000000) ? 1 : 0);
    return new UInt64(lo >>> 0, hi >>> 0);
  }

  /**
   * Subtract two 64-bit numbers to produce a 64-bit number.
   * @param {!UInt64} other
   * @return {!UInt64}
   */
  sub(other) {
    const lo = ((this.lo - other.lo) & 0xffffffff) >>> 0;
    const hi = (((this.hi - other.hi) & 0xffffffff) >>> 0) -
        (((this.lo - other.lo) < 0) ? 1 : 0);
    return new UInt64(lo >>> 0, hi >>> 0);
  }

  /**
   * Multiply two 32-bit numbers to produce a 64-bit number.
   * @param {number} a The first integer:  must be in [0, 2^32-1).
   * @param {number} b The second integer: must be in [0, 2^32-1).
   * @return {!UInt64}
   */
  static mul32x32(a, b) {
    // Directly multiplying two 32-bit numbers may produce up to 64 bits of
    // precision, thus losing precision because of the 53-bit mantissa of
    // JavaScript numbers. So we multiply with 16-bit digits (radix 65536)
    // instead.
    const aLow = (a & 0xffff);
    const aHigh = (a >>> 16);
    const bLow = (b & 0xffff);
    const bHigh = (b >>> 16);
    let productLow =
        // 32-bit result, result bits 0-31, take all 32 bits
        (aLow * bLow) +
        // 32-bit result, result bits 16-47, take bottom 16 as our top 16
        ((aLow * bHigh) & 0xffff) * 0x10000 +
        // 32-bit result, result bits 16-47, take bottom 16 as our top 16
        ((aHigh * bLow) & 0xffff) * 0x10000;
    let productHigh =
        // 32-bit result, result bits 32-63, take all 32 bits
        (aHigh * bHigh) +
        // 32-bit result, result bits 16-47, take top 16 as our bottom 16
        ((aLow * bHigh) >>> 16) +
        // 32-bit result, result bits 16-47, take top 16 as our bottom 16
        ((aHigh * bLow) >>> 16);

    // Carry. Note that we actually have up to *two* carries due to addition of
    // three terms.
    while (productLow >= 0x100000000) {
      productLow -= 0x100000000;
      productHigh += 1;
    }

    return new UInt64(productLow >>> 0, productHigh >>> 0);
  }

  /**
   * Multiply this number by a 32-bit number, producing a 96-bit number, then
   * truncate the top 32 bits.
   * @param {number} a The multiplier.
   * @return {!UInt64}
   */
  mul(a) {
    // Produce two parts: at bits 0-63, and 32-95.
    const lo = UInt64.mul32x32(this.lo, a);
    const hi = UInt64.mul32x32(this.hi, a);
    // Left-shift hi by 32 bits, truncating its top bits. The parts will then be
    // aligned for addition.
    hi.hi = hi.lo;
    hi.lo = 0;
    return lo.add(hi);
  }

  /**
   * Divide a 64-bit number by a 32-bit number to produce a
   * 64-bit quotient and a 32-bit remainder.
   * @param {number} _divisor
   * @return {!Array<!UInt64>} array of [quotient, remainder],
   * unless divisor is 0, in which case an empty array is returned.
   */
  div(_divisor) {
    if (_divisor == 0) {
      return [];
    }

    // We perform long division using a radix-2 algorithm, for simplicity (i.e.,
    // one bit at a time). TODO: optimize to a radix-2^32 algorithm, taking care
    // to get the variable shifts right.
    let quotient = new UInt64(0, 0);
    let remainder = new UInt64(this.lo, this.hi);
    let divisor = new UInt64(_divisor, 0);
    let unit = new UInt64(1, 0);

    // Left-shift the divisor and unit until the high bit of divisor is set.
    while (!divisor.msb()) {
      divisor = divisor.leftShift();
      unit = unit.leftShift();
    }

    // Perform long division one bit at a time.
    while (!unit.zero()) {
      // If divisor < remainder, add unit to quotient and subtract divisor from
      // remainder.
      if (divisor.cmp(remainder) <= 0) {
        quotient = quotient.add(unit);
        remainder = remainder.sub(divisor);
      }
      // Right-shift the divisor and unit.
      divisor = divisor.rightShift();
      unit = unit.rightShift();
    }

    return [quotient, remainder];
  }

  /**
   * Convert a 64-bit number to a string.
   * @return {string}
   * @override
   */
  toString() {
    let result = '';
    let num = this;
    while (!num.zero()) {
      const divResult = num.div(10);
      const quotient = divResult[0], remainder = divResult[1];
      result = remainder.lo + result;
      num = quotient;
    }
    if (result == '') {
      result = '0';
    }
    return result;
  }

  /**
   * Parse a string into a 64-bit number. Returns `null` on a parse error.
   * @param {string} s
   * @return {?UInt64}
   */
  static fromString(s) {
    let result = new UInt64(0, 0);
    // optimization: reuse this instance for each digit.
    const digit64 = new UInt64(0, 0);
    for (let i = 0; i < s.length; i++) {
      if (s[i] < '0' || s[i] > '9') {
        return null;
      }
      const digit = parseInt(s[i], 10);
      digit64.lo = digit;
      result = result.mul(10).add(digit64);
    }
    return result;
  }

  /**
   * Make a copy of the uint64.
   * @return {!UInt64}
   */
  clone() {
    return new UInt64(this.lo, this.hi);
  }
}



/**
 * Int64 is like UInt64, but modifies string conversions to interpret the stored
 * 64-bit value as a twos-complement-signed integer. It does *not* support the
 * full range of operations that UInt64 does: only add, subtract, and string
 * conversions.
 * N.B. that multiply and divide routines are *NOT* supported. They will throw
 * exceptions. (They are not necessary to implement string conversions, which
 * are the only operations we really need in jspb.)
 * @unrestricted
 */
 class Int64{
  /**
   * @param {number} lo The low 32 bits.
   * @param {number} hi The high 32 bits.
   */
  constructor(lo, hi) {
    /**
     * The low 32 bits.
     * @public {number}
     */
    this.lo = lo;
    /**
     * The high 32 bits.
     * @public {number}
     */
    this.hi = hi;
  }

  /**
   * Add two 64-bit numbers to produce a 64-bit number.
   * @param {!Int64} other
   * @return {!Int64}
   */
  add(other) {
    const lo = ((this.lo + other.lo) & 0xffffffff) >>> 0;
    const hi = (((this.hi + other.hi) & 0xffffffff) >>> 0) +
        (((this.lo + other.lo) >= 0x100000000) ? 1 : 0);
    return new Int64(lo >>> 0, hi >>> 0);
  }

  /**
   * Subtract two 64-bit numbers to produce a 64-bit number.
   * @param {!Int64} other
   * @return {!Int64}
   */
  sub(other) {
    const lo = ((this.lo - other.lo) & 0xffffffff) >>> 0;
    const hi = (((this.hi - other.hi) & 0xffffffff) >>> 0) -
        (((this.lo - other.lo) < 0) ? 1 : 0);
    return new Int64(lo >>> 0, hi >>> 0);
  }

  /**
   * Make a copy of the int64.
   * @return {!Int64}
   */
  clone() {
    return new Int64(this.lo, this.hi);
  }

  /**
   * Convert a 64-bit number to a string.
   * @return {string}
   * @override
   */
  toString() {
    // If the number is negative, find its twos-complement inverse.
    const sign = (this.hi & 0x80000000) != 0;
    let num = new UInt64(this.lo, this.hi);
    if (sign) {
      num = new UInt64(0, 0).sub(num);
    }
    return (sign ? '-' : '') + num.toString();
  }

  /**
   * Parse a string into a 64-bit number. Returns `null` on a parse error.
   * @param {string} s
   * @return {?Int64}
   */
  static fromString(s) {
    const hasNegative = (s.length > 0 && s[0] == '-');
    if (hasNegative) {
      s = s.substring(1);
    }
    let num = UInt64.fromString(s);
    if (num === null) {
      return null;
    }
    if (hasNegative) {
      num = new UInt64(0, 0).sub(num);
    }
    return new Int64(num.lo, num.hi);
  }
}

exports = {
  UInt64,
  Int64
};

;return exports;});

//javascript/apps/jspb/binary/encoder.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview BinaryEncode defines methods for encoding Javascript values
 * into arrays of bytes compatible with the Protocol Buffer wire format.
 *
 * @author aappleby@google.com (Austin Appleby)
 */

goog.module('jspb.binary.encoder');

const BinaryConstants = goog.require('jspb.BinaryConstants');
const asserts = goog.require('goog.asserts');
const utils = goog.require('jspb.utils');

/**
 * Initial size for buffers, in bytes.
 * @const {number}
 */
const INITIAL_UINT8_BUFFER_SIZE = 64;

/**
 * Growth factor for buffers when they've overflowed.
 * @const {number}
 */
const BUFFER_GROWTH_FACTOR = 2;

/**
 * BinaryEncoder implements encoders for all the wire types specified in
 * https://developers.google.com/protocol-buffers/docs/encoding.
 */
const BinaryEncoder = class {
  constructor() {
    /** @private {!Uint8Array} */
    this.buffer_ = new Uint8Array(INITIAL_UINT8_BUFFER_SIZE);

    /** @private {number} */
    this.length_ = 0;
  }

  /**
   * Ensures that there is space in this.buffer_ to write the given number of
   * bytes. This should only be called by methods which directly manipulate
   * this.buffer_ (such as push).
   *
   * @param {number} n The number of bytes we intend to write.
   */
  ensureSpace_(n) {
    if (this.length_ + n < this.buffer_.length) {
      return;
    }

    const nextLen = Math.ceil(n + this.buffer_.length * BUFFER_GROWTH_FACTOR);
    const old = this.buffer_;
    this.buffer_ = new Uint8Array(nextLen);
    this.buffer_.set(old);
  }

  /**
   * Writes a byte to our buffer.
   * @param {number} b The byte to write.
   * @private
   */
  push(b) {
    this.ensureSpace_(1);
    this.buffer_[this.length_++] = b;
  }

  /**
   * Writes a byte array to our buffer.
   * @param {!Uint8Array} bytes The array of bytes to write.
   */
  writeBytes(bytes) {
    this.ensureSpace_(bytes.length);
    this.buffer_.set(bytes, this.length_);
    this.length_ += bytes.length;
  }

  /**
   * @return {number}
   */
  length() {
    return this.length_;
  }

  /**
   * Returns the current buffer contents then re-initializes this encoder.
   *
   * @return {!Uint8Array}
   */
  end() {
    const buffer = this.buffer_;
    const length = this.length_;
    this.length_ = 0;
    return utils.sliceUint8Array(buffer, 0, length);
  }

  /**
   * Writes the current buffer contents then re-initializes this encoder.
   *
   * @param {!Uint8Array} outBuffer
   * @param {number} outBufferOffset
   * @return {number} the number of bytes written
   */
  writeAndEnd(outBuffer, outBufferOffset) {
    const length = this.length_;
    if (length === 0) {
      // Opera does not allow writing zero-length arrays at the end of the
      // buffer (b/190101276)
      return 0;
    }
    outBuffer.set(this.buffer_.subarray(0, length), outBufferOffset);
    this.length_ = 0;
    return length;
  }

  /**
   * Encodes a 64-bit integer in 32:32 split representation into its wire-format
   * varint representation and stores it in the buffer.
   * @param {number} lowBits The low 32 bits of the int.
   * @param {number} highBits The high 32 bits of the int.
   */
  writeSplitVarint64(lowBits, highBits) {
    asserts.assert(lowBits == Math.floor(lowBits));
    asserts.assert(highBits == Math.floor(highBits));
    asserts.assert((lowBits >= 0) && (lowBits < BinaryConstants.TWO_TO_32));
    asserts.assert((highBits >= 0) && (highBits < BinaryConstants.TWO_TO_32));

    // Break the binary representation into chunks of 7 bits, set the 8th bit
    // in each chunk if it's not the final chunk, and append to the result.
    while (highBits > 0 || lowBits > 127) {
      this.push((lowBits & 0x7f) | 0x80);
      lowBits = ((lowBits >>> 7) | (highBits << 25)) >>> 0;
      highBits = highBits >>> 7;
    }
    this.push(lowBits);
  }

  /**
   * Encodes a 64-bit integer in 32:32 split representation into its wire-format
   * fixed representation and stores it in the buffer.
   * @param {number} lowBits The low 32 bits of the int.
   * @param {number} highBits The high 32 bits of the int.
   */
  writeSplitFixed64(lowBits, highBits) {
    asserts.assert(lowBits == Math.floor(lowBits));
    asserts.assert(highBits == Math.floor(highBits));
    asserts.assert((lowBits >= 0) && (lowBits < BinaryConstants.TWO_TO_32));
    asserts.assert((highBits >= 0) && (highBits < BinaryConstants.TWO_TO_32));
    this.writeUint32(lowBits);
    this.writeUint32(highBits);
  }

  /**
   * Encodes a 64-bit integer in 32:32 split representation into its wire-format
   * a zigzag varint representation and stores it in the buffer.
   * @param {number} lowBits The low 32 bits of the int.
   * @param {number} highBits The high 32 bits of the int.
   */
  writeSplitZigzagVarint64(lowBits, highBits) {
    const self = this;
    utils.toZigzag64(lowBits, highBits, function(lo, hi) {
      self.writeSplitVarint64(lo >>> 0, hi >>> 0);
    });
  }

  /**
   * Encodes a 32-bit unsigned integer into its wire-format varint
   * representation and stores it in the buffer.
   * @param {number} value The integer to convert.
   */
  writeUnsignedVarint32(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < BinaryConstants.TWO_TO_32));

    while (value > 127) {
      this.push((value & 0x7f) | 0x80);
      value = value >>> 7;
    }

    this.push(value);
  }

  /**
   * Encodes a 32-bit signed integer into its wire-format varint representation
   * and stores it in the buffer.
   * @param {number} value The integer to convert.
   */
  writeSignedVarint32(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_31) &&
        (value < BinaryConstants.TWO_TO_31));

    // Use the unsigned version if the value is not negative.
    if (value >= 0) {
      this.writeUnsignedVarint32(value);
      return;
    }

    // Write nine bytes with a _signed_ right shift so we preserve the sign bit.
    for (let i = 0; i < 9; i++) {
      this.push((value & 0x7f) | 0x80);
      value = value >> 7;
    }

    // The above loop writes out 63 bits, so the last byte is always the sign
    // bit which is always set for negative numbers.
    this.push(1);
  }

  /**
   * Encodes a 64-bit unsigned integer into its wire-format varint
   * representation and stores it in the buffer. Integers that are not
   * representable in 64 bits will be truncated.
   * @param {number} value The integer to convert.
   */
  writeUnsignedVarint64(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < BinaryConstants.TWO_TO_64));
    utils.splitInt64(value);
    this.writeSplitVarint64(utils.getSplit64Low(), utils.getSplit64High());
  }

  /**
   * Encodes a 64-bit signed integer into its wire-format varint representation
   * and stores it in the buffer. Integers that are not representable in 64 bits
   * will be truncated.
   * @param {number} value The integer to convert.
   */
  writeSignedVarint64(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_63) &&
        (value < BinaryConstants.TWO_TO_63));
    utils.splitInt64(value);
    this.writeSplitVarint64(utils.getSplit64Low(), utils.getSplit64High());
  }

  /**
   * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint
   * representation and stores it in the buffer.
   * @param {number} value The integer to convert.
   */
  writeZigzagVarint32(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_31) &&
        (value < BinaryConstants.TWO_TO_31));
    this.writeUnsignedVarint32(((value << 1) ^ (value >> 31)) >>> 0);
  }

  /**
   * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint
   * representation and stores it in the buffer. Integers not representable in
   * 64 bits will be truncated.
   * @param {number} value The integer to convert.
   */
  writeZigzagVarint64(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_63) &&
        (value < BinaryConstants.TWO_TO_63));
    utils.splitZigzag64(value);
    this.writeSplitVarint64(utils.getSplit64Low(), utils.getSplit64High());
  }

  /**
   * Encodes a JavaScript decimal string into its wire-format, zigzag-encoded
   * varint representation and stores it in the buffer. Integers not
   * representable in 64 bits will be truncated.
   * @param {string} value The integer to convert.
   */
  writeZigzagVarint64String(value) {
    const self = this;
    utils.splitDecimalString(value);
    utils.toZigzag64(
        utils.getSplit64Low(), utils.getSplit64High(), function(lo, hi) {
          self.writeSplitVarint64(lo >>> 0, hi >>> 0);
        });
  }

  /**
   * Writes an 8-bit unsigned integer to the buffer. Numbers outside the range
   * [0,2^8) will be truncated.
   * @param {number} value The value to write.
   */
  writeUint8(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < 256));
    this.push((value >>> 0) & 0xFF);
  }

  /**
   * Writes a 16-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^16) will be truncated.
   * @param {number} value The value to write.
   */
  writeUint16(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < 65536));
    this.push((value >>> 0) & 0xFF);
    this.push((value >>> 8) & 0xFF);
  }

  /**
   * Writes a 32-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^32) will be truncated.
   * @param {number} value The value to write.
   */
  writeUint32(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < BinaryConstants.TWO_TO_32));
    this.push((value >>> 0) & 0xFF);
    this.push((value >>> 8) & 0xFF);
    this.push((value >>> 16) & 0xFF);
    this.push((value >>> 24) & 0xFF);
  }

  /**
   * Writes a 64-bit unsigned integer to the buffer. Numbers outside the
   * range [0,2^64) will be truncated.
   * @param {number} value The value to write.
   */
  writeUint64(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= 0) && (value < BinaryConstants.TWO_TO_64));
    utils.splitUint64(value);
    this.writeUint32(utils.getSplit64Low());
    this.writeUint32(utils.getSplit64High());
  }

  /**
   * Writes an 8-bit integer to the buffer. Numbers outside the range
   * [-2^7,2^7) will be truncated.
   * @param {number} value The value to write.
   */
  writeInt8(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= -128) && (value < 128));
    this.push((value >>> 0) & 0xFF);
  }

  /**
   * Writes a 16-bit integer to the buffer. Numbers outside the range
   * [-2^15,2^15) will be truncated.
   * @param {number} value The value to write.
   */
  writeInt16(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert((value >= -32768) && (value < 32768));
    this.push((value >>> 0) & 0xFF);
    this.push((value >>> 8) & 0xFF);
  }

  /**
   * Writes a 32-bit integer to the buffer. Numbers outside the range
   * [-2^31,2^31) will be truncated.
   * @param {number} value The value to write.
   */
  writeInt32(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_31) &&
        (value < BinaryConstants.TWO_TO_31));
    this.push((value >>> 0) & 0xFF);
    this.push((value >>> 8) & 0xFF);
    this.push((value >>> 16) & 0xFF);
    this.push((value >>> 24) & 0xFF);
  }

  /**
   * Writes a 64-bit integer to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   * @param {number} value The value to write.
   */
  writeInt64(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_63) &&
        (value < BinaryConstants.TWO_TO_63));
    utils.splitInt64(value);
    this.writeSplitFixed64(utils.getSplit64Low(), utils.getSplit64High());
  }

  /**
   * Writes a 64-bit integer decimal strings to the buffer. Numbers outside the
   * range [-2^63,2^63) will be truncated.
   * @param {string} value The value to write.
   */
  writeInt64String(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (+value >= -BinaryConstants.TWO_TO_63) &&
        (+value < BinaryConstants.TWO_TO_63));
    utils.splitDecimalString(value);
    this.writeSplitFixed64(utils.getSplit64Low(), utils.getSplit64High());
  }

  /**
   * Writes a single-precision floating point value to the buffer. Numbers
   * requiring more than 32 bits of precision will be truncated.
   * @param {number} value The value to write.
   */
  writeFloat(value) {
    asserts.assert(
        value === Infinity || value === -Infinity || isNaN(value) ||
        ((value >= -BinaryConstants.FLOAT32_MAX) &&
         (value <= BinaryConstants.FLOAT32_MAX)));
    utils.splitFloat32(value);
    this.writeUint32(utils.getSplit64Low());
  }

  /**
   * Writes a double-precision floating point value to the buffer. As this is
   * the native format used by JavaScript, no precision will be lost.
   * @param {number} value The value to write.
   */
  writeDouble(value) {
    asserts.assert(
        value === Infinity || value === -Infinity || isNaN(value) ||
        ((value >= -BinaryConstants.FLOAT64_MAX) &&
         (value <= BinaryConstants.FLOAT64_MAX)));
    utils.splitFloat64(value);
    this.writeUint32(utils.getSplit64Low());
    this.writeUint32(utils.getSplit64High());
  }

  /**
   * Writes a boolean value to the buffer as a varint. We allow numbers as input
   * because the JSPB code generator uses 0/1 instead of true/false to save
   * space in the string representation of the proto.
   * @param {boolean|number} value The value to write.
   */
  writeBool(value) {
    asserts.assert(typeof value === 'boolean' || typeof value === 'number');
    this.push(value ? 1 : 0);
  }

  /**
   * Writes an enum value to the buffer as a varint.
   * @param {number} value The value to write.
   */
  writeEnum(value) {
    asserts.assert(value == Math.floor(value));
    asserts.assert(
        (value >= -BinaryConstants.TWO_TO_31) &&
        (value < BinaryConstants.TWO_TO_31));
    this.writeSignedVarint32(value);
  }
};

exports = {BinaryEncoder};

;return exports;});

//third_party/javascript/closure/crypt/base64.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base64 en/decoding. Not much to say here except that we
 * work with decoded values in arrays of bytes. By "byte" I mean a number
 * in [0, 255].
 */

goog.provide('goog.crypt.base64');

goog.require('goog.asserts');
goog.require('goog.crypt');
goog.require('goog.string');
goog.require('goog.userAgent');
goog.require('goog.userAgent.product');

/**
 * Default alphabet, shared between alphabets. Only 62 characters.
 * @private {string}
 */
goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
    'abcdefghijklmnopqrstuvwxyz' +
    '0123456789';


/**
 * Alphabet characters for Alphabet.DEFAULT encoding.
 * For characters without padding, please consider using
 * `goog.crypt.baseN.BASE_64` instead.
 *
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS =
    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '+/=';


/**
 * Alphabet characters for Alphabet.WEBSAFE_DOT_PADDING encoding.
 * The dot padding is no Internet Standard, according to RFC 4686.
 * https://tools.ietf.org/html/rfc4648
 * For characters without padding, please consider using
 * `goog.crypt.baseN.BASE_64_URL_SAFE` instead.
 *
 * @type {string}
 */
goog.crypt.base64.ENCODED_VALS_WEBSAFE =
    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '-_.';


/**
 * Alphabets for Base64 encoding
 * Alphabets with no padding character are for encoding without padding.
 * About the alphabets, please refer to RFC 4686.
 * https://tools.ietf.org/html/rfc4648
 * @enum {number}
 */
goog.crypt.base64.Alphabet = {
  DEFAULT: 0,
  NO_PADDING: 1,
  WEBSAFE: 2,
  WEBSAFE_DOT_PADDING: 3,
  WEBSAFE_NO_PADDING: 4,
};


/**
 * Padding chars for Base64 encoding
 * @const {string}
 * @private
 */
goog.crypt.base64.paddingChars_ = '=.';


/**
 * Check if a character is a padding character
 *
 * @param {string} char
 * @return {boolean}
 * @private
 */
goog.crypt.base64.isPadding_ = function(char) {
  'use strict';
  return goog.string.contains(goog.crypt.base64.paddingChars_, char);
};


// Static lookup maps, lazily populated by init_()

/**
 * For each `Alphabet`, maps from bytes to characters.
 *
 * @see https://jsperf.com/char-lookups
 * @type {!Object<!goog.crypt.base64.Alphabet, !Array<string>>}
 * @private
 */
goog.crypt.base64.byteToCharMaps_ = {};

/**
 * Maps characters to bytes.
 *
 * This map is used for all alphabets since, across alphabets, common chars
 * always map to the same byte.
 *
 * `null` indicates `init` has not yet been called.
 *
 * @type {?Object<string, number>}
 * @private
 */
goog.crypt.base64.charToByteMap_ = null;


/**
 * White list of implementations with known-good native atob and btoa functions.
 * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code
 * removal in per-browser compilations.
 * @private {boolean}
 */
goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ =
    goog.userAgent.GECKO || goog.userAgent.WEBKIT;


/**
 * Does this browser have a working btoa function?
 * @private {boolean}
 */
goog.crypt.base64.HAS_NATIVE_ENCODE_ =
    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||
    typeof(goog.global.btoa) == 'function';


/**
 * Does this browser have a working atob function?
 * We blacklist known-bad implementations:
 *  - IE (10+) added atob() but it does not tolerate whitespace on the input.
 * @private {boolean}
 */
goog.crypt.base64.HAS_NATIVE_DECODE_ =
    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||
    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&
     typeof(goog.global.atob) == 'function');


/**
 * Base64-encode an array of bytes.
 *
 * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
 *     value in [0, 255]) to encode.
 * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to
 *     use in encoding. Alphabet.DEFAULT is used by default.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeByteArray = function(input, alphabet) {
  'use strict';
  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce
  // size of jscompiler output, and which yields slight performance increase.
  goog.asserts.assert(
      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');

  if (alphabet === undefined) {
    alphabet = goog.crypt.base64.Alphabet.DEFAULT;
  }
  goog.crypt.base64.init_();

  const byteToCharMap = goog.crypt.base64.byteToCharMaps_[alphabet];
  const output = new Array(Math.floor(input.length / 3));
  const paddingChar = byteToCharMap[64] || '';

  // Add all blocks for which we have four output bytes.
  let inputIdx = 0;
  let outputIdx = 0;
  for (; inputIdx < input.length - 2; inputIdx += 3) {
    const byte1 = input[inputIdx];
    const byte2 = input[inputIdx + 1];
    const byte3 = input[inputIdx + 2];

    const outChar1 = byteToCharMap[byte1 >> 2];
    const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];
    const outChar3 = byteToCharMap[((byte2 & 0x0F) << 2) | (byte3 >> 6)];
    const outChar4 = byteToCharMap[byte3 & 0x3F];

    output[outputIdx++] = ((('' + outChar1) + outChar2) + outChar3) + outChar4;
  }

  // Add our trailing block, in which case we can skip computations relating to
  // byte3/outByte4.
  let byte2 = 0;
  let outChar3 = paddingChar;
  switch (input.length - inputIdx) {
    case 2:
      byte2 = input[inputIdx + 1];
      outChar3 = byteToCharMap[(byte2 & 0x0F) << 2] || paddingChar;
      // fall through.
    case 1:
      const byte1 = input[inputIdx];
      const outChar1 = byteToCharMap[byte1 >> 2];
      const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];

      output[outputIdx] =
          ((('' + outChar1) + outChar2) + outChar3) + paddingChar;
      // fall through.
    default:
      // We've ended on a block, so we have no more bytes to encode.
  }

  return output.join('');
};


/**
 * Base64-encode a string.
 *
 * @param {string} input A string to encode.
 * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to
 *     use in encoding. Alphabet.DEFAULT is used by default.
 * @return {string} The base64 encoded string.
 */
goog.crypt.base64.encodeString = function(input, alphabet) {
  'use strict';
  // Shortcut for browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {
    return goog.global.btoa(input);
  }
  return goog.crypt.base64.encodeByteArray(
      goog.crypt.stringToByteArray(input), alphabet);
};


/**
 * Base64-decode a string.
 *
 * @param {string} input Input to decode. Any whitespace is ignored, and the
 *     input maybe encoded with either supported alphabet (or a mix thereof).
 * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,
 *     which supports alternative alphabets. Note that passing false may still
 *     use the custom decoder on browsers without native support.
 * @return {string} string representing the decoded value.
 */
goog.crypt.base64.decodeString = function(input, useCustomDecoder) {
  'use strict';
  // Shortcut for browsers that implement
  // a native base64 encoder in the form of "btoa/atob"
  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !useCustomDecoder) {
    return goog.global.atob(input);
  }
  var output = '';
  function pushByte(b) {
    output += String.fromCharCode(b);
  }

  goog.crypt.base64.decodeStringInternal_(input, pushByte);

  return output;
};


/**
 * Base64-decode a string to an Array of numbers.
 *
 * In base-64 decoding, groups of four characters are converted into three
 * bytes.  If the encoder did not apply padding, the input length may not
 * be a multiple of 4.
 *
 * In this case, the last group will have fewer than 4 characters, and
 * padding will be inferred.  If the group has one or two characters, it decodes
 * to one byte.  If the group has three characters, it decodes to two bytes.
 *
 * @param {string} input Input to decode. Any whitespace is ignored, and the
 *     input maybe encoded with either supported alphabet (or a mix thereof).
 * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.
 * @return {!Array<number>} bytes representing the decoded value.
 */
goog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {
  'use strict';
  var output = [];
  function pushByte(b) {
    output.push(b);
  }

  goog.crypt.base64.decodeStringInternal_(input, pushByte);

  return output;
};


/**
 * Base64-decode a string to a Uint8Array.
 *
 * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.
 * @see http://caniuse.com/uint8array
 *
 * In base-64 decoding, groups of four characters are converted into three
 * bytes.  If the encoder did not apply padding, the input length may not
 * be a multiple of 4.
 *
 * In this case, the last group will have fewer than 4 characters, and
 * padding will be inferred.  If the group has one or two characters, it decodes
 * to one byte.  If the group has three characters, it decodes to two bytes.
 *
 * @param {string} input Input to decode. Any whitespace is ignored, and the
 *     input maybe encoded with either supported alphabet (or a mix thereof).
 * @return {!Uint8Array} bytes representing the decoded value.
 */
goog.crypt.base64.decodeStringToUint8Array = function(input) {
  'use strict';
  goog.asserts.assert(
      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher('10'),
      'Browser does not support typed arrays');
  var len = input.length;
  // Approximate the length of the array needed for output.
  // Our method varies according to the format of the input, which we can
  // consider in three categories:
  //   A) well-formed with proper padding
  //   B) well-formed without any padding
  //   C) not-well-formed, either with extra whitespace in the middle or with
  //      extra padding characters.
  //
  //  In the case of (A), (length * 3 / 4) will result in an integer number of
  //  bytes evenly divisible by 3, and we need only subtract bytes according to
  //  the padding observed.
  //
  //  In the case of (B), (length * 3 / 4) will result in a non-integer number
  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible
  //  by 3, it's well-formed with the proper amount of padding [0 padding]).
  //  This approximation can become exact by rounding down.
  //
  //  In the case of (C), the only way to get the length is to walk the full
  //  length of the string to consider each character. This is handled by
  //  tracking the number of bytes added to the array and using subarray to
  //  trim the array back down to size.
  var approxByteLength = len * 3 / 4;
  if (approxByteLength % 3) {
    // The string isn't complete, either because it didn't include padding, or
    // because it has extra white space.
    // In either case, we won't generate more bytes than are completely encoded,
    // so rounding down is appropriate to have a buffer at least as large as
    // output.
    approxByteLength = Math.floor(approxByteLength);
  } else if (goog.crypt.base64.isPadding_(input[len - 1])) {
    // The string has a round length, and has some padding.
    // Reduce the byte length according to the quantity of padding.
    if (goog.crypt.base64.isPadding_(input[len - 2])) {
      approxByteLength -= 2;
    } else {
      approxByteLength -= 1;
    }
  }
  var output = new Uint8Array(approxByteLength);
  var outLen = 0;
  function pushByte(b) {
    output[outLen++] = b;
  }

  goog.crypt.base64.decodeStringInternal_(input, pushByte);

  // Return a subarray to handle the case that input included extra whitespace
  // or extra padding and approxByteLength was incorrect.
  return output.subarray(0, outLen);
};


/**
 * @param {string} input Input to decode.
 * @param {function(number):void} pushByte result accumulator.
 * @private
 */
goog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {
  'use strict';
  goog.crypt.base64.init_();

  var nextCharIndex = 0;
  /**
   * @param {number} default_val Used for end-of-input.
   * @return {number} The next 6-bit value, or the default for end-of-input.
   */
  function getByte(default_val) {
    while (nextCharIndex < input.length) {
      var ch = input.charAt(nextCharIndex++);
      var b = goog.crypt.base64.charToByteMap_[ch];
      if (b != null) {
        return b;  // Common case: decoded the char.
      }
      if (!goog.string.isEmptyOrWhitespace(ch)) {
        throw new Error('Unknown base64 encoding at char: ' + ch);
      }
      // We encountered whitespace: loop around to the next input char.
    }
    return default_val;  // No more input remaining.
  }

  while (true) {
    var byte1 = getByte(-1);
    var byte2 = getByte(0);
    var byte3 = getByte(64);
    var byte4 = getByte(64);

    // The common case is that all four bytes are present, so if we have byte4
    // we can skip over the truncated input special case handling.
    if (byte4 === 64) {
      if (byte1 === -1) {
        return;  // Terminal case: no input left to decode.
      }
      // Here we know an intermediate number of bytes are missing.
      // The defaults for byte2, byte3 and byte4 apply the inferred padding
      // rules per the public API documentation. i.e: 1 byte
      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield
      // a single byte of output. (Recall that 64 corresponds the padding char).
    }

    var outByte1 = (byte1 << 2) | (byte2 >> 4);
    pushByte(outByte1);

    if (byte3 != 64) {
      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);
      pushByte(outByte2);

      if (byte4 != 64) {
        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;
        pushByte(outByte3);
      }
    }
  }
};


/**
 * Lazy static initialization function. Called before
 * accessing any of the static map variables.
 * @private
 */
goog.crypt.base64.init_ = function() {
  'use strict';
  if (goog.crypt.base64.charToByteMap_) {
    return;
  }
  goog.crypt.base64.charToByteMap_ = {};

  // We want quick mappings back and forth, so we precompute encoding maps.

  /** @type {!Array<string>} */
  var commonChars = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split('');
  var specialChars = [
    '+/=',  // DEFAULT
    '+/',   // NO_PADDING
    '-_=',  // WEBSAFE
    '-_.',  // WEBSAFE_DOT_PADDING
    '-_',   // WEBSAFE_NO_PADDING
  ];

  for (var i = 0; i < 5; i++) {
    // `i` is each value of the `goog.crypt.base64.Alphabet` enum
    var chars = commonChars.concat(specialChars[i].split(''));

    // Sets byte-to-char map
    goog.crypt.base64
        .byteToCharMaps_[/** @type {!goog.crypt.base64.Alphabet} */ (i)] =
        chars;

    // Sets char-to-byte map
    for (var j = 0; j < chars.length; j++) {
      var char = chars[j];

      var existingByte = goog.crypt.base64.charToByteMap_[char];
      if (existingByte === undefined) {
        goog.crypt.base64.charToByteMap_[char] = j;
      } else {
        goog.asserts.assert(existingByte === j);
      }
    }
  }
};

//javascript/apps/jspb/binary/writer.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview This file contains utilities for encoding Javascript objects
 * into binary, wire-format protocol buffers (in the form of Uint8Arrays) that
 * a server can consume directly.
 *
 * jspb's BinaryWriter class defines methods for efficiently encoding
 * Javascript objects into binary, wire-format protocol buffers and supports
 * all the fundamental field types used in protocol buffers.
 *
 * Major caveat 1 - Users of this library _must_ keep their Javascript proto
 * parsing code in sync with the original .proto file - presumably you'll be
 * using the typed jspb code generator, but if you bypass that you'll need
 * to keep things in sync by hand.
 *
 * Major caveat 2 - Javascript is unable to accurately represent integers
 * larger than 2^53 due to its use of a double-precision floating point format
 * for all numbers. BinaryWriter does not make any special effort to preserve
 * precision for values above this limit - if you need to pass 64-bit integers
 * (hash codes, for example) between the client and server without precision
 * loss, do _not_ use this library.
 *
 * Major caveat 3 - This class uses typed arrays and must not be used on older
 * browsers that do not support them.
 *
 * @author aappleby@google.com (Austin Appleby)
 */

goog.module('jspb.binary.writer');

const {Alphabet, encodeByteArray} = goog.require('goog.crypt.base64');
const {AnyFieldType} = goog.requireType('jspb.binary.any_field_type');
const {BinaryEncoder} = goog.require('jspb.binary.encoder');
const {ByteSource} = goog.requireType('jspb.binary.bytesource');
const {FieldType, TWO_TO_31, TWO_TO_32, TWO_TO_63, TWO_TO_64, WireType} = goog.require('jspb.BinaryConstants');
const {Int64, UInt64} = goog.require('jspb.arith');
const {assert, fail} = goog.require('goog.asserts');
const {byteSourceToUint8Array} = goog.require('jspb.utils');
const {encodeUtf8} = goog.require('jspb.binary.utf8');

/**
 * Describes bookmark metadata for the construction of delimited message protos.
 *
 * @record
 */
class Bookmark {
  constructor() {
    /**
     * @type {number} the total length of the serialized state before
     *     serializing a submessage.
     */
    this.lengthAtStart;

    /**
     * @type {number} The placement of the delimiter preceding a submessage in
     *     the encoder's blocks array.
     */
    this.blockIndex;
  }
}

/**
 * BinaryWriter implements encoders for all the wire types specified in
 * https://developers.google.com/protocol-buffers/docs/encoding.
 */
const BinaryWriter = class {
  constructor() {
    /**
     * Blocks of serialized data that will be concatenated once all messages
     * have been written.
     * @private {!Array<!Uint8Array>}
     */
    this.blocks_ = [];

    /**
     * Total number of bytes in the blocks_ array. Does _not_ include bytes in
     * the encoder below.
     * @private {number}
     */
    this.totalLength_ = 0;

    /**
     * Binary encoder holding pieces of a message that we're still serializing.
     * When we get to a stopping point (either the start of a new submessage, or
     * when we need to append a raw Uint8Array), the encoder's buffer will be
     * added to the block array above and the encoder will be reset.
     * @private @const {!BinaryEncoder}
     */
    this.encoder_ = new BinaryEncoder();
  }

  /**
   * Append a typed array of bytes onto the buffer.
   *
   * @param {!Uint8Array} arr The byte array to append.
   * @private
   */
  appendUint8Array_(arr) {
    const temp = this.encoder_.end();
    this.blocks_.push(temp);
    this.blocks_.push(arr);
    this.totalLength_ += temp.length + arr.length;
  }

  /**
   * Begins a new message by writing the field header and returning a bookmark
   * which we will use to patch in the message length to in endDelimited_ below.
   * @param {number} field
   * @return {!Bookmark}
   * @private
   */
  beginDelimited_(field) {
    this.writeFieldHeader_(field, WireType.DELIMITED);
    const bookmark = this.encoder_.end();
    this.blocks_.push(bookmark);
    this.totalLength_ += bookmark.length;
    return {
      lengthAtStart: this.totalLength_,
      blockIndex: this.blocks_.length - 1,
    };
  }

  /**
   * Ends a message by encoding the _change_ in length of the buffer to the
   * parent block and adds the number of bytes needed to encode that length to
   * the total byte length.
   * @param {!Bookmark} bookmark
   * @private
   */
  endDelimited_(bookmark) {
    const nextBlock = this.encoder_.end();
    this.blocks_.push(nextBlock);
    this.totalLength_ += nextBlock.length;

    // Compute the wire representation for the length of the message.
    this.encoder_.writeUnsignedVarint32(
        this.totalLength_ + this.encoder_.length() - bookmark.lengthAtStart);
    const delimiterLengthBytes = this.encoder_.end();

    // Append our block length after the existing delimiter.
    this.totalLength_ += delimiterLengthBytes.length;
    this.blocks_.splice(1 + bookmark.blockIndex, 0, delimiterLengthBytes);
  }

  /**
   * Writes a pre-serialized message to the buffer.
   * @param {!Uint8Array} bytes The array of bytes to write.
   * @param {number} start The start of the range to write.
   * @param {number} end The end of the range to write.
   */
  writeSerializedMessage(bytes, start, end) {
    this.appendUint8Array_(bytes.subarray(start, end));
  }

  /**
   * Writes a pre-serialized message to the buffer if the message and endpoints
   * are non-null.
   * @param {?Uint8Array} bytes The array of bytes to write.
   * @param {?number} start The start of the range to write.
   * @param {?number} end The end of the range to write.
   */
  maybeWriteSerializedMessage(bytes, start, end) {
    if (bytes != null && start != null && end != null) {
      this.writeSerializedMessage(bytes, start, end);
    }
  }

  /**
   * Converts the encoded data into a Uint8Array.
   * @return {!Uint8Array}
   */
  getResultBuffer() {
    const resultLength = this.totalLength_ + this.encoder_.length();
    if (resultLength === 0) {
      // Opera does not allow writing zero-length arrays at the end of the
      // buffer (b/190101276).
      return new Uint8Array(0);
    }

    const flat = new Uint8Array(resultLength);
    const blocks = this.blocks_;
    const blockCount = blocks.length;
    let offset = 0;

    for (let i = 0; i < blockCount; i++) {
      const block = blocks[i];
      if (block.length === 0) {
        // Opera does not allow writing zero-length arrays at the end of the
        // buffer (b/190101276).
        continue;
      }
      flat.set(block, offset);
      offset += block.length;
    }

    // Write the final block and omit the final copy.
    offset += this.encoder_.writeAndEnd(flat, offset);

    // Post condition: `flattened` must have had every byte written.
    assert(offset == flat.length);

    // Replace our block list with the flattened block, which lets GC reclaim
    // the temp blocks sooner.
    this.blocks_ = [flat];

    return flat;
  }

  /**
   * Converts the encoded data into a base64-encoded string.
   * @param {!Alphabet=} alphabet Which flavor of base64 to
   *     use.
   * @return {string}
   */
  getResultBase64String(alphabet) {
    return encodeByteArray(this.getResultBuffer(), alphabet);
  }

  /**
   * Encodes a (field number, wire type) tuple into a wire-format field header
   * and stores it in the buffer as a varint.
   * @param {number} field The field number.
   * @param {number} wireType The wire-type of the field, as specified in the
   *     protocol buffer documentation.
   * @private
   */
  writeFieldHeader_(field, wireType) {
    assert(field >= 1 && field == Math.floor(field));
    const x = field * 8 + wireType;
    this.encoder_.writeUnsignedVarint32(x);
  }

  /**
   * Writes a field of any valid scalar type to the binary stream.
   * @param {!FieldType} fieldType
   * @param {number} field
   * @param {!AnyFieldType} value
   */
  writeAny(fieldType, field, value) {
    const fieldTypes = FieldType;
    switch (fieldType) {
      case fieldTypes.DOUBLE:
        this.writeDouble(field, /** @type {number} */ (value));
        return;
      case fieldTypes.FLOAT:
        this.writeFloat(field, /** @type {number} */ (value));
        return;
      case fieldTypes.INT64:
        this.writeInt64(field, /** @type {number} */ (value));
        return;
      case fieldTypes.UINT64:
        this.writeUint64(field, /** @type {number} */ (value));
        return;
      case fieldTypes.INT32:
        this.writeInt32(field, /** @type {number} */ (value));
        return;
      case fieldTypes.FIXED64:
        this.writeFixed64(field, /** @type {number} */ (value));
        return;
      case fieldTypes.FIXED32:
        this.writeFixed32(field, /** @type {number} */ (value));
        return;
      case fieldTypes.BOOL:
        this.writeBool(field, /** @type {boolean} */ (value));
        return;
      case fieldTypes.STRING:
        this.writeString(field, /** @type {string} */ (value));
        return;
      case fieldTypes.GROUP:
        fail('Group field type not supported in writeAny()');
        return;
      case fieldTypes.MESSAGE:
        fail('Message field type not supported in writeAny()');
        return;
      case fieldTypes.BYTES:
        this.writeBytes(field, /** @type {?Uint8Array} */ (value));
        return;
      case fieldTypes.UINT32:
        this.writeUint32(field, /** @type {number} */ (value));
        return;
      case fieldTypes.ENUM:
        this.writeEnum(field, /** @type {number} */ (value));
        return;
      case fieldTypes.SFIXED32:
        this.writeSfixed32(field, /** @type {number} */ (value));
        return;
      case fieldTypes.SFIXED64:
        this.writeSfixed64(field, /** @type {number} */ (value));
        return;
      case fieldTypes.SINT32:
        this.writeSint32(field, /** @type {number} */ (value));
        return;
      case fieldTypes.SINT64:
        this.writeSint64(field, /** @type {number} */ (value));
        return;
      default:
        fail('Invalid field type in writeAny()');
        return;
    }
  }

  /**
   * Writes a varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeUnsignedVarint32_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint32(value);
  }

  /**
   * Writes a varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeSignedVarint32_(field, value) {
    if (value == null) return;
    assertSignedInteger(field, value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(value);
  }

  /**
   * Writes a varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeUnsignedVarint64_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeUnsignedVarint64(value);
  }

  /**
   * Writes a varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeSignedVarint64_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint64(value);
  }

  /**
   * Writes a zigzag varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeZigzagVarint32_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint32(value);
  }

  /**
   * Writes a zigzag varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   * @private
   */
  writeZigzagVarint64_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64(value);
  }

  /**
   * Writes a zigzag varint field to the buffer without range checking.
   * @param {number} field The field number.
   * @param {string?} value The value to write.
   * @private
   */
  writeZigzagVarint64String_(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeZigzagVarint64String(value);
  }

  /**
   * Writes an int32 field to the buffer. Numbers outside the range [-2^31,2^31)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeInt32(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_31) && (value < TWO_TO_31));
    this.writeSignedVarint32_(field, value);
  }

  /**
   * Writes an int64 field to the buffer. Numbers outside the range [-2^63,2^63)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeInt64(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_63) && (value < TWO_TO_63));
    this.writeSignedVarint64_(field, value);
  }

  /**
   * Writes a int64 field (with value as a string) to the buffer.
   * @param {number} field The field number.
   * @param {string?} value The value to write.
   */
  writeInt64String(field, value) {
    if (value == null) return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }

  /**
   * Writes a uint32 field to the buffer. Numbers outside the range [0,2^32)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeUint32(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= 0) && (value < TWO_TO_32));
    this.writeUnsignedVarint32_(field, value);
  }


  /**
   * Writes a uint64 field to the buffer. Numbers outside the range [0,2^64)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeUint64(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= 0) && (value < TWO_TO_64));
    this.writeUnsignedVarint64_(field, value);
  }

  /**
   * Writes a uint64 field (with value as a string) to the buffer.
   * @param {number} field The field number.
   * @param {string?} value The value to write.
   */
  writeUint64String(field, value) {
    if (value == null) return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(num.lo, num.hi);
  }

  /**
   * Writes an sint32 field to the buffer. Numbers outside the range
   * [-2^31,2^31) will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeSint32(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_31) && (value < TWO_TO_31));
    this.writeZigzagVarint32_(field, value);
  }

  /**
   * Writes an sint64 field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeSint64(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_63) && (value < TWO_TO_63));
    this.writeZigzagVarint64_(field, value);
  }

  /**
   * Writes an sint64 field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   * @param {number} field The field number.
   * @param {string?} value The decimal string to write.
   */
  writeSint64String(field, value) {
    if (value == null) return;
    this.writeZigzagVarint64String_(field, value);
  }

  /**
   * Writes a fixed32 field to the buffer. Numbers outside the range [0,2^32)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeFixed32(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= 0) && (value < TWO_TO_32));
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeUint32(value);
  }

  /**
   * Writes a fixed64 field to the buffer. Numbers outside the range [0,2^64)
   * will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeFixed64(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= 0) && (value < TWO_TO_64));
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeUint64(value);
  }

  /**
   * Writes a fixed64 field (with value as a string) to the buffer.
   * @param {number} field The field number.
   * @param {string?} value The value to write.
   */
  writeFixed64String(field, value) {
    if (value == null) return;
    const num = UInt64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }

  /**
   * Writes a sfixed32 field to the buffer. Numbers outside the range
   * [-2^31,2^31) will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeSfixed32(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_31) && (value < TWO_TO_31));
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeInt32(value);
  }

  /**
   * Writes a sfixed64 field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeSfixed64(field, value) {
    if (value == null) return;
    assertThat(field, value, (value >= -TWO_TO_63) && (value < TWO_TO_63));
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeInt64(value);
  }

  /**
   * Writes a sfixed64 string field to the buffer. Numbers outside the range
   * [-2^63,2^63) will be truncated.
   * @param {number} field The field number.
   * @param {string?} value The value to write.
   */
  writeSfixed64String(field, value) {
    if (value == null) return;
    const num = Int64.fromString(value);
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(num.lo, num.hi);
  }

  /**
   * Writes a single-precision floating point field to the buffer. Numbers
   * requiring more than 32 bits of precision will be truncated.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeFloat(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.FIXED32);
    this.encoder_.writeFloat(value);
  }

  /**
   * Writes a double-precision floating point field to the buffer. As this is
   * the native format used by JavaScript, no precision will be lost.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeDouble(field, value) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeDouble(value);
  }

  /**
   * Writes a boolean field to the buffer. We allow numbers as input
   * because the JSPB code generator uses 0/1 instead of true/false to save
   * space in the string representation of the proto.
   * @param {number} field The field number.
   * @param {boolean?|number?} value The value to write.
   */
  writeBool(field, value) {
    if (value == null) return;
    assertThat(
        field, value, typeof value === 'boolean' || typeof value === 'number');
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeBool(value);
  }

  /**
   * Writes an enum field to the buffer.
   * @param {number} field The field number.
   * @param {number?} value The value to write.
   */
  writeEnum(field, value) {
    if (value == null) return;
    // Converting since value might be object typed integer here.
    const intValue = /** number */ parseInt(value, 10);
    assertSignedInteger(field, intValue);
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSignedVarint32(intValue);
  }

  /**
   * Writes a string field to the buffer.
   * @param {number} field The field number.
   * @param {string?} value The string to write.
   */
  writeString(field, value) {
    if (value == null) return;
    this.writeUint8Array(field, encodeUtf8(value));
  }

  /**
   * Writes an arbitrary byte field to the buffer. Note - to match the behavior
   * of the C++ implementation, empty byte arrays _are_ serialized.
   * @param {number} field The field number.
   * @param {?ByteSource} value The array of bytes to write.
   */
  writeBytes(field, value) {
    if (value == null) return;
    this.writeUint8Array(field, byteSourceToUint8Array(value));
  }

  /**
   * @param {number} field The field number.
   * @param {!Uint8Array} value The array of bytes to write.
   * @private
   */
  writeUint8Array(field, value) {
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length);
    this.appendUint8Array_(value);
  }

  /**
   * Writes a message to the buffer.
   * @param {number} field The field number.
   * @param {?MessageType} value The message to write.
   * @param {function(MessageTypeNonNull, !BinaryWriter)} writerCallback
   *     Will be invoked with the value to write and the writer to write it
   * with.
   * @template MessageType
   * Use go/closure-ttl to declare a non-nullable version of MessageType.
   * Replace the null in blah|null with none.  This is necessary because the
   * compiler will infer MessageType to be nullable if the value parameter is
   * nullable.
   * @template MessageTypeNonNull :=
   *     cond(isUnknown(MessageType), unknown(),
   *       mapunion(MessageType, (X) =>
   *         cond(eq(X, 'null'), none(), X)))
   * =:
   */
  writeMessage(field, value, writerCallback) {
    if (value == null) return;
    const bookmark = this.beginDelimited_(field);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
  }

  /**
   * Writes a message set extension to the buffer.
   * @param {number} field The field number for the extension.
   * @param {?MessageType} value The extension message object to write. Note
   *     that message set can only have extensions with type of optional
   *     message.
   * @param {function(!MessageTypeNonNull, !BinaryWriter)} writerCallback
   *     Will be invoked with the value to write and the writer to write it
   * with.
   * @template MessageType
   * Use go/closure-ttl to declare a non-nullable version of MessageType.
   * Replace the null in blah|null with none.  This is necessary because the
   * compiler will infer MessageType to be nullable if the value parameter is
   * nullable.
   * @template MessageTypeNonNull :=
   *     cond(isUnknown(MessageType), unknown(),
   *       mapunion(MessageType, (X) =>
   *         cond(eq(X, 'null'), none(), X)))
   * =:
   */
  writeMessageSet(field, value, writerCallback) {
    if (value == null) return;
    // The wire format for a message set is defined by
    // google3/net/proto/message_set.proto
    this.writeFieldHeader_(1, WireType.START_GROUP);
    this.writeFieldHeader_(2, WireType.VARINT);
    this.encoder_.writeSignedVarint32(field);
    const bookmark = this.beginDelimited_(3);
    writerCallback(value, this);
    this.endDelimited_(bookmark);
    this.writeFieldHeader_(1, WireType.END_GROUP);
  }

  /**
   * Writes a group message to the buffer.
   *
   * @param {number} field The field number.
   * @param {?MessageType} value The message to write, wrapped with START_GROUP
   *     / END_GROUP tags. Will be a no-op if 'value' is null.
   * @param {function(MessageTypeNonNull, !BinaryWriter)} writerCallback
   *     Will be invoked with the value to write and the writer to write it
   * with.
   * @template MessageType
   * Use go/closure-ttl to declare a non-nullable version of MessageType.
   * Replace the null in blah|null with none.  This is necessary because the
   * compiler will infer MessageType to be nullable if the value parameter is
   * nullable.
   * @template MessageTypeNonNull :=
   *     cond(isUnknown(MessageType), unknown(),
   *       mapunion(MessageType, (X) =>
   *         cond(eq(X, 'null'), none(), X)))
   * =:
   */
  writeGroup(field, value, writerCallback) {
    if (value == null) return;
    this.writeFieldHeader_(field, WireType.START_GROUP);
    writerCallback(value, this);
    this.writeFieldHeader_(field, WireType.END_GROUP);
  }

  /**
   * Writes a 64-bit field to the buffer as a fixed64.
   * @param {number} field The field number.
   * @param {number} lowBits The low 32 bits.
   * @param {number} highBits The high 32 bits.
   */
  writeSplitFixed64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.FIXED64);
    this.encoder_.writeSplitFixed64(lowBits, highBits);
  }

  /**
   * Writes a 64-bit field to the buffer as a varint.
   * @param {number} field The field number.
   * @param {number} lowBits The low 32 bits.
   * @param {number} highBits The high 32 bits.
   */
  writeSplitVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitVarint64(lowBits, highBits);
  }

  /**
   * Writes a 64-bit field to the buffer as a zigzag encoded varint.
   * @param {number} field The field number.
   * @param {number} lowBits The low 32 bits.
   * @param {number} highBits The high 32 bits.
   */
  writeSplitZigzagVarint64(field, lowBits, highBits) {
    this.writeFieldHeader_(field, WireType.VARINT);
    this.encoder_.writeSplitZigzagVarint64(lowBits >>> 0, highBits >>> 0);
  }

  /**
   * Writes an array of numbers to the buffer as a repeated 32-bit int field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedInt32(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint32_(field, value[i]);
    }
  }


  /**
   * Writes an array of numbers to the buffer as a repeated 64-bit int field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedInt64(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSignedVarint64_(field, value[i]);
    }
  }

  /**
   * Writes an array of 64-bit values to the buffer as a fixed64.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writeRepeatedSplitFixed64(field, value, lo, hi) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitFixed64(field, lo(value[i]), hi(value[i]));
    }
  }

  /**
   * Writes an array of 64-bit values to the buffer as a varint.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writeRepeatedSplitVarint64(field, value, lo, hi) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitVarint64(field, lo(value[i]), hi(value[i]));
    }
  }

  /**
   * Writes an array of 64-bit values to the buffer as a zigzag varint.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writeRepeatedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSplitZigzagVarint64(field, lo(value[i]), hi(value[i]));
    }
  }

  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * 64-bit int field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of ints to write.
   */
  writeRepeatedInt64String(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeInt64String(field, value[i]);
    }
  }

  /**
   * Writes an array numbers to the buffer as a repeated unsigned 32-bit int
   *     field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedUint32(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint32_(field, value[i]);
    }
  }

  /**
   * Writes an array numbers to the buffer as a repeated unsigned 64-bit int
   *     field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedUint64(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeUnsignedVarint64_(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers formatted as strings to the buffer as a repeated
   * unsigned 64-bit int field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of ints to write.
   */
  writeRepeatedUint64String(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeUint64String(field, value[i]);
    }
  }

  /**
   * Writes an array numbers to the buffer as a repeated signed 32-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedSint32(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint32_(field, value[i]);
    }
  }

  /**
   * Writes an array numbers to the buffer as a repeated signed 64-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedSint64(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64_(field, value[i]);
    }
  }

  /**
   * Writes an array numbers to the buffer as a repeated signed 64-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of ints to write.
   */
  writeRepeatedSint64String(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeZigzagVarint64String_(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated fixed32 field. This
   * works for both signed and unsigned fixed32s.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedFixed32(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed32(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated fixed64 field. This
   * works for both signed and unsigned fixed64s.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedFixed64(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated fixed64 field. This
   * works for both signed and unsigned fixed64s.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of decimal strings to write.
   */
  writeRepeatedFixed64String(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeFixed64String(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated sfixed32 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedSfixed32(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed32(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated sfixed64 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedSfixed64(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64(field, value[i]);
    }
  }

  /**
   * Writes an array of decimal strings to the buffer as a repeated sfixed64
   * field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of decimal strings to write.
   */
  writeRepeatedSfixed64String(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeSfixed64String(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated float field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedFloat(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeFloat(field, value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a repeated double field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedDouble(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeDouble(field, value[i]);
    }
  }

  /**
   * Writes an array of booleans to the buffer as a repeated bool field.
   * @param {number} field The field number.
   * @param {?Array<boolean>} value The array of ints to write.
   */
  writeRepeatedBool(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeBool(field, value[i]);
    }
  }

  /**
   * Writes an array of enums to the buffer as a repeated enum field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writeRepeatedEnum(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeEnum(field, value[i]);
    }
  }

  /**
   * Writes an array of strings to the buffer as a repeated string field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of strings to write.
   */
  writeRepeatedString(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeString(field, value[i]);
    }
  }

  /**
   * Writes an array of arbitrary byte fields to the buffer.
   * @param {number} field The field number.
   * @param {?Array<!ByteSource>} value The arrays of arrays of bytes to
   *     write.
   */
  writeRepeatedBytes(field, value) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeBytes(field, value[i]);
    }
  }

  /**
   * Writes an array of messages to the buffer.
   * @template MessageType
   * @param {number} field The field number.
   * @param {?Array<MessageType>} value The array of messages to
   *    write.
   * @param {function(MessageType, !BinaryWriter)} writerCallback
   *     Will be invoked with the value to write and the writer to write it
   * with.
   */
  writeRepeatedMessage(field, value, writerCallback) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      const bookmark = this.beginDelimited_(field);
      writerCallback(value[i], this);
      this.endDelimited_(bookmark);
    }
  }

  /**
   * Writes an array of group messages to the buffer.
   * @template MessageType
   * @param {number} field The field number.
   * @param {?Array<MessageType>} value The array of messages to
   *    write.
   * @param {function(MessageType, !BinaryWriter)} writerCallback
   *     Will be invoked with the value to write and the writer to write it
   * with.
   */
  writeRepeatedGroup(field, value, writerCallback) {
    if (value == null) return;
    for (let i = 0; i < value.length; i++) {
      this.writeFieldHeader_(field, WireType.START_GROUP);
      writerCallback(value[i], this);
      this.writeFieldHeader_(field, WireType.END_GROUP);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed 32-bit int field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedInt32(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      assertSignedInteger(field, value[i]);
      this.encoder_.writeSignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * 32-bit int field.
   * @param {number} field
   * @param {?Array<string>} value
   */
  writePackedInt32String(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const intValue = parseInt(value[i], 10);
      assertSignedInteger(field, intValue);
      this.encoder_.writeSignedVarint32(intValue);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers to the buffer as a packed 64-bit int field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedInt64(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of 64-bit values to the buffer as a fixed64.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writePackedSplitFixed64(field, value, lo, hi) {
    if (value == null) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitFixed64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of 64-bit values to the buffer as a varint.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writePackedSplitVarint64(field, value, lo, hi) {
    if (value == null) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeSplitVarint64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of 64-bit values to the buffer as a zigzag varint.
   * @param {number} field The field number.
   * @param {?Array<T>} value The value.
   * @param {function(T): number} lo Function to get low bits.
   * @param {function(T): number} hi Function to get high bits.
   * @template T
   */
  writePackedSplitZigzagVarint64(field, value, lo, hi) {
    if (value == null) return;
    const bookmark = this.beginDelimited_(field);
    const encoder = this.encoder_;
    for (let i = 0; i < value.length; i++) {
      encoder.writeSplitZigzagVarint64(lo(value[i]), hi(value[i]));
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * 64-bit int field.
   * @param {number} field
   * @param {?Array<string>} value
   */
  writePackedInt64String(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = Int64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array numbers to the buffer as a packed unsigned 32-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedUint32(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array numbers to the buffer as a packed unsigned 64-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedUint64(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUnsignedVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * unsigned 64-bit int field.
   * @param {number} field
   * @param {?Array<string>} value
   */
  writePackedUint64String(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitVarint64(num.lo, num.hi);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array numbers to the buffer as a packed signed 32-bit int field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedSint32(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint32(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers to the buffer as a packed signed 64-bit int
   * field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedSint64(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint64(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of decimal strings to the buffer as a packed signed 64-bit
   * int field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of decimal strings to write.
   */
  writePackedSint64String(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeZigzagVarint64String(value[i]);
    }
    this.endDelimited_(bookmark);
  }

  /**
   * Writes an array of numbers to the buffer as a packed fixed32 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedFixed32(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint32(value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed fixed64 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedFixed64(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeUint64(value[i]);
    }
  }

  /**
   * Writes an array of numbers represented as strings to the buffer as a packed
   * fixed64 field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of strings to write.
   */
  writePackedFixed64String(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      const num = UInt64.fromString(value[i]);
      this.encoder_.writeSplitFixed64(num.lo, num.hi);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed sfixed32 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedSfixed32(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt32(value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed sfixed64 field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedSfixed64(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64(value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed sfixed64 field.
   * @param {number} field The field number.
   * @param {?Array<string>} value The array of decimal strings to write.
   */
  writePackedSfixed64String(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeInt64String(value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed float field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedFloat(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 4);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeFloat(value[i]);
    }
  }

  /**
   * Writes an array of numbers to the buffer as a packed double field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedDouble(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length * 8);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeDouble(value[i]);
    }
  }

  /**
   * Writes an array of booleans to the buffer as a packed bool field.
   * @param {number} field The field number.
   * @param {?Array<boolean>} value The array of ints to write.
   */
  writePackedBool(field, value) {
    if (value == null || !value.length) return;
    this.writeFieldHeader_(field, WireType.DELIMITED);
    this.encoder_.writeUnsignedVarint32(value.length);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeBool(value[i]);
    }
  }

  /**
   * Writes an array of enums to the buffer as a packed enum field.
   * @param {number} field The field number.
   * @param {?Array<number>} value The array of ints to write.
   */
  writePackedEnum(field, value) {
    if (value == null || !value.length) return;
    const bookmark = this.beginDelimited_(field);
    for (let i = 0; i < value.length; i++) {
      this.encoder_.writeEnum(value[i]);
    }
    this.endDelimited_(bookmark);
  }
};

/**
 * Asserts that the value is signed integer.
 * @param {number} field
 * @param {?} value
 */
function assertSignedInteger(field, value) {
  assertThat(field, value, value === Math.floor(value));
  assertThat(field, value, value >= -TWO_TO_31 && value < TWO_TO_31);
}

/**
 * Asserts the condition.
 * @param {number} field
 * @param {?} value
 * @param {?} condition
 */
function assertThat(field, value, condition) {
  // Manual assertion here instead of asserts.assert(...) call for perf
  // reasons, to avoid unnecessary string concatenations.
  if (!condition) {
    fail(`for [${value}] at [${field}]`);
  }
}


exports = {BinaryWriter};

;return exports;});

//javascript/apps/jspb/binary/writer_alias.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Legacy alias for the old namespace used by writer.js
 */
goog.module('jspb.BinaryWriter');
goog.module.declareLegacyNamespace();

const {BinaryWriter} = goog.require('jspb.binary.writer');

exports = BinaryWriter;

;return exports;});

//javascript/apps/jspb/freezer_loading_info.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview this file stores a value to record if the freezer is loaded. It
 * is in a separate module such that both message.js and map.js can depend on it
 * directly.
 */

goog.module('jspb.Freezer.Loading.Info');

/**
 * If freezer is loaded. Currently, the use of message freezer is restricted.
 *
 * This property makes it easier for the JsCompiler to prove that freeze
 * is unused and eliminate the code for users who don't load freezer.js.
 * @package
 */
let isFreezerLoaded = false;

exports = {isFreezerLoaded};

;return exports;});

//javascript/apps/jspb/internal.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Internal runtime fucntionality for JSPB, shared between Message
 * and Freezer.
 * @package
 */
goog.module('jspb.internal');

const FreezerInfo = goog.require('jspb.Freezer.Loading.Info');
const base64 = goog.require('goog.crypt.base64');
const {ENABLE_ASSERTS, assert, fail} = goog.require('goog.asserts');

/**
 * Inner interface of the structure of a Message.
 *
 * <p>This can contain whatever we need in order to move functionality into this
 * file and out of message.js.  Because of the `exports` in message.js all
 * functionality needs to be exposed as properties on `Message`, as such it will
 * be inherited by es6 subclasses due to static-side inheritance.  To avoid that
 * internal functionality should be moved here.
 *
 * @interface
 */
class InternalMessage {
  constructor() {
    /** @package @const {!Array} */
    this.internalArray_;
    /** @package @const {number} */
    this.arrayIndexOffset;
    /** @package @type {?Object} */
    this.internalExtensionObject_;
  }
}

/**
 * Returns the index into msg.array at which the proto field with tag number
 * fieldNumber will be located.
 * @return {number}
 */
function indexFromFieldNumber(
    /** !InternalMessage */ msg, /** number */ fieldNumber) {
  return fieldNumber + msg.arrayIndexOffset;
}

/**
 * Returns the tag number based on the index in msg.array.
 * @return {number}
 */
function fieldNumberFromIndex(
    /** !InternalMessage */ msg, /** number */ index) {
  return index - msg.arrayIndexOffset;
}

/**
 * Returns true if the provided message has been frozen.
 * @param {!InternalMessage} msg Message to check.
 * @return {boolean}
 * @package
 */
function isFrozen(msg) {
  if (FreezerInfo.isFreezerLoaded) {
    return Object.isFrozen(msg.internalArray_);
  }
  return false;
}

/**
 * Freeze a message or an array.
 * @param {!InternalMessage|!Array} value
 * @package
 */
function internalMarkFrozen(value) {
  assert(FreezerInfo.isFreezerLoaded);
  if (Array.isArray(value)) {
    Object.freeze(value);
  } else {
    Object.freeze(value.internalArray_);
    if (value.internalExtensionObject_) {
      Object.freeze(value.internalExtensionObject_);
    }
  }
}


/**
 * Does this JavaScript environment support Uint8Aray typed arrays?
 * @const {boolean}
 */
const SUPPORTS_UINT8ARRAY = (typeof Uint8Array === 'function');

/**
 * Returns true if the provided argument is an extension object.
 * @param {*} o The object to classify as array or not.
 * @return {boolean} True if the provided object is an extension object.
 */
function isExtensionObject(o) {
  // Normal fields are never objects, so we can be sure that if we find an
  // object here, then it's the extension object. However, we must ensure that
  // the object is not an array, since arrays are valid field values (bytes
  // fields can also be array).
  // NOTE(lukestebbing): We avoid looking at .length to avoid a JIT bug
  // in Safari on iOS 8. See the description of CL/86511464 for details.
  return (
      o !== null && typeof o == 'object' && !Array.isArray(o) &&
      !(SUPPORTS_UINT8ARRAY && o instanceof Uint8Array));
}


/**
 * Helper method to ensure that properties iterated with for-in loop come from
 * the object. If JS runs on a pages with other 3rd party code it's possible
 * that that code (e.g. prototype.js) patches native Object.prototype. Without
 * hasOwnProperty JSPB code might get broken by that. Most google code runs on
 * owned pages and it's very unlikely to get patched native prototype. So by
 * default this check always returns true. The check is only enabled when
 * goog.TRUSTED_SITE is set to false.
 *
 * @param {!Object} obj
 * @param {string} property
 * @return {boolean}
 */
function hasOwnPropertyIfNotTrusted(obj, property) {
  return goog.TRUSTED_SITE ||
      Object.prototype.hasOwnProperty.call(obj, property);
}

/**
 * Helper for cloning an internal JsPb object.
 * @param {!Array<?>} obj A JsPb object, eg, a field, to be cloned.
 * @return {!Array<?>} A clone of the input object.
 */
function cloneJspb(obj) {
  return /** @type {!Array<?>} */ (cloneJspbObjectInternal(
      obj,
      /* convertPrimitive = */ (v) => v,
      /* convertUint8Array = */ (v) => new Uint8Array(v)));
}

/**
 * Helper for cloning an internal JsPb object.
 * @param {*} f A JsPb field to be cloned.
 * @param {(function(*): *)} convertPrimitive a function to map onto all
 *     primitive values in this object.
 * @param {(function(!Uint8Array): (string|!Uint8Array))} convertUint8Array a
 *     function to map onto all Uint8Array values in this object.
 * @return {*} A clone of the input object.
 */
function cloneJspbFieldInternal(f, convertPrimitive, convertUint8Array) {
  return (typeof f === 'object') ?
      ((SUPPORTS_UINT8ARRAY && !Array.isArray(f) && f instanceof Uint8Array) ?
           convertUint8Array(f) :
           cloneJspbObjectInternal(
               assert(f), convertPrimitive, convertUint8Array)) :
      convertPrimitive(f);
}

/**
 * Helper for cloning an internal JsPb object.
 * @param {!Object} obj A JsPb object, eg, a field, to be cloned.
 * @param {(function(*): *)} convertPrimitive a function to map onto all
 *     primitive values in this object.
 * @param {(function(!Uint8Array): (string|!Uint8Array))} convertUint8Array a
 *     function to map onto all Uint8Array values in this object.
 * @return {!Object|string} A clone of the input object.
 */
function cloneJspbObjectInternal(obj, convertPrimitive, convertUint8Array) {
  if (Array.isArray(obj)) {
    // Allocate array of correct size.
    const clonedArray = new Array(obj.length);
    // Use array iteration where possible because it is faster than for-in.
    for (let i = 0; i < obj.length; i++) {
      const o = obj[i];
      if (o != null) {
        clonedArray[i] =
            cloneJspbFieldInternal(o, convertPrimitive, convertUint8Array);
      }
    }
    if (isRepeatedField(obj)) {
      markRepeatedField(clonedArray);
    }
    return clonedArray;
  } else /* if ((typeof obj) === 'object') */ {
    const clone = {};
    for (let key in obj) {
      if (!hasOwnPropertyIfNotTrusted(obj, key)) {
        continue;
      }
      const o = obj[key];
      if (o != null) {
        clone[key] =
            cloneJspbFieldInternal(o, convertPrimitive, convertUint8Array);
      }
    }
    return clone;
  }
}


/**
 * Returns a deep copy of the given object, converting inner fields to
 * JSON-compatible types.
 *
 * @param {T} el element to clone.
 * @return {T} A copy of this element
 * @template T
 */
function cloneToJsonFormat(el) {
  return cloneJspbObjectInternal(
      el,
      /* convertPrimitive = */ (v) => {
        if (typeof v === 'number') {
          return numberToJspbFormat(v);
        }
        return v;
      }, /* convertUint8Array = */ (v) => base64.encodeByteArray(v));
}

/**
 * Returns a deep copy of the given object, converting inner fields to
 * StructuredClone-compatible types.
 *
 * @param {T} el element to clone.
 * @return {T} A copy of this element
 * @template T
 */
function cloneToStructuredCloneableFormat(el) {
  return cloneJspbObjectInternal(
      el,
      /* convertPrimitive = */ (v) => v,
      /* convertUint8Array = */ (v) => new Uint8Array(v));
}

/**
 * Converts a number to JSPB wire format.
 *
 * @param {number} n the number to convert to JSPB format.
 * @return {number|string} the resulting JSPB-formatted number field.
 */
function numberToJspbFormat(n) {
  return isFinite(n) ? n : String(n);
}


// Explicitly test support for native Symbol because Symbol is more performant
// than generic properties, but we don't want to fallback to the polyfill since
// that creates an enumerable property which isn't desirable.
const SUPPORTS_NATIVE_SYMBOL = goog.FEATURESET_YEAR >= 2018;

const IS_REPEATED_FIELD_SYMBOL = Symbol('IS_REPEATED_FIELD');

const IS_REPEATED_FIELD_PROP = {
  isRepeatedField: {value: true, configurable: true}
};

/**
 * Returns whether arr is an empty repeated field array.
 * @param {*} arr
 * @return {boolean}
 */
const isRepeatedField = SUPPORTS_NATIVE_SYMBOL ? function(arr) {
  return Array.isArray(arr) && !!arr[IS_REPEATED_FIELD_SYMBOL];
} : function(arr) {
  return Array.isArray(arr) &&
      !!(/** @type {{isRepeatedField: (boolean|undefined)}} */ (arr))
            .isRepeatedField;
};

/**
 * Marks arr as a repeated field array.
 * @param {!Array<T>} arr
 * @return {!Array<T>} arr
 * @template T
 */
const markRepeatedField = SUPPORTS_NATIVE_SYMBOL ? function(arr) {
  if (Array.isArray(arr) && !Object.isFrozen(arr)) {
    arr[IS_REPEATED_FIELD_SYMBOL] = true;
  }
  return arr;
} : function(arr) {
  if (Array.isArray(arr) && !Object.isFrozen(arr)) {
    // Use defineProperties because we don't want it to be enumerable.
    Object.defineProperties(arr, IS_REPEATED_FIELD_PROP);
  }
  return arr;
};

/**
 * Returns a new empty array for a repeated field.
 * @return {!Array}
 */
function newRepeatedField() {
  return markRepeatedField([]);
}


/**
 * This field indicates that we're within the Message.serialize() procedure.
 *
 * @type {?boolean}
 */
let inSerialize;

/**
 * Sets whether we're within the Message.serialize() procedure.
 *
 * @param {?boolean} value
 * @package
 */
function setInSerialize(value) {
  inSerialize = value;
}


/**
 * Gets whether we're within the Message.serialize() procedure.
 *
 * @return {?boolean}
 * @package
 */
function getInSerialize() {
  return inSerialize;
}

/**
 * A marker for JSPB subclasses which have been explicitly exempted from runtime
 * enforcement. See javascript/apps/jspb/exemptions/unsupported_subclass.js and
 * its callers.
 * @const {symbol|undefined}
 * @public because it is accessed by the 'exemptions' subpackage.
 */
const EXEMPTED_SUBCLASS_MARKER = ENABLE_ASSERTS ?
    Symbol(goog.DEBUG ? 'exempted jspb subclass' : undefined) :
    undefined;

/**
 * A marker added to all generated JSPB subclasses so the runtime can verify
 * expected subclasses.
 *  @const {symbol|undefined}
 */
const GENERATED_SUBCLASS_MARKER = ENABLE_ASSERTS ?
    Symbol(goog.DEBUG ? 'generated by jspb' : undefined) :
    undefined;


/**
 * Coerce a 'bytes' field to a Uint8Array byte buffer.
 * Note that Uint8Array is not supported on IE versions before 10 nor on Opera
 * Mini. @see http://caniuse.com/Uint8Array
 * @param {string|!Uint8Array|null} value
 * @return {?Uint8Array} The field's coerced value.
 */
function bytesAsU8(value) {
  if (value == null || value instanceof Uint8Array) {
    return value;
  }
  if (typeof value === 'string') {
    return base64.decodeStringToUint8Array(value);
  }
  fail('Cannot coerce to Uint8Array: ' + goog.typeOf(value));
  return null;
}

/**
 * Compares two message extension fields recursively.
 * @param {!Object} extension1 The first field.
 * @param {!Object} extension2 The second field.
 * @return {boolean} true if the extensions are null/undefined, or otherwise
 *     equal.
 */
function compareExtensions(extension1, extension2) {
  extension1 = extension1 || {};
  extension2 = extension2 || {};

  const keys = {};
  for (let name in extension1) {
    if (!hasOwnPropertyIfNotTrusted(extension1, name)) {
      continue;
    }
    keys[name] = 0;
  }
  for (let name in extension2) {
    if (!hasOwnPropertyIfNotTrusted(extension2, name)) {
      continue;
    }
    keys[name] = 0;
  }
  for (let name in keys) {
    if (!hasOwnPropertyIfNotTrusted(keys, name)) {
      continue;
    }
    if (!compareFields(extension1[name], extension2[name])) {
      return false;
    }
  }
  return true;
}

/**
 * Compares two message fields recursively.
 * @param {*} field1 The first field.
 * @param {*} field2 The second field.
 * @return {boolean} true if the fields are null/undefined, or otherwise equal.
 */
function compareFields(field1, field2) {
  // If the fields are trivially equal, they're equal.
  if (field1 == field2) return true;

  if (SUPPORTS_UINT8ARRAY) {
    const f1IsArray = field1 instanceof Uint8Array;
    const f2IsArray = field2 instanceof Uint8Array;

    // If both are Uint8Arrays, or one is a Uint8Array and one is an encoded
    // string, compare them element-by-element.
    if (f1IsArray || f2IsArray) {
      let bytes1, bytes2;
      if (f1IsArray) {
        bytes1 = /** @type {!Uint8Array} */ (field1);
      } else if (typeof field1 === 'string') {
        bytes1 = bytesAsU8(field1);
      } else {
        return false;
      }
      if (f2IsArray) {
        bytes2 = /** @type {!Uint8Array} */ (field2);
      } else if (typeof field2 === 'string') {
        bytes2 = bytesAsU8(field2);
      } else {
        return false;
      }

      if (bytes1.length !== bytes2.length) {
        return false;
      }
      for (let i = 0; i < bytes1.length; i++) {
        if (bytes1[i] !== bytes2[i]) {
          return false;
        }
      }
      return true;
    }
  }

  // NOTE(b/70216118): Empty repeated fields can be represented as either `null`
  // or `[]`. This allows the two representations to compare equal.
  if ((field1 == null && isEmptyRepeatedField(field2)) ||
      (field2 == null && isEmptyRepeatedField(field1))) {
    return true;
  }

  if (!goog.isObject(field1) || !goog.isObject(field2)) {
    // NaN != NaN so we cover this case.
    if ((typeof field1 === 'number' && isNaN(field1)) ||
        (typeof field2 === 'number' && isNaN(field2))) {
      // One of the fields might be a string 'NaN'.
      return String(field1) == String(field2);
    }
    // If the fields aren't trivially equal and one of them isn't an object,
    // they can't possibly be equal.
    return false;
  }

  // We have two objects. If they're different types, they're not equal.
  field1 = /** @type {!Object} */ (field1);
  field2 = /** @type {!Object} */ (field2);
  if (field1.constructor != field2.constructor) return false;

  // If they're both Arrays, compare them element by element except for the
  // optional extension objects at the end, which we compare separately.
  if (field1.constructor === Array) {
    const typedField1 = /** @type {!Array<?>} */ (field1);
    const typedField2 = /** @type {!Array<?>} */ (field2);
    let extension1 = undefined;
    let extension2 = undefined;

    const length = Math.max(typedField1.length, typedField2.length);
    for (let i = 0; i < length; i++) {
      let val1 = typedField1[i];
      let val2 = typedField2[i];

      if (val1 && (val1.constructor == Object)) {
        assert(extension1 === undefined);
        assert(i === typedField1.length - 1);
        extension1 = val1;
        val1 = undefined;
      }

      if (val2 && (val2.constructor == Object)) {
        assert(extension2 === undefined);
        assert(i === typedField2.length - 1);
        extension2 = val2;
        val2 = undefined;
      }

      if (!compareFields(val1, val2)) {
        return false;
      }
    }

    if (extension1 || extension2) {
      extension1 = extension1 || {};
      extension2 = extension2 || {};
      return compareExtensions(extension1, extension2);
    }

    return true;
  }

  // If they're both plain Objects (i.e. extensions), compare them as
  // extensions.
  if (field1.constructor === Object) {
    return compareExtensions(field1, field2);
  }

  throw new Error('Invalid type in JSPB array');
}

/**
 * Returns whether arr is an empty repeated field array.
 * @param {*} arr
 * @return {boolean}
 */
function isEmptyRepeatedField(arr) {
  return isRepeatedField(arr) && !(/** @type {!Array} */ (arr)).length;
}

exports = {
  bytesAsU8,
  InternalMessage,
  SUPPORTS_UINT8ARRAY,
  cloneJspb,
  cloneToJsonFormat,
  cloneToStructuredCloneableFormat,
  compareExtensions,
  compareFields,
  fieldNumberFromIndex,
  getInSerialize,
  hasOwnPropertyIfNotTrusted,
  indexFromFieldNumber,
  internalMarkFrozen,
  isEmptyRepeatedField,
  isExtensionObject,
  isFrozen,
  isRepeatedField,
  markRepeatedField,
  newRepeatedField,
  numberToJspbFormat,
  setInSerialize,
  GENERATED_SUBCLASS_MARKER,
  EXEMPTED_SUBCLASS_MARKER,
};

;return exports;});

//javascript/apps/jspb/map.js
goog.loadModule(function(exports) {'use strict';goog.module('jspb.map');
goog.module.declareLegacyNamespace();

const FreezerInfo = goog.require('jspb.Freezer.Loading.Info');
const asserts = goog.require('goog.asserts');
const {Message} = goog.requireType('jspb');
const {cloneToJsonFormat, getInSerialize} = goog.require('jspb.internal');

/**
 * A Map is a container that is used to implement map
 * fields on message objects. It closely follows the ES6 Map API; however,
 * it is distinct because we do not want to depend on external polyfills or
 * on ES6 itself.
 *
 * @implements Iterable<!Array<K|V>>
 * @template K, V
 */
class Map {
  /**
   * This constructor should only be called from generated message code. It is
   * not intended for general use by library consumers.
   *
   * @param {!Array<!Array<?>>} arr
   *
   * @param {?function(new:V, ?=)=} valueCtor
   *    The constructor for type V, if type V is a message type.
   *
   */
  constructor(arr, valueCtor) {
    /** @const @private */
    this.arr_ = arr;
    /** @const @package */
    this.valueCtor = valueCtor;

    /** @type {!Object<string, !Entry_<K,V>>} @package */
    this.map = {};

    /**
     * Is `this.arr_ updated with respect to `this.map`?
     * @type {boolean}
     */
    this.arrClean = true;

    /**
     * If this map is marked frozen, the caller should pass a function to mark
     * the messages inside this map frozen, if the map contains messages.
     * @type {?function(!Message)}
     * @private
     */
    this.markMessageFrozenFn_ = null;

    if (this.arr_.length > 0) {
      this.loadFromArray_();
    }
  }

  /**
   * Check if the map is marked as frozen.
   * @return {boolean}
   * @package
   */
  isFrozen() {
    return FreezerInfo.isFreezerLoaded && this.markMessageFrozenFn_ != null;
  }

  /**
   * Mark this map frozen and pass a function to mark message inside this map
   * frozen, if the map contains messages.
   * @param {function(!Message)} markMessageFrozenFn The function to mark
   * message frozen. Since map.js cannot depend on message.js, map.js will have
   * repeated code to freeze a message; instead, passing that freeze function
   * via this parameter from the message's callers would avoid this problem.
   * @package
   */
  internalMarkFrozen(markMessageFrozenFn) {
    asserts.assert(FreezerInfo.isFreezerLoaded);
    this.markMessageFrozenFn_ = markMessageFrozenFn;
  }

  /**
   * Throws if trying to mutate a frozen map.
   * @private
   */
  checkNotFrozen_() {
    if (FreezerInfo.isFreezerLoaded && this.isFrozen()) {
      throw new Error("Cannot mutate a frozen Map");
    }
  }

  /**
   * Load initial content from underlying array.
   * @private
   */
  loadFromArray_() {
    for (let i = 0; i < this.arr_.length; i++) {
      const record = this.arr_[i];
      const key = record[0];
      const value = record[1];
      this.map[key.toString()] = new Entry_(key, value);
    }
    this.arrClean = true;
  }

  /**
   * Returns this JSPB map as a JSON.stringify-compatible array.
   *
   * @return {!Array} The proto represented as an array.
   * @override
   * @private
   */
  toJSON() {
    const arr = this.toArrayInternal(/* failIfFrozen = */ false);
    return getInSerialize() ? arr : cloneToJsonFormat(arr);
  }

  /**
   * Synchronize content to underlying array, if needed, and return it. Throws
   * if this map is frozen or contains frozen messages.
   * @return {!Array<!Array<!Object>>}
   * @deprecated Instead iterate over `entries()` (or `keys()`, `values()`, or
   *     use `foreach`)
   */
  toArray() {
    return this.toJSON();
  }

  /**
   * Synchronize content to underlying array, if needed, and return it.
   * @param {boolean} failIfFrozen if set and any part of this map is frozen,
   *   this method will throw.
   * @return {!Array<!Array<!Object>>}
   * @package
   */
  toArrayInternal(failIfFrozen) {
    if (this.arrClean) {
      if (this.valueCtor) {
        // We need to recursively sync maps in submessages to their arrays.
        const m = this.map;
        for (let p in m) {
          if (Object.prototype.hasOwnProperty.call(m, p)) {
            const valueWrapper = /** @type {?Message} */ (m[p].valueWrapper);
            if (valueWrapper) {
              valueWrapper.toArrayInternal(failIfFrozen);
            }
          }
        }
      }
    } else {
      // Delete all elements.
      this.arr_.length = 0;
      const strKeys = this.stringKeys_();
      // Output keys in deterministic (sorted) order.
      strKeys.sort();
      for (let i = 0; i < strKeys.length; i++) {
        const entry = this.map[strKeys[i]];
        const valueWrapper = /** @type {?Message} */ (entry.valueWrapper);
        if (valueWrapper) {
          valueWrapper.toArrayInternal(failIfFrozen);
        }
        this.arr_.push([entry.key, entry.value]);
      }
      this.arrClean = true;
    }
    return this.arr_;
  }

  /**
   * Returns the map's length (number of key/value pairs).
   * @return {number}
   */
  getLength() {
    return this.stringKeys_().length;
  }

  /**
   * Clears the map.
   */
  clear() {
    this.checkNotFrozen_();
    this.map = {};
    this.arrClean = false;
  }

  /**
   * Deletes a particular key from the map.
   * N.B.: differs in name from ES6 Map's `delete` because IE8 does not support
   * reserved words as property names.
   * @param {K} key
   * @return {boolean} Whether any entry with this key was deleted.
   */
  del(key) {
    this.checkNotFrozen_();
    const keyValue = key.toString();
    const hadKey = this.map.hasOwnProperty(keyValue);
    delete this.map[keyValue];
    this.arrClean = false;
    return hadKey;
  }

  /**
   * Returns an array of [key, value] pairs in the map.
   *
   * This is redundant compared to the plain entries() method, but we provide
   * this to help out Angular 1.x users.  Still evaluating whether this is the
   * best option.
   *
   * @return {!Array<!Array<K|V>>}
   */
  getEntryList() {
    const entries = [];
    const strKeys = this.stringKeys_();
    strKeys.sort();
    for (let i = 0; i < strKeys.length; i++) {
      const entry = this.map[strKeys[i]];
      entries.push([entry.key, entry.value]);  // TODO: why not wrapEntry_()?
    }
    return entries;
  }

  /**
   * Returns an iterator-iterable over [key, value] pairs in the map.
   * Closure compiler sadly doesn't support tuples, ie. Iterator<[K,V]>.
   * @return {!IteratorIterable<!Array<K|V>>} The iterator-iterable.
   */
  entries() {
    const entries = [];
    const strKeys = this.stringKeys_();
    strKeys.sort();
    for (let i = 0; i < strKeys.length; i++) {
      const entry = this.map[strKeys[i]];
      entries.push([entry.key, this.wrapEntry_(entry)]);
    }
    return new ArrayIteratorIterable(entries);
  }

  /**
   * Returns an iterator-iterable over keys in the map.
   * @return {!IteratorIterable<K>} The iterator-iterable.
   */
  keys() {
    const keys = [];
    const strKeys = this.stringKeys_();
    strKeys.sort();
    for (let i = 0; i < strKeys.length; i++) {
      const entry = this.map[strKeys[i]];
      keys.push(entry.key);
    }
    return new ArrayIteratorIterable(keys);
  }

  /**
   * Returns an iterator-iterable over values in the map.
   * @return {!IteratorIterable<V>} The iterator-iterable.
   */
  values() {
    const values = [];
    const strKeys = this.stringKeys_();
    strKeys.sort();
    for (let i = 0; i < strKeys.length; i++) {
      const entry = this.map[strKeys[i]];
      values.push(this.wrapEntry_(entry));
    }
    return new ArrayIteratorIterable(values);
  }

  /**
   * Iterates over entries in the map, calling a function on each.
   * @template T
   * @param {function(this:T, V, K, ?Map<K, V>)} cb
   * @param {T=} thisArg
   */
  forEach(cb, thisArg) {
    const strKeys = this.stringKeys_();
    strKeys.sort();
    for (let i = 0; i < strKeys.length; i++) {
      const entry = this.map[strKeys[i]];
      cb.call(thisArg, this.wrapEntry_(entry), entry.key, this);
    }
  }


  /**
   * Sets a key in the map to the given value.
   * @param {K} key The key
   * @param {V} value The value
   * @return {!Map<K,V>}
   */
  set(key, value) {
    this.checkNotFrozen_();
    const entry = new Entry_(key);
    if (this.valueCtor) {
      entry.valueWrapper = value;
      entry.value = value.toArrayInternal(/* failIfFrozen = */ false);
    } else {
      entry.value = value;
    }
    this.map[key.toString()] = entry;
    this.arrClean = false;
    return this;
  }

  /**
   * Sets an unconstructed/primitive value. Internal use only.
   * @param {K} key The key
   * @param {V} rawData The raw data, could be an array or a primitive
   * @package
   */
  setRawData(key, rawData) {
    let entry = new Entry_(key, rawData);
    this.map[key.toString()] = entry;
    this.arrClean = false;
  }

  /**
   * Helper: lazily construct a wrapper around an entry, if needed, and return
   * the user-visible type.
   * @param {!Entry_<K,V>} entry
   * @return {V}
   * @private
   * @suppress {visibility} Access to message's private field in order to
   *   freeze it. Cannot call Message.internalMarkFrozen because it will result
   *   in a circular dependency.
   */
  wrapEntry_(entry) {
    if (this.valueCtor) {
      if (!entry.valueWrapper) {
        entry.valueWrapper = new this.valueCtor(entry.value);
        if (this.isFrozen()) {
          asserts.assert(this.markMessageFrozenFn_ != null);
          this.markMessageFrozenFn_(
              /** @type {!Message} */ (entry.valueWrapper));
        }
      }
      return /** @type {V} */ (entry.valueWrapper);
    } else {
      return entry.value;
    }
  }

  /**
   * Gets the value corresponding to a key in the map.
   * @param {K} key
   * @return {V|undefined} The value, or `undefined` if key not present
   */
  get(key) {
    const keyValue = key.toString();
    const entry = this.map[keyValue];
    if (entry) {
      return this.wrapEntry_(entry);
    } else {
      return undefined;
    }
  }

  /**
   * Determines whether the given key is present in the map.
   * @param {K} key
   * @return {boolean} `true` if the key is present
   */
  has(key) {
    const keyValue = key.toString();
    return (keyValue in this.map);
  }

  /**
   * Helper: compute the list of all stringified keys in the underlying Object
   * map.
   * @return {!Array<string>}
   * @private
   */
  stringKeys_() {
    let m = this.map;
    const ret = [];
    for (let p in m) {
      if (Object.prototype.hasOwnProperty.call(m, p)) {
        ret.push(p);
      }
    }
    return ret;
  }

  /**
   * @override
   * @return {!Iterator<!Array<K|V>>} The iterator-iterable.
   */
  [Symbol.iterator]() {
    return this.entries();
  };
}

/**
 * @template K, V
 * @private
 */
class Entry_ {
  /**
   * @param {K} key The entry's key.
   * @param {V=} value The entry's value wrapper.
   */
  constructor(key, value) {
    /** @const {K} */
    this.key = key;

    // The JSPB-serializable value.  For primitive types this will be of type V.
    // For message types it will be an array.
    /** @type {V} */
    this.value = value;

    // Only used for submessage values.
    /** @type {V} */
    this.valueWrapper = undefined;
  }
}

/**
 * Helper: an IteratorIterable over an array.
 * @implements {IteratorIterable<T>}
 * @template T
 * @final
 */
class ArrayIteratorIterable {
  /**
   * @param {!Array<T>} arr the array
   */
  constructor(arr) {
    /** @type {number} @private */
    this.idx_ = 0;

    /** @const @private */
    this.arr_ = arr;
  }

  /**
   * @override
   * @return {!IIterableResult<T>}
   */
  next() {
    if (this.idx_ < this.arr_.length) {
      return {done: false, value: this.arr_[this.idx_++]};
    } else {
      return {done: true, value: undefined};
    }
  }

  /**
   * @override
   * @return {!Iterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  }
}

exports = {Map};

;return exports;});

//javascript/apps/jspb/message_ctor.js
goog.loadModule(function(exports) {'use strict';/** @fileoverview Utilities for message construction. */
goog.module('jspb.message_ctor');

/**
 * Construct a new message from the given data array, of the type indicated
 * by the given constructor.
 *
 * This field contains a pending constructor parameter for a subclass.
 * Generally this should be ignored and is redundant with the parameter,
 * however, due to b/178741724, the JsCompiler may delete constructor parameters
 * of our subclasses if the parameters are only passed to the constructor via
 * indirect uses of `.constructor` properties (and presumably other ways as
 * well).  We can use this parameter as a side channel to work around this
 * optimization.
 *
 * <p>Some ideas to avoid this:
 * <ul>
 *   <li>Change the JsCompiler optimization to not fire on Message subclasses.
 *   <li>Change our gencode to avoid the optimization. b/187315573
 *   <li>fix user code to not access .constructor on message subclasses.
 * </ul>
 *
 * @type{?Array<?>}
 */
let alternateDataPayload;

/**
 * Constructs a new Message instance from the given data array.
 *
 * Note that this does **not** check that the given constructor is a subclass
 * of Message, due to build cycle issues, so callers must check.
 *
 * A generic constructor for working around b/178741724
 *
 * @param {function(new:JSPB, ?Array<?>=)} ctor The constructor of the
 *     message type.
 * @param {?Array<?>} data The data as an array.
 * @return {JSPB} The new message with the serialized data populating
 *     its fields.
 * @template JSPB
 */
function newMessage(ctor, data) {
  // Put the data in our side channel so initialize can definitely find it
  alternateDataPayload = data;
  // data is needed for classes extending JSPB messages that have
  // initialization logic in addition to Message.initialize.
  const newInstance = new ctor(data);
  // Don't leak. The Message construct clears this as well but we should be
  // careful since some people subclass JSPB in weird ways
  alternateDataPayload = null;
  return newInstance;
}


/**
 * A side-channel getter for working around b/178741724.
 *
 * @return {?Array<?>} data The alternate data payload
 */
function getAndResetAlternateDataPayload() {
  const data = alternateDataPayload;
  alternateDataPayload = null;
  return data;
}

exports = {
  newMessage,
  getAndResetAlternateDataPayload,
};

;return exports;});

//javascript/apps/jspb/message.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Main library for JSPB, includes functions and classes related
 * to `Message` the baseclass of all generated protocol buffers.
 *
 * Functionality should go in this file if it is part of `Message` or is
 * directly related to `Message` and can't be reasonably used independently of
 * `Message`.  If the functionality is only needed for rare cases or by the
 * generated code, it would ideally go in a different file.
 */
goog.module('jspb');

const FreezerInfo = goog.require('jspb.Freezer.Loading.Info');
// BEGIN GOOGLE-INTERNAL
// Not needed in compilation units that have no protos with xids.
const XString = goog.requireType('xid.String');
// END GOOGLE-INTERNAL
const asserts = goog.require('goog.asserts');
const base64 = goog.require('goog.crypt.base64');
const garray = goog.require('goog.array');
const {EXEMPTED_SUBCLASS_MARKER, GENERATED_SUBCLASS_MARKER, InternalMessage, SUPPORTS_UINT8ARRAY, cloneJspb, cloneToJsonFormat, cloneToStructuredCloneableFormat, compareFields, fieldNumberFromIndex, getInSerialize, hasOwnPropertyIfNotTrusted, indexFromFieldNumber, internalMarkFrozen, isEmptyRepeatedField, isExtensionObject, isFrozen, isRepeatedField, markRepeatedField, newRepeatedField, numberToJspbFormat, setInSerialize} = goog.require('jspb.internal');
const {ExtensionFieldInfo} = goog.requireType('jspb.extension_field_info');
const {Map: JspbMap} = goog.require('jspb.map');
const {getAndResetAlternateDataPayload, newMessage} = goog.require('jspb.message_ctor');


/**
 * Base class for all JsPb messages.
 *
 * Several common methods (toObject, serializeBinary, in particular) are not
 * defined on the prototype to encourage code patterns that minimize code bloat
 * due to otherwise unused code on all protos contained in the project.
 *
 * If you want to call these methods on a generic message, either
 * pass in your instance of method as a parameter:
 *     someFunction(instanceOfKnownProto,
 *                  KnownProtoClass.prototype.serializeBinary);
 * or use a lambda that knows the type:
 *     someFunction(()=>instanceOfKnownProto.serializeBinary());
 * or, if you don't care about code size, just suppress the
 *     WARNING - Property serializeBinary never defined on Message
 * and call it the intuitive way.
 *
 * @abstract
 * @constructor
 * @struct
 * @implements {InternalMessage}
 * @param {?Array|undefined} data An initial data array.
 * @param {number=} suggestedPivot The field number at which to start putting
 *     fields into the extension object. This is only used if data does not
 *     contain an extension object already. -1 if no extension object is
 *     required for this message type.
 * @param {?Array<number>=} repeatedFields The message's repeated fields.
 * @param {?Array<!Array<number>>=} oneofFields The fields belonging to
 *     each of the message's oneof unions.
 */
const Message = function(data, suggestedPivot, repeatedFields, oneofFields) {
  // Add some debug only consistency checks
  // Were we directly called?
  asserts.assertInstanceof(
      this, Message,
      'The message constructor should only be used by subclasses');
  // Were we directly instantiated?
  asserts.assert(
      this.constructor !== Message,
      'Message is an abstract class and cannot be directly constructed');

  // Now check that we are an expected subclass, or explicitly exempted.
  if (asserts.ENABLE_ASSERTS &&
      // Cast is necessary to remove @struct
      /** @type{!Object} */ (this)[EXEMPTED_SUBCLASS_MARKER] !== true) {
    // We could technically do both checks at once with the second assert, but
    // this leads to slightly better error messages.

    // Is this a subclass of GeneratedMessage?
    asserts.assert(
        // Cast is necessary to remove @struct
        /** @type{!Object} */ (this)[GENERATED_SUBCLASS_MARKER] === true,
        'Message can only be subclassed by proto gencode.');
    const parentPrototype =
        Object.getPrototypeOf(asserts.assert(Object.getPrototypeOf(this)));
    // Is the concrete type a direct subclass of GeneratedMessage.
    asserts.assert(
        parentPrototype.hasOwnProperty(GENERATED_SUBCLASS_MARKER),
        'Generated jspb classes should not be extended');
  }

  // Get data from alternateDataPayload if the parameter was optimized away.
  const alternateDataPayload = getAndResetAlternateDataPayload();
  if (!data) {
    data = alternateDataPayload;
  }

  // Compute and validate our message ID.
  let messageId = this.getJsPbMessageId();
  if (!data) {
    data = messageId ? [messageId] : [];
  } else if (
      !UNSAFE_SKIP_MESSAGE_ID_VALIDATION && messageId &&
      messageId !== OPT_OUT_MESSAGE_ID && messageId !== data[0]) {
    // Validate message ids in messages constructed from data.
    // Ensure that the data matches the Id unless explicitly disabled or is the
    // OPT_OUT_MESSAGE_ID value.
    throw new Error(`Expected message to have a message id: "${
        messageId}" in the array, got: ${
        JSON.stringify(data)}, are you parsing with the wrong proto?`);
  }

  // If this message is not a response message, we shift array indices down by 1
  // so as not to waste the first position in the array, which would otherwise
  // go unused.
  /** @override @package @type {number}*/
  this.arrayIndexOffset = messageId ? 0 : -1;

  this.internalWrappers_ = null;
  this.convertedPrimitiveFields_ = null;
  this.internalArray_ = data;
  initPivotAndExtensionObject(this, suggestedPivot);

  if (repeatedFields) {
    for (let i = 0; i < repeatedFields.length; i++) {
      let fieldNumber = repeatedFields[i];
      if (fieldNumber < this.pivot_) {
        let index = indexFromFieldNumber(this, fieldNumber);
        let value = this.internalArray_[index];
        if (value) {
          markRepeatedField(value);
        } else {
          this.internalArray_[index] = EMPTY_LIST_SENTINEL;
        }
      } else {
        maybeInitEmptyExtensionObject(this);
        let value = this.internalExtensionObject_[fieldNumber];
        if (value) {
          markRepeatedField(value);
        } else {
          this.internalExtensionObject_[fieldNumber] = EMPTY_LIST_SENTINEL;
        }
      }
    }
  }

  if (oneofFields && oneofFields.length) {
    // Compute the oneof case for each union. This ensures only one value is
    // set in the union.
    for (let i = 0; i < oneofFields.length; i++) {
      this.internal_computeOneofCase(oneofFields[i]);
    }
  }
};

/**
 * @define {boolean} Whether to generate toString methods for objects. Turn
 *     this off if you do not use toString in your project and want to trim it
 *     from the compiled JS.
 */
const GENERATE_TO_STRING = goog.define('jspb.Message.GENERATE_TO_STRING', true);



// TODO(jakubvrana): Turn this off by default.
/**
 * @define {boolean} Disabling the serialization of empty trailing fields
 *     reduces the size of serialized protos. The price is an extra iteration of
 *     the proto before serialization. This is enabled by default to be
 *     backwards compatible. Projects are advised to turn this flag always off.
 */
const SERIALIZE_EMPTY_TRAILING_FIELDS =
    goog.define('jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS', true);

/**
 * @define {boolean} Disables checking that message ids are correct.  Current
 *     default is `true` to enable this feature to be rolled out.
 */
const UNSAFE_SKIP_MESSAGE_ID_VALIDATION =
    goog.define('jspb.Message.UNSAFE_SKIP_MESSAGE_ID_VALIDATION', true);

/**
 * A special message_id value that opts messages out of validation.
 *
 * This message_id was introduced to a number of protos as part of the
 * `jspb.response_proto` migration (see b/187543102).  Because these protos may
 * have been serialized with other ids or no id we cannot enforce constraints on
 * the values passed to the constructor. The `_` special case should be safe to
 * remove anytime in 2022.
 *
 * @const {string}
 */
const OPT_OUT_MESSAGE_ID = '_';

/**
 * The internal data array.
 * @type {!Array<?>}
 * @package
 */
Message.prototype.internalArray_;


/**
 * Wrappers are the constructed instances of message-type fields. They are built
 * on demand from the raw array data. Includes message fields, repeated message
 * fields and extension message fields. Indexed by field number.
 * @type {!Object<string|number,?>|null}
 * @package
 */
Message.prototype.internalWrappers_;


/**
 * The object that contains extension fields, if any. This is an object that
 * maps from a proto field number to the field's value.
 * @type {!Object<string|number,?>|null}
 * @package
 */
Message.prototype.internalExtensionObject_;


/**
 * Non-extension fields with a field number at or above the pivot are
 * stored in the extension object (in addition to all extension fields).
 * @type {number}
 * @private
 */
Message.prototype.pivot_;


/**
 * Repeated fields that have been converted to their proper type. This is used
 * for numbers stored as strings (typically "NaN", "Infinity" and "-Infinity")
 * and for booleans stored as numbers (0 or 1).
 * @private {?Object<number,boolean>|undefined}
 */
Message.prototype.convertedPrimitiveFields_;

// BEGIN GOOGLE-INTERNAL
/**
 * The xid of this proto type (The same for all instances of a proto). Provides
 * a way to identify a proto by stable obfuscated name.
 * @see {xid}.
 * Available if {@link jspb.generate_xid} is added as a Message option to
 * a protocol buffer.
 * @type {!XString|undefined} The xid or undefined if message is
 *     annotated to generate the xid.
 * See go/const-js-library-faq
 */
Message.prototype.messageXid;
// END GOOGLE-INTERNAL

/**
 * Returns the JsPb message_id of this proto.
 * @return {string|undefined} the message id or undefined if this message
 *     has no id.
 */
Message.prototype.getJsPbMessageId = function() {
  return /** @type {{messageId: (string|undefined)}} */ (this.constructor)
      .messageId;
};


/**
 * Used to mark empty repeated fields. Serializes to null when serialized
 * to JSON.
 * When reading a repeated field readers must check the return value against
 * this value and return and replace it with a new empty array if it is
 * present.
 * @const {!Object}
 */
const EMPTY_LIST_SENTINEL = Object.freeze(newRepeatedField());



/**
 * If the array contains an extension object in its last position, then the
 * object is kept in place and its position is used as the pivot.  If not,
 * decides the pivot of the message based on suggestedPivot without
 * materializing the extension object.
 *
 * @param {!Message} msg The JsPb proto to modify.
 * @param {number|undefined} suggestedPivot See description for initialize().
 */
const initPivotAndExtensionObject = function(msg, suggestedPivot) {
  // There are 3 variants that need to be dealt with which are the
  // combination of whether there exists an extension object (EO) and
  // whether there is a suggested pivot (SP).
  //
  // EO,    ?    : pivot is the index of the EO
  // no-EO, no-SP: pivot is MAX_INT
  // no-EO, SP   : pivot is the max(lastindex + 1, SP)

  const msgLength = msg.internalArray_.length;
  const lastIndex = msgLength - 1;
  if (msgLength) {
    const obj = msg.internalArray_[lastIndex];
    if (isExtensionObject(obj)) {
      msg.pivot_ = fieldNumberFromIndex(msg, lastIndex);
      msg.internalExtensionObject_ = obj;
      return;
    }
  }

  if (suggestedPivot !== undefined && suggestedPivot > -1) {
    // If a extension object is not present, set the pivot value as being
    // after the last value in the array to avoid overwriting values, etc.
    msg.pivot_ =
        Math.max(suggestedPivot, fieldNumberFromIndex(msg, lastIndex + 1));
    // Avoid changing the shape of the proto with an empty extension object by
    // deferring the materialization of the extension object until the first
    // time a field set into it (may be due to getting a repeated proto field
    // from it, in which case a new empty array is set into it at first).
    msg.internalExtensionObject_ = null;
  } else {
    // suggestedPivot is undefined or -1, which means that we don't have an
    // extension object at all, in which case all fields are stored in the
    // array.
    msg.pivot_ = Number.MAX_VALUE;
  }
};


/**
 * Creates an empty internalExtensionObject_ if non exists.
 * @param {!Message} msg The JsPb proto to modify.
 */
const maybeInitEmptyExtensionObject = function(msg) {
  let pivotIndex = indexFromFieldNumber(msg, msg.pivot_);
  if (!msg.internalArray_[pivotIndex]) {
    if (!isFrozen(msg)) {
      msg.internalExtensionObject_ = msg.internalArray_[pivotIndex] = {};
    } else {
      // When initializing the empty extension object of a frozen msg.
      msg.internalExtensionObject_ = {};
      Object.freeze(msg.internalExtensionObject_);
    }
  }
};

/**
 * Gets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @return {string|number|boolean|!Uint8Array|!Array|null|undefined}
 * The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getField = function(fieldNumber) {
  if (fieldNumber < this.pivot_) {
    let index = indexFromFieldNumber(this, fieldNumber);
    let val = this.internalArray_[index];
    if (val === EMPTY_LIST_SENTINEL && !isFrozen(this)) {
      return this.internalArray_[index] = newRepeatedField();
    }
    return val;
  } else {
    if (!this.internalExtensionObject_) {
      return undefined;
    }
    let val = this.internalExtensionObject_[fieldNumber];
    if (val === EMPTY_LIST_SENTINEL && !isFrozen(this)) {
      return this.internalExtensionObject_[fieldNumber] = newRepeatedField();
    }
    return val;
  }
};

/**
 * Returns whether the given field is set.
 * @param {number} fieldNumber The field number.
 * @return {boolean}
 * @protected
 * @final
 */
Message.prototype.internal_hasField = function(fieldNumber) {
  return this.internal_getField(fieldNumber) != null;
};

/**
 * Gets the value of a non-extension repeated field.
 * @param {number} fieldNumber The field number.
 * @return {!Array<?>}
 * The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getRepeatedField = function(fieldNumber) {
  let values = /** @type {!Array<?>} */ (this.internal_getField(fieldNumber));
  if (isFrozen(this)) {
    internalMarkFrozen(values);
  }
  return values;
};


/**
 * Gets the value of an optional float or double field.
 * @param {number} fieldNumber The field number.
 * @return {?number|undefined} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getFloatingPointField = function(fieldNumber) {
  let value = this.internal_getField(fieldNumber);
  // Converts "NaN", "Infinity" and "-Infinity" to their corresponding numbers.
  return value == null ? value : +value;
};


/**
 * Gets the value of an optional boolean field.
 * @param {number} fieldNumber The field number.
 * @return {?boolean|undefined} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getBooleanField = function(fieldNumber) {
  let value = this.internal_getField(fieldNumber);
  // TODO(b/122673075): always return null when the value is null-ish.
  return value == null ? (value) : !!value;
};


/**
 * Gets the value of a repeated float or double field.
 * @param {number} fieldNumber The field number.
 * @return {!Array<number>} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getRepeatedFloatingPointField = function(
    fieldNumber) {
  let values = /** @type {!Array<?>} */ (this.internal_getField(fieldNumber));
  if (!this.convertedPrimitiveFields_) {
    this.convertedPrimitiveFields_ = {};
  }
  if (!this.convertedPrimitiveFields_[fieldNumber]) {
    for (let i = 0; i < values.length; i++) {
      // Converts "NaN", "Infinity" and "-Infinity" to their corresponding
      // numbers.
      values[i] = +values[i];
    }
    this.convertedPrimitiveFields_[fieldNumber] = true;
  }

  if (isFrozen(this)) {
    internalMarkFrozen(values);
  }

  return /** @type {!Array<number>} */ (values);
};

/**
 * Gets the value of a repeated boolean field.
 * @param {number} fieldNumber The field number.
 * @return {!Array<boolean>} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getRepeatedBooleanField = function(fieldNumber) {
  let values = /** @type {!Array<?>} */ (this.internal_getField(fieldNumber));
  if (!this.convertedPrimitiveFields_) {
    this.convertedPrimitiveFields_ = {};
  }
  if (!this.convertedPrimitiveFields_[fieldNumber]) {
    for (let i = 0; i < values.length; i++) {
      // Converts 0 and 1 to their corresponding booleans.
      values[i] = !!values[i];
    }
    this.convertedPrimitiveFields_[fieldNumber] = true;
  }

  if (isFrozen(this)) {
    internalMarkFrozen(values);
  }

  return /** @type {!Array<boolean>} */ (values);
};


/**
 * Gets the value of a non-extension primitive field, with proto3 (non-nullable
 * primitives) semantics. Returns `defaultValue` if the field is not otherwise
 * set.
 * @template T
 * @param {number} fieldNumber The field number.
 * @param {T} defaultValue The default value.
 * @return {T} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getFieldWithDefault = function(
    fieldNumber, defaultValue) {
  let value = this.internal_getField(fieldNumber);
  if (value == null) {
    return defaultValue;
  } else {
    return value;
  }
};


/**
 * Gets the value of a boolean field, with proto3 (non-nullable primitives)
 * semantics. Returns `defaultValue` if the field is not otherwise set.
 * @param {number} fieldNumber The field number.
 * @param {boolean=} defaultValue The default value. false if not set.
 * @return {boolean} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getBooleanFieldWithDefault = function(
    fieldNumber, defaultValue = false) {
  let value = this.internal_getBooleanField(fieldNumber);
  if (value == null) {
    return defaultValue;
  } else {
    return value;
  }
};


/**
 * Gets the value of a floating point field, with proto3 (non-nullable
 * primitives) semantics. Returns `defaultValue` if the field is not otherwise
 * set.
 * @param {number} fieldNumber The field number.
 * @param {number=} defaultValue The default value. 0.0 if not set.
 * @return {number} The field's value.
 * @protected
 * @final
 */
Message.prototype.internal_getFloatingPointFieldWithDefault = function(
    fieldNumber, defaultValue = 0.0) {
  let value = this.internal_getFloatingPointField(fieldNumber);
  if (value == null) {
    return defaultValue;
  } else {
    return value;
  }
};


/**
 * Gets the value of a map field, lazily creating the map container if
 * necessary.
 *
 * This should only be called from generated code, because it requires knowledge
 * of serialization/parsing callbacks (which are required by the map at
 * construction time, and the map may be constructed here).
 *
 * @template K, V
 * @param {number} fieldNumber
 * @param {boolean|undefined} noLazyCreate
 * @param {?=} valueCtor
 * @return {!JspbMap<K, V>|undefined}
 * @protected
 * @final
 */
Message.prototype.internal_getMapField = function(
    fieldNumber, noLazyCreate, valueCtor) {
  if (!this.internalWrappers_) {
    this.internalWrappers_ = {};
  }
  // If we already have a map in the map wrappers, return that.
  if (fieldNumber in this.internalWrappers_) {
    return this.internalWrappers_[fieldNumber];
  }
  let arr = this.internal_getField(fieldNumber);
  // Wrap the underlying elements array with a Map.
  if (!arr) {
    if (noLazyCreate) {
      return undefined;
    }
    arr = newRepeatedField();
    if (!isFrozen(this)) {
      // Don't set the internal array; it's frozen anyway.
      this.internal_setField(fieldNumber, arr);
    }
  }

  let jspbMap =
      new JspbMap(/** @type {!Array<!Array<!Object>>} */ (arr), valueCtor);
  if (isFrozen(this)) {
    jspbMap.internalMarkFrozen(internalMarkFrozen);
  }
  return this.internalWrappers_[fieldNumber] = jspbMap;
};


/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {string|number|boolean|!Uint8Array|!Array|null|undefined} value New
 *     value
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setField = function(fieldNumber, value) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  if (fieldNumber < self.pivot_) {
    self.internalArray_[indexFromFieldNumber(self, fieldNumber)] = value;
  } else {
    maybeInitEmptyExtensionObject(self);
    self.internalExtensionObject_[fieldNumber] = value;
  }
  return self;
};


/**
 * Sets the value of a non-extension repeated field.
 * TODO(shaod): document unexpected behavior of set a frozen repeated field
 * inside a mutable message.
 * @param {number} fieldNumber The field number.
 * @param {!Array|null|undefined} value New value
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setRepeatedField = function(fieldNumber, value) {
  let self = /** @type {!Message} */ (this);
  return self.internal_setField(fieldNumber, markRepeatedField(value || []));
};


/**
 * Clears a primitive field by making it undefined.
 * @param {number} fieldNumber The field number.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_clearField = function(fieldNumber) {
  return (/** @type {!Message} */ (this))
      .internal_setField(fieldNumber, undefined);
};

/**
 * Clears a repeated primitive field by making it empty.
 * @param {number} fieldNumber The field number.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_clearRepeatedField = function(fieldNumber) {
  return (/** @type {!Message} */ (this))
      .internal_setField(fieldNumber, newRepeatedField());
};

/**
 * Clears a wrapper field by making it undefined.
 * @param {number} fieldNumber The field number.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_clearWrapperField = function(fieldNumber) {
  return (/** @type {!Message} */ (this))
      .internal_setWrapperField(fieldNumber, undefined);
};

/**
 * Clears a repeated wrapper field by making it empty.
 * @param {number} fieldNumber The field number.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_clearRepeatedWrapperField = function(fieldNumber) {
  return (/** @type {!Message} */ (this))
      .internal_setRepeatedWrapperField(fieldNumber, []);
};

/**
 * Sets the value of a non-extension primitive field, with proto3 (non-nullable
 * primitives) semantics of ignoring values that are equal to the type's
 * default.
 * @param {T} msg A jspb proto.
 * @param {number} fieldNumber The field number.
 * @param {!Uint8Array|string|number|boolean|undefined} value New value
 * @param {!Uint8Array|string|number|boolean} defaultValue The default value.
 * @return {T} return msg
 * @template T
 */
const setFieldIgnoringDefault = function(
    msg, fieldNumber, value, defaultValue) {
  asserts.assertInstanceof(msg, Message);
  checkNotFrozen(msg);
  if (value !== defaultValue) {
    msg.internal_setField(fieldNumber, value);
  } else if (fieldNumber < msg.pivot_) {
    msg.internalArray_[indexFromFieldNumber(msg, fieldNumber)] = null;
  } else {
    maybeInitEmptyExtensionObject(msg);
    delete msg.internalExtensionObject_[fieldNumber];
  }
  return msg;
};


/**
 * Adds a value to a repeated, primitive field.
 * @param {number} fieldNumber The field number.
 * @param {string|number|boolean|!Uint8Array} value New value
 * @param {number=} index Index where to put new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_addToRepeatedField = function(
    fieldNumber, value, index) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  let arr = self.internal_getRepeatedField(fieldNumber);
  if (index != undefined) {
    arr.splice(index, 0, value);
  } else {
    arr.push(value);
  }
  return self;
};


/**
 * Sets the value of a field in a oneof union and clears all other fields in
 * the union.
 * @param {number} fieldNumber The field number.
 * @param {!Array<number>} oneof The fields belonging to the union.
 * @param {string|number|boolean|!Uint8Array|!Array|null|undefined} value New
 *     value
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setOneofField = function(fieldNumber, oneof, value) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  let currentCase = self.internal_computeOneofCase(oneof);
  if (currentCase && currentCase !== fieldNumber && value != null) {
    if (self.internalWrappers_ && currentCase in self.internalWrappers_) {
      self.internalWrappers_[currentCase] = undefined;
    }
    self.internal_setField(currentCase, undefined);
  }
  return self.internal_setField(fieldNumber, value);
};



/**
 * Computes the selection in a oneof group for the given message, ensuring
 * only one field is set in the process.
 *
 * According to the protobuf language guide (
 * https://developers.google.com/protocol-buffers/docs/proto#oneof), "if the
 * parser encounters multiple members of the same oneof on the wire, only the
 * last member seen is used in the parsed message." Since JSPB serializes
 * messages to a JSON array, the "last member seen" will always be the field
 * with the greatest field number (directly corresponding to the greatest
 * array index).
 *
 * @param {!Array<number>} oneof The field numbers belonging to the union.
 * @return {number} The field number currently set in the union, or 0 if none.
 * @protected
 * @final
 */
Message.prototype.internal_computeOneofCase = function(oneof) {
  let oneofField;
  let oneofValue;
  let amIFrozen = isFrozen(this);

  for (let i = 0; i < oneof.length; i++) {
    let fieldNumber = oneof[i];
    let value = this.internal_getField(fieldNumber);
    if (value != null) {
      oneofField = fieldNumber;
      oneofValue = value;
      if (!amIFrozen) {
        this.internal_setField(fieldNumber, undefined);
      }
    }
  }

  if (oneofField) {
    // NB: We know the value is unique, so we can call Message.setField
    // directly instead of jpsb.Message.setOneofField. Also, setOneofField
    // calls this function.
    if (!amIFrozen) {
      this.internal_setField(oneofField, oneofValue);
    }
    return oneofField;
  }

  return 0;
};


/**
 * Gets and wraps a proto field on access.
 * @param {function(new:Message, ?Array)} ctor Constructor for the field.
 * @param {number} fieldNumber The field number.
 * @param {number=} required True (1) if this is a required field.
 * @return {?Message} The field as a jspb proto.
 * @protected
 * @final
 */
Message.prototype.internal_getWrapperField = function(
    ctor, fieldNumber, required) {
  // TODO(mwr): Consider copying data and/or arrays.
  if (!this.internalWrappers_) {
    this.internalWrappers_ = {};
  }
  if (!this.internalWrappers_[fieldNumber]) {
    let data = /** @type {?Array<?>} */ (this.internal_getField(fieldNumber));
    if (required || data) {
      // TODO(mwr): Remove existence test for always valid default protos.
      this.internalWrappers_[fieldNumber] = new ctor(data);
      if (isFrozen(this)) {
        internalMarkFrozen(this.internalWrappers_[fieldNumber]);
      }
    }
  }
  return /** @type {?Message} */ (this.internalWrappers_[fieldNumber]);
};


/**
 * Gets and wraps a repeated proto field on access.
 * @param {function(new:Message, ?Array)} ctor Constructor for the field.
 * @param {number} fieldNumber The field number.
 * @return {!Array<!Message>} The repeated field as an array of protos.
 * @protected
 * @final
 */
Message.prototype.internal_getRepeatedWrapperField = function(
    ctor, fieldNumber) {
  wrapRepeatedField(this, ctor, fieldNumber);
  const val = this.internalWrappers_[fieldNumber];
  return /** @type {!Array<!Message>} */ (val);
};


/**
 * Wraps underlying array into proto message representation if it wasn't done
 * before.
 * @param {!Message} msg A jspb proto.
 * @param {?function(new:Message, ?Array<?>)} ctor Constructor for the field.
 * @param {number} fieldNumber The field number.
 */
const wrapRepeatedField = function(msg, ctor, fieldNumber) {
  if (!msg.internalWrappers_) {
    msg.internalWrappers_ = {};
  }
  if (!msg.internalWrappers_[fieldNumber]) {
    let data = msg.internal_getRepeatedField(fieldNumber);
    let wrappers = [];
    for (let i = 0; i < data.length; i++) {
      wrappers[i] = new ctor(data[i]);
      if (isFrozen(msg)) {
        internalMarkFrozen(wrappers[i]);
      }
    }
    if (isFrozen(msg)) {
      internalMarkFrozen(wrappers);
    }
    msg.internalWrappers_[fieldNumber] = wrappers;
  }
};


/**
 * Sets a proto field and syncs it to the backing array.
 * @param {number} fieldNumber The field number.
 * @param {?Message|?JspbMap|undefined} value A new value for this proto
 * field.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setWrapperField = function(fieldNumber, value) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  if (!self.internalWrappers_) {
    self.internalWrappers_ = {};
  }
  let data = value ? value.toArrayInternal(/* failIfFrozen = */ false) : value;
  self.internalWrappers_[fieldNumber] = value;
  return self.internal_setField(fieldNumber, data);
};


/**
 * Sets a proto field in a oneof union and syncs it to the backing array.
 * @param {number} fieldNumber The field number.
 * @param {!Array<number>} oneof The fields belonging to the union.
 * @param {?Message|undefined} value A new value for this proto field.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setOneofWrapperField = function(
    fieldNumber, oneof, value) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  if (!self.internalWrappers_) {
    self.internalWrappers_ = {};
  }
  let data = value ? value.toArrayInternal(/* failIfFrozen = */ false) : value;
  self.internalWrappers_[fieldNumber] = value;
  return self.internal_setOneofField(fieldNumber, oneof, data);
};

/**
 * Sets a repeated proto field and syncs it to the backing array.
 * @param {number} fieldNumber The field number.
 * @param {?Array<!Message>|undefined} value An array of protos.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setRepeatedWrapperField = function(
    fieldNumber, value) {
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  if (!self.internalWrappers_) {
    self.internalWrappers_ = {};
  }
  value = value || [];
  let data = newRepeatedField();
  for (let i = 0; i < value.length; i++) {
    data[i] = value[i].toArrayInternal(/* failIfFrozen = */ false);
  }
  self.internalWrappers_[fieldNumber] = value;
  return self.internal_setField(fieldNumber, data);
};

/**
 * Add a message to a repeated proto field.
 * @param {number} fieldNumber The field number.
 * @param {T_CHILD|undefined} value Proto that will be added to the
 *     repeated field.
 * @param {function(new:T_CHILD, ?Array=)} ctor The constructor of the
 *     message type.
 * @param {number|undefined} index Index at which to insert the value.
 * @return {T_CHILD_NOT_UNDEFINED} proto that was inserted to the repeated field
 * @template MessageType
 * Use go/closure-ttl to declare a non-undefined version of T_CHILD. Replace the
 * undefined in blah|undefined with none. This is necessary because the compiler
 * will infer T_CHILD to be |undefined.
 * @template T_CHILD
 * @template T_CHILD_NOT_UNDEFINED :=
 *     cond(isUnknown(T_CHILD), unknown(),
 *       mapunion(T_CHILD, (X) =>
 *         cond(eq(X, 'undefined'), none(), X)))
 * =:
 * @protected
 * @final
 */
Message.prototype.internal_addToRepeatedWrapperField = function(
    fieldNumber, value, ctor, index) {
  checkNotFrozen(this);
  let wrapperArray = this.internal_getRepeatedWrapperField(ctor, fieldNumber);
  let insertedValue = value ? value : new ctor();
  let array = this.internal_getRepeatedField(fieldNumber);
  if (index != undefined) {
    wrapperArray.splice(index, 0, insertedValue);
    array.splice(
        index, 0, insertedValue.toArrayInternal(/* failIfFrozen = */ false));
  } else {
    wrapperArray.push(insertedValue);
    array.push(insertedValue.toArrayInternal(/* failIfFrozen = */ false));
  }
  return insertedValue;
};

/**
 * Syncs all map fields' contents back to their underlying arrays.
 * @param {boolean} failIfFrozen if set and any part of this message is frozen,
 *   this method will throw.
 * @private
 */
Message.prototype.syncMapFields_ = function(failIfFrozen) {
  // This iterates over submessage, map, and repeated fields, which is intended.
  // Submessages can contain maps which also need to be synced.
  //
  // There is a lot of opportunity for optimization here.  For example we could
  // statically determine that some messages have no submessages with maps and
  // optimize this method away for those just by generating one extra static
  // boolean per message type.
  if (this.internalWrappers_) {
    for (let fieldNumber in this.internalWrappers_) {
      if (!hasOwnPropertyIfNotTrusted(this.internalWrappers_, fieldNumber)) {
        continue;
      }
      const val = this.internalWrappers_[fieldNumber];
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; i++) {
          if (val[i]) {
            val[i].toArrayInternal(/* failIfFrozen = */ failIfFrozen);
          }
        }
      } else {
        // Works for submessages and maps.
        if (val) {
          val.toArrayInternal(/* failIfFrozen = */ failIfFrozen);
        }
      }
    }
  }
};

/**
 * Returns a copy of the array representation of this proto.
 *
 * @return {!Array<?>} The proto represented as an array.
 * @deprecated To get a wire compatible array call `toJsonValue()`, to
 *     serialize the message call `serialize()`, to get a copy of this instance
 *     call `clone()`.
 */
Message.prototype.toArray = function() {
  return this.toJSON();
};

/**
 * Returns this JSPB as a JSON-compatible array.
 *
 * Generally, `serialize()` should be called instead, but this may be useful
 * when a JSON stringifiable value is required for compatibility with other
 * APIs.
 *
 * Note that this function performs a deep clone and converts internal
 * Uint8Array objects to base64 strings, and therefore the function is fairly
 * expensive, though not quite as expensive as serializing then deserializing.
 *
 * @return {!Array<?>} The proto represented as an array.
 */
Message.prototype.toJsonValue = function() {
  return this.toJSON();
};

/**
 * Returns this JSPB as a JSON.stringify-compatible array.
 *
 * Generally, `serialize()` should be called instead, but this may be useful
 * when a JSON stringifiable value is required for compatibility with other
 * APIs.
 *
 * @return {!Array<?>} The proto represented as an array.
 * @override
 * @private
 */
Message.prototype.toJSON = function() {
  const arr =
      prepareForSerialize(this.toArrayInternal(/* failIfFrozen = */ false));
  return getInSerialize() ? arr : cloneToJsonFormat(arr);
};

/**
 * Returns this JSPB as an array compatible with structured clones.
 *
 * Note that this function performs a deep clone and therefore the function is
 * fairly expensive, though not quite as expensive as serializing then
 * deserializing. The output format is compatible with JSPB except that
 * Uint8Arrays may be used instead of base64 strings and special numbers
 * (NaN, Infinity) may be represented as a number instead of a string.
 *
 * @return {!Array<?>} The proto represented as an array.
 */
Message.prototype.toStructuredCloneableValue = function() {
  return cloneToStructuredCloneableFormat(
      this.toArrayInternal(/* failIfFrozen = */ false));
};


/**
 * The same as toArray, but only for internal use and does not check frozen
 * status.
 * @param {boolean} failIfFrozen if set and any part of this message is frozen,
 *   this method will throw.
 * @return {!Array<?>} The proto represented as an array.
 * @package
 */
Message.prototype.toArrayInternal = function(failIfFrozen) {
  this.syncMapFields_(failIfFrozen);
  return this.internalArray_;
};


// BEGIN GOOGLE-INTERNAL

// We are not releasing the JSPB wire format in open-source until it is
// better standardized.


/**
 * Serializes a JsPb proto for use in server requests.
 * @this {!Message}
 * @return {string} The serialized proto.
 */
Message.prototype.serialize = function() {
  setInSerialize(true);
  try {
    return JSON.stringify(this.toJSON(), serializeSpecialValues);
  } finally {
    setInSerialize(false);
  }
};


/**
 * Removes empty fields from arrays.
 * @param {!Array<?>} array
 * @return {!Array<?>}
 */
const prepareForSerialize = function(array) {
  if (SERIALIZE_EMPTY_TRAILING_FIELDS) {
    return array;
  }
  // To minimize memory allocations, we copy the array only if it's different
  // from the original.
  let result;
  let length = array.length;
  let needsCopy = false;
  let extension;
  for (let i = array.length; i--;) {
    let value = array[i];
    if (Array.isArray(value)) {
      let oldValue = value;
      if (isEmptyRepeatedField(value)) {
        // This is an empty repeated field, we could remove it.
        value = null;
      } else {
        // Recursively process submessages or repeated fields.
        value = prepareForSerialize(value);
      }
      if (value != oldValue) {
        needsCopy = true;
      }
    } else if (isExtensionObject(value)) {
      extension = prepareExtensionForSerialize(value);
      if (extension != value) {
        needsCopy = true;
      }
      length--;
      continue;
    }
    if (value == null && length == i + 1) {
      needsCopy = true;
      length--;
    } else if (needsCopy) {
      if (!result) {
        result = array.slice(0, length);
      }
      result[i] = value;
    }
  }
  if (!needsCopy) {
    return array;
  }
  if (!result) {
    result = array.slice(0, length);
  }
  if (extension) {
    result.push(extension);
  }
  return result;
};


/**
 * Removes empty fields from extension.
 * @param {!Object} extension
 * @return {?Object} Extension object with removed empty fields or null if
 *     empty.
 */
const prepareExtensionForSerialize = function(extension) {
  asserts.assert(!SERIALIZE_EMPTY_TRAILING_FIELDS);
  let result = {};
  let changed = false;
  for (let key in extension) {
    if (!hasOwnPropertyIfNotTrusted(extension, key)) {
      continue;
    }
    let value = extension[key];
    if (Array.isArray(value)) {
      let oldValue = value;
      if (isEmptyRepeatedField(value)) {
        // Omit empty repeated field.
        value = null;
      } else {
        // Recursively process submessages or repeated fields.
        value = prepareForSerialize(value);
      }
      if (value != oldValue) {
        changed = true;
      }
    }
    if (value != null) {
      result[key] = value;
    } else {
      // Omit null values from result, which means there's a change.
      changed = true;
    }
  }
  if (!changed) {
    // We return the original object if possible.
    return extension;
  }
  // Equivalent to goog.object.isEmpty.
  for (let key in result) {
    return result;
  }
  return null;
};


/**
 * Not all values stored in the `array` are json compatible.
 * - Converts NaN to "NaN", Infinity to "Infinity" and -Infinity to "-Infinity".
 *   These numbers are otherwise serialized as null.
 * - Converts Uint8Array instances to base64 encoded strings, these values are
 *   otherwise encoded as objects.
 * @param {string} key
 * @param {*} value
 * @return {*} The converted proto message.
 */
const serializeSpecialValues = function(key, value) {
  switch (typeof value) {
    case 'number':
      return numberToJspbFormat(/** @type {number} */ (value));
    case 'object':
      // NOTE: we guard the test with typeof and null check to avoid a
      // potentially expensive instanceof test.
      if (SUPPORTS_UINT8ARRAY && value != null && value instanceof Uint8Array) {
        return base64.encodeByteArray(value);
      }
      break;
  }
  return value;
};


/**
 * Deserialize a JsPb string.
 * @param {function(new:JSPB, ?Array=)} ctor The constructor of the
 *     message type.
 * @param {string} data Our serialized data.
 * @return {JSPB} The new message with the serialized data populating
 *     its fields.
 * @template JSPB
 */
Message.deserializeWithCtor = function(ctor, data) {
  const msg = newMessage(
      ctor, data ? /** @type {?Array<?>} */ (JSON.parse(data)) : null);
  asserts.assertInstanceof(msg, Message);
  return msg;
};

// END GOOGLE-INTERNAL

if (GENERATE_TO_STRING) {
  /**
   * Creates a string representation of the internal data array of this proto.
   * <p>NOTE: This string is *not* suitable for use in server requests.
   * @return {string} A string representation of this proto.
   * @override
   * @deprecated please use .serialize() instead.
   */
  Message.prototype.toString = function() {
    return this.toArrayInternal(/* failIfFrozen = */ false).toString();
  };
}

/**
 * Gets the value of the extension field from the extended object.
 * @param {ExtensionFieldInfo<T>} fieldInfo Specifies the field to get.
 * @return {T} The value of the field.
 * @template T
 */
Message.prototype.getExtension = function(fieldInfo) {
  maybeInitEmptyExtensionObject(this);
  if (!this.internalWrappers_) {
    this.internalWrappers_ = {};
  }
  const amIFrozen = isFrozen(this);
  let fieldNumber = fieldInfo.fieldIndex;
  if (fieldInfo.isRepeated) {
    if (fieldInfo.isMessageType()) {
      if (!this.internalWrappers_[fieldNumber]) {
        this.internalWrappers_[fieldNumber] =
            // The data of an extension must be extracted from the
            // internalExtensionObject_ of msg; otherwise, if using getField or
            // getRepeatedField, it might return null even it exists due to
            // the semantics of JSPB transport format.
            garray.map(
                this.internalExtensionObject_[fieldNumber] || [],
                function(arr) {
                  let msg = new fieldInfo.ctor(arr);
                  if (amIFrozen) {
                    internalMarkFrozen(msg);
                  }
                  return msg;
                });
      }
      if (amIFrozen) {
        internalMarkFrozen(this.internalWrappers_[fieldNumber]);
      }
      return this.internalWrappers_[fieldNumber];
    } else {
      if (amIFrozen) {
        let res = this.internalExtensionObject_[fieldNumber];
        if (!res) {
          res = newRepeatedField();
          internalMarkFrozen(res);
        }
        return res;
      } else {
        return this.internalExtensionObject_[fieldNumber] =
                   this.internalExtensionObject_[fieldNumber] ||
            newRepeatedField();
      }
    }
  } else {
    if (fieldInfo.isMessageType()) {
      if (!this.internalWrappers_[fieldNumber] &&
          this.internalExtensionObject_[fieldNumber]) {
        this.internalWrappers_[fieldNumber] = new fieldInfo.ctor(
            /** @type {!Array<?>} */ (
                this.internalExtensionObject_[fieldNumber]));
        if (amIFrozen) {
          internalMarkFrozen(this.internalWrappers_[fieldNumber]);
        }
      }

      return this.internalWrappers_[fieldNumber];
    } else {
      return this.internalExtensionObject_[fieldNumber];
    }
  }
};


/**
 * Sets the value of the extension field in the extended object.
 * @param {ExtensionFieldInfo} fieldInfo Specifies the field to set.
 * @param {Message|string|Uint8Array|number|boolean|Array?} value The value
 *     to set.
 * @return {THIS} For chaining
 * @this {THIS}
 * @template THIS
 */
Message.prototype.setExtension = function(fieldInfo, value) {
  // Cast self, since the inferred THIS is unknown inside the function body.
  // https://github.com/google/closure-compiler/issues/1411#issuecomment-232442220
  let self = /** @type {!Message} */ (this);
  checkNotFrozen(self);
  if (!self.internalWrappers_) {
    self.internalWrappers_ = {};
  }
  maybeInitEmptyExtensionObject(self);
  let fieldNumber = fieldInfo.fieldIndex;
  if (fieldInfo.isRepeated) {
    value = value || [];
    if (fieldInfo.isMessageType()) {
      self.internalWrappers_[fieldNumber] = value;
      self.internalExtensionObject_[fieldNumber] = markRepeatedField(garray.map(
          /** @type {!Array<!Message>} */ (value), function(msg) {
            return msg.toArrayInternal(/* failIfFrozen = */ false);
          }));
    } else {
      self.internalExtensionObject_[fieldNumber] =
          markRepeatedField(/** @type {!Array<?>} */ (value));
    }
  } else {
    if (fieldInfo.isMessageType()) {
      self.internalWrappers_[fieldNumber] = value;
      self.internalExtensionObject_[fieldNumber] = value ?
          /** @type {!Message} */ (value).toArrayInternal(
              /* failIfFrozen = */ false) :
          value;
    } else {
      self.internalExtensionObject_[fieldNumber] = value;
    }
  }
  return self;
};


/**
 * Creates a difference object between two messages.
 *
 * The result will contain the top-level fields of m2 that differ from those of
 * m1 at any level of nesting. No data is cloned, the result object will
 * share its top-level elements with m2 (but not with m1).
 *
 * Note that repeated fields should not have null/undefined elements, but if
 * they do, this operation will treat repeated fields of different length as
 * the same if the only difference between them is due to trailing
 * null/undefined values.
 *
 * @param {!Message} m1 The first message object.
 * @param {!Message} m2 The second message object.
 * @return {!Message} The difference returned as a proto message.
 *     Note that the returned message may be missing required fields. This is
 *     currently tolerated in Js, but would cause an error if you tried to
 *     send such a proto to the server.
 * @throws {Error} If the messages are responses with different types.
 */
Message.difference = function(m1, m2) {
  if (!(m1 instanceof m2.constructor)) {
    throw new Error('Messages have different types.');
  }
  let arr1 = m1.toArrayInternal(/* failIfFrozen = */ false);
  let arr2 = m2.toArrayInternal(/* failIfFrozen = */ false);
  const res = [];
  let start = 0;
  const length = arr1.length > arr2.length ? arr1.length : arr2.length;
  if (m1.getJsPbMessageId()) {
    res[0] = m1.getJsPbMessageId();
    start = 1;
  }
  for (let i = start; i < length; i++) {
    if (!compareFields(arr1[i], arr2[i])) {
      res[i] = arr2[i];
    }
  }
  return new m1.constructor(res);
};


/**
 * Tests whether two messages are equal.
 * @param {Message|undefined} m1 The first message object.
 * @param {Message|undefined} m2 The second message object.
 * @return {boolean} true if both messages are null/undefined, or if both are
 *     of the same type and have the same field values.
 */
Message.equals = function(m1, m2) {
  return m1 == m2 ||
      (!!(m1 && m2) && (m1 instanceof m2.constructor) &&
       compareFields(
           m1.toArrayInternal(/* failIfFrozen = */ false),
           m2.toArrayInternal(/* failIfFrozen = */ false)));
};

/**
 * Makes a deep copy of this message.
 *
 * Named `clone` for compatibility with `goog.object.unsafeClone`
 *
 * @return {T}
 * @this {T}
 * @template T
 */
Message.prototype.clone = function() {
  const self = asserts.assertInstanceof(this, Message);
  const ctor = /** @type {function(new:T, ?Array<?>=)} */ (self.constructor);
  const arr = /** @type {!Array<?>} */ (
      cloneJspb(self.toArrayInternal(/* failIfFrozen = */ false)));
  return newMessage(ctor, arr);
};


/**
 * Clears the value if it is a non-empty repeated field.
 *
 * Returns true if it was a repeated field, false otherwise.
 * @return {boolean}
 */
function tryClearIfRepeated(/** ? */ v) {
  if (isRepeatedField(v)) {
    // Only reset non-empty arrays, this is needed to avoid mutating the
    // EMPTY_LIST_SENTINEL and probably beneficial in general.
    if (v.length) {
      v.length = 0;
    }
    return true;
  }
  return false;
}

/**
 * Clear all fields of the message and set them to their default values.
 *
 * After this operation the message will be equivalent to a newly constructed
 * instance.
 *
 * @param {T} msg
 * @template T
 * @return {T}
 */
function clearMessage(msg) {
  asserts.assertInstanceof(msg, Message);
  checkNotFrozen(msg);
  const array = msg.internalArray_;
  // Iterate over all fields of the message to delete non-repeated fields from
  // the array.  For repeated fields we need to preserve them but empty them
  // out.  This is because various parts of the message API depend on repeated
  // fields being initialized in the constructor. preserve a message id if
  // present
  const start = msg.getJsPbMessageId() != null ? 1 : 0;
  const extensionObject = msg.internalExtensionObject_;
  const end = array.length + (extensionObject != null ? -1 : 0);
  for (let i = start; i < end; i++) {
    if (!tryClearIfRepeated(array[i])) {
      array[i] = null;
    }
  }
  if (extensionObject) {
    for (let key in extensionObject) {
      if (!hasOwnPropertyIfNotTrusted(extensionObject, key)) {
        continue;
      }
      if (!tryClearIfRepeated(extensionObject[key])) {
        // Delete instead of assigning undefined to ensure other operations
        // like clone don't need to iterate these properties.
        delete extensionObject[key];
      }
    }
  }
  // Reset our fields
  msg.internalWrappers_ = null;
  msg.convertedPrimitiveFields_ = null;
  // NOTE: unlike copyInto we don't need to reset the extension object or the
  // pivot, instead we can just preserve their current values.
  return msg;
}

/**
 * Takes 2 messages of the same type and copies the contents of the fromMessage
 * into toMessage. After this the 2 messages will equals in terms of
 * value semantics, but share no state. All data in the destination message will
 * be overridden.
 *
 * This function has equivalent functionality to `CopyFrom` found in other
 * proto implementations (C++, Python), and the signature is meant to match that
 * of core web methods like `Object.assign`.
 *
 * @param {MESSAGE} toMessage Message which will receive a copy of fromMessage
 * @param {MESSAGE} fromMessage Message that will be copied into toMessage.
 *     as its contents.
 * @template MESSAGE
 * @return {MESSAGE} toMessage
 */
function copyMessage(toMessage, fromMessage) {
  asserts.assertInstanceof(toMessage, Message);
  asserts.assertInstanceof(fromMessage, Message);
  asserts.assert(
      fromMessage.constructor == toMessage.constructor,
      'Copy source and target message should have the same type.');
  checkNotFrozen(toMessage);
  const fromArrayCopy =
      cloneJspb(fromMessage.toArrayInternal(/* failIfFrozen = */ false));
  // There is no point in syncing map fields if we are just going to delete
  // them, so just access the array directly.
  const toArray = toMessage.internalArray_;

  // Resize destination in case it has more values at the end of the array.
  toArray.length = fromArrayCopy.length;
  // and then copy everything from the new to the existing message.
  for (let i = 0; i < fromArrayCopy.length; i++) {
    toArray[i] = fromArrayCopy[i];
  }

  // Reset toMessage's fields
  toMessage.internalWrappers_ = null;
  toMessage.convertedPrimitiveFields_ = null;
  toMessage.internalExtensionObject_ = null;
  // if fromMessage has an extension object this will update our pivot and
  // internalExtensionObject_ field.
  initPivotAndExtensionObject(toMessage, toMessage.pivot_);

  return toMessage;
}

/**
 * Takes 2 messages of the same type and copies the contents of the first
 * message into the second. After this the 2 messages will equals in terms of
 * value semantics but share no state. All data in the destination message will
 * be overridden.
 *
 * @param {MESSAGE} fromMessage Message that will be copied into toMessage.
 * @param {MESSAGE} toMessage Message which will receive a copy of fromMessage
 *     as its contents.
 * @template MESSAGE
 */
Message.copyInto = function(fromMessage, toMessage) {
  copyMessage(toMessage, fromMessage);
};



/**
 * Throws an error if the msg is frozen.
 * @param {!Message} msg The message to check against.
 */
const checkNotFrozen = function(msg) {
  if (FreezerInfo.isFreezerLoaded && isFrozen(msg)) {
    throw new Error('Cannot mutate a frozen Message');
  }
};

// BEGIN AUTO-GENERATED ////////////////////////////////////////////////////////

/**
 * Gets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {T=} defaultValue The default value.
 * @return {T}
 * @template T
 * @protected
 * @final
 */
Message.prototype.internal_getIntegerFieldWithDefault = function(
    fieldNumber, defaultValue = 0) {
  return this.internal_getFieldWithDefault(fieldNumber, defaultValue);
};

/**
 * Gets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {T=} defaultValue The default value.
 * @return {T}
 * @template T
 * @protected
 * @final
 */
Message.prototype.internal_getIntegerInStringFieldWithDefault = function(
    fieldNumber, defaultValue = '0') {
  return this.internal_getFieldWithDefault(fieldNumber, defaultValue);
};

/**
 * Gets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {T=} defaultValue The default value.
 * @return {T}
 * @template T
 * @protected
 * @final
 */
Message.prototype.internal_getStringFieldWithDefault = function(
    fieldNumber, defaultValue = '') {
  return this.internal_getFieldWithDefault(fieldNumber, defaultValue);
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {boolean} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3BooleanField = function(
    fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, false);
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {number} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3IntField = function(fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, 0);
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {string} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3StringIntField = function(
    fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, '0');
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {number} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3FloatField = function(fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, 0);
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {string} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3StringField = function(fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, '');
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {!Uint8Array|string} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3BytesField = function(fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, '');
};

/**
 * Sets the value of a non-extension field.
 * @param {number} fieldNumber The field number.
 * @param {number} value The new value.
 * @return {THIS}
 * @this {THIS}
 * @template THIS
 * @protected
 * @final
 */
Message.prototype.internal_setProto3EnumField = function(fieldNumber, value) {
  return setFieldIgnoringDefault(
      /** @type {!Message} */ (this), fieldNumber, value, 0);
};

// END AUTO-GENERATED //////////////////////////////////////////////////////////

exports = {
  Message,
  clearMessage,
  copyMessage,
};

;return exports;});

//javascript/apps/jspb/internal_public.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Public APIs exposed purely for use by generated code.  Use of
 * these APIs outside of that context is not supported and actively discouraged.
 * @public
 */

goog.module('jspb.internal.public_for_gencode');
goog.module.declareLegacyNamespace();


const asserts = goog.require('goog.asserts');
const base64 = goog.require('goog.crypt.base64');
const garray = goog.require('goog.array');
const {BinaryReader} = goog.require('jspb.binary.reader');
const {BinaryWriter} = goog.requireType('jspb.binary.writer');
const {ExtensionFieldBinaryInfo} = goog.requireType('jspb.extension_field_binary_info');
const {ExtensionFieldInfo} = goog.requireType('jspb.extension_field_info');
const {GENERATED_SUBCLASS_MARKER, SUPPORTS_UINT8ARRAY, bytesAsU8, hasOwnPropertyIfNotTrusted} = goog.require('jspb.internal');
const {Map: JspbMap} = goog.requireType('jspb.map');
const {Message} = goog.require('jspb');
const {WireType} = goog.require('jspb.BinaryConstants');

/**
 * @define {boolean} Whether to generate toObject methods for objects. Turn
 *     this off, if you do not want toObject to be ever used in your project.
 *     When turning off this flag, consider adding a conformance test that bans
 *     calling toObject. Enabling this will disable the JSCompiler's ability to
 *     dead code eliminate fields used in protocol buffers that are never used
 *     in an application.
 */
const GENERATE_TO_OBJECT = goog.define('jspb.Message.GENERATE_TO_OBJECT', true);


/**
 * @define {boolean} Whether to generate fromObject methods for objects. Turn
 *     this off, if you do not want fromObject to be ever used in your project.
 *     When turning off this flag, consider adding a conformance test that bans
 *     calling fromObject. Enabling this might disable the JSCompiler's ability
 *     to dead code eliminate fields used in protocol buffers that are never
 *     used in an application.
 *     By default this is enabled for test code only.
 */
const GENERATE_FROM_OBJECT = goog.define(
    'jspb.Message.GENERATE_FROM_OBJECT', !goog.DISALLOW_TEST_ONLY_CODE);


/**
 * Converts a JsPb repeated message field into an object list.
 * @param {!Array<!T>} field The repeated message field to be
 *     converted.
 * @param {function((boolean|undefined),T_OR_NULL_UNDEFINED):(!O|undefined)}
 *     toObjectFn The toObject function for this field.  We need to pass this
 *     for effective dead code removal.
 * @param {boolean=} includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Array<!O>} An array of converted message objects.
 * @template T, O
 * Use go/closure-ttl  to create a `?T|undefined` type
 * @template T_OR_NULL_UNDEFINED := union(T, 'null', 'undefined') =:
 */
function toObjectList(field, toObjectFn, includeInstance) {
  // Not using array.map in the generated code to keep it small.
  // And not using it here to avoid a function call.
  const result = [];
  for (let i = 0; i < field.length; i++) {
    result.push(toObjectFn(includeInstance, field[i]));
  }
  return result;
}

/**
 * Adds a proto's extension data to a Soy rendering object.
 * @param {!Message} proto The proto whose extensions to convert.
 * @param {!Object} obj The Soy object to add converted extension data to.
 * @param {!Object<!ExtensionFieldInfo>} extensions The proto class' registered
 *     extensions.
 * @param {boolean=} includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 */
function toObjectExtension(proto, obj, extensions, includeInstance) {
  for (let fieldNumber in extensions) {
    if (!hasOwnPropertyIfNotTrusted(extensions, fieldNumber)) {
      continue;
    }
    const fieldInfo = extensions[fieldNumber];
    const value = proto.getExtension(fieldInfo);
    if (value != null) {
      let name;
      for (name in fieldInfo.fieldName) {
        if (fieldInfo.fieldName.hasOwnProperty(name)) {
          break;  // the compiled field name
        }
      }
      const toObjectFn = fieldInfo.toObjectFn;
      if (!toObjectFn) {
        obj[name] = value;
      } else {
        if (fieldInfo.isRepeated) {
          obj[name] = toObjectList(
              /** @type {!Array<!Message>} */ (value), toObjectFn,
              includeInstance);
        } else {
          obj[name] =
              toObjectFn(includeInstance, /** @type {!Message} */ (value));
        }
      }
    }
  }
}


/**
 * Writes a proto's extension data to a binary-format output stream.
 * @param {!Message} proto The proto whose extensions to convert.
 * @param {*} writer The binary-format writer to write to.
 * @param {!Object<!ExtensionFieldBinaryInfo>} extensions The proto class'
 *     registered extensions.
 */
function serializeBinaryExtensions(proto, writer, extensions) {
  for (let fieldNumber in extensions) {
    if (!hasOwnPropertyIfNotTrusted(extensions, fieldNumber)) {
      continue;
    }
    const binaryFieldInfo = extensions[fieldNumber];
    const fieldInfo = binaryFieldInfo.fieldInfo;

    // The old codegen doesn't add the extra fields to ExtensionFieldInfo, so we
    // need to gracefully error-out here rather than produce a null dereference
    // below.
    if (!binaryFieldInfo.binaryWriterFn) {
      throw new Error(
          'Message extension present that was generated ' +
          'without binary serialization support');
    }
    const value = proto.getExtension(fieldInfo);
    if (value != null) {
      if (fieldInfo.isMessageType()) {
        // If the message type of the extension was generated without binary
        // support, there may not be a binary message serializer function, and
        // we can't know when we codegen the extending message that the extended
        // message may require binary support, so we can *only* catch this error
        // here, at runtime (and this decoupled codegen is the whole point of
        // extensions!).
        if (binaryFieldInfo.binaryMessageSerializeFn) {
          binaryFieldInfo.binaryWriterFn.call(
              writer, fieldInfo.fieldIndex, value,
              binaryFieldInfo.binaryMessageSerializeFn);
        } else {
          throw new Error(
              'Message extension present holding submessage ' +
              'without binary support enabled, and message is ' +
              'being serialized to binary format');
        }
      } else {
        binaryFieldInfo.binaryWriterFn.call(
            writer, fieldInfo.fieldIndex, value);
      }
    }
  }
}


/**
 * Reads an message set extension from the given reader and, if a valid
 * extension, sets the extension value to the message set message.
 * @param {!Message} msg A jspb proto.
 * @param {!BinaryReader} reader
 * @param {!Object<!ExtensionFieldBinaryInfo>} extensions The extensions object.
 */
function readBinaryExtensionMessageSet(msg, reader, extensions) {
  // The wire format for a message set is defined by
  // google3/net/proto/message_set.proto
  if (reader.getFieldNumber() == 1 &&
      reader.getWireType() == WireType.START_GROUP) {
    let fieldNumber = 0;
    let rawBytes = null;
    while (reader.nextField()) {
      //  tag = 0 case
      if (reader.getWireType() == 0 && reader.getFieldNumber() == 0) {
        break;
      }
      if (reader.getWireType() == WireType.VARINT &&
          reader.getFieldNumber() == 2) {
        // message set type id case
        fieldNumber = reader.readUint32();
      } else if (
          reader.getWireType() == WireType.DELIMITED &&
          reader.getFieldNumber() == 3) {
        // message set contents case
        rawBytes = reader.readBytes();
      } else if (reader.getWireType() == WireType.END_GROUP) {
        // message set ending case
        break;
      } else {
        reader.skipField();
      }
    }
    if (reader.getFieldNumber() != 1 ||
        reader.getWireType() != WireType.END_GROUP || rawBytes == null ||
        fieldNumber == 0) {
      throw new Error('Malformed binary bytes for message set');
    }
    const binaryFieldInfo = extensions[fieldNumber];
    if (binaryFieldInfo) {
      const fieldInfo = binaryFieldInfo.fieldInfo;
      const newValue = new fieldInfo.ctor();
      binaryFieldInfo.binaryMessageDeserializeFn.call(
          newValue, newValue, new BinaryReader(rawBytes));
      msg.setExtension(fieldInfo, newValue);
    }
  } else {
    // TODO(yilunchong): change delimited type to be restored in unknowns when
    // jspb support unknowns.
    reader.skipField();
  }
}

/**
 * Reads an extension field from the given reader and, if a valid extension,
 * sets the extension value.
 * @param {!Message} msg A jspb proto.
 * @param {!BinaryReader} reader
 * @param {!Object<!ExtensionFieldBinaryInfo>=} extensions The extensions
 *     object.
 * @return {boolean} `true` if the field was consumed, otherwise false (implying
 *     an end group)
 */
function handleUnknownBinaryField(msg, reader, extensions) {
  if (reader.isEndGroup()) {
    return false;
  }
  if (extensions) {
    readBinaryExtension(msg, reader, extensions);
  } else {
    reader.skipField();
  }
  return true;
}

/**
 * Reads an extension field from the given reader and, if a valid extension,
 * sets the extension value.
 * @param {!Message} msg A jspb proto.
 * @param {!BinaryReader} reader
 * @param {!Object<!ExtensionFieldBinaryInfo>} extensions The extensions object.
 */
function readBinaryExtension(msg, reader, extensions) {
  const binaryFieldInfo = extensions[reader.getFieldNumber()];
  if (!binaryFieldInfo ||
      // NOTE: wireTypes only ever has 1 or 2 entries
      !garray.contains(binaryFieldInfo.wireTypes, reader.getWireType())) {
    reader.skipField();
    return;
  }
  const fieldInfo = binaryFieldInfo.fieldInfo;
  if (!binaryFieldInfo.binaryReaderFn) {
    throw new Error(
        'Deserializing extension whose generated code does not ' +
        'support binary format');
  }

  let value;
  if (fieldInfo.isMessageType()) {
    value = binaryFieldInfo.binaryReaderFn.call(
        reader, new fieldInfo.ctor(),
        binaryFieldInfo.binaryMessageDeserializeFn);
  } else {
    // All other types.
    value = binaryFieldInfo.binaryReaderFn.call(reader);
  }

  if (fieldInfo.isRepeated) {
    const currentList = msg.getExtension(fieldInfo);
    // For repeated fields that might be `packed` on the wire, binaryReaderFn
    // returns an array, for unpackable repeated fields we only get a single
    // value
    if (Array.isArray(value)) {
      Array.prototype.push.apply(currentList, value);
    } else {
      currentList.push(value);
    }
    // ensure messages are sync'd back to the array.
    msg.setExtension(fieldInfo, currentList);
  } else {
    msg.setExtension(fieldInfo, value);
  }
}


/**
 * Coerce a 'bytes' field to a base 64 string.
 * @param {string|!Uint8Array|null} value
 * @return {?string} The field's coerced value.
 */
function bytesAsB64(value) {
  if (value == null || typeof value === 'string') {
    return value;
  }
  if (SUPPORTS_UINT8ARRAY && value instanceof Uint8Array) {
    return base64.encodeByteArray(value);
  }
  asserts.fail('Cannot coerce to b64 string: ' + goog.typeOf(value));
  return null;
}


/**
 * Coerce a repeated 'bytes' field to an array of base 64 strings.
 * Note: the returned array should be treated as immutable.
 * @param {!Array<string>|!Array<!Uint8Array>} value
 * @return {!Array<string?>} The field's coerced value.
 */
function bytesListAsB64(value) {
  assertConsistentTypes(value);
  if (!value.length || typeof value[0] === 'string') {
    return /** @type {!Array<string>} */ (value);
  }
  return garray.map(value, bytesAsB64);
}


/**
 * Coerce a repeated 'bytes' field to an array of Uint8Array byte buffers.
 * Note: the returned array should be treated as immutable.
 * Note that Uint8Array is not supported on IE versions before 10 nor on Opera
 * Mini. @see http://caniuse.com/Uint8Array
 * @param {!Array<string>|!Array<!Uint8Array>} value
 * @return {!Array<Uint8Array?>} The field's coerced value.
 */
function bytesListAsU8(value) {
  assertConsistentTypes(value);
  if (!value.length || value[0] instanceof Uint8Array) {
    return /** @type {!Array<!Uint8Array>} */ (value);
  }
  return garray.map(value, bytesAsU8);
}


/**
 * Asserts that all elements of an array are of the same type.
 * @param {Array?} array The array to test.
 */
function assertConsistentTypes(array) {
  if (goog.DEBUG && array && array.length > 1) {
    const expected = goog.typeOf(array[0]);
    garray.forEach(array, function(e) {
      if (goog.typeOf(e) != expected) {
        asserts.fail(
            'Inconsistent type in JSPB repeated field array. ' +
            'Got ' + goog.typeOf(e) + ' expected ' + expected);
      }
    });
  }
}


/**
 * Write this Map field in wire format to a BinaryWriter, using the given
 * field number.
 * @param {!JspbMap<K,V>} map
 * @param {number} fieldNumber
 * @param {!BinaryWriter} writer
 * @param {function(this:BinaryWriter,number,K_OR_NULL)} keyWriterFn
 *     The method on BinaryWriter that writes type K to the stream.
 * @param {function(this:BinaryWriter,number,V,?=)|
 *          function(this:BinaryWriter,number,V,?)} valueWriterFn
 *     The method on BinaryWriter that writes type V to the stream.  May be
 *     writeMessage, in which case the second callback arg form is used.
 * @param {function(V,!BinaryWriter)=} valueWriterCallback
 *    The BinaryWriter serialization callback for type V, if V is a message
 *    type.
 * @template K,V
 * Use go/closure-ttl  to create a `K|null` type for the keyWriterFn argument
 * closure type inference will occasionally infer K based on the keyWriterFn
 * argument instead of the map argument which will cause type errors when they
 * don't match
 * @template K_OR_NULL := union(K, 'null') =:
 */
function serializeMapToBinary(
    map, fieldNumber, writer, keyWriterFn, valueWriterFn, valueWriterCallback) {
  map.forEach((value, key) => {
    writer.writeMessage(
        fieldNumber, /* we need a non-null value to pass here */ map,
        (ignored, w) => {
          keyWriterFn.call(w, 1, key);
          valueWriterFn.call(w, 2, value, valueWriterCallback);
        });
  });
}


/**
 * Read one key/value message from the given BinaryReader. Compatible as the
 * `reader` callback parameter to BinaryReader.readMessage, to be called
 * when a key/value pair submessage is encountered. If the Key is undefined,
 * we should default it to 0.
 * @template K, V
 * @param {!JspbMap} map
 * @param {!BinaryReader} reader
 * @param {function(this:BinaryReader):K} keyReaderFn
 *     The method on BinaryReader that reads type K from the stream.
 *
 * @param {function(this:BinaryReader):V|
 *          function(this:BinaryReader,V,
 *                  function(V,!BinaryReader))} valueReaderFn
 *    The method on BinaryReader that reads type V from the stream. May be
 *    readMessage, in which case the second callback arg form is used.
 *
 * @param {?function(V,!BinaryReader)=} valueReaderCallback
 *    The BinaryReader parsing callback for type V, if V is a message type
 *
 * @param {K=} defaultKey
 *    The default value for the type of map keys. Accepting map entries with
 *    unset keys is required for maps to be backwards compatible with the
 *    repeated message representation described here: goo.gl/zuoLAC
 *
 * @param {V=} defaultValue
 *    The default value for the type of map values. Accepting map entries with
 *    unset values is required for maps to be backwards compatible with the
 *    repeated message representation described here: goo.gl/zuoLAC
 */
function deserializeMapFromBinary(
    map, reader, keyReaderFn, valueReaderFn, valueReaderCallback, defaultKey,
    defaultValue) {
  let key = defaultKey;
  let value = defaultValue;

  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    const field = reader.getFieldNumber();

    if (field == 1) {
      // Key.
      key = keyReaderFn.call(reader);
    } else if (field == 2) {
      // Value.
      if (map.valueCtor) {
        asserts.assert(valueReaderCallback);
        if (!value) {
          // Old generator still doesn't provide default value message.
          // Need this for backward compatibility.
          value = new map.valueCtor();
        }
        valueReaderFn.call(reader, value, valueReaderCallback);
      } else {
        value = (/** @type {function(this:BinaryReader):?} */ (valueReaderFn))
                    .call(reader);
      }
    }
  }

  asserts.assert(key != undefined);
  asserts.assert(value != undefined);
  map.set(key, value);
}


/**
 * Returns the map formatted as an array of key-value pairs, suitable for the
 * toObject() form of a message.
 *
 * @template K, V
 * Use go/closure-ttl  to create a `?V|undefined` type
 * @template V_OR_NULL_UNDEFINED := union(V, 'null', 'undefined') =:
 * @param {!JspbMap<K,V>} map
 * @param {boolean=} includeInstance Whether to include the JSPB instance for
 *    transitional soy proto support: http://goto/soy-param-migration
 * @param {function((boolean|undefined),V_OR_NULL_UNDEFINED):(!Object|undefined)=}
 *     valueToObject
 *    The static toObject() method, if V is a message type.
 * @return {!Array<!Array<!Object>>}
 */
function mapToObject(map, includeInstance, valueToObject) {
  // this would be more natural as a call to Array.from passing a mapper
  // but that is disallowed by some applications.
  const entries = [];
  map.forEach((v, k) => {
    entries.push([k, valueToObject ? valueToObject(includeInstance, v) : v]);
  });
  return entries;
}

/**
 * Returns a Map from the given array of key-value pairs when the values are
 * of message type. The values in the array must match the format returned by
 * their message type's toObject() method.
 *
 * @template K, V
 * @param {!JspbMap<K,V>} map
 * @param {!Array<!Array<!Object>>} entries
 * @param {function(!Object):V} valueFromObject
 *    The fromObject function for type V.
 * @return {!JspbMap<K, V>}
 */
function mapFromObject(map, entries, valueFromObject) {
  for (let i = 0; i < entries.length; i++) {
    const key = entries[i][0];
    const value = valueFromObject(entries[i][1]);
    map.set(key, value);
  }
  return map;
}

/** Debug only implementation. */
class GeneratedMessageImpl extends Message {}
if (asserts.ENABLE_ASSERTS) {
  GeneratedMessageImpl.prototype[GENERATED_SUBCLASS_MARKER] = true;
}

/**
 * The baseclass used by generated code.
 *
 * In production mode this is `Message`, in debug it is `GeneratedMessageImpl` a
 * special intermediate class that we stash a custom property on so that
 * `Message` can confirm the provenance of subclasses.  See b/187815238.
 *
 * @type {typeof Message}
 */
const GeneratedMessage =
    asserts.ENABLE_ASSERTS ? GeneratedMessageImpl : Message;

exports = {
  GENERATE_FROM_OBJECT,
  GENERATE_TO_OBJECT,
  bytesAsB64,
  bytesAsU8,
  bytesListAsB64,
  bytesListAsU8,
  deserializeMapFromBinary,
  mapFromObject,
  mapToObject,
  handleUnknownBinaryField,
  readBinaryExtensionMessageSet,
  serializeBinaryExtensions,
  serializeMapToBinary,
  toObjectExtension,
  toObjectList,
  GeneratedMessage,
};

;return exports;});

//javascript/apps/jspb/message_alias.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Re-exports jspb.Message for compatibility with the old
 * namespace and export style.
 */
goog.module('jspb.Message');
goog.module.declareLegacyNamespace();

const {Message: JspbMessage} = goog.require('jspb');

/** @type {typeof JspbMessage} */
const Message = JspbMessage;

exports = Message;

;return exports;});

//javascript/jfk/button/proto_jspb/buttonstyle.jspb.js
// source: javascript/jfk/button/buttonstyle.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions,useOfGoogProvide} JS Compiler reports an error
 *     if a variable or field starts with 'MSG_' and isn't a translatable
 *     message.
 */
// GENERATED CODE -- DO NOT EDIT!

goog.provide('proto.jfk.ButtonStyle');
goog.provide('proto.jfk.ButtonStyle.Style');
goog.provide('proto.jfk.ButtonStyle.Width');

goog.require('jspb.BinaryReader');
goog.require('jspb.BinaryWriter');
goog.require('jspb.Message');
goog.require('jspb.internal.public_for_gencode');
goog.requireType('jspb.ByteSource');

/**
 * @final
 */
proto.jfk.ButtonStyle = class extends jspb.internal.public_for_gencode.GeneratedMessage {
  /**
   * Generated by JsPbCodeGenerator.
   * @param {?Array<?>=} data Optional initial data array, typically  from a
   *     server response. The array is used in place and becomes part of the
   *     constructed object. It is not cloned. If no data is provided, the
   *     constructed object will be empty, but  still
   */
  constructor(data) {
    super(data);
  }


  /**
   * Serializes the message to binary data (in protobuf wire format).
   * @return {!Uint8Array}
   */
  serializeBinary() {
    const writer = new jspb.BinaryWriter();
    proto.jfk.ButtonStyle.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
  }


  /**
   * Serializes the given message to binary data (in protobuf wire
   * format), writing to the given BinaryWriter.
   * @param {!proto.jfk.ButtonStyle} message
   * @param {!jspb.BinaryWriter} writer
   * @return {void}
   * @suppress {unusedLocalVariables} f is only used for nested messages
   */
  static serializeBinaryToWriter(message, writer) {
    let f;
  }


  /**
   * Deserializes binary data (in protobuf wire format).
   * @param {?jspb.ByteSource} bytes The bytes to deserialize.
   * @return {!proto.jfk.ButtonStyle}
   */
  static deserializeBinary(bytes) {
    return proto.jfk.ButtonStyle.deserializeBinaryFromReader(
        new proto.jfk.ButtonStyle(), new jspb.BinaryReader(bytes));
  }


  /**
   * Deserializes binary data (in protobuf wire format) from the
   * given reader into the given message object.
   * @param {!proto.jfk.ButtonStyle} msg The message object to deserialize into.
   * @param {!jspb.BinaryReader} reader The BinaryReader to use.
   * @return {!proto.jfk.ButtonStyle}
   */
  static deserializeBinaryFromReader(msg, reader) {
    while (reader.nextField()) {
        switch (reader.getTag()) {
        default:
          if (!jspb.internal.public_for_gencode.handleUnknownBinaryField(
                  msg, reader)) {
            return msg;
          }
          break;
        }
    }
    return msg;
  }


  /**
   * @param {string} data The serialized JSON data in JSPB wire format.
   * @return {!proto.jfk.ButtonStyle}
   */
  static deserialize(data) {
    return jspb.Message.deserializeWithCtor(proto.jfk.ButtonStyle, data);
  }


};

if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   * @type {string}
   */
  proto.jfk.ButtonStyle.displayName = 'proto.jfk.ButtonStyle';
}
if (jspb.internal.public_for_gencode.GENERATE_FROM_OBJECT ||
    jspb.internal.public_for_gencode.GENERATE_TO_OBJECT) {

/**
 * The raw object form of ButtonStyle as accepted by the `fromObject` method.
 * @record
 */
proto.jfk.ButtonStyle.ObjectFormat = function() {
};
}

if (jspb.internal.public_for_gencode.GENERATE_FROM_OBJECT) {

/**
 * Loads data from an object into a new instance of this proto.
 *
 * The object format is **not a stable serialization format**.
 * Using it as such will lead to undefined behavior.
 *
 * @param {!proto.jfk.ButtonStyle.ObjectFormat} obj
 *     The object representation of this proto to load the data from.
 * @return {!proto.jfk.ButtonStyle}
 */
proto.jfk.ButtonStyle.fromObject = function(obj) {
  const msg = new proto.jfk.ButtonStyle();
  return msg;
};
}



if (jspb.internal.public_for_gencode.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 *
 * The object format is **not a stable serialization format**.
 * Using it as such will lead to undefined behavior.
 *
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!proto.jfk.ButtonStyle.ObjectFormat}
 */
proto.jfk.ButtonStyle.prototype.toObject = function(includeInstance) {
  return /** @type {!proto.jfk.ButtonStyle.ObjectFormat} */ (proto.jfk.ButtonStyle.internal_toObject(includeInstance, this));
};


/**
 * Static, internal implementation of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {?proto.jfk.ButtonStyle|undefined} msg The msg instance to transform.
 * @return {!proto.jfk.ButtonStyle.ObjectFormat|undefined}
 * @suppress {unusedLocalVariables} f is only used when the message descriptor contains one or more fields which are not ignored
 */
proto.jfk.ButtonStyle.internal_toObject = function(includeInstance, msg) {
  if (msg == null) {
    return undefined;
  }
  let f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return /** @type {!proto.jfk.ButtonStyle.ObjectFormat} */ (obj);
};
}


/**
 * @enum {number}
 */
proto.jfk.ButtonStyle.Style = {
  STANDARD: 0,
  DEFAULT: 1,
  ACTION: 2,
  PRIMARY: 3,
  FLAT: 4,
  MINI: 5,
  CONTRAST: 6
};

/**
 * @enum {number}
 */
proto.jfk.ButtonStyle.Width = {
  NORMAL: 0,
  NARROW: 1
};


//javascript/jfk/tooltip/abstracttooltiprenderer.js
goog.loadModule(function(exports) {'use strict';goog.module('jfk.AbstractTooltipRenderer');
const Disposable = goog.require('goog.Disposable');
const LivePriority = goog.require('goog.a11y.aria.LivePriority');
const Role = goog.require('goog.a11y.aria.Role');
const State = goog.require('goog.a11y.aria.State');
const aria = goog.require('goog.a11y.aria');
const dom = goog.require('goog.dom');

/**
 * Creates a callout tooltip DOM element (but doesn't append it to the
 * document).  Provides methods to easily access the internal structure.
 * This is helpful for times when the presentation of the tooltip needs to be
 * shared, but the behavioral aspects have varying implementations.
 * @unrestricted
 */
const AbstractTooltipRenderer = class extends Disposable {
  /**
   * @param {dom.DomHelper=} opt_domHelper Optional DOM helper.
   */
  constructor(opt_domHelper) {
    super();

    /** @protected {!dom.DomHelper} */
    this.dom = opt_domHelper || dom.getDomHelper();
  }

  /**
   * Initializes the aria role and state of the tooltip element. Must be called
   * after the DOM is rendered and {@link #getElement()} returns a valid
   * Element.
   */
  initAriaState() {
    aria.setRole(this.getElement(), this.getAriaRole());
    aria.setState(this.getElement(), State.LIVE, LivePriority.POLITE);
  }

  /**
   * Returns the ARIA role to be applied to the tooltip element.
   * See http://wiki/Main/ARIA for more info.
   * @return {Role} ARIA role.
   */
  getAriaRole() {
    return Role.TOOLTIP;
  }
};

/**
 * @return {string} Root element CSS class name.
 */
AbstractTooltipRenderer.prototype.getClassName = goog.abstractMethod;

/**
 * @return {!Element} Tooltip element.
 */
AbstractTooltipRenderer.prototype.getElement = goog.abstractMethod;

/**
 * @return {!Element} Tooltip content wrapper element.
 */
AbstractTooltipRenderer.prototype.getContentElement = goog.abstractMethod;

/**
 * @return {!Element} Tooltip arrow element.
 */
AbstractTooltipRenderer.prototype.getArrowElement = goog.abstractMethod;

exports = AbstractTooltipRenderer;

;return exports;});

//javascript/jfk/tooltip/tooltiprenderer.js
goog.loadModule(function(exports) {'use strict';// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Renders a tooltip with a 'callout arrow' and provides methods
 * to access its internal structure.
 *
 * @author mleibman@google.com (Michael Leibman)
 */

goog.module('jfk.TooltipRenderer');
goog.module.declareLegacyNamespace();

const AbstractTooltipRenderer = goog.require('jfk.AbstractTooltipRenderer');
const TagName = goog.require('goog.dom.TagName');
const dom = goog.require('goog.dom');

/**
 * Creates a callout tooltip DOM element (but doesn't append it to the
 * document).  Provides methods to easily access the internal structure.
 * This is helpful for times when the presentation of the tooltip needs to be
 * shared, but the behavioral aspects have varying implementations.
 * @unrestricted
 */
const TooltipRenderer = class extends AbstractTooltipRenderer {
  /**
   * @param {dom.DomHelper=} opt_domHelper Optional DOM helper.
   */
  constructor(opt_domHelper) {
    super(opt_domHelper);

    /**
     * @type {!Element}
     * @private
     */
    this.contentEl_ = this.dom.createDom(
        TagName.DIV, goog.getCssName(this.getClassName(), 'contentId'));

    /**
     * @type {!Element}
     * @private
     */
    this.arrowEl_ = this.dom.createDom(
        TagName.DIV, goog.getCssName(this.getClassName(), 'arrow'),
        this.dom.createDom(
            TagName.DIV,
            goog.getCssName(this.getClassName(), 'arrowimplbefore')),
        this.dom.createDom(
            TagName.DIV,
            goog.getCssName(this.getClassName(), 'arrowimplafter')));

    /**
     * @type {!Element}
     * @private
     */
    this.tooltipEl_ = this.dom.createDom(
        TagName.DIV, {'class': this.getClassName(), 'role': 'tooltip'},
        this.contentEl_, this.arrowEl_);

    this.initAriaState();
  }

  /** @override */
  getClassName() {
    return goog.getCssName('jfk-tooltip');
  }

  /** @override */
  getElement() {
    return this.tooltipEl_;
  }

  /** @override */
  getContentElement() {
    return this.contentEl_;
  }

  /** @override */
  getArrowElement() {
    return this.arrowEl_;
  }

  /** @override */
  disposeInternal() {
    super.disposeInternal();
    if (this.tooltipEl_) {
      dom.removeNode(this.tooltipEl_);
    }
  }
};

exports = TooltipRenderer;

;return exports;});

//javascript/jfk/tooltip/silenttooltiprenderer.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview A tooltip renderer that prevents making the tooltip element an
 * ARIA live region.
 * @author markcollins@google.com (Mark Collins)
 */

goog.module('jfk.SilentTooltipRenderer');
goog.module.declareLegacyNamespace();

const DomHelper = goog.requireType('goog.dom.DomHelper');
const TooltipRenderer = goog.require('jfk.TooltipRenderer');
const aria = goog.require('goog.a11y.aria');

/**
 * A tooltip renderer for tooltips where the content text matches the ARIA label
 * of the anchor element.  In this case, the tooltip doesn't need to be a live
 * region because the ARIA label will announce on the anchor element.
 * @unrestricted
 */
const SilentTooltipRenderer = class extends TooltipRenderer {
  /**
   * @param {DomHelper=} opt_domHelper Optional DOM helper.
   */
  constructor(opt_domHelper) {
    super(opt_domHelper);
  }

  /**
   * Initializes the aria role of the tooltip element, but doesn't set the
   * element's state to LIVE.
   * @override
   */
  initAriaState() {
    aria.setRole(this.getElement(), this.getAriaRole());
  }
};

exports = SilentTooltipRenderer;

;return exports;});

//third_party/javascript/closure/html/utils.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview HTML processing utilities for HTML in string form.
 */

goog.provide('goog.html.utils');

goog.require('goog.string');


/**
 * Extracts plain text from HTML.
 *
 * This behaves similarly to extracting textContent from a hypothetical DOM
 * element containing the specified HTML.  Block-level elements such as div are
 * surrounded with whitespace, but inline elements are not.  Span is treated as
 * a block level element because it is often used as a container.  Breaking
 * spaces are compressed and trimmed.
 *
 * @param {string} value The input HTML to have tags removed.
 * @return {string} The plain text of value without tags, HTML comments, or
 *     other non-text content.  Does NOT return safe HTML!
 */
goog.html.utils.stripHtmlTags = function(value) {
  'use strict';
  // TODO(tnicole): Make a version that extracts text attributes such as alt.
  return goog.string.unescapeEntities(goog.string.trim(
      value
          .replace(
              goog.html.utils.HTML_TAG_REGEX_,
              function(fullMatch, tagName) {
                'use strict';
                return goog.html.utils.INLINE_HTML_TAG_REGEX_.test(tagName) ?
                    '' :
                    ' ';
              })
          .replace(/[\t\n ]+/g, ' ')));
};


/**
 * Matches all tags that do not require extra space.
 *
 * @private @const
 */
goog.html.utils.INLINE_HTML_TAG_REGEX_ =
    /^(?:abbr|acronym|address|b|em|i|small|strong|su[bp]|u)$/i;


/**
 * Matches all tags, HTML comments, and DOCTYPEs in tag soup HTML.
 * By removing these, and replacing any '<' or '>' characters with
 * entities we guarantee that the result can be embedded into
 * an attribute without introducing a tag boundary.
 *
 * @private @const
 */
goog.html.utils.HTML_TAG_REGEX_ = /<[!\/]?([a-z0-9]+)([\/ ][^>]*)?>/gi;

//javascript/jfk/tooltip/tooltipmanager.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview A document-wide tooltip provider.
 *
 * @author mleibman@google.com (Michael Leibman)
 */

goog.provide('jfk.tooltipManager');
goog.provide('jfk.tooltipManager.TriggerType');

goog.require('goog.Timer');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.array');
goog.require('goog.async.Delay');
goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.dom.safe');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.html.SafeHtml');
goog.require('goog.html.utils');
goog.require('goog.positioning.Corner');
goog.require('goog.string');
goog.require('goog.style');
goog.require('jfk.ArrowAlignment');
goog.require('jfk.ArrowPosition');
goog.require('jfk.PopupPosition');
goog.require('jfk.SilentTooltipRenderer');
goog.requireType('goog.events.Event');
goog.requireType('jfk.TooltipRenderer');


// TODO(mleibman):  Allow consumers to register the tooltip implementations and
// extraction delegates.


/**
 * Installs tooltip handler on a given DOM helper, or for the current document,
 * if none is specified.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 */
jfk.tooltipManager.install = function(opt_domHelper) {
  var domHelper = opt_domHelper || goog.dom.getDomHelper();
  var id = goog.getUid(domHelper.getDocument());
  if (!jfk.tooltipManager.instances_[id]) {
    jfk.tooltipManager.instances_[id] = new jfk.TooltipManager_(domHelper);
  }
};


/**
 * Uninstalls a previously installed tooltip handler on a given DOM helper,
 * or for the current document, if none is specified.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 */
jfk.tooltipManager.uninstall = function(opt_domHelper) {
  var domHelper = opt_domHelper || goog.dom.getDomHelper();
  var id = goog.getUid(domHelper.getDocument());
  if (jfk.tooltipManager.instances_[id]) {
    jfk.tooltipManager.instances_[id].dispose();
    delete jfk.tooltipManager.instances_[id];
  }
};


/**
 * Sets the tooltip on the given element with the given `tooltipText`.
 * The text will be html-escaped. If `opt_ariaLabel` is provided, the
 * tooltip's aria-label will be set to it, otherwise, it will be set to match
 * `tooltipText`.  For convenience, linebreaks will be converted to
 * <br>s.
 *
 * Passing an empty string to this function will remove the tooltip.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {string} tooltipText Text for the tooltip.
 * @param {string=} opt_ariaLabel Text to use for the tooltip's aria-label.
 */
jfk.tooltipManager.setTooltipText = function(
    element, tooltipText, opt_ariaLabel) {
  jfk.tooltipManager.setTooltipHelper_(element, tooltipText, opt_ariaLabel);
};


/**
 * Sets the tooltip on the given element with the given `tooltipHtml`.
 * If `opt_ariaLabel` is provided, the tooltip's aria-label will be set to
 * it, otherwise, it will be set to match text version of `tooltipHtml`.
 *
 * Cloning a node will not preverve the tooltip. Use data-tooltip-contained if
 * you need this.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {!goog.html.SafeHtml} tooltipHtml HTML for the tooltip.
 * @param {string=} opt_ariaLabel Text to use for the tooltip's aria-label.
 */
jfk.tooltipManager.setTooltipSafeHtml = function(
    element, tooltipHtml, opt_ariaLabel) {
  jfk.tooltipManager.setTooltipHelper_(element, tooltipHtml, opt_ariaLabel);
};


/**
 * Sets the tooltip on the given element using the title attribute of the
 * element if it exists. If the title attribute is undefined, the tooltip will
 * be unchanged. The title attribute will be html-escaped.
 *
 * @param {!Element} element Element to set the tooltip on.
 */
jfk.tooltipManager.setTooltipFromTitle = function(element) {
  var title = element.getAttribute('title');
  // TODO(akatkova):Use `!== undefined` or element.hasAttribute once we no
  // longer support ie7.
  if (!title) {
    return;
  }
  jfk.tooltipManager.setTooltipHelper_(element, title);
};


/**
 * Sets a tooltip on a given DOM element and ensures that a TooltipManager is
 * wired up for the parent document.
 *
 * The original "title" attribute will be deleted to prevent the default
 * browser tooltip from showing up and aria-label will be set to the new tooltip
 * or to `opt_ariaLabel` if it is defined.
 *
 * If `tooltip` is empty, the tooltip and aria-label are removed.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {string|!goog.html.SafeHtml} tooltip Tooltip text (if string) or HTML.
 * @param {string=} opt_ariaLabel Text to use for the tooltip's aria-label.
 * @private
 */
jfk.tooltipManager.setTooltipHelper_ = function(
    element, tooltip, opt_ariaLabel) {
  var ariaLabel = opt_ariaLabel;
  if (!ariaLabel) {
    ariaLabel =
        (tooltip instanceof goog.html.SafeHtml ?
             goog.html.utils.stripHtmlTags(goog.html.SafeHtml.unwrap(tooltip)) :
             tooltip);
  }
  element.removeAttribute('title');
  element.removeAttribute(jfk.tooltipManager.TOOLTIP_CONTAINED_ATTR_);
  element.removeAttribute(jfk.tooltipManager.TOOLTIP_ATTR_);

  if (tooltip) {
    if (tooltip instanceof goog.html.SafeHtml) {
      element.jfkTooltipHtmlInternal = tooltip;
    } else {
      element.setAttribute(jfk.tooltipManager.TOOLTIP_ATTR_, tooltip);
      element.jfkTooltipHtmlInternal = null;
    }
    element.setAttribute('aria-label', ariaLabel);
  } else {
    element.jfkTooltipHtmlInternal = null;
    element.removeAttribute('aria-label');
  }

  jfk.tooltipManager.install(goog.dom.getDomHelper(element));
};


/**
 * Sets the tooltip delay on a given DOM element. This should be used in
 * conjunction with setTooltip so that the tooltip content is also set. Without
 * content, the delay attribute has no effect.
 *
 * The minimum delay is configurable at SHOW_DELAY_MS, although this may change
 * in the future.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {number} delay Delay in ms to wait before showing the tooltip. The
 *     minimum delay is configurable at SHOW_DELAY_MS.
 */
jfk.tooltipManager.setTooltipDelay = function(element, delay) {
  element.setAttribute(jfk.tooltipManager.TOOLTIP_DELAY_ATTR, delay);
};


/**
 * Sets the tooltip hide delay on a given DOM element. This should be used in
 * conjunction with setTooltip so that the tooltip content is also set. Without
 * content, the hide delay attribute has no effect.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {number} delay Delay in ms to wait before hiding the tooltip.
 */
jfk.tooltipManager.setTooltipHideDelay = function(element, delay) {
  element.setAttribute(jfk.tooltipManager.TOOLTIP_HIDE_DELAY_ATTR_, delay);
};


/**
 * Sets the tooltip position and alignment on a given DOM element. This should
 * be used in conjunction with setTooltip so that the tooltip content is also
 * set. Without content, the position attribute has no effect.
 *
 * @param {!Element} element Element to set the tooltip on.
 * @param {jfk.PopupPosition} position Popup position for the tooltip.
 * @param {jfk.ArrowAlignment} alignment Alignment for the tooltip
 *     arrow.
 */
jfk.tooltipManager.setTooltipPosition = function(element, position, alignment) {
  element.setAttribute(
      jfk.tooltipManager.TOOLTIP_ALIGNMENT_ATTR,
      jfk.TooltipManager_.computeAlignmentAttr_(position, alignment));
};


/**
 * Sets the tooltip offset on a given DOM element. This should be used in
 * conjunction with setTooltip so that the tooltip content is also set. Without
 * content, the position attribute has no effect.
 *
 * @param {!Element} element Element to set the tooltip offset on.
 * @param {number} offset Offset (in px) for the tooltip with respect to the
 *     anchor. Positive value brings the tooltip closer to the center of the
 *     anchor.
 */
jfk.tooltipManager.setTooltipOffset = function(element, offset) {
  element.setAttribute(jfk.tooltipManager.TOOLTIP_OFFSET_ATTR, offset);
};


/**
 * Sets the types of events that will trigger the tooltip. By default, both
 * focus and mouse events will cause it to appear.
 * @param {!Element} element The element to change tooltip behavior for.
 * @param {jfk.tooltipManager.TriggerType} triggerType The type of trigger that
 *     the tooltip should respond to..
 */
jfk.tooltipManager.setTooltipTrigger = function(element, triggerType) {
  if (triggerType == jfk.tooltipManager.TriggerType.ALL) {
    element.removeAttribute(jfk.tooltipManager.TOOLTIP_TRIGGER_ATTR);
  } else {
    element.setAttribute(jfk.tooltipManager.TOOLTIP_TRIGGER_ATTR, triggerType);
  }
};


/**
 * Adds the given class name to the given tooltip.
 * @param {!Element} element The element to add the class names to.
 * @param {string} className Additional CSS class for the tooltip.
 */
jfk.tooltipManager.setTooltipClass = function(element, className) {
  // TODO(mayzie): Add support for multiple class names.
  if (!goog.string.isEmptyOrWhitespace(goog.string.makeSafe(className))) {
    element.setAttribute(jfk.tooltipManager.TOOLTIP_CLASS_ATTR_, className);
  }
};


/**
 * Suspends or resumes all tooltips on the element specified, but not those of
 * ancestors or descendants. When a tooltip is suspended, it doesn't
 * appear on hover, but the tooltip is still present in the element attributes,
 * so it can be restored without setting up the tooltip again.
 * @param {!Element} element Element to set the tooltip on.
 * @param {boolean} suspend Whether to suspend or resume the tooltip.
 **/
jfk.tooltipManager.setTooltipSuspended = function(element, suspend) {
  if (suspend) {
    element.setAttribute(jfk.tooltipManager.TOOLTIP_SUSPENDED_ATTR_, 'true');
  } else {
    element.removeAttribute(jfk.tooltipManager.TOOLTIP_SUSPENDED_ATTR_);
  }
};


/**
 * Prevents the tooltip from staying visible when it itself is hovered. This is
 * usefull for simple text tooltips that are not interactive.
 * @param {!Element} element Element to set the tooltip on.
 * @param {boolean} unhoverable Whether to make the tooltip unhoverable (hover
 *     on the tooltip will not keep it visible).
 **/
jfk.tooltipManager.setTooltipUnhoverable = function(element, unhoverable) {
  if (unhoverable) {
    element.setAttribute(jfk.tooltipManager.TOOLTIP_UNHOVERABLE_ATTR_, 'true');
  } else {
    element.removeAttribute(jfk.tooltipManager.TOOLTIP_UNHOVERABLE_ATTR_);
  }
};


/**
 * Prevents the tooltip from showing on the specified element unless the
 * contents of the element is overflowing (in either the x or y direction).
 * @param {!Element} element Element to set the tooltip on.
 * @param {boolean} onlyOnOverflow Whether to show tooltips for this element
 *     only when the contents are overflowing.
 */
jfk.tooltipManager.setTooltipOnlyOnOverflow = function(
    element, onlyOnOverflow) {
  if (onlyOnOverflow) {
    element.setAttribute(
        jfk.tooltipManager.TOOLTIP_ONLY_ON_OVERFLOW_ATTR_, 'true');
  } else {
    element.removeAttribute(jfk.tooltipManager.TOOLTIP_ONLY_ON_OVERFLOW_ATTR_);
  }
};


/**
 * Hides the tooltip on the given DOM helper, or for the current document, if
 * none is specified.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 */
jfk.tooltipManager.hide = function(opt_domHelper) {
  var domHelper = opt_domHelper || goog.dom.getDomHelper();
  var id = goog.getUid(domHelper.getDocument());
  if (jfk.tooltipManager.instances_[id]) {
    jfk.tooltipManager.instances_[id].hideTooltip();
  }
};


/**
 * Class name of the nested element with tooltip contents.
 * @private {string}
 */
jfk.tooltipManager.TOOLTIP_ELEMENT_CLASS_ = goog.getCssName('jfk-tooltip-data');


/**
 * Element attribute specifying to extract the tooltip from nested element.
 * @private {string}
 */
jfk.tooltipManager.TOOLTIP_CONTAINED_ATTR_ = 'data-tooltip-contained';


/**
 * Element attribute to extract the tooltip text from.
 * @type {string}
 * @private
 */
jfk.tooltipManager.TOOLTIP_ATTR_ = 'data-tooltip';


/**
 * Element attribute indicating whether the tooltip is suspended.
 * @type {string}
 * @private
 */
jfk.tooltipManager.TOOLTIP_SUSPENDED_ATTR_ = 'data-tooltip-suspended';


/**
 * Element attribute indicating whether the tooltip should only be displayed
 * if the elements contents are overflowing.
 * @type {string}
 * @private
 */
jfk.tooltipManager.TOOLTIP_ONLY_ON_OVERFLOW_ATTR_ =
    'data-tooltip-only-on-overflow';


/**
 * Element attribute to extract the additional tooltip CSS class from.
 * @private {string}
 */
jfk.tooltipManager.TOOLTIP_CLASS_ATTR_ = 'data-tooltip-class';


/**
 * Element attribute to extract the popup position and tooltip alignment from.
 * Properties are comma separated, with the first property being the popup
 * position and second the tooltip alignment.
 * The popup position can be one of: 'l' for left, 't' for top, 'r' for right,
 * and 'b' for bottom which is the default.
 * The tooltip alignment can be one of: 'l' for left-or-top, 'r' for
 * right-or-bottom, or 'c' for center which is the default.
 * E.g. t,r for a tooltip that displays above the given element with the arrow
 * aligned near the right side of the popup.
 * @type {string}
 */
jfk.tooltipManager.TOOLTIP_ALIGNMENT_ATTR = 'data-tooltip-align';


/**
 * Element attribute to extract the popup offset from. Positive value brings the
 * tooltip closer to the center of the anchor. If the attribute is absent, the
 * default value of -1 will be assumed.
 * @type {string}
 */
jfk.tooltipManager.TOOLTIP_OFFSET_ATTR = 'data-tooltip-offset';


/**
 * Element attribute indicating whether to disable hover on the tooltip itself.
 * If unhoverable, the tooltip will not be taken into account when handling
 * hover changes (ie, hovering on the tooltip will not keep it visible).
 * @type {string}
 * @private
 */
jfk.tooltipManager.TOOLTIP_UNHOVERABLE_ATTR_ = 'data-tooltip-unhoverable';


/**
 * Element attribute to extract the tooltip delay from. Note that there is a
 * minumum delay configurable at SHOW_DELAY_MS, and any smaller values will be
 * ignored.
 *
 * TODO(moedinger): If we want to allow having a delay less than SHOW_DELAY_MS,
 * then we should add a THROTTLE_DELAY_MS for the listening and just use
 * SHOW_DELAY_MS and HIDE_DELAY_MS for the default values.
 * @type {string}
 */
jfk.tooltipManager.TOOLTIP_DELAY_ATTR = 'data-tooltip-delay';


/**
 * Element attribute to extract the tooltip hide delay from.
 * @type {string}
 * @private
 */
jfk.tooltipManager.TOOLTIP_HIDE_DELAY_ATTR_ = 'data-tooltip-hide-delay';


/**
 * The attribute to determine when a tooltip should be triggered on a DOM
 * element. Its values should come from the
 * {jfk.tooltipManager.TriggerType} enum. If the attribute is absent,
 * the default value of ALL will be assumed.
 * @type {string}
 * @see {jfk.tooltipManager.TriggerType}
 */
jfk.tooltipManager.TOOLTIP_TRIGGER_ATTR = 'data-tooltip-trigger';


/**
 * An enumeration of possible triggers for the tooltip.
 * @enum {string}
 */
jfk.tooltipManager.TriggerType = {
  /** Triggers tooltip by either mouse hover or focus. This is the default. */
  ALL: 'all',

  /** Triggers tooltip by mouse hover only. */
  MOUSE: 'mouse'
};


/**
 * Delay in ms before a tooltip is shown.
 * @type {number}
 */
jfk.tooltipManager.SHOW_DELAY_MS = 300;


/**
 * Delay in ms before a tooltip is hidden.
 * @type {number}
 */
jfk.tooltipManager.HIDE_DELAY_MS = 50;


/**
 * Default offset of the tooltip from the anchor element. Positive values bring
 * the tooltip closer to the center of the anchor.
 * @type {number}
 */
jfk.tooltipManager.TOOLTIP_OFFSET_PX = -1;


/**
 * A map of document UIDs to TooltipManager_ instances.
 * @type {Object.<number, jfk.TooltipManager_>}
 * @private
 */
jfk.tooltipManager.instances_ = {};



/**
 * A document-wide tooltip provider.
 * A replacement for goog.ui.Tooltip allowing for tooltips to be set in the
 * HTML declaratively and eliminating the need for goog.ui.Tooltip instances
 * to be created individually.  This improves performance by eliminating
 * redundant DOM nodes, event listeners and boilerplate JavaScript code.
 * The tooltip manager ensures that there is only one active tooltip at a time.
 * @private
 * @unrestricted
 */
jfk.TooltipManager_ = class extends goog.events.EventHandler {
  /**
   * @param {!goog.dom.DomHelper} domHelper DOM helper.
   */
  constructor(domHelper) {
    super();

    /**
     * @type {goog.dom.DomHelper}
     * @private
     */
    this.domHelper_ = domHelper;

    /**
     * @type {goog.async.Delay}
     * @private
     */
    this.delay_ = new goog.async.Delay(this.throttledHover_, 0, this);
    this.registerDisposable(this.delay_);

    var win = goog.dom.getWindow();
    /** @private {MutationObserver} */
    this.mutationObserver_ = typeof win.MutationObserver === 'function' ?
        new win.MutationObserver(
            goog.bind(this.handleAttributesChange_, this)) :
        null;

    var doc = domHelper.getDocument();

    // NOTE:  FOCUS and BLUR events do not bubble and IE doesn't support event
    // capturing, so we use the FOCUSIN and FOCUSOUT events which are mapped to
    // the proprietary IE events (identically named) that do bubble and the
    // generally unsupported DOMFocusIn and DOMFocusOut for everyone else.
    // For all other browsers, FOCUS and BLUR can be captured at the document
    // level.

    // ALL of these events are needed.  Do not change without extensive testing!
    this.listen(
        doc,
        [
          goog.events.EventType.MOUSEOUT, goog.events.EventType.MOUSEDOWN,
          goog.events.EventType.CLICK, goog.events.EventType.BLUR,
          goog.events.EventType.FOCUSOUT, goog.events.EventType.KEYDOWN
        ],
        this.clearActiveElement_, true);

    this.listen(
        doc,
        [
          goog.events.EventType.MOUSEOVER, goog.events.EventType.FOCUS,
          goog.events.EventType.FOCUSIN
        ],
        this.setActiveElement_, true);
  }

  /** @override */
  disposeInternal() {
    this.clearSecondaryTimer_();
    super.disposeInternal();
  }

  /**
   * Tracks whether the last event was triggered by a keyboard.
   * This lets us detect when a FOCUS event is triggered via a keyboard
   * and not by clicking on the element.  If a window loses focus and is
   * later re-activated, this flag will retain its state, so the tooltip
   * will be shown only if it has previously been shown as a result of
   * keyboard navigation.  Yay.
   * @param {goog.events.Event} e Event object.
   * @private
   */
  trackEventTrigger_(e) {
    switch (e.type) {
      case goog.events.EventType.MOUSEDOWN:
      case goog.events.EventType.MOUSEOVER:
      case goog.events.EventType.MOUSEOUT:
      case goog.events.EventType.CLICK:
        this.isKeyboardEvent_ = false;
        break;
      case goog.events.EventType.KEYDOWN:
        this.isKeyboardEvent_ = true;
        break;
    }
  }

  /**
   * Sets the active element from event target and resets the timer.
   * @param {goog.events.Event} e Event object.
   * @private
   */
  setActiveElement_(e) {
    // Disconnect the observer on focus change event.
    if (this.mutationObserver_) {
      this.mutationObserver_.disconnect();
    }

    this.trackEventTrigger_(e);
    var targetEl = /** @type {Element}*/ (e.target);
    // If the focus was caused by a non-key event and the target
    // is outside the tooltip, then treat it as a signal to
    // hide the tooltip.
    // This can happen either programmatically, by the browser window
    // getting focused and re-setting focus on the last focused element
    // or as a result of a mouse interaction.
    var focusEvent =
        (e.type == goog.events.EventType.FOCUS ||
         e.type == goog.events.EventType.FOCUSIN);
    var isTargetWithinTooltip = this.tooltip_ &&
        goog.dom.contains(this.tooltip_.getContentElement(), targetEl);
    if (!this.isKeyboardEvent_ && focusEvent && !isTargetWithinTooltip) {
      this.activeEl_ = null;
    } else {
      this.isFocusEvent_ = focusEvent;

      if (targetEl && targetEl.getAttribute && this.mutationObserver_ &&
          goog.a11y.aria.isContainerRole(targetEl)) {
        // Focus remains on the container when arrowing around active
        // descendants. So if the element belongs to a container role, then
        // start observing the attributes change on the container element.
        this.observeMutations_(targetEl);

        // If target element already has active-descendant then handle setting
        // tooltip for the first time.
        var activeDescendant = goog.a11y.aria.getActiveDescendant(targetEl);
        if (activeDescendant) {
          targetEl = activeDescendant;
        }
      }

      this.activeEl_ = targetEl;
    }
    this.resetTimer_();
  }

  /**
   * Starts observing mutations on the target element.
   * @param {Element} targetEl Element to observe mutations on.
   * @private
   */
  observeMutations_(targetEl) {
    var config = /** @type {MutationObserverInit} */ ({attributes: true});
    this.mutationObserver_.observe(targetEl, config);
  }

  /**
   * Clears the active element and resets the timer.
   * @param {goog.events.Event} e Event object.
   * @private
   */
  clearActiveElement_(e) {
    this.trackEventTrigger_(e);
    var targetEl = /** @type {Element}*/ (e.target);
    var isClickEvent = e.type == goog.events.EventType.MOUSEDOWN ||
        e.type == goog.events.EventType.CLICK;
    var isTargetWithinTooltip = this.tooltip_ &&
        goog.dom.contains(this.tooltip_.getContentElement(), targetEl);
    if (isClickEvent && isTargetWithinTooltip) {
      return;
    }

    this.activeEl_ = null;
    this.resetTimer_();
  }

  /**
   * Handles attribute changes on the target element.
   * @param {Array.<!MutationRecord>} mutations List of mutations received by
   *     message observer.
   * @param {MutationObserver} observer Reference to the message observer.
   * @private
   */
  handleAttributesChange_(mutations, observer) {
    goog.array.forEach(mutations, goog.bind(function(mutation) {
      var el = goog.a11y.aria.getActiveDescendant(mutation.target);
      var ARIA_PREFIX = 'aria-';
      var attributeName = ARIA_PREFIX + goog.a11y.aria.State.ACTIVEDESCENDANT;
      if (el && mutation.attributeName == attributeName) {
        this.activeEl_ = el;
        this.resetTimer_();
      }
    }, this));
  }

  /**
   * Resets the throttle timer.
   * The delay varies depending on whether a tooltip is active and whether a
   * custom hide delay was set for the current tooltip.
   * @private
   */
  resetTimer_() {
    // Skip resetting the timer when a tooltip is already visible and has a
    // custom delay in progress. Otherwise the tooltip will never to hidden
    // while the user is interacting within the delay time (ex: moving the mouse
    // over different element within the delay time).
    if (this.delay_.isActive() && this.hoverEl_ && this.tooltipHideDelayMs_) {
      return;
    }

    this.clearSecondaryTimer_();

    var hideDelay = this.tooltipHideDelayMs_ != null ?
        this.tooltipHideDelayMs_ :
        jfk.tooltipManager.HIDE_DELAY_MS;
    var delay = this.hoverEl_ ? hideDelay : jfk.tooltipManager.SHOW_DELAY_MS;
    this.delay_.start(delay);
  }

  /**
   * Clears the secondary timer. Secondary timer may be present of the
   * tooltip delay is customized to be > the mouseover delay.
   * @private
   */
  clearSecondaryTimer_() {
    if (this.secondaryTimerId_) {
      goog.Timer.clear(this.secondaryTimerId_);
      this.secondaryTimerId_ = 0;
      this.hoverEl_ = null;
    }
  }

  /**
   * @param {!Element} element
   * @return {!goog.html.SafeHtml}
   * @private
   */
  static getTooltipHtml_(element) {
    if (element.jfkTooltipHtmlInternal) {
      return /** @type {!goog.html.SafeHtml} */ (
          element.jfkTooltipHtmlInternal);
    }
    return goog.html.SafeHtml.htmlEscapePreservingNewlines(
        element.getAttribute(jfk.tooltipManager.TOOLTIP_ATTR_));
  }

  /**
   * Throttled "hover intent" event.
   * Potentially hides an existing tooltip and/or shows a new one.
   * @private
   */
  throttledHover_() {
    if (!this.activeEl_) {
      // This can happen when the tooltip target is overlapping one of
      // the browser viewport edge.
      this.hideTooltip();
      return;
    }

    // Are we hovering over the tooltip itself?
    if (this.hoverEl_ && this.tooltip_ &&
        goog.dom.contains(this.tooltip_.getElement(), this.activeEl_) &&
        !this.hoverEl_.getAttribute(
            jfk.tooltipManager.TOOLTIP_UNHOVERABLE_ATTR_)) {
      return;
    }

    var ancestorWithTooltip = /** @type {Element} */ (
        goog.dom.getAncestor(this.activeEl_, function(node) {
          return node.getAttribute &&
              (node.getAttribute(jfk.tooltipManager.TOOLTIP_CONTAINED_ATTR_) ||
               node.getAttribute(jfk.tooltipManager.TOOLTIP_ATTR_) ||
               node.jfkTooltipHtmlInternal) &&
              !node.getAttribute(jfk.tooltipManager.TOOLTIP_SUSPENDED_ATTR_);
        }, true));

    var tooltipWasVisibleAndThenHidden = false;
    if (this.hoverEl_ && this.hoverEl_ != ancestorWithTooltip) {
      this.hideTooltip();
      tooltipWasVisibleAndThenHidden = true;
    }

    if (!this.hoverEl_ && ancestorWithTooltip) {
      this.hoverEl_ = ancestorWithTooltip;
      if (!this.shouldShowTooltip_(ancestorWithTooltip)) {
        return;
      }

      var tooltipHtml = goog.html.SafeHtml.EMPTY;
      if (ancestorWithTooltip.getAttribute(
              jfk.tooltipManager.TOOLTIP_CONTAINED_ATTR_)) {
        var tooltipEls = goog.dom.getElementsByClass(
            jfk.tooltipManager.TOOLTIP_ELEMENT_CLASS_, ancestorWithTooltip);
        for (var i = 0; i < tooltipEls.length; i++) {
          if (tooltipEls[i].parentNode == ancestorWithTooltip) {
            tooltipHtml = tooltipEls[i].cloneNode(true);
            break;
          }
        }
      } else {
        tooltipHtml = jfk.TooltipManager_.getTooltipHtml_(ancestorWithTooltip);
      }

      var alignmentAttr = ancestorWithTooltip.getAttribute(
          jfk.tooltipManager.TOOLTIP_ALIGNMENT_ATTR);
      var classAttr = ancestorWithTooltip.getAttribute(
          jfk.tooltipManager.TOOLTIP_CLASS_ATTR_);
      var offsetAttr = ancestorWithTooltip.getAttribute(
          jfk.tooltipManager.TOOLTIP_OFFSET_ATTR);
      var offset =
          goog.string.isEmptyOrWhitespace(goog.string.makeSafe(offsetAttr)) ?
          jfk.tooltipManager.TOOLTIP_OFFSET_PX :
          Number(offsetAttr);
      var hideDelayAttr = ancestorWithTooltip.getAttribute(
          jfk.tooltipManager.TOOLTIP_HIDE_DELAY_ATTR_);
      var hideDelay =
          goog.string.isEmptyOrWhitespace(goog.string.makeSafe(hideDelayAttr)) ?
          null :
          Number(hideDelayAttr);

      if (!tooltipWasVisibleAndThenHidden) {
        var delay = ancestorWithTooltip.getAttribute(
            jfk.tooltipManager.TOOLTIP_DELAY_ATTR);
        delay = Math.max(0, delay - jfk.tooltipManager.SHOW_DELAY_MS);
        if (delay) {
          this.secondaryTimerId_ = goog.Timer.callOnce(
              goog.partial(
                  this.showTooltipImpl_, this.hoverEl_, tooltipHtml,
                  alignmentAttr, offset, classAttr, hideDelay),
              delay, this);
          return;
        }
      }

      this.showTooltipImpl_(
          this.hoverEl_, tooltipHtml, alignmentAttr, offset, classAttr,
          hideDelay);
    }
  }

  /**
   * Whether a tooltip should be shown for the given element.
   * @param {Element} element
   * @return {boolean} Whether the tooltip should be shown.
   * @private
   */
  shouldShowTooltip_(element) {
    // Check if contents are overflowing and if the element only shows tooltips
    // on overflowing content.
    if (element.getAttribute(
            jfk.tooltipManager.TOOLTIP_ONLY_ON_OVERFLOW_ATTR_) &&
        element.offsetWidth >= element.scrollWidth &&
        element.offsetHeight >= element.scrollHeight) {
      return false;
    }

    // Check if this is a focus event and the element doesn't show tooltips
    // on focus.
    if (this.isFocusEvent_) {
      var showOnFocus = jfk.tooltipManager.TriggerType.MOUSE !=
          element.getAttribute(jfk.tooltipManager.TOOLTIP_TRIGGER_ATTR);
      if (!showOnFocus) {
        return false;
      }
    }
    return true;
  }

  /**
   * Computes the alignment attribute value that is the string representation of
   * the given popup position and arrow alignment.
   * @param {jfk.PopupPosition} position The popup position.
   * @param {jfk.ArrowAlignment} alignment The enum value for the popup
   *     position to.
   * @return {string} The computed alignment attribute value that is the string
   *     representation of the given popup position and arrow alignment.
   * @private
   */
  static computeAlignmentAttr_(position, alignment) {
    var alignmentAttr = '';
    switch (position) {
      case jfk.PopupPosition.LEFT:
        alignmentAttr += 'l';
        break;
      case jfk.PopupPosition.TOP:
        alignmentAttr += 't';
        break;
      case jfk.PopupPosition.RIGHT:
        alignmentAttr += 'r';
        break;
      default:
        alignmentAttr += 'b';
        break;
    }

    alignmentAttr += ',';

    switch (alignment) {
      case jfk.ArrowAlignment.LEFT_OR_TOP:
        alignmentAttr += 'l';
        break;
      case jfk.ArrowAlignment.RIGHT_OR_BOTTOM:
        alignmentAttr += 'r';
        break;
      default:
        alignmentAttr += 'c';
        break;
    }
    return alignmentAttr;
  }

  /**
   * Parses the position from an alignment string and returns the PopupPosition
   * enum value. The format is specified in the documentation for
   * TOOLTIP_ALIGNMENT_ATTR.
   * @param {string} alignmentStr The alignment string. Properties are space
   *     separated, with the first property being the arrow the second the popup
   *     position. Popup position can be one of: 'l' for left, 't' for top, 'r'
   *     for right, and 'b' for bottom which is the default.
   * @return {jfk.PopupPosition} The enum value for the popup position to
   *     use.
   * @private
   */
  static parsePosition_(alignmentStr) {
    if (alignmentStr) {
      var splitStr = alignmentStr.toLowerCase().split(',');
      switch (splitStr[0]) {
        case 'l':
          return jfk.PopupPosition.LEFT;
        case 't':
          return jfk.PopupPosition.TOP;
        case 'r':
          return jfk.PopupPosition.RIGHT;
      }
    }
    return jfk.PopupPosition.BOTTOM;
  }

  /**
   * Parses the arrow alignment from an alignment attribute string and returns
   * the ArrowAlignment enum value. The format is specified in the documentation
   * for TOOLTIP_ALIGNMENT_ATTR.
   * @param {string} alignmentStr The alignment string. Properties are space
   *     separated, with the first property being the arrow the second the popup
   *     position. Arrow alignment can be one of: 'l' for left-or-top, 'r' for
   *     right-or-bottom, or 'c' for center which is the default.
   * @return {jfk.ArrowAlignment} The enum value for the arrow alignment
   *     to use.
   * @private
   */
  static parseArrowAlignment_(alignmentStr) {
    if (alignmentStr) {
      var splitStr = alignmentStr.toLowerCase().split(',');
      switch (splitStr[1]) {
        case 'l':
          return jfk.ArrowAlignment.LEFT_OR_TOP;
        case 'r':
          return jfk.ArrowAlignment.RIGHT_OR_BOTTOM;
      }
    }
    return jfk.ArrowAlignment.CENTER;
  }

  /**
   * Shows a tooltip.
   * @param {Element} anchor Element that the tooltip should be anchored to.
   * @param {!Element|!goog.html.SafeHtml} tooltipHtml Element containing the
   *     tooltip or HTML markup for the tooltip.
   * @param {string} alignmentAttr The alignment string to use for positioning
   *     the tooltip. The format is specified in the documentation for
   *     TOOLTIP_ALIGNMENT_ATTR.
   * @param {number} offset The offset from the anchor element.
   * @param {string} classAttr The additional CSS class for the tooltip.
   * @param {?number} tooltipHideDelayMs The delay for hiding the tooltip or
   *     null if the default should be used.
   * @private
   */
  showTooltipImpl_(
      anchor, tooltipHtml, alignmentAttr, offset, classAttr,
      tooltipHideDelayMs) {
    this.secondaryTimerId_ = 0;
    this.tooltipHideDelayMs_ = tooltipHideDelayMs;
    if (!this.tooltip_) {
      this.tooltip_ = new jfk.SilentTooltipRenderer(this.domHelper_);
      this.hideTooltipImpl_();
      goog.dom.appendChild(
          this.domHelper_.getDocument().body, this.tooltip_.getElement());
      this.registerDisposable(this.tooltip_);
      // NOTE(klevy): Disabling subpixels is a patch for
      // http://code.google.com/p/chromium/issues/detail?id=29937 (subpixels
      // cause janky rendering with opacity transitions).
      this.tooltipPos_ = new jfk.ArrowPosition(
          this.tooltip_.getClassName(), true /* opt_disableSubpixels*/);
      this.tooltipPos_.setAutoReposition(true);
      this.tooltipPos_.setBoxOverflowAllowedOnPositioningFail(true);
      this.tooltipPos_.setElements(
          this.tooltip_.getElement(), this.tooltip_.getArrowElement());
    }

    var alignment = jfk.TooltipManager_.parseArrowAlignment_(alignmentAttr);
    var position = jfk.TooltipManager_.parsePosition_(alignmentAttr);
    this.tooltipPos_.setPosition(
        position, alignment, undefined /* opt_arrowOffset */, offset);

    goog.dom.classlist.remove(
        this.tooltip_.getElement(),
        jfk.TooltipManager_.HIDE_TOOLTIP_CLASS_NAME_);
    if (this.tooltipClass_ != classAttr) {
      if (this.tooltipClass_ &&
          !goog.string.isEmptyOrWhitespace(
              goog.string.makeSafe(this.tooltipClass_))) {
        goog.dom.classlist.remove(
            this.tooltip_.getElement(), this.tooltipClass_);
      }

      if (!goog.string.isEmptyOrWhitespace(goog.string.makeSafe(classAttr))) {
        goog.dom.classlist.add(this.tooltip_.getElement(), classAttr);
      }
      this.tooltipClass_ = classAttr;
    }

    // Reset tooltip position so its new content doesn't make it extend past
    // the window border and cause text wrapping before being repositioned.
    goog.style.setPosition(this.tooltip_.getElement(), 0, 0);

    if (tooltipHtml instanceof goog.html.SafeHtml) {
      goog.dom.safe.setInnerHtml(
          this.tooltip_.getContentElement(), tooltipHtml);
    } else {
      goog.dom.removeChildren(this.tooltip_.getContentElement());
      var child;
      while ((child = tooltipHtml.firstChild)) {
        this.tooltip_.getContentElement().appendChild(child);
      }
    }
    this.tooltipPos_.setAnchorElement(anchor);
    this.tooltipPos_.reposition(
        null /* unused */, goog.positioning.Corner.TOP_LEFT /* unused */);
  }

  /**
   * Hides a tooltip.
   * @private
   */
  hideTooltipImpl_() {
    if (this.tooltip_) {
      goog.dom.classlist.add(
          this.tooltip_.getElement(),
          jfk.TooltipManager_.HIDE_TOOLTIP_CLASS_NAME_);
    }
  }

  /**
   * Forces the tooltip to hide.
   */
  hideTooltip() {
    this.hideTooltipImpl_();
    this.hoverEl_ = null;
    this.tooltipHideDelayMs_ = null;
  }
};



/**
 * Keep track of whether the last event was a KEYDOWN.
 * @type {boolean}
 * @private
 */
jfk.TooltipManager_.prototype.isKeyboardEvent_;


/**
 * Keeps track of whether the event that triggered the tooltip timer was a
 * FOCUS.
 * @type {boolean}
 * @private
 */
jfk.TooltipManager_.prototype.isFocusEvent_;


/**
 * Active element.
 * @type {Element}
 * @private
 */
jfk.TooltipManager_.prototype.activeEl_;


/**
 * A node for which a throttled hover event has been fired and the tooltip
 * is being shown.
 * @type {Element}
 * @private
 */
jfk.TooltipManager_.prototype.hoverEl_;


/**
 * Tooltip DOM element wrapper.
 * @type {jfk.TooltipRenderer}
 * @private
 */
jfk.TooltipManager_.prototype.tooltip_;


/**
 * Tooltip positioning helper.
 * @type {jfk.ArrowPosition}
 * @private
 */
jfk.TooltipManager_.prototype.tooltipPos_;


/**
 * Additional tooltip class name.
 * @private {string}
 */
jfk.TooltipManager_.prototype.tooltipClass_;


/**
 * The hide delay for the current tooltip or null. The value of HIDE_DELAY_MS is
 * used when this is null.
 * @private {?number}
 */
jfk.TooltipManager_.prototype.tooltipHideDelayMs_;


/**
 * The id of the secondary delay timer, used if a tooltip has an additional
 * delay on top of the normal mouse over delay.
 * @type {number}
 * @private
 */
jfk.TooltipManager_.prototype.secondaryTimerId_;


/**
 * Class name for hiding tooltip element.
 * @type {string}
 * @private
 */
jfk.TooltipManager_.HIDE_TOOLTIP_CLASS_NAME_ =
    goog.getCssName('jfk-tooltip-hide');

//third_party/javascript/closure/ui/controlcontent.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Type declaration for control content.
 */
goog.provide('goog.ui.ControlContent');


/**
 * Type declaration for text caption or DOM structure to be used as the content
 * of {@link goog.ui.Control}s.
 * @typedef {string|Node|Array<!Node>|NodeList<!Node>}
 */
goog.ui.ControlContent;

//third_party/javascript/closure/ui/controlrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base class for control renderers.
 * TODO(attila):  If the renderer framework works well, pull it into Component.
 */

goog.provide('goog.ui.ControlRenderer');

goog.forwardDeclare('goog.ui.Control');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.style');
goog.require('goog.ui.Component');
goog.require('goog.ui.ControlContent');
goog.require('goog.userAgent');  // circular



/**
 * Default renderer for {@link goog.ui.Control}s.  Can be used as-is, but
 * subclasses of Control will probably want to use renderers specifically
 * tailored for them by extending this class.  Controls that use renderers
 * delegate one or more of the following API methods to the renderer:
 * <ul>
 *    <li>`createDom` - renders the DOM for the component
 *    <li>`canDecorate` - determines whether an element can be decorated
 *        by the component
 *    <li>`decorate` - decorates an existing element with the component
 *    <li>`setState` - updates the appearance of the component based on
 *        its state
 *    <li>`getContent` - returns the component's content
 *    <li>`setContent` - sets the component's content
 * </ul>
 * Controls are stateful; renderers, on the other hand, should be stateless and
 * reusable.
 * @constructor
 */
goog.ui.ControlRenderer = function() {};
goog.addSingletonGetter(goog.ui.ControlRenderer);


/**
 * Constructs a new renderer and sets the CSS class that the renderer will use
 * as the base CSS class to apply to all elements rendered by that renderer.
 * An example to use this function using a color palette:
 *
 * <pre>
 * var myCustomRenderer = goog.ui.ControlRenderer.getCustomRenderer(
 *     goog.ui.PaletteRenderer, 'my-special-palette');
 * var newColorPalette = new goog.ui.ColorPalette(
 *     colors, myCustomRenderer, opt_domHelper);
 * </pre>
 *
 * Your CSS can look like this now:
 * <pre>
 * .my-special-palette { }
 * .my-special-palette-table { }
 * .my-special-palette-cell { }
 * etc.
 * </pre>
 *
 * <em>instead</em> of
 * <pre>
 * .CSS_MY_SPECIAL_PALETTE .goog-palette { }
 * .CSS_MY_SPECIAL_PALETTE .goog-palette-table { }
 * .CSS_MY_SPECIAL_PALETTE .goog-palette-cell { }
 * etc.
 * </pre>
 *
 * You would want to use this functionality when you want an instance of a
 * component to have specific styles different than the other components of the
 * same type in your application.  This avoids using descendant selectors to
 * apply the specific styles to this component.
 *
 * @param {Function} ctor The constructor of the renderer you are trying to
 *     create.
 * @param {string} cssClassName The name of the CSS class for this renderer.
 * @return {goog.ui.ControlRenderer} An instance of the desired renderer with
 *     its getCssClass() method overridden to return the supplied custom CSS
 *     class name.
 */
goog.ui.ControlRenderer.getCustomRenderer = function(ctor, cssClassName) {
  'use strict';
  var renderer = new ctor();

  /**
   * Returns the CSS class to be applied to the root element of components
   * rendered using this renderer.
   * @return {string} Renderer-specific CSS class.
   */
  renderer.getCssClass = function() {
    'use strict';
    return cssClassName;
  };

  return renderer;
};


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.ControlRenderer.CSS_CLASS = goog.getCssName('goog-control');


/**
 * Array of arrays of CSS classes that we want composite classes added and
 * removed for in IE6 and lower as a workaround for lack of multi-class CSS
 * selector support.
 *
 * Subclasses that have accompanying CSS requiring this workaround should define
 * their own static IE6_CLASS_COMBINATIONS constant and override
 * getIe6ClassCombinations to return it.
 *
 * For example, if your stylesheet uses the selector .button.collapse-left
 * (and is compiled to .button_collapse-left for the IE6 version of the
 * stylesheet,) you should include ['button', 'collapse-left'] in this array
 * and the class button_collapse-left will be applied to the root element
 * whenever both button and collapse-left are applied individually.
 *
 * Members of each class name combination will be joined with underscores in the
 * order that they're defined in the array. You should alphabetize them (for
 * compatibility with the CSS compiler) unless you are doing something special.
 * @type {Array<Array<string>>}
 */
goog.ui.ControlRenderer.IE6_CLASS_COMBINATIONS = [];


/**
 * Map of component states to corresponding ARIA attributes.  Since the mapping
 * of component states to ARIA attributes is neither component- nor
 * renderer-specific, this is a static property of the renderer class, and is
 * initialized on first use.
 * @type {Object<goog.ui.Component.State, goog.a11y.aria.State>}
 * @private
 */
goog.ui.ControlRenderer.ariaAttributeMap_;


/**
 * Map of certain ARIA states to ARIA roles that support them. Used for checked
 * and selected Component states because they are used on Components with ARIA
 * roles that do not support the corresponding ARIA state.
 * @private {!Object<goog.a11y.aria.Role, goog.a11y.aria.State>}
 * @const
 */
goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_ = goog.object.create(
    goog.a11y.aria.Role.BUTTON, goog.a11y.aria.State.PRESSED,
    goog.a11y.aria.Role.CHECKBOX, goog.a11y.aria.State.CHECKED,
    goog.a11y.aria.Role.MENU_ITEM, goog.a11y.aria.State.SELECTED,
    goog.a11y.aria.Role.MENU_ITEM_CHECKBOX, goog.a11y.aria.State.CHECKED,
    goog.a11y.aria.Role.MENU_ITEM_RADIO, goog.a11y.aria.State.CHECKED,
    goog.a11y.aria.Role.RADIO, goog.a11y.aria.State.CHECKED,
    goog.a11y.aria.Role.TAB, goog.a11y.aria.State.SELECTED,
    goog.a11y.aria.Role.TREEITEM, goog.a11y.aria.State.SELECTED);


/**
 * Returns the ARIA role to be applied to the control.
 * See http://wiki/Main/ARIA for more info.
 * @return {goog.a11y.aria.Role|undefined} ARIA role.
 */
goog.ui.ControlRenderer.prototype.getAriaRole = function() {
  'use strict';
  // By default, the ARIA role is unspecified.
  return undefined;
};


/**
 * Returns the control's contents wrapped in a DIV, with the renderer's own
 * CSS class and additional state-specific classes applied to it.
 * @param {goog.ui.Control} control Control to render.
 * @return {Element} Root element for the control.
 */
goog.ui.ControlRenderer.prototype.createDom = function(control) {
  'use strict';
  // Create and return DIV wrapping contents.
  var element = control.getDomHelper().createDom(
      goog.dom.TagName.DIV, this.getClassNames(control).join(' '),
      control.getContent());

  return element;
};


/**
 * Takes the control's root element and returns the parent element of the
 * control's contents.  Since by default controls are rendered as a single
 * DIV, the default implementation returns the element itself.  Subclasses
 * with more complex DOM structures must override this method as needed.
 * @param {Element} element Root element of the control whose content element
 *     is to be returned.
 * @return {Element} The control's content element.
 */
goog.ui.ControlRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return element;
};


/**
 * Updates the control's DOM by adding or removing the specified class name
 * to/from its root element. May add additional combined classes as needed in
 * IE6 and lower. Because of this, subclasses should use this method when
 * modifying class names on the control's root element.
 * @param {goog.ui.Control|Element} control Control instance (or root element)
 *     to be updated.
 * @param {string} className CSS class name to add or remove.
 * @param {boolean} enable Whether to add or remove the class name.
 */
goog.ui.ControlRenderer.prototype.enableClassName = function(
    control, className, enable) {
  'use strict';
  var element = /** @type {Element} */ (
      control.getElement ? control.getElement() : control);
  if (element) {
    var classNames = [className];

    goog.dom.classlist.enableAll(element, classNames, enable);
  }
};


/**
 * Updates the control's DOM by adding or removing the specified extra class
 * name to/from its element.
 * @param {goog.ui.Control} control Control to be updated.
 * @param {string} className CSS class name to add or remove.
 * @param {boolean} enable Whether to add or remove the class name.
 */
goog.ui.ControlRenderer.prototype.enableExtraClassName = function(
    control, className, enable) {
  'use strict';
  // The base class implementation is trivial; subclasses should override as
  // needed.
  this.enableClassName(control, className, enable);
};


/**
 * Returns true if this renderer can decorate the element, false otherwise.
 * The default implementation always returns true.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 */
goog.ui.ControlRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return true;
};


/**
 * Default implementation of `decorate` for {@link goog.ui.Control}s.
 * Initializes the control's ID, content, and state based on the ID of the
 * element, its child nodes, and its CSS classes, respectively.  Returns the
 * element.
 * @param {goog.ui.Control} control Control instance to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 */
goog.ui.ControlRenderer.prototype.decorate = function(control, element) {
  'use strict';
  // Set the control's ID to the decorated element's DOM ID, if any.
  if (element.id) {
    control.setId(element.id);
  }

  // Set the control's content to the decorated element's content.
  var contentElem = this.getContentElement(element);
  if (contentElem && contentElem.firstChild) {
    control.setContentInternal(
        contentElem.firstChild.nextSibling ?
            goog.array.clone(contentElem.childNodes) :
            contentElem.firstChild);
  } else {
    control.setContentInternal(null);
  }

  // Initialize the control's state based on the decorated element's CSS class.
  // This implementation is optimized to minimize object allocations, string
  // comparisons, and DOM access.
  var state = 0x00;
  var rendererClassName = this.getCssClass();
  var structuralClassName = this.getStructuralCssClass();
  var hasRendererClassName = false;
  var hasStructuralClassName = false;
  var hasCombinedClassName = false;
  var classNames = goog.array.toArray(goog.dom.classlist.get(element));
  classNames.forEach(function(className) {
    'use strict';
    if (!hasRendererClassName && className == rendererClassName) {
      hasRendererClassName = true;
      if (structuralClassName == rendererClassName) {
        hasStructuralClassName = true;
      }
    } else if (!hasStructuralClassName && className == structuralClassName) {
      hasStructuralClassName = true;
    } else {
      state |= this.getStateFromClass(className);
    }
    if (this.getStateFromClass(className) == goog.ui.Component.State.DISABLED) {
      goog.asserts.assertElement(contentElem);
      if (goog.dom.isFocusableTabIndex(contentElem)) {
        goog.dom.setFocusableTabIndex(contentElem, false);
      }
    }
  }, this);
  control.setStateInternal(state);

  // Make sure the element has the renderer's CSS classes applied, as well as
  // any extra class names set on the control.
  if (!hasRendererClassName) {
    classNames.push(rendererClassName);
    if (structuralClassName == rendererClassName) {
      hasStructuralClassName = true;
    }
  }
  if (!hasStructuralClassName) {
    classNames.push(structuralClassName);
  }
  var extraClassNames = control.getExtraClassNames();
  if (extraClassNames) {
    classNames.push.apply(classNames, extraClassNames);
  }

  // Only write to the DOM if new class names had to be added to the element.
  if (!hasRendererClassName || !hasStructuralClassName || extraClassNames ||
      hasCombinedClassName) {
    goog.dom.classlist.set(element, classNames.join(' '));
  }

  return element;
};


/**
 * Initializes the control's DOM by configuring properties that can only be set
 * after the DOM has entered the document.  This implementation sets up BiDi
 * and keyboard focus.  Called from {@link goog.ui.Control#enterDocument}.
 * @param {goog.ui.Control} control Control whose DOM is to be initialized
 *     as it enters the document.
 */
goog.ui.ControlRenderer.prototype.initializeDom = function(control) {
  'use strict';
  // Initialize render direction (BiDi).  We optimize the left-to-right render
  // direction by assuming that elements are left-to-right by default, and only
  // updating their styling if they are explicitly set to right-to-left.
  if (control.isRightToLeft()) {
    this.setRightToLeft(control.getElement(), true);
  }

  // Initialize keyboard focusability (tab index).  We assume that components
  // aren't focusable by default (i.e have no tab index), and only touch the
  // DOM if the component is focusable, enabled, and visible, and therefore
  // needs a tab index.
  if (control.isEnabled()) {
    this.setFocusable(control, control.isVisible());
  }
};


/**
 * Sets the element's ARIA role.
 * @param {Element} element Element to update.
 * @param {?goog.a11y.aria.Role=} opt_preferredRole The preferred ARIA role.
 */
goog.ui.ControlRenderer.prototype.setAriaRole = function(
    element, opt_preferredRole) {
  'use strict';
  var ariaRole = opt_preferredRole || this.getAriaRole();
  if (ariaRole) {
    goog.asserts.assert(
        element, 'The element passed as a first parameter cannot be null.');
    var currentRole = goog.a11y.aria.getRole(element);
    if (ariaRole == currentRole) {
      return;
    }
    goog.a11y.aria.setRole(element, ariaRole);
  }
};


/**
 * Sets the element's ARIA attributes, including distinguishing between
 * universally supported ARIA properties and ARIA states that are only
 * supported by certain ARIA roles. Only attributes which are initialized to be
 * true will be set.
 * @param {!goog.ui.Control} control Control whose ARIA state will be updated.
 * @param {!Element} element Element whose ARIA state is to be updated.
 */
goog.ui.ControlRenderer.prototype.setAriaStates = function(control, element) {
  'use strict';
  goog.asserts.assert(control);
  goog.asserts.assert(element);

  var ariaLabel = control.getAriaLabel();
  if (ariaLabel != null) {
    this.setAriaLabel(element, ariaLabel);
  }

  if (!control.isVisible()) {
    goog.a11y.aria.setState(
        element, goog.a11y.aria.State.HIDDEN, !control.isVisible());
  }
  if (!control.isEnabled()) {
    this.updateAriaState(
        element, goog.ui.Component.State.DISABLED, !control.isEnabled());
  }
  if (control.isSupportedState(goog.ui.Component.State.SELECTED)) {
    this.updateAriaState(
        element, goog.ui.Component.State.SELECTED, control.isSelected());
  }
  if (control.isSupportedState(goog.ui.Component.State.CHECKED)) {
    this.updateAriaState(
        element, goog.ui.Component.State.CHECKED, control.isChecked());
  }
  if (control.isSupportedState(goog.ui.Component.State.OPENED)) {
    this.updateAriaState(
        element, goog.ui.Component.State.OPENED, control.isOpen());
  }
};


/**
 * Sets the element's ARIA label. This should be overriden by subclasses that
 * don't apply the role directly on control.element_.
 * @param {!Element} element Element whose ARIA label is to be updated.
 * @param {string} ariaLabel Label to add to the element.
 */
goog.ui.ControlRenderer.prototype.setAriaLabel = function(element, ariaLabel) {
  'use strict';
  goog.a11y.aria.setLabel(element, ariaLabel);
};


/**
 * Allows or disallows text selection within the control's DOM.
 * @param {Element} element The control's root element.
 * @param {boolean} allow Whether the element should allow text selection.
 */
goog.ui.ControlRenderer.prototype.setAllowTextSelection = function(
    element, allow) {
  'use strict';
  // On all browsers other than IE and Opera, it isn't necessary to recursively
  // apply unselectable styling to the element's children.
  goog.style.setUnselectable(element, !allow, !goog.userAgent.IE);
};


/**
 * Applies special styling to/from the control's element if it is rendered
 * right-to-left, and removes it if it is rendered left-to-right.
 * @param {Element} element The control's root element.
 * @param {boolean} rightToLeft Whether the component is rendered
 *     right-to-left.
 */
goog.ui.ControlRenderer.prototype.setRightToLeft = function(
    element, rightToLeft) {
  'use strict';
  this.enableClassName(
      element, goog.getCssName(this.getStructuralCssClass(), 'rtl'),
      rightToLeft);
};


/**
 * Returns true if the control's key event target supports keyboard focus
 * (based on its `tabIndex` attribute), false otherwise.
 * @param {goog.ui.Control} control Control whose key event target is to be
 *     checked.
 * @return {boolean} Whether the control's key event target is focusable.
 */
goog.ui.ControlRenderer.prototype.isFocusable = function(control) {
  'use strict';
  var keyTarget;
  if (control.isSupportedState(goog.ui.Component.State.FOCUSED) &&
      (keyTarget = control.getKeyEventTarget())) {
    return goog.dom.isFocusableTabIndex(keyTarget);
  }
  return false;
};


/**
 * Updates the control's key event target to make it focusable or non-focusable
 * via its `tabIndex` attribute.  Does nothing if the control doesn't
 * support the `FOCUSED` state, or if it has no key event target.
 * @param {goog.ui.Control} control Control whose key event target is to be
 *     updated.
 * @param {boolean} focusable Whether to enable keyboard focus support on the
 *     control's key event target.
 */
goog.ui.ControlRenderer.prototype.setFocusable = function(control, focusable) {
  'use strict';
  var keyTarget;
  if (control.isSupportedState(goog.ui.Component.State.FOCUSED) &&
      (keyTarget = control.getKeyEventTarget())) {
    if (!focusable && control.isFocused()) {
      // Blur before hiding.  Note that IE calls onblur handlers asynchronously.
      try {
        keyTarget.blur();
      } catch (e) {
        // TODO(marcinb|pupius):  Find out why this fails on IE.
      }
      // The blur event dispatched by the key event target element when blur()
      // was called on it should have been handled by the control's handleBlur()
      // method, so at this point the control should no longer be focused.
      // However, blur events are unreliable on IE and FF3, so if at this point
      // the control is still focused, we trigger its handleBlur() method
      // programmatically.
      if (control.isFocused()) {
        control.handleBlur(null);
      }
    }
    // Don't overwrite existing tab index values unless needed.
    if (goog.dom.isFocusableTabIndex(keyTarget) != focusable) {
      goog.dom.setFocusableTabIndex(keyTarget, focusable);
    }
  }
};


/**
 * Shows or hides the element.
 * @param {Element} element Element to update.
 * @param {boolean} visible Whether to show the element.
 */
goog.ui.ControlRenderer.prototype.setVisible = function(element, visible) {
  'use strict';
  // The base class implementation is trivial; subclasses should override as
  // needed.  It should be possible to do animated reveals, for example.
  goog.style.setElementShown(element, visible);
  if (element) {
    goog.a11y.aria.setState(element, goog.a11y.aria.State.HIDDEN, !visible);
  }
};


/**
 * Updates the appearance of the control in response to a state change.
 * @param {goog.ui.Control} control Control instance to update.
 * @param {goog.ui.Component.State} state State to enable or disable.
 * @param {boolean} enable Whether the control is entering or exiting the state.
 */
goog.ui.ControlRenderer.prototype.setState = function(control, state, enable) {
  'use strict';
  var element = control.getElement();
  if (element) {
    var className = this.getClassForState(state);
    if (className) {
      this.enableClassName(control, className, enable);
    }
    this.updateAriaState(element, state, enable);
  }
};


/**
 * Updates the element's ARIA (accessibility) attributes , including
 * distinguishing between universally supported ARIA properties and ARIA states
 * that are only supported by certain ARIA roles.
 * @param {Element} element Element whose ARIA state is to be updated.
 * @param {goog.ui.Component.State} state Component state being enabled or
 *     disabled.
 * @param {boolean} enable Whether the state is being enabled or disabled.
 * @protected
 */
goog.ui.ControlRenderer.prototype.updateAriaState = function(
    element, state, enable) {
  'use strict';
  // Ensure the ARIA attribute map exists.
  if (!goog.ui.ControlRenderer.ariaAttributeMap_) {
    goog.ui.ControlRenderer.ariaAttributeMap_ = goog.object.create(
        goog.ui.Component.State.DISABLED, goog.a11y.aria.State.DISABLED,
        goog.ui.Component.State.SELECTED, goog.a11y.aria.State.SELECTED,
        goog.ui.Component.State.CHECKED, goog.a11y.aria.State.CHECKED,
        goog.ui.Component.State.OPENED, goog.a11y.aria.State.EXPANDED);
  }
  goog.asserts.assert(
      element, 'The element passed as a first parameter cannot be null.');
  var ariaAttr = goog.ui.ControlRenderer.getAriaStateForAriaRole_(
      element, goog.ui.ControlRenderer.ariaAttributeMap_[state]);
  if (ariaAttr) {
    goog.a11y.aria.setState(element, ariaAttr, enable);
  }
};


/**
 * Returns the appropriate ARIA attribute based on ARIA role if the ARIA
 * attribute is an ARIA state.
 * @param {!Element} element The element from which to get the ARIA role for
 * matching ARIA state.
 * @param {goog.a11y.aria.State} attr The ARIA attribute to check to see if it
 * can be applied to the given ARIA role.
 * @return {goog.a11y.aria.State} An ARIA attribute that can be applied to the
 * given ARIA role.
 * @private
 */
goog.ui.ControlRenderer.getAriaStateForAriaRole_ = function(element, attr) {
  'use strict';
  var role = goog.a11y.aria.getRole(element);
  if (!role) {
    return attr;
  }
  role = /** @type {goog.a11y.aria.Role} */ (role);
  var matchAttr = goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_[role] || attr;
  return goog.ui.ControlRenderer.isAriaState_(attr) ? matchAttr : attr;
};


/**
 * Determines if the given ARIA attribute is an ARIA property or ARIA state.
 * @param {goog.a11y.aria.State} attr The ARIA attribute to classify.
 * @return {boolean} If the ARIA attribute is an ARIA state.
 * @private
 */
goog.ui.ControlRenderer.isAriaState_ = function(attr) {
  'use strict';
  return attr == goog.a11y.aria.State.CHECKED ||
      attr == goog.a11y.aria.State.SELECTED;
};


/**
 * Takes a control's root element, and sets its content to the given text
 * caption or DOM structure.  The default implementation replaces the children
 * of the given element.  Renderers that create more complex DOM structures
 * must override this method accordingly.
 * @param {Element} element The control's root element.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to be
 *     set as the control's content. The DOM nodes will not be cloned, they
 *     will only moved under the content element of the control.
 */
goog.ui.ControlRenderer.prototype.setContent = function(element, content) {
  'use strict';
  var contentElem = this.getContentElement(element);
  if (contentElem) {
    goog.dom.removeChildren(contentElem);
    if (content) {
      if (typeof content === 'string') {
        goog.dom.setTextContent(contentElem, content);
      } else {
        var childHandler = function(child) {
          'use strict';
          if (child) {
            var doc = goog.dom.getOwnerDocument(contentElem);
            contentElem.appendChild(
                typeof child === 'string' ? doc.createTextNode(child) : child);
          }
        };
        if (Array.isArray(content)) {
          // Array of nodes.
          content.forEach(childHandler);
        } else if (goog.isArrayLike(content) && !('nodeType' in content)) {
          // NodeList. The second condition filters out TextNode which also has
          // length attribute but is not array like. The nodes have to be cloned
          // because childHandler removes them from the list during iteration.
          goog.array.clone(/** @type {!NodeList<?>} */ (content))
              .forEach(childHandler);
        } else {
          // Node or string.
          childHandler(content);
        }
      }
    }
  }
};


/**
 * Returns the element within the component's DOM that should receive keyboard
 * focus (null if none).  The default implementation returns the control's root
 * element.
 * @param {goog.ui.Control} control Control whose key event target is to be
 *     returned.
 * @return {Element} The key event target.
 */
goog.ui.ControlRenderer.prototype.getKeyEventTarget = function(control) {
  'use strict';
  return control.getElement();
};


// CSS class name management.


/**
 * Returns the CSS class name to be applied to the root element of all
 * components rendered or decorated using this renderer.  The class name
 * is expected to uniquely identify the renderer class, i.e. no two
 * renderer classes are expected to share the same CSS class name.
 * @return {string} Renderer-specific CSS class name.
 */
goog.ui.ControlRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.ControlRenderer.CSS_CLASS;
};


/**
 * Returns an array of combinations of classes to apply combined class names for
 * in IE6 and below. See {@link IE6_CLASS_COMBINATIONS} for more detail. This
 * method doesn't reference {@link IE6_CLASS_COMBINATIONS} so that it can be
 * compiled out, but subclasses should return their IE6_CLASS_COMBINATIONS
 * static constant instead.
 * @return {!Array<Array<string>>} Array of class name combinations.
 */
goog.ui.ControlRenderer.prototype.getIe6ClassCombinations = function() {
  'use strict';
  return [];
};


/**
 * Returns the name of a DOM structure-specific CSS class to be applied to the
 * root element of all components rendered or decorated using this renderer.
 * Unlike the class name returned by {@link #getCssClass}, the structural class
 * name may be shared among different renderers that generate similar DOM
 * structures.  The structural class name also serves as the basis of derived
 * class names used to identify and style structural elements of the control's
 * DOM, as well as the basis for state-specific class names.  The default
 * implementation returns the same class name as {@link #getCssClass}, but
 * subclasses are expected to override this method as needed.
 * @return {string} DOM structure-specific CSS class name (same as the renderer-
 *     specific CSS class name by default).
 */
goog.ui.ControlRenderer.prototype.getStructuralCssClass = function() {
  'use strict';
  return this.getCssClass();
};


/**
 * Returns all CSS class names applicable to the given control, based on its
 * state.  The return value is an array of strings containing
 * <ol>
 *   <li>the renderer-specific CSS class returned by {@link #getCssClass},
 *       followed by
 *   <li>the structural CSS class returned by {@link getStructuralCssClass} (if
 *       different from the renderer-specific CSS class), followed by
 *   <li>any state-specific classes returned by {@link #getClassNamesForState},
 *       followed by
 *   <li>any extra classes returned by the control's `getExtraClassNames`
 *       method and
 *   <li>for IE6 and lower, additional combined classes from
 *       {@link getAppliedCombinedClassNames_}.
 * </ol>
 * Since all controls have at least one renderer-specific CSS class name, this
 * method is guaranteed to return an array of at least one element.
 * @param {goog.ui.Control} control Control whose CSS classes are to be
 *     returned.
 * @return {!Array<string>} Array of CSS class names applicable to the control.
 * @protected
 */
goog.ui.ControlRenderer.prototype.getClassNames = function(control) {
  'use strict';
  var cssClass = this.getCssClass();

  // Start with the renderer-specific class name.
  var classNames = [cssClass];

  // Add structural class name, if different.
  var structuralCssClass = this.getStructuralCssClass();
  if (structuralCssClass != cssClass) {
    classNames.push(structuralCssClass);
  }

  // Add state-specific class names, if any.
  var classNamesForState = this.getClassNamesForState(control.getState());
  classNames.push.apply(classNames, classNamesForState);

  // Add extra class names, if any.
  var extraClassNames = control.getExtraClassNames();
  if (extraClassNames) {
    classNames.push.apply(classNames, extraClassNames);
  }

  return classNames;
};


/**
 * Returns an array of all the combined class names that should be applied based
 * on the given list of classes. Checks the result of
 * {@link getIe6ClassCombinations} for any combinations that have all
 * members contained in classes. If a combination matches, the members are
 * joined with an underscore (in order), and added to the return array.
 *
 * If opt_includedClass is provided, return only the combined classes that have
 * all members contained in classes AND include opt_includedClass as well.
 * opt_includedClass is added to classes as well.
 * @param {IArrayLike<string>} classes Array-like thing of classes to
 *     return matching combined classes for.
 * @param {?string=} opt_includedClass If provided, get only the combined
 *     classes that include this one.
 * @return {!Array<string>} Array of combined class names that should be
 *     applied.
 * @private
 */
goog.ui.ControlRenderer.prototype.getAppliedCombinedClassNames_ = function(
    classes, opt_includedClass) {
  'use strict';
  var toAdd = [];
  if (opt_includedClass) {
    classes = goog.array.concat(classes, [opt_includedClass]);
  }
  this.getIe6ClassCombinations().forEach(function(combo) {
    'use strict';
    if (goog.array.every(combo, goog.partial(goog.array.contains, classes)) &&
        (!opt_includedClass || goog.array.contains(combo, opt_includedClass))) {
      toAdd.push(combo.join('_'));
    }
  });
  return toAdd;
};


/**
 * Takes a bit mask of {@link goog.ui.Component.State}s, and returns an array
 * of the appropriate class names representing the given state, suitable to be
 * applied to the root element of a component rendered using this renderer, or
 * null if no state-specific classes need to be applied.  This default
 * implementation uses the renderer's {@link getClassForState} method to
 * generate each state-specific class.
 * @param {number} state Bit mask of component states.
 * @return {!Array<string>} Array of CSS class names representing the given
 *     state.
 * @protected
 */
goog.ui.ControlRenderer.prototype.getClassNamesForState = function(state) {
  'use strict';
  var classNames = [];
  while (state) {
    // For each enabled state, push the corresponding CSS class name onto
    // the classNames array.
    var mask = state & -state;  // Least significant bit
    classNames.push(
        this.getClassForState(
            /** @type {goog.ui.Component.State} */ (mask)));
    state &= ~mask;
  }
  return classNames;
};


/**
 * Takes a single {@link goog.ui.Component.State}, and returns the
 * corresponding CSS class name (null if none).
 * @param {goog.ui.Component.State} state Component state.
 * @return {string|undefined} CSS class representing the given state (undefined
 *     if none).
 * @protected
 */
goog.ui.ControlRenderer.prototype.getClassForState = function(state) {
  'use strict';
  if (!this.classByState_) {
    this.createClassByStateMap_();
  }
  return this.classByState_[state];
};


/**
 * Takes a single CSS class name which may represent a component state, and
 * returns the corresponding component state (0x00 if none).
 * @param {string} className CSS class name, possibly representing a component
 *     state.
 * @return {goog.ui.Component.State} state Component state corresponding
 *     to the given CSS class (0x00 if none).
 * @protected
 */
goog.ui.ControlRenderer.prototype.getStateFromClass = function(className) {
  'use strict';
  if (!this.stateByClass_) {
    this.createStateByClassMap_();
  }
  var state = parseInt(this.stateByClass_[className], 10);
  return /** @type {goog.ui.Component.State} */ (isNaN(state) ? 0x00 : state);
};


/**
 * Creates the lookup table of states to classes, used during state changes.
 * @private
 */
goog.ui.ControlRenderer.prototype.createClassByStateMap_ = function() {
  'use strict';
  var baseClass = this.getStructuralCssClass();

  // This ensures space-separated css classnames are not allowed, which some
  // ControlRenderers had been doing.  See http://b/13694665.
  var isValidClassName =
      !goog.string.contains(goog.string.normalizeWhitespace(baseClass), ' ');
  goog.asserts.assert(
      isValidClassName,
      'ControlRenderer has an invalid css class: \'' + baseClass + '\'');

  /**
   * Map of component states to state-specific structural class names,
   * used when changing the DOM in response to a state change.  Precomputed
   * and cached on first use to minimize object allocations and string
   * concatenation.
   * @type {Object}
   * @private
   */
  this.classByState_ = goog.object.create(
      goog.ui.Component.State.DISABLED, goog.getCssName(baseClass, 'disabled'),
      goog.ui.Component.State.HOVER, goog.getCssName(baseClass, 'hover'),
      goog.ui.Component.State.ACTIVE, goog.getCssName(baseClass, 'active'),
      goog.ui.Component.State.SELECTED, goog.getCssName(baseClass, 'selected'),
      goog.ui.Component.State.CHECKED, goog.getCssName(baseClass, 'checked'),
      goog.ui.Component.State.FOCUSED, goog.getCssName(baseClass, 'focused'),
      goog.ui.Component.State.OPENED, goog.getCssName(baseClass, 'open'));
};


/**
 * Creates the lookup table of classes to states, used during decoration.
 * @private
 */
goog.ui.ControlRenderer.prototype.createStateByClassMap_ = function() {
  'use strict';
  // We need the classByState_ map so we can transpose it.
  if (!this.classByState_) {
    this.createClassByStateMap_();
  }

  /**
   * Map of state-specific structural class names to component states,
   * used during element decoration.  Precomputed and cached on first use
   * to minimize object allocations and string concatenation.
   * @type {Object}
   * @private
   */
  this.stateByClass_ = goog.object.transpose(this.classByState_);
};

//third_party/javascript/closure/ui/buttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Default renderer for {@link goog.ui.Button}s.
 */

goog.provide('goog.ui.ButtonRenderer');

goog.forwardDeclare('goog.ui.Button');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.ui.ButtonSide');
goog.require('goog.ui.Component');
goog.require('goog.ui.ControlRenderer');  // circular



/**
 * Default renderer for {@link goog.ui.Button}s.  Extends the superclass with
 * the following button-specific API methods:
 * <ul>
 *   <li>`getValue` - returns the button element's value
 *   <li>`setValue` - updates the button element to reflect its new value
 *   <li>`getTooltip` - returns the button element's tooltip text
 *   <li>`setTooltip` - updates the button element's tooltip text
 *   <li>`setCollapsed` - removes one or both of the button element's
 *       borders
 * </ul>
 * For alternate renderers, see {@link goog.ui.NativeButtonRenderer},
 * {@link goog.ui.CustomButtonRenderer}, and {@link goog.ui.FlatButtonRenderer}.
 * @constructor
 * @extends {goog.ui.ControlRenderer}
 */
goog.ui.ButtonRenderer = function() {
  'use strict';
  goog.ui.ControlRenderer.call(this);
};
goog.inherits(goog.ui.ButtonRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.ButtonRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.ButtonRenderer.CSS_CLASS = goog.getCssName('goog-button');


/**
 * Returns the ARIA role to be applied to buttons.
 * @return {goog.a11y.aria.Role|undefined} ARIA role.
 * @override
 */
goog.ui.ButtonRenderer.prototype.getAriaRole = function() {
  'use strict';
  return goog.a11y.aria.Role.BUTTON;
};


/**
 * Updates the button's ARIA (accessibility) state if the button is being
 * treated as a checkbox. Also makes sure that attributes which aren't
 * supported by buttons aren't being added.
 * @param {Element} element Element whose ARIA state is to be updated.
 * @param {goog.ui.Component.State} state Component state being enabled or
 *     disabled.
 * @param {boolean} enable Whether the state is being enabled or disabled.
 * @protected
 * @override
 */
goog.ui.ButtonRenderer.prototype.updateAriaState = function(
    element, state, enable) {
  'use strict';
  switch (state) {
    // If button has CHECKED or SELECTED state, assign aria-pressed
    case goog.ui.Component.State.SELECTED:
    case goog.ui.Component.State.CHECKED:
      goog.asserts.assert(element, 'The button DOM element cannot be null.');
      goog.a11y.aria.setState(element, goog.a11y.aria.State.PRESSED, enable);
      break;
    default:
    case goog.ui.Component.State.OPENED:
    case goog.ui.Component.State.DISABLED:
      goog.ui.ButtonRenderer.base(
          this, 'updateAriaState', element, state, enable);
      break;
  }
};


/** @override */
goog.ui.ButtonRenderer.prototype.createDom = function(button) {
  'use strict';
  var element = goog.ui.ButtonRenderer.base(this, 'createDom', button);
  this.setTooltip(element, button.getTooltip());

  var value = button.getValue();
  if (value) {
    this.setValue(element, value);
  }

  // If this is a toggle button, set ARIA state
  if (button.isSupportedState(goog.ui.Component.State.CHECKED)) {
    this.updateAriaState(
        element, goog.ui.Component.State.CHECKED, button.isChecked());
  }

  return element;
};


/** @override */
goog.ui.ButtonRenderer.prototype.decorate = function(button, element) {
  'use strict';
  // The superclass implementation takes care of common attributes; we only
  // need to set the value and the tooltip.
  element =
      goog.ui.ButtonRenderer.superClass_.decorate.call(this, button, element);

  button.setValueInternal(this.getValue(element));
  button.setTooltipInternal(this.getTooltip(element));

  // If this is a toggle button, set ARIA state
  if (button.isSupportedState(goog.ui.Component.State.CHECKED)) {
    this.updateAriaState(
        element, goog.ui.Component.State.CHECKED, button.isChecked());
  }

  return element;
};


/**
 * Takes a button's root element, and returns the value associated with it.
 * No-op in the base class.
 * @param {Element} element The button's root element.
 * @return {string|undefined} The button's value (undefined if none).
 */
goog.ui.ButtonRenderer.prototype.getValue = goog.nullFunction;


/**
 * Takes a button's root element and a value, and updates the element to reflect
 * the new value.  No-op in the base class.
 * @param {Element} element The button's root element.
 * @param {string} value New value.
 */
goog.ui.ButtonRenderer.prototype.setValue = goog.nullFunction;


/**
 * Takes a button's root element, and returns its tooltip text.
 * @param {Element} element The button's root element.
 * @return {string|undefined} The tooltip text.
 */
goog.ui.ButtonRenderer.prototype.getTooltip = function(element) {
  'use strict';
  return element.title;
};


/**
 * Takes a button's root element and a tooltip string, and updates the element
 * with the new tooltip.
 * @param {Element} element The button's root element.
 * @param {string} tooltip New tooltip text.
 * @protected
 */
goog.ui.ButtonRenderer.prototype.setTooltip = function(element, tooltip) {
  'use strict';
  if (element) {
    // Don't set a title attribute if there isn't a tooltip. Blank title
    // attributes can be interpreted incorrectly by screen readers.
    if (tooltip) {
      element.title = tooltip;
    } else {
      element.removeAttribute('title');
    }
  }
};


/**
 * Collapses the border on one or both sides of the button, allowing it to be
 * combined with the adjacent button(s), forming a single UI componenet with
 * multiple targets.
 * @param {goog.ui.Button} button Button to update.
 * @param {number} sides Bitmap of one or more {@link goog.ui.ButtonSide}s for
 *     which borders should be collapsed.
 * @protected
 */
goog.ui.ButtonRenderer.prototype.setCollapsed = function(button, sides) {
  'use strict';
  var isRtl = button.isRightToLeft();
  var collapseLeftClassName =
      goog.getCssName(this.getStructuralCssClass(), 'collapse-left');
  var collapseRightClassName =
      goog.getCssName(this.getStructuralCssClass(), 'collapse-right');

  button.enableClassName(
      isRtl ? collapseRightClassName : collapseLeftClassName,
      !!(sides & goog.ui.ButtonSide.START));
  button.enableClassName(
      isRtl ? collapseLeftClassName : collapseRightClassName,
      !!(sides & goog.ui.ButtonSide.END));
};


/** @override */
goog.ui.ButtonRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.ButtonRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/componentutil.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Static utility methods for UI components.
 */

goog.provide('goog.ui.ComponentUtil');

goog.require('goog.events.MouseAsMouseEventType');
goog.require('goog.events.MouseEvents');
goog.require('goog.events.PointerAsMouseEventType');



/**
 * @param {!goog.ui.Component} component
 * @return {!goog.events.MouseEvents} The browser events that should be listened
 *     to for the given mouse events.
 */
goog.ui.ComponentUtil.getMouseEventType = function(component) {
  'use strict';
  return component.pointerEventsEnabled() ?
      goog.events.PointerAsMouseEventType :
      goog.events.MouseAsMouseEventType;
};

//third_party/javascript/closure/ui/registry.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Global renderer and decorator registry.
 */

goog.provide('goog.ui.registry');

goog.require('goog.asserts');
goog.require('goog.dom.classlist');
goog.require('goog.object');
goog.requireType('goog.ui.Component');
goog.requireType('goog.ui.ControlRenderer');


/**
 * Given a {@link goog.ui.Component} constructor, returns an instance of its
 * default renderer.  If the default renderer is a singleton, returns the
 * singleton instance; otherwise returns a new instance of the renderer class.
 * @param {!Function} componentCtor Component constructor function (for example
 *     `goog.ui.Button`).
 * @return {?goog.ui.ControlRenderer} Renderer instance (for example the
 *     singleton instance of `goog.ui.ButtonRenderer`), or null if
 *     no default renderer was found.
 */
goog.ui.registry.getDefaultRenderer = function(componentCtor) {
  'use strict';
  // TODO(b/141512323): This should probably be implemented with a `WeakMap`.
  // Locate the default renderer based on the constructor's unique ID.  If no
  // renderer is registered for this class, walk up the superClass_ chain.
  var key;
  var /** ?Function|undefined */ ctor = componentCtor;
  var /** ?Function|undefined */ rendererCtor;
  while (ctor) {
    key = goog.getUid(ctor);
    if ((rendererCtor = goog.ui.registry.defaultRenderers_[key])) break;
    ctor = /** @type {?Function|undefined} */ (goog.object.getSuperClass(ctor));
  }

  // If the renderer has a static getInstance method, return the singleton
  // instance; otherwise create and return a new instance.
  if (rendererCtor) {
    return typeof rendererCtor.getInstance === 'function' ?
        rendererCtor.getInstance() :
        new rendererCtor();
  }

  return null;
};


/**
 * Sets the default renderer for the given {@link goog.ui.Component}
 * constructor.
 * @param {Function} componentCtor Component constructor function (for example
 *     `goog.ui.Button`).
 * @param {Function} rendererCtor Renderer constructor function (for example
 *     `goog.ui.ButtonRenderer`).
 * @throws {Error} If the arguments aren't functions.
 */
goog.ui.registry.setDefaultRenderer = function(componentCtor, rendererCtor) {
  'use strict';
  // In this case, explicit validation has negligible overhead (since each
  // renderer is only registered once), and helps catch subtle bugs.
  if (typeof componentCtor !== 'function') {
    throw new Error('Invalid component class ' + componentCtor);
  }
  if (typeof rendererCtor !== 'function') {
    throw new Error('Invalid renderer class ' + rendererCtor);
  }

  // Map the component constructor's unique ID to the renderer constructor.
  var key = goog.getUid(componentCtor);
  goog.ui.registry.defaultRenderers_[key] = rendererCtor;
};


/**
 * Returns the {@link goog.ui.Component} instance created by the decorator
 * factory function registered for the given CSS class name, or null if no
 * decorator factory function was found.
 * @param {string} className CSS class name.
 * @return {goog.ui.Component?} Component instance.
 */
goog.ui.registry.getDecoratorByClassName = function(className) {
  'use strict';
  return className in goog.ui.registry.decoratorFunctions_ ?
      goog.ui.registry.decoratorFunctions_[className]() :
      null;
};


/**
 * Maps a CSS class name to a function that returns a new instance of
 * {@link goog.ui.Component} or a subclass, suitable to decorate an element
 * that has the specified CSS class.
 * @param {string} className CSS class name.
 * @param {Function} decoratorFn No-argument function that returns a new
 *     instance of a {@link goog.ui.Component} to decorate an element.
 * @throws {Error} If the class name or the decorator function is invalid.
 */
goog.ui.registry.setDecoratorByClassName = function(className, decoratorFn) {
  'use strict';
  // In this case, explicit validation has negligible overhead (since each
  // decorator  is only registered once), and helps catch subtle bugs.
  if (!className) {
    throw new Error('Invalid class name ' + className);
  }
  if (typeof decoratorFn !== 'function') {
    throw new Error('Invalid decorator function ' + decoratorFn);
  }

  goog.ui.registry.decoratorFunctions_[className] = decoratorFn;
};


/**
 * Returns an instance of {@link goog.ui.Component} or a subclass suitable to
 * decorate the given element, based on its CSS class.
 *
 * TODO(nnaze): Type of element should be {!Element}.
 *
 * @param {Element} element Element to decorate.
 * @return {goog.ui.Component?} Component to decorate the element (null if
 *     none).
 */
goog.ui.registry.getDecorator = function(element) {
  'use strict';
  var decorator;
  goog.asserts.assert(element);
  var classNames = goog.dom.classlist.get(element);
  for (var i = 0, len = classNames.length; i < len; i++) {
    if ((decorator = goog.ui.registry.getDecoratorByClassName(classNames[i]))) {
      return decorator;
    }
  }
  return null;
};


/**
 * Resets the global renderer and decorator registry.
 */
goog.ui.registry.reset = function() {
  'use strict';
  goog.ui.registry.defaultRenderers_ = {};
  goog.ui.registry.decoratorFunctions_ = {};
};


/**
 * Map of {@link goog.ui.Component} constructor unique IDs to the constructors
 * of their default {@link goog.ui.Renderer}s.
 * @type {Object}
 * @private
 */
goog.ui.registry.defaultRenderers_ = {};


/**
 * Map of CSS class names to registry factory functions.  The keys are
 * class names.  The values are function objects that return new instances
 * of {@link goog.ui.registry} or one of its subclasses, suitable to
 * decorate elements marked with the corresponding CSS class.  Used by
 * containers while decorating their children.
 * @type {Object}
 * @private
 */
goog.ui.registry.decoratorFunctions_ = {};

//third_party/javascript/closure/ui/control.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base class for UI controls such as buttons, menus, menu items,
 * toolbar buttons, etc.  The implementation is based on a generalized version
 * of {@link goog.ui.MenuItem}.
 * TODO(attila):  If the renderer framework works well, pull it into Component.
 *
 * @see ../demos/control.html
 * @see http://code.google.com/p/closure-library/wiki/IntroToControls
 */

goog.provide('goog.ui.Control');

goog.require('goog.Disposable');
goog.require('goog.array');
goog.require('goog.dispose');
goog.require('goog.dom');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.Event');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyHandler');
goog.require('goog.string');
goog.require('goog.ui.Component');
goog.require('goog.ui.ComponentUtil');
/** @suppress {extraRequire} */
goog.require('goog.ui.ControlContent');
goog.require('goog.ui.ControlRenderer');
goog.require('goog.ui.registry');
goog.require('goog.userAgent');
goog.requireType('goog.a11y.aria.Role');
goog.requireType('goog.events.KeyEvent');



/**
 * Base class for UI controls.  Extends {@link goog.ui.Component} by adding
 * the following:
 *  <ul>
 *    <li>a {@link goog.events.KeyHandler}, to simplify keyboard handling,
 *    <li>a pluggable <em>renderer</em> framework, to simplify the creation of
 *        simple controls without the need to subclass this class,
 *    <li>the notion of component <em>content</em>, like a text caption or DOM
 *        structure displayed in the component (e.g. a button label),
 *    <li>getter and setter for component content, as well as a getter and
 *        setter specifically for caption text (for convenience),
 *    <li>support for hiding/showing the component,
      <li>fine-grained control over supported states and state transition
          events, and
 *    <li>default mouse and keyboard event handling.
 *  </ul>
 * This class has sufficient built-in functionality for most simple UI controls.
 * All controls dispatch SHOW, HIDE, ENTER, LEAVE, and ACTION events on show,
 * hide, mouseover, mouseout, and user action, respectively.  Additional states
 * are also supported.  See closure/demos/control.html
 * for example usage.
 * @param {goog.ui.ControlContent=} opt_content Text caption or DOM structure
 *     to display as the content of the control (if any).
 * @param {goog.ui.ControlRenderer=} opt_renderer Renderer used to render or
 *     decorate the component; defaults to {@link goog.ui.ControlRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @constructor
 * @extends {goog.ui.Component}
 */
goog.ui.Control = function(opt_content, opt_renderer, opt_domHelper) {
  'use strict';
  goog.ui.Component.call(this, opt_domHelper);
  this.renderer_ =
      opt_renderer || goog.ui.registry.getDefaultRenderer(this.constructor);
  this.setContentInternal(opt_content !== undefined ? opt_content : null);

  /** @private {?string} The control's aria-label. */
  this.ariaLabel_ = null;

  /** @private {goog.ui.Control.IeMouseEventSequenceSimulator_} */
  this.ieMouseEventSequenceSimulator_;
};
goog.inherits(goog.ui.Control, goog.ui.Component);


// Renderer registry.
// TODO(attila): Refactor existing usages inside Google in a follow-up CL.


/**
 * Maps a CSS class name to a function that returns a new instance of
 * {@link goog.ui.Control} or a subclass thereof, suitable to decorate
 * an element that has the specified CSS class.  UI components that extend
 * {@link goog.ui.Control} and want {@link goog.ui.Container}s to be able
 * to discover and decorate elements using them should register a factory
 * function via this API.
 * @param {string} className CSS class name.
 * @param {Function} decoratorFunction Function that takes no arguments and
 *     returns a new instance of a control to decorate an element with the
 *     given class.
 * @deprecated Use {@link goog.ui.registry.setDecoratorByClassName} instead.
 */
goog.ui.Control.registerDecorator = goog.ui.registry.setDecoratorByClassName;


/**
 * Takes an element and returns a new instance of {@link goog.ui.Control}
 * or a subclass, suitable to decorate it (based on the element's CSS class).
 * @param {Element} element Element to decorate.
 * @return {goog.ui.Control?} New control instance to decorate the element
 *     (null if none).
 * @deprecated Use {@link goog.ui.registry.getDecorator} instead.
 */
goog.ui.Control.getDecorator =
    /** @type {function(Element): goog.ui.Control} */ (
        goog.ui.registry.getDecorator);


/**
 * Renderer associated with the component.
 * @type {goog.ui.ControlRenderer|undefined}
 * @private
 */
goog.ui.Control.prototype.renderer_;


/**
 * Text caption or DOM structure displayed in the component.
 * @type {?goog.ui.ControlContent}
 * @private
 */
goog.ui.Control.prototype.content_ = null;


/**
 * Current component state; a bit mask of {@link goog.ui.Component.State}s.
 * @type {number}
 * @private
 */
goog.ui.Control.prototype.state_ = 0x00;


/**
 * A bit mask of {@link goog.ui.Component.State}s this component supports.
 * @type {number}
 * @private
 */
goog.ui.Control.prototype.supportedStates_ = goog.ui.Component.State.DISABLED |
    goog.ui.Component.State.HOVER | goog.ui.Component.State.ACTIVE |
    goog.ui.Component.State.FOCUSED;


/**
 * A bit mask of {@link goog.ui.Component.State}s for which this component
 * provides default event handling.  For example, a component that handles
 * the HOVER state automatically will highlight itself on mouseover, whereas
 * a component that doesn't handle HOVER automatically will only dispatch
 * ENTER and LEAVE events but not call {@link setHighlighted} on itself.
 * By default, components provide default event handling for all states.
 * Controls hosted in containers (e.g. menu items in a menu, or buttons in a
 * toolbar) will typically want to have their container manage their highlight
 * state.  Selectable controls managed by a selection model will also typically
 * want their selection state to be managed by the model.
 * @type {number}
 * @private
 */
goog.ui.Control.prototype.autoStates_ = goog.ui.Component.State.ALL;


/**
 * A bit mask of {@link goog.ui.Component.State}s for which this component
 * dispatches state transition events.  Because events are expensive, the
 * default behavior is to not dispatch any state transition events at all.
 * Use the {@link #setDispatchTransitionEvents} API to request transition
 * events  as needed.  Subclasses may enable transition events by default.
 * Controls hosted in containers or managed by a selection model will typically
 * want to dispatch transition events.
 * @type {number}
 * @private
 */
goog.ui.Control.prototype.statesWithTransitionEvents_ = 0x00;


/**
 * Component visibility.
 * @type {boolean}
 * @private
 */
goog.ui.Control.prototype.visible_ = true;


/**
 * Keyboard event handler.
 * @type {goog.events.KeyHandler}
 * @private
 */
goog.ui.Control.prototype.keyHandler_;


/**
 * Additional class name(s) to apply to the control's root element, if any.
 * @type {Array<string>?}
 * @private
 */
goog.ui.Control.prototype.extraClassNames_ = null;


/**
 * Whether the control should listen for and handle mouse events; defaults to
 * true.
 * @type {boolean}
 * @private
 */
goog.ui.Control.prototype.handleMouseEvents_ = true;


/**
 * Whether the control allows text selection within its DOM.  Defaults to false.
 * @type {boolean}
 * @private
 */
goog.ui.Control.prototype.allowTextSelection_ = false;


/**
 * The control's preferred ARIA role.
 * @type {?goog.a11y.aria.Role}
 * @private
 */
goog.ui.Control.prototype.preferredAriaRole_ = null;


// Event handler and renderer management.


/**
 * Returns true if the control is configured to handle its own mouse events,
 * false otherwise.  Controls not hosted in {@link goog.ui.Container}s have
 * to handle their own mouse events, but controls hosted in containers may
 * allow their parent to handle mouse events on their behalf.  Considered
 * protected; should only be used within this package and by subclasses.
 * @return {boolean} Whether the control handles its own mouse events.
 */
goog.ui.Control.prototype.isHandleMouseEvents = function() {
  'use strict';
  return this.handleMouseEvents_;
};


/**
 * Enables or disables mouse event handling for the control.  Containers may
 * use this method to disable mouse event handling in their child controls.
 * Considered protected; should only be used within this package and by
 * subclasses.
 * @param {boolean} enable Whether to enable or disable mouse event handling.
 */
goog.ui.Control.prototype.setHandleMouseEvents = function(enable) {
  'use strict';
  if (this.isInDocument() && enable != this.handleMouseEvents_) {
    // Already in the document; need to update event handler.
    this.enableMouseEventHandling_(enable);
  }
  this.handleMouseEvents_ = enable;
};


/**
 * Returns the DOM element on which the control is listening for keyboard
 * events (null if none).
 * @return {Element} Element on which the control is listening for key
 *     events.
 */
goog.ui.Control.prototype.getKeyEventTarget = function() {
  'use strict';
  // Delegate to renderer.
  return this.renderer_.getKeyEventTarget(this);
};


/**
 * Returns the keyboard event handler for this component, lazily created the
 * first time this method is called.  Considered protected; should only be
 * used within this package and by subclasses.
 * @return {!goog.events.KeyHandler} Keyboard event handler for this component.
 * @protected
 */
goog.ui.Control.prototype.getKeyHandler = function() {
  'use strict';
  return this.keyHandler_ || (this.keyHandler_ = new goog.events.KeyHandler());
};


/**
 * Returns the renderer used by this component to render itself or to decorate
 * an existing element.
 * @return {goog.ui.ControlRenderer|undefined} Renderer used by the component
 *     (undefined if none).
 */
goog.ui.Control.prototype.getRenderer = function() {
  'use strict';
  return this.renderer_;
};


/**
 * Registers the given renderer with the component.  Changing renderers after
 * the component has entered the document is an error.
 * @param {goog.ui.ControlRenderer} renderer Renderer used by the component.
 * @throws {Error} If the control is already in the document.
 */
goog.ui.Control.prototype.setRenderer = function(renderer) {
  'use strict';
  if (this.isInDocument()) {
    // Too late.
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  if (this.getElement()) {
    // The component has already been rendered, but isn't yet in the document.
    // Replace the renderer and delete the current DOM, so it can be re-rendered
    // using the new renderer the next time someone calls render().
    this.setElementInternal(null);
  }

  this.renderer_ = renderer;
};


// Support for additional styling.


/**
 * Returns any additional class name(s) to be applied to the component's
 * root element, or null if no extra class names are needed.
 * @return {Array<string>?} Additional class names to be applied to
 *     the component's root element (null if none).
 */
goog.ui.Control.prototype.getExtraClassNames = function() {
  'use strict';
  return this.extraClassNames_;
};


/**
 * Adds the given class name to the list of classes to be applied to the
 * component's root element.
 * @param {string} className Additional class name to be applied to the
 *     component's root element.
 */
goog.ui.Control.prototype.addClassName = function(className) {
  'use strict';
  if (className) {
    if (this.extraClassNames_) {
      if (!goog.array.contains(this.extraClassNames_, className)) {
        this.extraClassNames_.push(className);
      }
    } else {
      this.extraClassNames_ = [className];
    }
    this.renderer_.enableExtraClassName(this, className, true);
  }
};


/**
 * Removes the given class name from the list of classes to be applied to
 * the component's root element.
 * @param {string} className Class name to be removed from the component's root
 *     element.
 */
goog.ui.Control.prototype.removeClassName = function(className) {
  'use strict';
  if (className && this.extraClassNames_ &&
      goog.array.remove(this.extraClassNames_, className)) {
    if (this.extraClassNames_.length == 0) {
      this.extraClassNames_ = null;
    }
    this.renderer_.enableExtraClassName(this, className, false);
  }
};


/**
 * Adds or removes the given class name to/from the list of classes to be
 * applied to the component's root element.
 * @param {string} className CSS class name to add or remove.
 * @param {boolean} enable Whether to add or remove the class name.
 */
goog.ui.Control.prototype.enableClassName = function(className, enable) {
  'use strict';
  if (enable) {
    this.addClassName(className);
  } else {
    this.removeClassName(className);
  }
};


// Standard goog.ui.Component implementation.


/**
 * Creates the control's DOM.  Overrides {@link goog.ui.Component#createDom} by
 * delegating DOM manipulation to the control's renderer.
 * @override
 */
goog.ui.Control.prototype.createDom = function() {
  'use strict';
  var element = this.renderer_.createDom(this);
  this.setElementInternal(element);

  // Initialize ARIA role.
  this.renderer_.setAriaRole(element, this.getPreferredAriaRole());

  // Initialize text selection.
  if (!this.isAllowTextSelection()) {
    // The renderer is assumed to create selectable elements.  Since making
    // elements unselectable is expensive, only do it if needed (bug 1037090).
    this.renderer_.setAllowTextSelection(element, false);
  }

  // Initialize visibility.
  if (!this.isVisible()) {
    // The renderer is assumed to create visible elements. Since hiding
    // elements can be expensive, only do it if needed (bug 1037105).
    this.renderer_.setVisible(element, false);
  }
};


/**
 * Returns the control's preferred ARIA role. This can be used by a control to
 * override the role that would be assigned by the renderer.  This is useful in
 * cases where a different ARIA role is appropriate for a control because of the
 * context in which it's used.  E.g., a {@link goog.ui.MenuButton} added to a
 * {@link goog.ui.Select} should have an ARIA role of LISTBOX and not MENUITEM.
 * @return {?goog.a11y.aria.Role} This control's preferred ARIA role or null if
 *     no preferred ARIA role is set.
 */
goog.ui.Control.prototype.getPreferredAriaRole = function() {
  'use strict';
  return this.preferredAriaRole_;
};


/**
 * Sets the control's preferred ARIA role. This can be used to override the role
 * that would be assigned by the renderer.  This is useful in cases where a
 * different ARIA role is appropriate for a control because of the
 * context in which it's used.  E.g., a {@link goog.ui.MenuButton} added to a
 * {@link goog.ui.Select} should have an ARIA role of LISTBOX and not MENUITEM.
 * @param {goog.a11y.aria.Role} role This control's preferred ARIA role.
 */
goog.ui.Control.prototype.setPreferredAriaRole = function(role) {
  'use strict';
  this.preferredAriaRole_ = role;
};


/**
 * Gets the control's aria label.
 * @return {?string} This control's aria label.
 */
goog.ui.Control.prototype.getAriaLabel = function() {
  'use strict';
  return this.ariaLabel_;
};


/**
 * Sets the control's aria label. This can be used to assign aria label to the
 * element after it is rendered.
 * @param {string} label The string to set as the aria label for this control.
 *     No escaping is done on this value.
 */
goog.ui.Control.prototype.setAriaLabel = function(label) {
  'use strict';
  this.ariaLabel_ = label;
  var element = this.getElement();
  if (element) {
    this.renderer_.setAriaLabel(element, label);
  }
};


/**
 * Returns the DOM element into which child components are to be rendered,
 * or null if the control itself hasn't been rendered yet.  Overrides
 * {@link goog.ui.Component#getContentElement} by delegating to the renderer.
 * @return {Element} Element to contain child elements (null if none).
 * @override
 */
goog.ui.Control.prototype.getContentElement = function() {
  'use strict';
  // Delegate to renderer.
  return this.renderer_.getContentElement(this.getElement());
};


/**
 * Returns true if the given element can be decorated by this component.
 * Overrides {@link goog.ui.Component#canDecorate}.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the element can be decorated by this component.
 * @override
 */
goog.ui.Control.prototype.canDecorate = function(element) {
  'use strict';
  // Controls support pluggable renderers; delegate to the renderer.
  return this.renderer_.canDecorate(element);
};


/**
 * Decorates the given element with this component. Overrides {@link
 * goog.ui.Component#decorateInternal} by delegating DOM manipulation
 * to the control's renderer.
 * @param {Element} element Element to decorate.
 * @protected
 * @override
 */
goog.ui.Control.prototype.decorateInternal = function(element) {
  'use strict';
  element = this.renderer_.decorate(this, element);
  this.setElementInternal(element);

  // Initialize ARIA role.
  this.renderer_.setAriaRole(element, this.getPreferredAriaRole());

  // Initialize text selection.
  if (!this.isAllowTextSelection()) {
    // Decorated elements are assumed to be selectable.  Since making elements
    // unselectable is expensive, only do it if needed (bug 1037090).
    this.renderer_.setAllowTextSelection(element, false);
  }

  // Initialize visibility based on the decorated element's styling.
  this.visible_ = element.style.display != 'none';
};


/**
 * Configures the component after its DOM has been rendered, and sets up event
 * handling.  Overrides {@link goog.ui.Component#enterDocument}.
 * @override
 */
goog.ui.Control.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Control.superClass_.enterDocument.call(this);

  // Call the renderer's setAriaStates method to set element's aria attributes.
  this.renderer_.setAriaStates(this, this.getElementStrict());

  // Call the renderer's initializeDom method to configure properties of the
  // control's DOM that can only be done once it's in the document.
  this.renderer_.initializeDom(this);

  // Initialize event handling if at least one state other than DISABLED is
  // supported.
  if (this.supportedStates_ & ~goog.ui.Component.State.DISABLED) {
    // Initialize mouse event handling if the control is configured to handle
    // its own mouse events.  (Controls hosted in containers don't need to
    // handle their own mouse events.)
    if (this.isHandleMouseEvents()) {
      this.enableMouseEventHandling_(true);
    }

    // Initialize keyboard event handling if the control is focusable and has
    // a key event target.  (Controls hosted in containers typically aren't
    // focusable, allowing their container to handle keyboard events for them.)
    if (this.isSupportedState(goog.ui.Component.State.FOCUSED)) {
      var keyTarget = this.getKeyEventTarget();
      if (keyTarget) {
        var keyHandler = this.getKeyHandler();
        keyHandler.attach(keyTarget);
        this.getHandler()
            .listen(
                keyHandler, goog.events.KeyHandler.EventType.KEY,
                this.handleKeyEvent)
            .listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus)
            .listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur);
      }
    }
  }
};


/**
 * Enables or disables mouse event handling on the control.
 * @param {boolean} enable Whether to enable mouse event handling.
 * @private
 */
goog.ui.Control.prototype.enableMouseEventHandling_ = function(enable) {
  'use strict';
  var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);

  var handler = this.getHandler();
  var element = this.getElement();
  if (enable) {
    handler.listen(element, MouseEventType.MOUSEDOWN, this.handleMouseDown)
        .listen(
            element, [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL],
            this.handleMouseUp)
        .listen(element, goog.events.EventType.MOUSEOVER, this.handleMouseOver)
        .listen(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut);
    if (this.pointerEventsEnabled()) {
      // Prevent pointer events from capturing the target element so they behave
      // more like mouse events.
      handler.listen(
          element, goog.events.EventType.GOTPOINTERCAPTURE,
          this.preventPointerCapture_);
    }
    if (this.handleContextMenu != goog.nullFunction) {
      handler.listen(
          element, goog.events.EventType.CONTEXTMENU, this.handleContextMenu);
    }
    if (goog.userAgent.IE) {
      // Versions of IE before 9 send only one click event followed by a
      // dblclick, so we must explicitly listen for these. In later versions,
      // two click events are fired  and so a dblclick listener is unnecessary.
      if (!goog.userAgent.isVersionOrHigher(9)) {
        handler.listen(
            element, goog.events.EventType.DBLCLICK, this.handleDblClick);
      }
      if (!this.ieMouseEventSequenceSimulator_) {
        this.ieMouseEventSequenceSimulator_ =
            new goog.ui.Control.IeMouseEventSequenceSimulator_(this);
        this.registerDisposable(this.ieMouseEventSequenceSimulator_);
      }
    }
  } else {
    handler.unlisten(element, MouseEventType.MOUSEDOWN, this.handleMouseDown)
        .unlisten(
            element, [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL],
            this.handleMouseUp)
        .unlisten(
            element, goog.events.EventType.MOUSEOVER, this.handleMouseOver)
        .unlisten(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut);
    if (this.pointerEventsEnabled()) {
      handler.unlisten(
          element, goog.events.EventType.GOTPOINTERCAPTURE,
          this.preventPointerCapture_);
    }
    if (this.handleContextMenu != goog.nullFunction) {
      handler.unlisten(
          element, goog.events.EventType.CONTEXTMENU, this.handleContextMenu);
    }
    if (goog.userAgent.IE) {
      if (!goog.userAgent.isVersionOrHigher(9)) {
        handler.unlisten(
            element, goog.events.EventType.DBLCLICK, this.handleDblClick);
      }
      goog.dispose(this.ieMouseEventSequenceSimulator_);
      this.ieMouseEventSequenceSimulator_ = null;
    }
  }
};


/**
 * Cleans up the component before its DOM is removed from the document, and
 * removes event handlers.  Overrides {@link goog.ui.Component#exitDocument}
 * by making sure that components that are removed from the document aren't
 * focusable (i.e. have no tab index).
 * @override
 */
goog.ui.Control.prototype.exitDocument = function() {
  'use strict';
  goog.ui.Control.superClass_.exitDocument.call(this);
  if (this.keyHandler_) {
    this.keyHandler_.detach();
  }
  if (this.isVisible() && this.isEnabled()) {
    this.renderer_.setFocusable(this, false);
  }
};


/** @override */
goog.ui.Control.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.Control.superClass_.disposeInternal.call(this);
  if (this.keyHandler_) {
    this.keyHandler_.dispose();
    delete this.keyHandler_;
  }
  delete this.renderer_;
  this.content_ = null;
  this.extraClassNames_ = null;
  this.ieMouseEventSequenceSimulator_ = null;
};


// Component content management.


/**
 * Returns the text caption or DOM structure displayed in the component.
 * @return {goog.ui.ControlContent} Text caption or DOM structure
 *     comprising the component's contents.
 */
goog.ui.Control.prototype.getContent = function() {
  'use strict';
  return this.content_;
};


/**
 * Sets the component's content to the given text caption, element, or array of
 * nodes.  (If the argument is an array of nodes, it must be an actual array,
 * not an array-like object.)
 * @param {goog.ui.ControlContent} content Text caption or DOM
 *     structure to set as the component's contents.
 */
goog.ui.Control.prototype.setContent = function(content) {
  'use strict';
  // Controls support pluggable renderers; delegate to the renderer.
  this.renderer_.setContent(this.getElement(), content);

  // setContentInternal needs to be after the renderer, since the implementation
  // may depend on the content being in the DOM.
  this.setContentInternal(content);
};


/**
 * Sets the component's content to the given text caption, element, or array
 * of nodes.  Unlike {@link #setContent}, doesn't modify the component's DOM.
 * Called by renderers during element decoration.
 *
 * This should only be used by subclasses and its associated renderers.
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure
 *     to set as the component's contents.
 */
goog.ui.Control.prototype.setContentInternal = function(content) {
  'use strict';
  this.content_ = content;
};


/**
 * @return {string} Text caption of the control or empty string if none.
 */
goog.ui.Control.prototype.getCaption = function() {
  'use strict';
  var content = this.getContent();
  if (!content) {
    return '';
  }
  var caption = (typeof content === 'string') ?
      content :
      Array.isArray(content) ?
      content.map(goog.dom.getRawTextContent).join('') :
      goog.dom.getTextContent(/** @type {!Node} */ (content));
  return goog.string.collapseBreakingSpaces(caption);
};


/**
 * Sets the text caption of the component.
 * @param {string} caption Text caption of the component.
 */
goog.ui.Control.prototype.setCaption = function(caption) {
  'use strict';
  this.setContent(caption);
};


// Component state management.


/** @override */
goog.ui.Control.prototype.setRightToLeft = function(rightToLeft) {
  'use strict';
  // The superclass implementation ensures the control isn't in the document.
  goog.ui.Control.superClass_.setRightToLeft.call(this, rightToLeft);

  var element = this.getElement();
  if (element) {
    this.renderer_.setRightToLeft(element, rightToLeft);
  }
};


/**
 * Returns true if the control allows text selection within its DOM, false
 * otherwise.  Controls that disallow text selection have the appropriate
 * unselectable styling applied to their elements.  Note that controls hosted
 * in containers will report that they allow text selection even if their
 * container disallows text selection.
 * @return {boolean} Whether the control allows text selection.
 */
goog.ui.Control.prototype.isAllowTextSelection = function() {
  'use strict';
  return this.allowTextSelection_;
};


/**
 * Allows or disallows text selection within the control's DOM.
 * @param {boolean} allow Whether the control should allow text selection.
 */
goog.ui.Control.prototype.setAllowTextSelection = function(allow) {
  'use strict';
  this.allowTextSelection_ = allow;

  var element = this.getElement();
  if (element) {
    this.renderer_.setAllowTextSelection(element, allow);
  }
};


/**
 * Returns true if the component's visibility is set to visible, false if
 * it is set to hidden.  A component that is set to hidden is guaranteed
 * to be hidden from the user, but the reverse isn't necessarily true.
 * A component may be set to visible but can otherwise be obscured by another
 * element, rendered off-screen, or hidden using direct CSS manipulation.
 * @return {boolean} Whether the component is visible.
 */
goog.ui.Control.prototype.isVisible = function() {
  'use strict';
  return this.visible_;
};


/**
 * Shows or hides the component.  Does nothing if the component already has
 * the requested visibility.  Otherwise, dispatches a SHOW or HIDE event as
 * appropriate, giving listeners a chance to prevent the visibility change.
 * When showing a component that is both enabled and focusable, ensures that
 * its key target has a tab index.  When hiding a component that is enabled
 * and focusable, blurs its key target and removes its tab index.
 * @param {boolean} visible Whether to show or hide the component.
 * @param {boolean=} opt_force If true, doesn't check whether the component
 *     already has the requested visibility, and doesn't dispatch any events.
 * @return {boolean} Whether the visibility was changed.
 */
goog.ui.Control.prototype.setVisible = function(visible, opt_force) {
  'use strict';
  if (opt_force ||
      (this.visible_ != visible &&
       this.dispatchEvent(
           visible ? goog.ui.Component.EventType.SHOW :
                     goog.ui.Component.EventType.HIDE))) {
    var element = this.getElement();
    if (element) {
      this.renderer_.setVisible(element, visible);
    }
    if (this.isEnabled()) {
      this.renderer_.setFocusable(this, visible);
    }
    this.visible_ = visible;
    return true;
  }
  return false;
};


/**
 * Returns true if the component is enabled, false otherwise.
 * @return {boolean} Whether the component is enabled.
 */
goog.ui.Control.prototype.isEnabled = function() {
  'use strict';
  return !this.hasState(goog.ui.Component.State.DISABLED);
};


/**
 * Returns true if the control has a parent that is itself disabled, false
 * otherwise.
 * @return {boolean} Whether the component is hosted in a disabled container.
 * @private
 */
goog.ui.Control.prototype.isParentDisabled_ = function() {
  'use strict';
  var parent = this.getParent();
  return !!parent && typeof parent.isEnabled == 'function' &&
      !parent.isEnabled();
};


/**
 * Enables or disables the component.  Does nothing if this state transition
 * is disallowed.  If the component is both visible and focusable, updates its
 * focused state and tab index as needed.  If the component is being disabled,
 * ensures that it is also deactivated and un-highlighted first.  Note that the
 * component's enabled/disabled state is "locked" as long as it is hosted in a
 * {@link goog.ui.Container} that is itself disabled; this is to prevent clients
 * from accidentally re-enabling a control that is in a disabled container.
 * @param {boolean} enable Whether to enable or disable the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setEnabled = function(enable) {
  'use strict';
  if (!this.isParentDisabled_() &&
      this.isTransitionAllowed(goog.ui.Component.State.DISABLED, !enable)) {
    if (!enable) {
      this.setActive(false);
      this.setHighlighted(false);
    }
    if (this.isVisible()) {
      this.renderer_.setFocusable(this, enable);
    }
    this.setState(goog.ui.Component.State.DISABLED, !enable, true);
  }
};


/**
 * Returns true if the component is currently highlighted, false otherwise.
 * @return {boolean} Whether the component is highlighted.
 */
goog.ui.Control.prototype.isHighlighted = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.HOVER);
};


/**
 * Highlights or unhighlights the component.  Does nothing if this state
 * transition is disallowed.
 * @param {boolean} highlight Whether to highlight or unhighlight the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setHighlighted = function(highlight) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.HOVER, highlight)) {
    this.setState(goog.ui.Component.State.HOVER, highlight);
  }
};


/**
 * Returns true if the component is active (pressed), false otherwise.
 * @return {boolean} Whether the component is active.
 */
goog.ui.Control.prototype.isActive = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.ACTIVE);
};


/**
 * Activates or deactivates the component.  Does nothing if this state
 * transition is disallowed.
 * @param {boolean} active Whether to activate or deactivate the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setActive = function(active) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.ACTIVE, active)) {
    this.setState(goog.ui.Component.State.ACTIVE, active);
  }
};


/**
 * Returns true if the component is selected, false otherwise.
 * @return {boolean} Whether the component is selected.
 */
goog.ui.Control.prototype.isSelected = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.SELECTED);
};


/**
 * Selects or unselects the component.  Does nothing if this state transition
 * is disallowed.
 * @param {boolean} select Whether to select or unselect the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setSelected = function(select) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.SELECTED, select)) {
    this.setState(goog.ui.Component.State.SELECTED, select);
  }
};


/**
 * Returns true if the component is checked, false otherwise.
 * @return {boolean} Whether the component is checked.
 */
goog.ui.Control.prototype.isChecked = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.CHECKED);
};


/**
 * Checks or unchecks the component.  Does nothing if this state transition
 * is disallowed.
 * @param {boolean} check Whether to check or uncheck the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setChecked = function(check) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.CHECKED, check)) {
    this.setState(goog.ui.Component.State.CHECKED, check);
  }
};


/**
 * Returns true if the component is styled to indicate that it has keyboard
 * focus, false otherwise.  Note that `isFocused()` returning true
 * doesn't guarantee that the component's key event target has keyboard focus,
 * only that it is styled as such.
 * @return {boolean} Whether the component is styled to indicate as having
 *     keyboard focus.
 */
goog.ui.Control.prototype.isFocused = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.FOCUSED);
};


/**
 * Applies or removes styling indicating that the component has keyboard focus.
 * Note that unlike the other "set" methods, this method is called as a result
 * of the component's element having received or lost keyboard focus, not the
 * other way around, so calling `setFocused(true)` doesn't guarantee that
 * the component's key event target has keyboard focus, only that it is styled
 * as such.
 * @param {boolean} focused Whether to apply or remove styling to indicate that
 *     the component's element has keyboard focus.
 */
goog.ui.Control.prototype.setFocused = function(focused) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.FOCUSED, focused)) {
    this.setState(goog.ui.Component.State.FOCUSED, focused);
  }
};


/**
 * Returns true if the component is open (expanded), false otherwise.
 * @return {boolean} Whether the component is open.
 */
goog.ui.Control.prototype.isOpen = function() {
  'use strict';
  return this.hasState(goog.ui.Component.State.OPENED);
};


/**
 * Opens (expands) or closes (collapses) the component.  Does nothing if this
 * state transition is disallowed.
 * @param {boolean} open Whether to open or close the component.
 * @see #isTransitionAllowed
 */
goog.ui.Control.prototype.setOpen = function(open) {
  'use strict';
  if (this.isTransitionAllowed(goog.ui.Component.State.OPENED, open)) {
    this.setState(goog.ui.Component.State.OPENED, open);
  }
};


/**
 * Returns the component's state as a bit mask of {@link
 * goog.ui.Component.State}s.
 * @return {number} Bit mask representing component state.
 */
goog.ui.Control.prototype.getState = function() {
  'use strict';
  return this.state_;
};


/**
 * Returns true if the component is in the specified state, false otherwise.
 * @param {goog.ui.Component.State} state State to check.
 * @return {boolean} Whether the component is in the given state.
 */
goog.ui.Control.prototype.hasState = function(state) {
  'use strict';
  return !!(this.state_ & state);
};


/**
 * Sets or clears the given state on the component, and updates its styling
 * accordingly.  Does nothing if the component is already in the correct state
 * or if it doesn't support the specified state.  Doesn't dispatch any state
 * transition events; use advisedly.
 * @param {goog.ui.Component.State} state State to set or clear.
 * @param {boolean} enable Whether to set or clear the state (if supported).
 * @param {boolean=} opt_calledFrom Prevents looping with setEnabled.
 */
goog.ui.Control.prototype.setState = function(state, enable, opt_calledFrom) {
  'use strict';
  if (!opt_calledFrom && state == goog.ui.Component.State.DISABLED) {
    this.setEnabled(!enable);
    return;
  }
  if (this.isSupportedState(state) && enable != this.hasState(state)) {
    // Delegate actual styling to the renderer, since it is DOM-specific.
    this.renderer_.setState(this, state, enable);
    this.state_ = enable ? this.state_ | state : this.state_ & ~state;
  }
};


/**
 * Sets the component's state to the state represented by a bit mask of
 * {@link goog.ui.Component.State}s.  Unlike {@link #setState}, doesn't
 * update the component's styling, and doesn't reject unsupported states.
 * Called by renderers during element decoration.  Considered protected;
 * should only be used within this package and by subclasses.
 *
 * This should only be used by subclasses and its associated renderers.
 *
 * @param {number} state Bit mask representing component state.
 */
goog.ui.Control.prototype.setStateInternal = function(state) {
  'use strict';
  this.state_ = state;
};


/**
 * Returns true if the component supports the specified state, false otherwise.
 * @param {goog.ui.Component.State} state State to check.
 * @return {boolean} Whether the component supports the given state.
 */
goog.ui.Control.prototype.isSupportedState = function(state) {
  'use strict';
  return !!(this.supportedStates_ & state);
};


/**
 * Enables or disables support for the given state. Disabling support
 * for a state while the component is in that state is an error.
 * @param {goog.ui.Component.State} state State to support or de-support.
 * @param {boolean} support Whether the component should support the state.
 * @throws {Error} If disabling support for a state the control is currently in.
 */
goog.ui.Control.prototype.setSupportedState = function(state, support) {
  'use strict';
  if (this.isInDocument() && this.hasState(state) && !support) {
    // Since we hook up event handlers in enterDocument(), this is an error.
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  if (!support && this.hasState(state)) {
    // We are removing support for a state that the component is currently in.
    this.setState(state, false);
  }

  this.supportedStates_ =
      support ? this.supportedStates_ | state : this.supportedStates_ & ~state;
};


/**
 * Returns true if the component provides default event handling for the state,
 * false otherwise.
 * @param {goog.ui.Component.State} state State to check.
 * @return {boolean} Whether the component provides default event handling for
 *     the state.
 */
goog.ui.Control.prototype.isAutoState = function(state) {
  'use strict';
  return !!(this.autoStates_ & state) && this.isSupportedState(state);
};


/**
 * Enables or disables automatic event handling for the given state(s).
 * @param {number} states Bit mask of {@link goog.ui.Component.State}s for which
 *     default event handling is to be enabled or disabled.
 * @param {boolean} enable Whether the component should provide default event
 *     handling for the state(s).
 */
goog.ui.Control.prototype.setAutoStates = function(states, enable) {
  'use strict';
  this.autoStates_ =
      enable ? this.autoStates_ | states : this.autoStates_ & ~states;
};


/**
 * Returns true if the component is set to dispatch transition events for the
 * given state, false otherwise.
 * @param {goog.ui.Component.State} state State to check.
 * @return {boolean} Whether the component dispatches transition events for
 *     the state.
 */
goog.ui.Control.prototype.isDispatchTransitionEvents = function(state) {
  'use strict';
  return !!(this.statesWithTransitionEvents_ & state) &&
      this.isSupportedState(state);
};


/**
 * Enables or disables transition events for the given state(s).  Controls
 * handle state transitions internally by default, and only dispatch state
 * transition events if explicitly requested to do so by calling this method.
 * @param {number} states Bit mask of {@link goog.ui.Component.State}s for
 *     which transition events should be enabled or disabled.
 * @param {boolean} enable Whether transition events should be enabled.
 */
goog.ui.Control.prototype.setDispatchTransitionEvents = function(
    states, enable) {
  'use strict';
  this.statesWithTransitionEvents_ = enable ?
      this.statesWithTransitionEvents_ | states :
      this.statesWithTransitionEvents_ & ~states;
};


/**
 * Returns true if the transition into or out of the given state is allowed to
 * proceed, false otherwise.  A state transition is allowed under the following
 * conditions:
 * <ul>
 *   <li>the component supports the state,
 *   <li>the component isn't already in the target state,
 *   <li>either the component is configured not to dispatch events for this
 *       state transition, or a transition event was dispatched and wasn't
 *       canceled by any event listener, and
 *   <li>the component hasn't been disposed of
 * </ul>
 * Considered protected; should only be used within this package and by
 * subclasses.
 * @param {goog.ui.Component.State} state State to/from which the control is
 *     transitioning.
 * @param {boolean} enable Whether the control is entering or leaving the state.
 * @return {boolean} Whether the state transition is allowed to proceed.
 * @protected
 */
goog.ui.Control.prototype.isTransitionAllowed = function(state, enable) {
  'use strict';
  return this.isSupportedState(state) && this.hasState(state) != enable &&
      (!(this.statesWithTransitionEvents_ & state) ||
       this.dispatchEvent(
           goog.ui.Component.getStateTransitionEvent(state, enable))) &&
      !this.isDisposed();
};


// Default event handlers, to be overridden in subclasses.


/**
 * Handles mouseover events.  Dispatches an ENTER event; if the event isn't
 * canceled, the component is enabled, and it supports auto-highlighting,
 * highlights the component.  Considered protected; should only be used
 * within this package and by subclasses.
 * @param {goog.events.BrowserEvent} e Mouse event to handle.
 */
goog.ui.Control.prototype.handleMouseOver = function(e) {
  'use strict';
  // Ignore mouse moves between descendants.
  if (!goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) &&
      this.dispatchEvent(goog.ui.Component.EventType.ENTER) &&
      this.isEnabled() && this.isAutoState(goog.ui.Component.State.HOVER)) {
    this.setHighlighted(true);
  }
};


/**
 * Handles mouseout events.  Dispatches a LEAVE event; if the event isn't
 * canceled, and the component supports auto-highlighting, deactivates and
 * un-highlights the component.  Considered protected; should only be used
 * within this package and by subclasses.
 * @param {goog.events.BrowserEvent} e Mouse event to handle.
 */
goog.ui.Control.prototype.handleMouseOut = function(e) {
  'use strict';
  if (!goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) &&
      this.dispatchEvent(goog.ui.Component.EventType.LEAVE)) {
    if (this.isAutoState(goog.ui.Component.State.ACTIVE)) {
      // Deactivate on mouseout; otherwise we lose track of the mouse button.
      this.setActive(false);
    }
    if (this.isAutoState(goog.ui.Component.State.HOVER)) {
      this.setHighlighted(false);
    }
  }
};


/**
 * @param {!goog.events.BrowserEvent} e Event to handle.
 * @private
 */
goog.ui.Control.prototype.preventPointerCapture_ = function(e) {
  'use strict';
  var elem = /** @type {!Element} */ (e.target);
  if (!!elem.releasePointerCapture) {
    elem.releasePointerCapture(e.pointerId);
  }
};


/**
 * Handles contextmenu events.
 * @param {goog.events.BrowserEvent} e Event to handle.
 */
goog.ui.Control.prototype.handleContextMenu = goog.nullFunction;


/**
 * Checks if a mouse event (mouseover or mouseout) occurred below an element.
 * @param {goog.events.BrowserEvent} e Mouse event (should be mouseover or
 *     mouseout).
 * @param {Element} elem The ancestor element.
 * @return {boolean} Whether the event has a relatedTarget (the element the
 *     mouse is coming from) and it's a descendant of elem.
 * @private
 */
goog.ui.Control.isMouseEventWithinElement_ = function(e, elem) {
  'use strict';
  // If relatedTarget is null, it means there was no previous element (e.g.
  // the mouse moved out of the window).  Assume this means that the mouse
  // event was not within the element.
  return !!e.relatedTarget && goog.dom.contains(elem, e.relatedTarget);
};


/**
 * Handles mousedown events.  If the component is enabled, highlights and
 * activates it.  If the component isn't configured for keyboard access,
 * prevents it from receiving keyboard focus.  Considered protected; should
 * only be used within this package and by subclasses.
 * @param {goog.events.Event} e Mouse event to handle.
 */
goog.ui.Control.prototype.handleMouseDown = function(e) {
  'use strict';
  if (this.isEnabled()) {
    // Highlight enabled control on mousedown, regardless of the mouse button.
    if (this.isAutoState(goog.ui.Component.State.HOVER)) {
      this.setHighlighted(true);
    }

    // For the left button only, activate the control, and focus its key event
    // target (if supported).
    if (e.isMouseActionButton()) {
      if (this.isAutoState(goog.ui.Component.State.ACTIVE)) {
        this.setActive(true);
      }
      if (this.renderer_ && this.renderer_.isFocusable(this)) {
        this.getKeyEventTarget().focus();
      }
    }
  }

  // Cancel the default action unless the control allows text selection.
  if (!this.isAllowTextSelection() && e.isMouseActionButton()) {
    e.preventDefault();
  }
};


/**
 * Handles mouseup events.  If the component is enabled, highlights it.  If
 * the component has previously been activated, performs its associated action
 * by calling {@link performActionInternal}, then deactivates it.  Considered
 * protected; should only be used within this package and by subclasses.
 * @param {goog.events.Event} e Mouse event to handle.
 */
goog.ui.Control.prototype.handleMouseUp = function(e) {
  'use strict';
  if (this.isEnabled()) {
    if (this.isAutoState(goog.ui.Component.State.HOVER)) {
      this.setHighlighted(true);
    }
    if (this.isActive() && this.performActionInternal(e) &&
        this.isAutoState(goog.ui.Component.State.ACTIVE)) {
      this.setActive(false);
    }
  }
};


/**
 * Handles dblclick events.  Should only be registered if the user agent is
 * IE.  If the component is enabled, performs its associated action by calling
 * {@link performActionInternal}.  This is used to allow more performant
 * buttons in IE.  In IE, no mousedown event is fired when that mousedown will
 * trigger a dblclick event.  Because of this, a user clicking quickly will
 * only cause ACTION events to fire on every other click.  This is a workaround
 * to generate ACTION events for every click.  Unfortunately, this workaround
 * won't ever trigger the ACTIVE state.  This is roughly the same behaviour as
 * if this were a 'button' element with a listener on mouseup.  Considered
 * protected; should only be used within this package and by subclasses.
 * @param {goog.events.Event} e Mouse event to handle.
 */
goog.ui.Control.prototype.handleDblClick = function(e) {
  'use strict';
  if (this.isEnabled()) {
    this.performActionInternal(e);
  }
};


/**
 * Performs the appropriate action when the control is activated by the user.
 * The default implementation first updates the checked and selected state of
 * controls that support them, then dispatches an ACTION event.  Considered
 * protected; should only be used within this package and by subclasses.
 * @param {goog.events.Event} e Event that triggered the action.
 * @return {boolean} Whether the action is allowed to proceed.
 * @protected
 */
goog.ui.Control.prototype.performActionInternal = function(e) {
  'use strict';
  if (this.isAutoState(goog.ui.Component.State.CHECKED)) {
    this.setChecked(!this.isChecked());
  }
  if (this.isAutoState(goog.ui.Component.State.SELECTED)) {
    this.setSelected(true);
  }
  if (this.isAutoState(goog.ui.Component.State.OPENED)) {
    this.setOpen(!this.isOpen());
  }

  var actionEvent =
      new goog.events.Event(goog.ui.Component.EventType.ACTION, this);
  if (e) {
    actionEvent.altKey = e.altKey;
    actionEvent.ctrlKey = e.ctrlKey;
    actionEvent.metaKey = e.metaKey;
    actionEvent.shiftKey = e.shiftKey;
    actionEvent.platformModifierKey = e.platformModifierKey;
  }
  return this.dispatchEvent(actionEvent);
};


/**
 * Handles focus events on the component's key event target element.  If the
 * component is focusable, updates its state and styling to indicate that it
 * now has keyboard focus.  Considered protected; should only be used within
 * this package and by subclasses.  <b>Warning:</b> IE dispatches focus and
 * blur events asynchronously!
 * @param {goog.events.Event} e Focus event to handle.
 */
goog.ui.Control.prototype.handleFocus = function(e) {
  'use strict';
  if (this.isAutoState(goog.ui.Component.State.FOCUSED)) {
    this.setFocused(true);
  }
};


/**
 * Handles blur events on the component's key event target element.  Always
 * deactivates the component.  In addition, if the component is focusable,
 * updates its state and styling to indicate that it no longer has keyboard
 * focus.  Considered protected; should only be used within this package and
 * by subclasses.  <b>Warning:</b> IE dispatches focus and blur events
 * asynchronously!
 * @param {goog.events.Event} e Blur event to handle.
 */
goog.ui.Control.prototype.handleBlur = function(e) {
  'use strict';
  if (this.isAutoState(goog.ui.Component.State.ACTIVE)) {
    this.setActive(false);
  }
  if (this.isAutoState(goog.ui.Component.State.FOCUSED)) {
    this.setFocused(false);
  }
};


/**
 * Attempts to handle a keyboard event, if the component is enabled and visible,
 * by calling {@link handleKeyEventInternal}.  Considered protected; should only
 * be used within this package and by subclasses.
 * @param {goog.events.KeyEvent} e Key event to handle.
 * @return {boolean} Whether the key event was handled.
 */
goog.ui.Control.prototype.handleKeyEvent = function(e) {
  'use strict';
  if (this.isVisible() && this.isEnabled() && this.handleKeyEventInternal(e)) {
    e.preventDefault();
    e.stopPropagation();
    return true;
  }
  return false;
};


/**
 * Attempts to handle a keyboard event; returns true if the event was handled,
 * false otherwise.  Considered protected; should only be used within this
 * package and by subclasses.
 * @param {goog.events.KeyEvent} e Key event to handle.
 * @return {boolean} Whether the key event was handled.
 * @protected
 */
goog.ui.Control.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  return e.keyCode == goog.events.KeyCodes.ENTER &&
      this.performActionInternal(e);
};


// Register the default renderer for goog.ui.Controls.
goog.ui.registry.setDefaultRenderer(goog.ui.Control, goog.ui.ControlRenderer);


// Register a decorator factory function for goog.ui.Controls.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.ControlRenderer.CSS_CLASS, function() {
      'use strict';
      return new goog.ui.Control(null);
    });



/**
 * A singleton that helps goog.ui.Control instances play well with screen
 * readers.  It necessitated by shortcomings in IE, and need not be
 * instantiated in any other browser.
 *
 * In most cases, a click on a goog.ui.Control results in a sequence of events:
 * MOUSEDOWN, MOUSEUP and CLICK.  UI controls rely on this sequence since most
 * behavior is trigged by MOUSEDOWN and MOUSEUP.  But when IE is used with some
 * traditional screen readers (JAWS, NVDA and perhaps others), IE only sends
 * the CLICK event, resulting in the control being unresponsive.  This class
 * monitors the sequence of these events, and if it detects a CLICK event not
 * not preceded by a MOUSEUP event, directly calls the control's event handlers
 * for MOUSEDOWN, then MOUSEUP.  While the resulting sequence is different from
 * the norm (the CLICK comes first instead of last), testing thus far shows
 * the resulting behavior to be correct.
 *
 * See http://goo.gl/qvQR4C for more details.
 *
 * @param {!goog.ui.Control} control
 * @constructor
 * @extends {goog.Disposable}
 * @private
 */
goog.ui.Control.IeMouseEventSequenceSimulator_ = function(control) {
  'use strict';
  goog.ui.Control.IeMouseEventSequenceSimulator_.base(this, 'constructor');

  /** @private {goog.ui.Control}*/
  this.control_ = control;

  /** @private {boolean} */
  this.clickExpected_ = false;

  /** @private @const {!goog.events.EventHandler<
   *                       !goog.ui.Control.IeMouseEventSequenceSimulator_>}
   */
  this.handler_ = new goog.events.EventHandler(this);
  this.registerDisposable(this.handler_);

  var element = this.control_.getElementStrict();
  var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(control);

  this.handler_.listen(element, MouseEventType.MOUSEDOWN, this.handleMouseDown_)
      .listen(element, MouseEventType.MOUSEUP, this.handleMouseUp_)
      .listen(element, goog.events.EventType.CLICK, this.handleClick_);
};
goog.inherits(goog.ui.Control.IeMouseEventSequenceSimulator_, goog.Disposable);


/**
 * Whether this browser supports synthetic MouseEvents.
 *
 * See https://msdn.microsoft.com/library/dn905219(v=vs.85).aspx for details.
 *
 * @private {boolean}
 * @const
 */
goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_ =
    !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9);


/** @private */
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleMouseDown_ =
    function() {
  'use strict';
  this.clickExpected_ = false;
};


/** @private */
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleMouseUp_ =
    function() {
  'use strict';
  this.clickExpected_ = true;
};


/**
 * @param {!MouseEvent} e
 * @param {goog.events.EventType} typeArg
 * @return {!MouseEvent}
 * @private
 */
goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_ = function(
    e, typeArg) {
  'use strict';
  'use strict';

  if (!goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_) {
    // IE < 9 does not support synthetic mouse events. Therefore, reuse the
    // existing MouseEvent by overwriting the read only button and type
    // properties. As IE < 9 does not support ES5 strict mode this will not
    // generate an exception even when the script specifies "use strict".
    e.button = goog.events.BrowserEvent.MouseButton.LEFT;
    e.type = typeArg;
    return e;
  }

  var event = /** @type {!MouseEvent} */ (document.createEvent('MouseEvents'));
  event.initMouseEvent(
      typeArg, e.bubbles, e.cancelable,
      e.view || null,  // IE9 errors if view is undefined
      e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey,
      e.shiftKey, e.metaKey, goog.events.BrowserEvent.MouseButton.LEFT,
      e.relatedTarget || null);  // IE9 errors if relatedTarget is undefined
  return event;
};


/**
 * @param {!goog.events.Event} e
 * @private
 */
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleClick_ =
    function(e) {
  'use strict';
  if (this.clickExpected_) {
    // This is the end of a normal click sequence: mouse-down, mouse-up, click.
    // Assume appropriate actions have already been performed.
    this.clickExpected_ = false;
    return;
  }

  // For click events not part of a normal sequence, similate the mouse-down and
  // mouse-up events by creating synthetic events for each and directly invoke
  // the corresponding event listeners in order.

  var browserEvent = /** @type {goog.events.BrowserEvent} */ (e);

  var event = /** @type {!MouseEvent} */ (browserEvent.getBrowserEvent());
  var origEventButton = event.button;
  var origEventType = event.type;

  var down = goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_(
      event, goog.events.EventType.MOUSEDOWN);
  this.control_.handleMouseDown(
      new goog.events.BrowserEvent(down, browserEvent.currentTarget));

  var up = goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_(
      event, goog.events.EventType.MOUSEUP);
  this.control_.handleMouseUp(
      new goog.events.BrowserEvent(up, browserEvent.currentTarget));

  if (goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_) {
    // This browser supports synthetic events. Avoid resetting the read only
    // properties (type, button) as they were not overwritten and writing them
    // results in an exception when running in ES5 strict mode.
    return;
  }

  // Restore original values for click handlers that have not yet been invoked.
  event.button = origEventButton;
  event.type = origEventType;
};


/** @override */
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.disposeInternal =
    function() {
  'use strict';
  this.control_ = null;
  goog.ui.Control.IeMouseEventSequenceSimulator_.base(this, 'disposeInternal');
};

//third_party/javascript/closure/ui/nativebuttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Native browser button renderer for {@link goog.ui.Button}s.
 */

goog.provide('goog.ui.NativeButtonRenderer');

goog.require('goog.asserts');
goog.require('goog.dom.InputType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.events.EventType');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.Component');



/**
 * Renderer for {@link goog.ui.Button}s.  Renders and decorates native HTML
 * button elements.  Since native HTML buttons have built-in support for many
 * features, overrides many expensive (and redundant) superclass methods to
 * be no-ops.
 * @constructor
 * @extends {goog.ui.ButtonRenderer}
 */
goog.ui.NativeButtonRenderer = function() {
  'use strict';
  goog.ui.ButtonRenderer.call(this);
};
goog.inherits(goog.ui.NativeButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.NativeButtonRenderer);


/** @override */
goog.ui.NativeButtonRenderer.prototype.getAriaRole = function() {
  'use strict';
  // Native buttons don't need ARIA roles to be recognized by screen readers.
  return undefined;
};


/**
 * Returns the button's contents wrapped in a native HTML button element.  Sets
 * the button's disabled attribute as needed.
 * @param {goog.ui.Control} button Button to render.
 * @return {!Element} Root element for the button (a native HTML button
 *     element).
 * @override
 */
goog.ui.NativeButtonRenderer.prototype.createDom = function(button) {
  'use strict';
  this.setUpNativeButton_(button);
  return button.getDomHelper().createDom(
      goog.dom.TagName.BUTTON, {
        'class': this.getClassNames(button).join(' '),
        'disabled': !button.isEnabled(),
        'title': button.getTooltip() || '',
        'value': button.getValue() || ''
      },
      button.getCaption() || '');
};


/**
 * Overrides {@link goog.ui.ButtonRenderer#canDecorate} by returning true only
 * if the element is an HTML button.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 * @override
 */
goog.ui.NativeButtonRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return element.tagName == goog.dom.TagName.BUTTON ||
      (element.tagName == goog.dom.TagName.INPUT &&
       (element.type == goog.dom.InputType.BUTTON ||
        element.type == goog.dom.InputType.SUBMIT ||
        element.type == goog.dom.InputType.RESET));
};


/** @override */
goog.ui.NativeButtonRenderer.prototype.decorate = function(button, element) {
  'use strict';
  this.setUpNativeButton_(button);
  if (element.disabled) {
    // Add the marker class for the DISABLED state before letting the superclass
    // implementation decorate the element, so its state will be correct.
    var disabledClassName = goog.asserts.assertString(
        this.getClassForState(goog.ui.Component.State.DISABLED));
    goog.dom.classlist.add(element, disabledClassName);
  }
  return goog.ui.NativeButtonRenderer.superClass_.decorate.call(
      this, button, element);
};


/**
 * Native buttons natively support BiDi and keyboard focus.
 * @suppress {visibility} getHandler and performActionInternal
 * @override
 */
goog.ui.NativeButtonRenderer.prototype.initializeDom = function(button) {
  'use strict';
  // WARNING:  This is a hack, and it is only applicable to native buttons,
  // which are special because they do natively what most goog.ui.Controls
  // do programmatically.  Do not use your renderer's initializeDom method
  // to hook up event handlers!
  button.getHandler().listen(
      button.getElement(), goog.events.EventType.CLICK,
      button.performActionInternal);
};


/**
 * @override
 * Native buttons don't support text selection.
 */
goog.ui.NativeButtonRenderer.prototype.setAllowTextSelection =
    goog.nullFunction;


/**
 * @override
 * Native buttons natively support right-to-left rendering.
 */
goog.ui.NativeButtonRenderer.prototype.setRightToLeft = goog.nullFunction;


/**
 * @override
 * Native buttons are always focusable as long as they are enabled.
 */
goog.ui.NativeButtonRenderer.prototype.isFocusable = function(button) {
  'use strict';
  return button.isEnabled();
};


/**
 * @override
 * Native buttons natively support keyboard focus.
 */
goog.ui.NativeButtonRenderer.prototype.setFocusable = goog.nullFunction;


/**
 * @override
 * Native buttons also expose the DISABLED state in the HTML button's
 * `disabled` attribute.
 */
goog.ui.NativeButtonRenderer.prototype.setState = function(
    button, state, enable) {
  'use strict';
  goog.ui.NativeButtonRenderer.superClass_.setState.call(
      this, button, state, enable);
  var element = button.getElement();
  if (element && state == goog.ui.Component.State.DISABLED) {
    element.disabled = enable;
  }
};


/**
 * @override
 * Native buttons store their value in the HTML button's `value`
 * attribute.
 */
goog.ui.NativeButtonRenderer.prototype.getValue = function(element) {
  'use strict';
  // TODO(attila): Make this work on IE!  This never worked...
  // See http://www.fourmilab.ch/fourmilog/archives/2007-03/000824.html
  // for a description of the problem.
  return element.value;
};


/**
 * @override
 * Native buttons also expose their value in the HTML button's `value`
 * attribute.
 */
goog.ui.NativeButtonRenderer.prototype.setValue = function(element, value) {
  'use strict';
  if (element) {
    // TODO(attila): Make this work on IE!  This never worked...
    // See http://www.fourmilab.ch/fourmilog/archives/2007-03/000824.html
    // for a description of the problem.
    element.value = value;
  }
};


/**
 * @override
 * Native buttons don't need ARIA states to support accessibility, so this is
 * a no-op.
 */
goog.ui.NativeButtonRenderer.prototype.updateAriaState = goog.nullFunction;


/**
 * Sets up the button control such that it doesn't waste time adding
 * functionality that is already natively supported by native browser
 * buttons.
 * @param {goog.ui.Control} button Button control to configure.
 * @private
 */
goog.ui.NativeButtonRenderer.prototype.setUpNativeButton_ = function(button) {
  'use strict';
  button.setHandleMouseEvents(false);
  button.setAutoStates(goog.ui.Component.State.ALL, false);
  button.setSupportedState(goog.ui.Component.State.FOCUSED, false);
};

//third_party/javascript/closure/ui/button.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A button control. This implementation extends {@link
 * goog.ui.Control}.
 *
 * @see ../demos/button.html
 */

goog.provide('goog.ui.Button');
goog.provide('goog.ui.Button.Side');

goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyHandler');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.ButtonSide');
goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.NativeButtonRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.KeyEvent');
goog.requireType('goog.ui.ControlContent');



/**
 * A button control, rendered as a native browser button by default.
 *
 * @param {goog.ui.ControlContent=} opt_content Text caption or existing DOM
 *     structure to display as the button's caption (if any).
 * @param {goog.ui.ButtonRenderer=} opt_renderer Renderer used to render or
 *     decorate the button; defaults to {@link goog.ui.NativeButtonRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @constructor
 * @extends {goog.ui.Control}
 */
goog.ui.Button = function(opt_content, opt_renderer, opt_domHelper) {
  'use strict';
  goog.ui.Control.call(
      this, opt_content,
      opt_renderer || goog.ui.NativeButtonRenderer.getInstance(),
      opt_domHelper);
};
goog.inherits(goog.ui.Button, goog.ui.Control);


/**
 * Constants for button sides, see {@link goog.ui.Button.prototype.setCollapsed}
 * for details. Aliased from goog.ui.ButtonSide to support legacy users without
 * creating a circular dependency in {@link goog.ui.ButtonRenderer}.
 * @enum {number}
 * @deprecated use {@link goog.ui.ButtonSide} instead.
 */
goog.ui.Button.Side = goog.ui.ButtonSide;


/**
 * Value associated with the button.
 * @type {*}
 * @private
 */
goog.ui.Button.prototype.value_;


/**
 * Tooltip text for the button, displayed on hover.
 * @type {string|undefined}
 * @private
 */
goog.ui.Button.prototype.tooltip_;


// goog.ui.Button API implementation.


/**
 * Returns the value associated with the button.
 * @return {*} Button value (undefined if none).
 */
goog.ui.Button.prototype.getValue = function() {
  'use strict';
  return this.value_;
};


/**
 * Sets the value associated with the button, and updates its DOM.
 * @param {*} value New button value.
 */
goog.ui.Button.prototype.setValue = function(value) {
  'use strict';
  this.value_ = value;
  var renderer = /** @type {!goog.ui.ButtonRenderer} */ (this.getRenderer());
  renderer.setValue(this.getElement(), /** @type {string} */ (value));
};


/**
 * Sets the value associated with the button.  Unlike {@link #setValue},
 * doesn't update the button's DOM.  Considered protected; to be called only
 * by renderer code during element decoration.
 * @param {*} value New button value.
 * @protected
 */
goog.ui.Button.prototype.setValueInternal = function(value) {
  'use strict';
  this.value_ = value;
};


/**
 * Returns the tooltip for the button.
 * @return {string|undefined} Tooltip text (undefined if none).
 */
goog.ui.Button.prototype.getTooltip = function() {
  'use strict';
  return this.tooltip_;
};


/**
 * Sets the tooltip for the button, and updates its DOM.
 * @param {string} tooltip New tooltip text.
 */
goog.ui.Button.prototype.setTooltip = function(tooltip) {
  'use strict';
  this.tooltip_ = tooltip;
  this.getRenderer().setTooltip(this.getElement(), tooltip);
};


/**
 * Sets the tooltip for the button.  Unlike {@link #setTooltip}, doesn't update
 * the button's DOM.  Considered protected; to be called only by renderer code
 * during element decoration.
 * @param {string} tooltip New tooltip text.
 * @protected
 */
goog.ui.Button.prototype.setTooltipInternal = function(tooltip) {
  'use strict';
  this.tooltip_ = tooltip;
};


/**
 * Collapses the border on one or both sides of the button, allowing it to be
 * combined with the adjancent button(s), forming a single UI componenet with
 * multiple targets.
 * @param {number} sides Bitmap of one or more {@link goog.ui.ButtonSide}s for
 *     which borders should be collapsed.
 */
goog.ui.Button.prototype.setCollapsed = function(sides) {
  'use strict';
  this.getRenderer().setCollapsed(this, sides);
};


// goog.ui.Control & goog.ui.Component API implementation.


/** @override */
goog.ui.Button.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.Button.superClass_.disposeInternal.call(this);
  delete this.value_;
  delete this.tooltip_;
};


/** @override */
goog.ui.Button.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Button.superClass_.enterDocument.call(this);
  if (this.isSupportedState(goog.ui.Component.State.FOCUSED)) {
    var keyTarget = this.getKeyEventTarget();
    if (keyTarget) {
      this.getHandler().listen(
          keyTarget, goog.events.EventType.KEYUP, this.handleKeyEventInternal);
    }
  }
};


/**
 * Attempts to handle a keyboard event; returns true if the event was handled,
 * false otherwise.  If the button is enabled and the Enter/Space key was
 * pressed, handles the event by dispatching an `ACTION` event,
 * and returns true. Overrides {@link goog.ui.Control#handleKeyEventInternal}.
 * @param {goog.events.KeyEvent} e Key event to handle.
 * @return {boolean} Whether the key event was handled.
 * @protected
 * @override
 */
goog.ui.Button.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  if (e.keyCode == goog.events.KeyCodes.ENTER &&
          e.type == goog.events.KeyHandler.EventType.KEY ||
      e.keyCode == goog.events.KeyCodes.SPACE &&
          e.type == goog.events.EventType.KEYUP) {
    return this.performActionInternal(e);
  }
  // Return true for space keypress (even though the event is handled on keyup)
  // as preventDefault needs to be called up keypress to take effect in IE and
  // WebKit.
  return e.keyCode == goog.events.KeyCodes.SPACE;
};


// Register a decorator factory function for goog.ui.Buttons.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.ButtonRenderer.CSS_CLASS, function() {
      'use strict';
      return new goog.ui.Button(null);
    });

//javascript/jfk/button/button.js
// Copyright 2011 Google, Inc. All Rights Reserved.

/**
 * @fileoverview JFK buttons.
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('jfk.Button');
goog.provide('jfk.Button.Style');
goog.provide('jfk.Button.Width');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.dom.safe');
goog.require('goog.object');
goog.require('goog.singleton');
goog.require('goog.soy');
goog.require('goog.style');
goog.require('goog.ui.Button');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.Component');
goog.require('jfk.templates.button');
goog.require('jfk.tooltipManager');
goog.require('proto.jfk.ButtonStyle.Style');
goog.require('proto.jfk.ButtonStyle.Width');
goog.requireType('goog.events.Event');
goog.requireType('goog.ui.ControlContent');



/**
 * Common JFK button.
 * @param {goog.ui.ControlContent=} opt_content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @param {jfk.Button.Style=} opt_buttonStyle Button style. Default
 *     is STANDARD.
 * @param {jfk.Button.Width=} opt_buttonWidth Button width. Default
 *     is NORMAL.
 * @constructor
 * @extends {goog.ui.Button}
 */
jfk.Button = function(opt_content, opt_domHelper, opt_buttonStyle,
                      opt_buttonWidth) {
  jfk.Button.base(this, 'constructor',
      opt_content, jfk.ButtonRenderer_.getInstance(), opt_domHelper);

  /**
   * Button style.
   * @type {!jfk.Button.Style}
   * @private
   */
  this.style_ = opt_buttonStyle || jfk.Button.Style.STANDARD;

  /**
   * Button width.
   * @type {!jfk.Button.Width}
   * @private
   */
  this.width_ = opt_buttonWidth || jfk.Button.Width.NORMAL;

  /**
   * Use JFK-style tooltip or the HTML "title" attribute.
   * @type {boolean}
   * @private
   */
  this.usingKennedyTooltip_ = false;
};
goog.inherits(jfk.Button, goog.ui.Button);


/**
 * Class name for the button.
 * @const {string}
 */
jfk.Button.CSS_NAME = goog.getCssName('jfk-button');


/**
 * Note: this is practically private, but needs to be seen by the renderer.
 * @return {!jfk.Button.Style} Button style.
 */
jfk.Button.prototype.getStyle = function() {
  return this.style_;
};


/**
 * Note: this is practically private, but needs to be seen by the renderer.
 * @return {!jfk.Button.Width} Button width.
 */
jfk.Button.prototype.getWidth = function() {
  return this.width_;
};


/**
 * @return {boolean} true when JFK tooltip is to be used, false otherwise.
 */
jfk.Button.prototype.isUsingKennedyTooltip = function() {
  return this.usingKennedyTooltip_;
};


/**
 * @param {!jfk.Button.Style} style Button style.
 */
jfk.Button.prototype.setStyle = function(style) {
  if (this.style_ != style) {
    this.style_ = style;
    this.maybeUpdateElement_();
  }
};


/**
 * @param {!jfk.Button.Width} width Button width.
 */
jfk.Button.prototype.setWidth = function(width) {
  if (this.width_ != width) {
    this.width_ = width;
    this.maybeUpdateElement_();
  }
};


/**
 * @param {boolean} enable Whether to use JFK tooltip instead of HTML's "title"
 *     attribute.
 */
jfk.Button.prototype.setUsingKennedyTooltip = function(enable) {
  this.usingKennedyTooltip_ = enable;
};


/** @override */
jfk.Button.prototype.setTooltip = function(tooltip) {
  this.setTooltipInternal(tooltip);
  var element = this.getElement();
  if (element) {
    if (this.usingKennedyTooltip_) {
      jfk.tooltipManager.setTooltipText(element, tooltip);
    } else if (tooltip) {
      element.title = tooltip;
    } else {
      element.removeAttribute('title');
    }
  }
};


/** @override */
jfk.Button.prototype.setEnabled = function(enabled) {
  if (this.isEnabled() != enabled) {
    jfk.Button.base(this, 'setEnabled', enabled);
    this.maybeUpdateElement_();
  }
};


/**
 * Focuses the button element. Fails if the button is not in the document.
 */
jfk.Button.prototype.focus = function() {
  var el = this.getElementStrict();
  try {
    el.focus();
  } catch (e) {
    // ie can throw if it can't focus the element
  }
};


/**
 * This method should not be used directly, if you wish to move focus to the
 * button use `focus`.
 * @override
 */
jfk.Button.prototype.setFocused = function(focused) {
  jfk.Button.base(this, 'setFocused', focused);

  // Style should be cleared whenever focus is changed.  Mouse event
  // should change it back.
  this.setNoFocusOutline_(false);
};


/**
 * Clears the outline style on mouse down, on top of the standard mouse down
 * handling of the superclass.  This will cause the button to have outline style
 * when tabbed to, but not when clicked with the mouse.  Focus event is fired
 * before mousedown, except in IE, and so we also listen for mouse up.
 * @param {goog.events.Event} e Mouse event to handle.
 * @override
 */
jfk.Button.prototype.handleMouseDown = function(e) {
  jfk.Button.base(this, 'handleMouseDown', e);
  if (this.isEnabled()) {
    this.setNoFocusOutline_(true);
  }
};


/**
 * Clears the outline style on mouse up, on top of the standard mouse up
 * handling of the superclass. This will cause the button to have outline style
 * when tabbed to, but not when clicked with the mouse. Focus event is fired
 * before mousedown, except in IE, where the focus event is fired asynchronously
 * from the mouse down event. So we listen here for mouse up, in addition to
 * what we do in handleMouseDown.
 * @param {goog.events.Event} e Mouse event to handle.
 * @override
 */
jfk.Button.prototype.handleMouseUp = function(e) {
  jfk.Button.base(this, 'handleMouseUp', e);
  if (this.isEnabled()) {
    this.setNoFocusOutline_(true);
  }
};


/**
 * Set class to clear the focus outline.
 * @param {boolean} enable Whether to enable the class.
 * @private
 */
jfk.Button.prototype.setNoFocusOutline_ = function(enable) {
  if (this.getElement()) {
    goog.dom.classlist.enable(
        this.getElement(),
        goog.getCssName(jfk.Button.CSS_NAME, 'clear-outline'),
        enable);
  }
};


/**
 * Re-styles the DOM of the button.  Called after a property has changed.
 * @private
 */
jfk.Button.prototype.maybeUpdateElement_ = function() {
  // If we already have an element, we have to add the appropriate styles.
  if (this.getElement()) {
    this.getRenderer().updateButtonStyles(this);
  }
};


/**
 * Button style. Alias for definition in buttonstyle.proto.
 * @enum {number}
 */
jfk.Button.Style = proto.jfk.ButtonStyle.Style;


/**
 * Button width. Alias for definition in buttonstyle.proto.
 * @enum {number}
 */
jfk.Button.Width = proto.jfk.ButtonStyle.Width;


/**
 * JFK Default button (green in JFK).
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with default style.
 */
jfk.Button.createDefaultButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.DEFAULT);
};


/**
 * Create a new JFK action button (blue in JFK).
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with action style.
 */
jfk.Button.createActionButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.ACTION);
};


/**
 * Create a new JFK Primary button (red in JFK).
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with primary style.
 */
jfk.Button.createPrimaryButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.PRIMARY);
};


/**
 * Create a new JFK flat button -- button with no border/background.
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with primary style.
 */
jfk.Button.createFlatButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.FLAT);
};


/**
 * Create a new JFK Contrast button (white in Rio, standard button in JFK).
 * See jfk.button.contrastButton (contrastbutton.gss) for more info on use
 * and visual styles.
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with default style.
 */
jfk.Button.createContrastButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.CONTRAST);
};


/**
 * Factory method for creating a JFK search button.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with the search icon and action
 *     style.
 */
jfk.Button.createSearchButton = function(opt_domHelper) {
  // TODO(nnaze): Needs a means to specify alt tag for accessibility.
  return jfk.Button.createActionButton(
      jfk.Button.createIconContent(jfk.Button.SEARCH_BUTTON_SRC_),
      opt_domHelper);
};


/**
 * Factory method for creating a JFK toggle button.
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with the search icon and action
 *     style.
 */
jfk.Button.createToggleButton = function(content, opt_domHelper) {
  // TODO(nnaze): Needs a means to specify alt tag for accessibility.
  var button = new jfk.Button(content, opt_domHelper);
  button.setSupportedState(goog.ui.Component.State.CHECKED, true);
  return button;
};


/**
 * Factory method for creating a JFK mini button.
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @return {!jfk.Button} A button initialized with primary style.
 */
jfk.Button.createMiniButton = function(content, opt_domHelper) {
  return new jfk.Button(content, opt_domHelper, jfk.Button.Style.MINI);
};


/**
 * Resource for the search button icon.
 * @type {string}
 * @const
 * @private
 */
jfk.Button.SEARCH_BUTTON_SRC_ =
    '//ssl.gstatic.com/ui/v1/button/search-white.png';


/**
 * Create control content for a standard icon.
 *
 * TODO(nnaze): This is a stop gap. Find a way to make this general for
 * sprited icons and teams' needs.
 *
 * If a source string is given, image is expected to be a 21x21 png with black
 * and transparent pixels.  See iconlist.png in this directory.
 *
 * @param {!HTMLImageElement|string} img An image or src URL for an image.
 * @param {string=} opt_label An optional label.
 * @return {!goog.ui.ControlContent} Content for use in a button.
 */
jfk.Button.createIconContent = function(img, opt_label) {
  if (typeof img === 'string') {
    var src = img;
    img = goog.dom.createDom(goog.dom.TagName.IMG);
    goog.dom.safe.setImageSrc(img, src);
    goog.style.setSize(img, 21, 21);
  }

  goog.dom.classlist.add(/** @type {Element} */ (img),
      goog.getCssName('jfk-button-img'));

  var nodes = [];
  nodes.push(img);

  if (opt_label) {
    var labelSpan = goog.dom.createDom(
        goog.dom.TagName.SPAN, goog.getCssName('jfk-button-label'), opt_label);
    nodes.push(labelSpan);
  }

  return nodes;
};


// Button renderer



/**
 * Renders a JFK button.
 * @constructor
 * @extends {goog.ui.ButtonRenderer}
 * @private
 */
jfk.ButtonRenderer_ = function() {
  jfk.ButtonRenderer_.base(this, 'constructor');

  /**
   * @type {string}
   * @private
   */
  this.standardButtonClass_ = goog.getCssName(this.getCssClass(), 'standard');

  /**
   * @type {string}
   * @private
   */
  this.actionButtonClass_ = goog.getCssName(this.getCssClass(), 'action');

  /**
   * @type {string}
   * @private
   */
  this.primaryButtonClass_ = goog.getCssName(this.getCssClass(), 'primary');

  /**
   * @type {string}
   * @private
   */
  this.defaultButtonClass_ = goog.getCssName(this.getCssClass(), 'default');

  /**
   * @type {string}
   * @private
   */
  this.flatButtonClass_ = goog.getCssName(this.getCssClass(), 'flat');

  /**
   * @type {string}
   * @private
   */
  this.narrowButtonClass_ = goog.getCssName(this.getCssClass(), 'narrow');

  /**
   * @type {string}
   * @private
   */
  this.miniButtonClass_ = goog.getCssName(this.getCssClass(), 'mini');

  /**
   * @type {string}
   * @private
   */
  this.contrastButtonClass_ = goog.getCssName(this.getCssClass(), 'contrast');
};
goog.inherits(jfk.ButtonRenderer_, goog.ui.ButtonRenderer);

/**
 * @return {!jfk.ButtonRenderer_}
 * @nocollapse
 */
jfk.ButtonRenderer_.getInstance = function() {
  return goog.singleton.getInstance(jfk.ButtonRenderer_);
};


/**
 * CSS class names to button updater to be used by decorate.
 * @type {Object}
 * @private
 */
jfk.ButtonRenderer_.prototype.classNamesToButtonUpdater_;


/**
 * Updates the button style and width.
 * @param {jfk.Button.Style} style The new style. If null is passed,
 *    the style will not be updated.
 * @param {jfk.Button.Width} width The new width. If null is passed,
 *    the width will not be updated.
 * @param {jfk.Button} button The button.
 * @private
 */
jfk.ButtonRenderer_.prototype.updateButton_ = function(style, width, button) {
  if (style) button.setStyle(style);
  if (width) button.setWidth(width);
};


/** @override */
jfk.ButtonRenderer_.prototype.getCssClass = function() {
  return jfk.Button.CSS_NAME;
};


/** @override */
jfk.ButtonRenderer_.prototype.createDom = function(button) {
  goog.asserts.assertInstanceof(button, jfk.Button,
      'Button is expected to be instance of jfk.Button');

  var domHelper = button.getDomHelper();
  var elem = goog.soy.renderAsElement(jfk.templates.button.strict, {
    disabled: !button.isEnabled(),
    checked: button.isChecked(),
    style: button.getStyle(),
    title: button.getTooltip(),
    usingKennedyTooltip: button.isUsingKennedyTooltip(),
    value: button.getValue(),
    width: button.getWidth()
  }, undefined, domHelper);
  domHelper.append(elem, button.getContent());

  this.decorate(button, elem);
  return elem;
};


/** @override */
jfk.ButtonRenderer_.prototype.decorate = function(button, element) {
  jfk.ButtonRenderer_.base(this, 'decorate', button, element);

  if (!this.classNamesToButtonUpdater_) {
    this.classNamesToButtonUpdater_ = goog.object.create(
        this.standardButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.STANDARD, null),
        this.actionButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.ACTION, null),
        this.primaryButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.PRIMARY, null),
        this.defaultButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.DEFAULT, null),
        this.flatButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.FLAT, null),
        this.miniButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.MINI, null),
        this.contrastButtonClass_,
        goog.partial(this.updateButton_, jfk.Button.Style.CONTRAST, null),
        this.narrowButtonClass_,
        goog.partial(this.updateButton_, null, jfk.Button.Width.NARROW));
  }

  var classNames = goog.dom.classlist.get(element);
  for (var i = 0; i < classNames.length; ++i) {
    var updaterFn = this.classNamesToButtonUpdater_[classNames[i]];
    if (updaterFn) updaterFn(button);
  }

  var kennedyTooltip = element.getAttribute('data-tooltip');
  if (kennedyTooltip) {
    button.setTooltipInternal(kennedyTooltip);
    button.setUsingKennedyTooltip(true);
  }

  return element;
};


/**
 * HTML attribute containing button's value.
 * @type {string}
 * @private
 * @const
 */
jfk.ButtonRenderer_.VALUE_ATTRIBUTE_ = 'value';


/** @override */
jfk.ButtonRenderer_.prototype.getValue = function(element) {
  return element.getAttribute(jfk.ButtonRenderer_.VALUE_ATTRIBUTE_) || '';
};


/** @override */
jfk.ButtonRenderer_.prototype.setValue = function(element, value) {
  if (element) {
    element.setAttribute(jfk.ButtonRenderer_.VALUE_ATTRIBUTE_, value);
  }
};


/**
 * Updates the element styles after a change.
 * @param {!jfk.Button} button Button to render.
 */
jfk.ButtonRenderer_.prototype.updateButtonStyles = function(button) {
  goog.asserts.assert(button.getElement(),
      'Button element must already exist when updating style.');

  var classNamesToAdd = [];
  var classNamesToRemove = [];

  function addOrRemoveClassName(addOrRemove, className) {
    (addOrRemove ? classNamesToAdd : classNamesToRemove).push(className);
  }

  // Button styles
  var style = button.getStyle();
  addOrRemoveClassName(
      style == jfk.Button.Style.STANDARD, this.standardButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.ACTION, this.actionButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.PRIMARY, this.primaryButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.FLAT, this.flatButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.MINI, this.miniButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.DEFAULT, this.defaultButtonClass_);
  addOrRemoveClassName(
      style == jfk.Button.Style.CONTRAST, this.contrastButtonClass_);

  // Button width
  addOrRemoveClassName(
      button.getWidth() == jfk.Button.Width.NARROW, this.narrowButtonClass_);

  // Enabled/disabled
  addOrRemoveClassName(
      !button.isEnabled(), goog.getCssName(this.getCssClass(), 'disabled'));

  // Apply/remove the new styles.
  goog.dom.classlist.removeAll(button.getElement(), classNamesToRemove);
  goog.dom.classlist.addAll(button.getElement(), classNamesToAdd);
};

//javascript/angular/jfkwrappers/button/button.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Implements the jfk-button directive.
 *
 * Usage example:
 * <pre>&lt;div jfk-button
 *   jfk-button-collapsed="END"
 *   jfk-button-style="ACTION"
 *   jfk-button-width="NARROW"
 *   jfk-on-action="doFoo()">Click Me!!1&lt;/div>
 * </pre>
 */
goog.module('ng.jfk.Button');
goog.module.declareLegacyNamespace();

const ButtonSide = goog.require('ng.jfk.ButtonSide');
const Common = goog.require('ng.jfk.Common');
const Component = goog.require('goog.ui.Component');
const JfkButton = goog.require('jfk.Button');
const classlist = goog.require('goog.dom.classlist');
const dom = goog.require('goog.dom');
const googArray = goog.require('goog.array');

/**
 * Angular module for the jfk-button directive.
 * @type {!angular.Module}
 */
const Button = angular.module('jfkButton', [Common.name]);

(function() {
  // Export the enum constants so the code can be compiled with property
  // renaming on and users don't have to put numeric values into their
  // templates.
  var styleEnumValues = {
    'STANDARD': JfkButton.Style.STANDARD,
    'DEFAULT': JfkButton.Style.DEFAULT,
    'ACTION': JfkButton.Style.ACTION,
    'PRIMARY': JfkButton.Style.PRIMARY,
    'FLAT': JfkButton.Style.FLAT,
    'MINI': JfkButton.Style.MINI
  };
  for (var key in styleEnumValues) {
    goog.exportProperty(JfkButton.Style, key, styleEnumValues[key]);
  }

  var widthEnumValues = {
    'NORMAL': JfkButton.Width.NORMAL,
    'NARROW': JfkButton.Width.NARROW
  };
  for (var key in widthEnumValues) {
    goog.exportProperty(JfkButton.Width, key, widthEnumValues[key]);
  }
})();

/**
 * Throws an error if there's an ng-disabled and an ng-click on a
 * where the containing element is not a <button>.
 *
 * This will prevent developers from incorrectly using ng-click instead of
 * jfk-on-action, since ng-click doesn't respect ng-disabled for jfk elements
 * in the same way it does for native elements.
 *
 * @param {!angular.JQLite} $element The element.
 * @param {!angular.Attributes} $attrs The attributes map.
 */
function checkNgClickDisabledElement($element, $attrs) {
  if (!goog.DEBUG) return;
  var nodeName = $element[0].nodeName.toUpperCase();
  if (nodeName != 'BUTTON' && $attrs.hasOwnProperty('ngClick') &&
      $attrs.hasOwnProperty('ngDisabled')) {
    throw new Error(
        'Error: ng-click found with ng-disabled on a jf' +
        'k-button on a non <button>. This won\'t respect ng-disabled. ' +
        'Did you mean to use jf' +
        'k-on-action instead?');
    // Some projects check for literals 'jfk-on-action' and 'jfk-button' in
    // their presubmits to ban them as selectors.
  }
}

/**
 * Decorates button with the DOM contents currently in $scope.
 *
 * @param {!angular.JQLite} $element The element.
 * @param {!angular.Attributes} $attrs The attributes map.
 * @param {!JfkButton} button Button to decorate with DOM content.
 */
function decorateButton($element, $attrs, button) {
  // Remove the contents from the DOM, but keep a reference to add it back.
  var children = googArray.clone($element[0].childNodes);
  dom.removeChildren($element[0]);

  button.decorate($element[0]);

  // Restore the contents.
  var contentElement = button.getContentElement();
  if (contentElement) {
    dom.append(contentElement, children);
  }

  // Decorate isn't quite able to take a bare DIV and turn it into a button,
  // so we need to add a couple classes. The second one is because
  // button.setStyle() only adds the class name when the style has changed,
  // but it starts out as "STANDARD".
  classlist.add(button.getElement(), goog.getCssName('goog-inline-block'));
  classlist.add(button.getElement(), goog.getCssName('jfk-button-standard'));

  if ($attrs.hasOwnProperty('jfkButtonStyle')) {
    $attrs.$observe('jfkButtonStyle', function(newStyle) {
      button.setStyle(JfkButton.Style[newStyle]);
    });
  }
  if ($attrs.hasOwnProperty('jfkButtonWidth')) {
    $attrs.$observe('jfkButtonWidth', function(newWidth) {
      button.setWidth(JfkButton.Width[newWidth]);
    });
  }
  if ($attrs.hasOwnProperty('jfkButtonCollapsed')) {
    $attrs.$observe('jfkButtonCollapsed', function(newCollapsed) {
      button.setCollapsed(ButtonSide[newCollapsed]);
    });
  }
}

Button.directive('jfkButton', [
  'jfkCommon',
  function(jfkCommon) {
    return {
      'link': function($scope, $element, $attrs, ctrl) {
        checkNgClickDisabledElement($element, $attrs);
        var button = new JfkButton('');
        decorateButton($element, $attrs, button);
        jfkCommon.componentLink($scope, $attrs, button);
      },
      'restrict': 'EAM'
    };

  }
]);

Button.directive('jfkToggleButton', [
  'jfkCommon',
  function(jfkCommon) {
    return {
      /**
       * @param {!angular.Scope} $scope The scope.
       * @param {!angular.JQLite} $element The element.
       * @param {!angular.Attributes} $attrs The attributes map.
       * @param {angular.NgModelController} ngModel An NgModelController
       * instance.
       */
      'link': function($scope, $element, $attrs, ngModel) {
        checkNgClickDisabledElement($element, $attrs);
        var button = JfkButton.createToggleButton('');
        decorateButton($element, $attrs, button);
        jfkCommon.componentLink($scope, $attrs, button);

        // Hook up the model. (Two-way binding)
        if (ngModel) {
          ngModel.$render = function() {
            button.setChecked(ngModel.$viewValue);
          };

          jfkCommon.listenUntilDestroy(
              $scope, button, Component.EventType.ACTION, function() {
                $scope.$apply(function() {
                  ngModel.$setViewValue(button.isChecked());
                });
              });
        }
      },
      'require': '?ngModel',
      'restrict': 'EAM'
    };
  }
]);

exports = Button;

;return exports;});

//third_party/javascript/closure/ui/selectionmodel.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Single-selection model implemenation.
 *
 * TODO(attila): Add keyboard & mouse event hooks?
 * TODO(attila): Add multiple selection?
 */


goog.provide('goog.ui.SelectionModel');

goog.require('goog.array');
goog.require('goog.events.EventTarget');
goog.require('goog.events.EventType');



/**
 * Single-selection model.  Dispatches a {@link goog.events.EventType.SELECT}
 * event when a selection is made.
 * @param {Array<Object>=} opt_items Array of items; defaults to empty.
 * @extends {goog.events.EventTarget}
 * @constructor
 */
goog.ui.SelectionModel = function(opt_items) {
  'use strict';
  goog.events.EventTarget.call(this);

  /**
   * Array of items controlled by the selection model.  If the items support
   * the `setSelected(Boolean)` interface, they will be (de)selected
   * as needed.
   * @type {!Array<Object>}
   * @private
   */
  this.items_ = [];
  this.addItems(opt_items);
};
goog.inherits(goog.ui.SelectionModel, goog.events.EventTarget);


/**
 * The currently selected item (null if none).
 * @type {?Object}
 * @private
 */
goog.ui.SelectionModel.prototype.selectedItem_ = null;


/**
 * Selection handler function.  Called with two arguments (the item to be
 * selected or deselected, and a Boolean indicating whether the item is to
 * be selected or deselected).
 * @type {?Function}
 * @private
 */
goog.ui.SelectionModel.prototype.selectionHandler_ = null;


/**
 * Returns the selection handler function used by the selection model to change
 * the internal selection state of items under its control.
 * @return {Function} Selection handler function (null if none).
 */
goog.ui.SelectionModel.prototype.getSelectionHandler = function() {
  'use strict';
  return this.selectionHandler_;
};


/**
 * Sets the selection handler function to be used by the selection model to
 * change the internal selection state of items under its control.  The
 * function must take two arguments:  an item and a Boolean to indicate whether
 * the item is to be selected or deselected.  Selection handler functions are
 * only needed if the items in the selection model don't natively support the
 * `setSelected(Boolean)` interface.
 * @param {Function} handler Selection handler function.
 */
goog.ui.SelectionModel.prototype.setSelectionHandler = function(handler) {
  'use strict';
  this.selectionHandler_ = handler;
};


/**
 * Returns the number of items controlled by the selection model.
 * @return {number} Number of items.
 */
goog.ui.SelectionModel.prototype.getItemCount = function() {
  'use strict';
  return this.items_.length;
};


/**
 * Returns the 0-based index of the given item within the selection model, or
 * -1 if no such item is found.
 * @param {Object|undefined} item Item to look for.
 * @return {number} Index of the given item (-1 if none).
 */
goog.ui.SelectionModel.prototype.indexOfItem = function(item) {
  'use strict';
  return item ? this.items_.indexOf(item) : -1;
};


/**
 * @return {Object|undefined} The first item, or undefined if there are no items
 *     in the model.
 */
goog.ui.SelectionModel.prototype.getFirst = function() {
  'use strict';
  return this.items_[0];
};


/**
 * @return {Object|undefined} The last item, or undefined if there are no items
 *     in the model.
 */
goog.ui.SelectionModel.prototype.getLast = function() {
  'use strict';
  return this.items_[this.items_.length - 1];
};


/**
 * Returns the item at the given 0-based index.
 * @param {number} index Index of the item to return.
 * @return {Object} Item at the given index (null if none).
 */
goog.ui.SelectionModel.prototype.getItemAt = function(index) {
  'use strict';
  return this.items_[index] || null;
};


/**
 * Bulk-adds items to the selection model.  This is more efficient than calling
 * {@link #addItem} for each new item.
 * @param {Array<Object>|undefined} items New items to add.
 */
goog.ui.SelectionModel.prototype.addItems = function(items) {
  'use strict';
  if (items) {
    // New items shouldn't be selected.
    items.forEach(function(item) {
      'use strict';
      this.selectItem_(item, false);
    }, this);
    goog.array.extend(this.items_, items);
  }
};


/**
 * Adds an item at the end of the list.
 * @param {Object} item Item to add.
 */
goog.ui.SelectionModel.prototype.addItem = function(item) {
  'use strict';
  this.addItemAt(item, this.getItemCount());
};


/**
 * Adds an item at the given index.
 * @param {Object} item Item to add.
 * @param {number} index Index at which to add the new item.
 */
goog.ui.SelectionModel.prototype.addItemAt = function(item, index) {
  'use strict';
  if (item) {
    // New items must not be selected.
    this.selectItem_(item, false);
    goog.array.insertAt(this.items_, item, index);
  }
};


/**
 * Removes the given item (if it exists).  Dispatches a `SELECT` event if
 * the removed item was the currently selected item.
 * @param {Object} item Item to remove.
 */
goog.ui.SelectionModel.prototype.removeItem = function(item) {
  'use strict';
  if (item && goog.array.remove(this.items_, item)) {
    if (item == this.selectedItem_) {
      this.selectedItem_ = null;
      this.dispatchEvent(goog.events.EventType.SELECT);
    }
  }
};


/**
 * Removes the item at the given index.
 * @param {number} index Index of the item to remove.
 */
goog.ui.SelectionModel.prototype.removeItemAt = function(index) {
  'use strict';
  this.removeItem(this.getItemAt(index));
};


/**
 * @return {Object} The currently selected item, or null if none.
 */
goog.ui.SelectionModel.prototype.getSelectedItem = function() {
  'use strict';
  return this.selectedItem_;
};


/**
 * @return {!Array<Object>} All items in the selection model.
 */
goog.ui.SelectionModel.prototype.getItems = function() {
  'use strict';
  return goog.array.clone(this.items_);
};


/**
 * Selects the given item, deselecting any previously selected item, and
 * dispatches a `SELECT` event.
 * @param {Object} item Item to select (null to clear the selection).
 */
goog.ui.SelectionModel.prototype.setSelectedItem = function(item) {
  'use strict';
  if (item != this.selectedItem_) {
    this.selectItem_(this.selectedItem_, false);
    this.selectedItem_ = item;
    this.selectItem_(item, true);
  }

  // Always dispatch a SELECT event; let listeners decide what to do if the
  // selected item hasn't changed.
  this.dispatchEvent(goog.events.EventType.SELECT);
};


/**
 * @return {number} The 0-based index of the currently selected item, or -1
 *     if none.
 */
goog.ui.SelectionModel.prototype.getSelectedIndex = function() {
  'use strict';
  return this.indexOfItem(this.selectedItem_);
};


/**
 * Selects the item at the given index, deselecting any previously selected
 * item, and dispatches a `SELECT` event.
 * @param {number} index Index to select (-1 to clear the selection).
 */
goog.ui.SelectionModel.prototype.setSelectedIndex = function(index) {
  'use strict';
  this.setSelectedItem(this.getItemAt(index));
};


/**
 * Clears the selection model by removing all items from the selection.
 */
goog.ui.SelectionModel.prototype.clear = function() {
  'use strict';
  goog.array.clear(this.items_);
  this.selectedItem_ = null;
};


/** @override */
goog.ui.SelectionModel.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.SelectionModel.superClass_.disposeInternal.call(this);
  delete this.items_;
  this.selectedItem_ = null;
};


/**
 * Private helper; selects or deselects the given item based on the value of
 * the `select` argument.  If a selection handler has been registered
 * (via {@link #setSelectionHandler}, calls it to update the internal selection
 * state of the item.  Otherwise, attempts to call `setSelected(Boolean)`
 * on the item itself, provided the object supports that interface.
 * @param {Object} item Item to select or deselect.
 * @param {boolean} select If true, the object will be selected; if false, it
 *     will be deselected.
 * @private
 */
goog.ui.SelectionModel.prototype.selectItem_ = function(item, select) {
  'use strict';
  if (item) {
    if (typeof this.selectionHandler_ == 'function') {
      // Use the registered selection handler function.
      this.selectionHandler_(item, select);
    } else if (typeof item.setSelected == 'function') {
      // Call setSelected() on the item, if it supports it.
      item.setSelected(select);
    }
  }
};

//javascript/angular/jfkwrappers/button/segmentedbuttons.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Implements the jfk-segmented-button-group directive, along with
 * the subdirective jfk-segmented-button.
 *
 * Example:<br>
 * <pre><code>
 * &lt;div jfk-segmented-button-group ng-model="fruit"&gt;
 *   &lt;div jfk-segmented-button jfk-model-value="a"&gt;Apple&lt;/div&gt;
 *   &lt;div jfk-segmented-button jfk-model-value="o"&gt;Orange&lt;/div&gt;
 *   &lt;div jfk-segmented-button jfk-model-value="b"&gt;Banana&lt;/div&gt;
 * &lt;/div&gt;
 * </code></pre>
 */
goog.module('ng.jfk.SegmentedButtons');
goog.module.declareLegacyNamespace();

const Button = goog.require('jfk.Button');
const ButtonSide = goog.require('ng.jfk.ButtonSide');
const Common = goog.require('ng.jfk.Common');
const Component = goog.require('goog.ui.Component');
const SelectionModel = goog.require('goog.ui.SelectionModel');
const dom = goog.require('goog.dom');
const functions = goog.require('goog.functions');
const googArray = goog.require('goog.array');

/**
 * Segmented button module.
 * @type {!angular.Module}
 */
const SegmentedButtons = angular.module('jfkSegmentedButtons', [Common.name]);

/** @unrestricted */
SegmentedButtons.Controller = class {
  /**
   * @param {!angular.Scope} $scope The scope.
   * @param {!angular.JQLite} $element The element.
   */
  constructor($scope, $element) {
    /** @private {!angular.Scope} */
    this.scope_ = $scope;

    /** @private {!angular.JQLite} */
    this.element_ = $element;

    /** @private {!Array.<!Component>} */
    this.buttonsInDomOrder_ = [];

    /** @private {!SelectionModel} */
    this.selectionModel_ = new SelectionModel();

    /** @private {boolean} */
    this.enabled_ = true;

    this.selectionModel_.setSelectionHandler(function(button, selected) {
      button.setChecked(selected);
    });

    // Watch for subsequent changes in buttons (e.g. by templating)
    $scope.$watch(function() {
      this.updateCollapsedBorders();
    }.bind(this));

    // Clean up.
    $scope.$on('$destroy', goog.bind(function() {
      this.selectionModel_.dispose();
    }, this));
  }

  /**
   * Adds the selectable component to selection model. To be called by a child
   * jfk-segmented-button widget.
   * @param {!Component} component
   */
  add(component) {
    this.selectionModel_.addItem(component);

    component.listen(Component.EventType.ACTION, function(e) {
      if (this.selectionModel_.getSelectedItem() != e.target) {
        this.selectionModel_.setSelectedItem(e.target);
      } else {
        // So that clicking an already-selected button does nothing.
        e.target.setChecked(true);
      }
    }, undefined, this);

    component.setEnabled(this.enabled_);
  }

  /**
   * Removes the selectable component from the selection model. To be called by
   * a child jfk-segmented-button widget.
   * @param {!Component} component
   */
  remove(component) {
    if (!this.selectionModel_.isDisposed()) {
      this.selectionModel_.removeItem(component);
    }
  }

  /**
   * @param {!angular.NgModelController} ngModel Model controller.
   */
  dataBind(ngModel) {
    // Bind value => model.
    this.selectionModel_.listen(
        Component.EventType.SELECT, function(e) {
          var item = e.target.getSelectedItem();
          if (item && item.getModel) {
            // Note: goog.ui.SelectionModel fires CHANGE events every time the
            // value is set, even if it's set to the same value. That's why we
            // need this "if" check.
            if (item.getModel() != ngModel.$viewValue) {
              this.scope_.$apply(function() {
                ngModel.$setViewValue(item.getModel());
              });
            }
          }
        }, undefined, this);

    // Bind model => value.
    ngModel.$render = goog.bind(function() {
      var index =
          googArray.findIndex(this.selectionModel_.getItems(), function(item) {
            return item.getModel && item.getModel() == ngModel.$viewValue;
          });
      this.selectionModel_.setSelectedIndex(index);
    }, this);

    // The only remaining issue is that the child jfk-segmented-button widgets
    // don't have their jfk-model-value's available right away, so do a watch
    // on that and re-render. This covers the initial state (when a button whose
    // value matches the ng-model comes into existence.)
    var modelValues = [];
    this.scope_.$watch(goog.bind(function() {
      if (this.selectionModel_.isDisposed()) {
        return;
      }
      var newModelValues = this.selectionModel_.getItems().map(function(item) {
        return item.getModel && item.getModel();
      });
      if (!googArray.equals(modelValues, newModelValues)) {
        modelValues = newModelValues;
        ngModel.$render();
      }
    }, this));
  }

  /**
   * Set the enabled state of all buttons in the button group.
   * @param {boolean} b Whether it's enabled.
   */
  setEnabled(b) {
    this.enabled_ = b;
    this.selectionModel_.getItems().forEach(function(button) {
      button.setEnabled(b);
    });
  }

  /**
   * Updates the collapsed state of the button borders, if needed, so they run
   * together continuously.
   */
  updateCollapsedBorders() {
    var buttonsInDomOrder = this.getButtonsInDomOrder_();
    if (!googArray.equals(buttonsInDomOrder, this.buttonsInDomOrder_)) {
      buttonsInDomOrder.forEach(function(button, i) {
        var first = (i == 0);
        var last = (i == buttonsInDomOrder.length - 1);
        var collapse = (first && last) ? 'NONE' :
            first                      ? 'END' :
            last                       ? 'START' :
                                         'BOTH';
        button.setCollapsed(ButtonSide[collapse]);
      });
      this.buttonsInDomOrder_ = buttonsInDomOrder;
    }
  }

  /**
   * Gets the Button objects corresponding to each child
   * jfk-segmented-button directive, in the order they currently appear in in
   * the DOM.
   * @return {!Array.<!Component>}
   * @private
   */
  getButtonsInDomOrder_() {
    var buttonDivs = dom.getElementsByClass('jfk-button', this.element_[0]);
    return googArray
        .map(
            buttonDivs,
            function(div) {
              return googArray.find(
                  this.selectionModel_.getItems(), function(button) {
                    return button.getElement() == div;
                  });
            },
            this)
        .filter(functions.identity);
  }
};

SegmentedButtons.Controller['$inject'] = ['$scope', '$element'];

/*
 * The button group -- a container for segmented buttons.
 */
SegmentedButtons.directive('jfkSegmentedButtonGroup', function() {
  return {
    'controller': SegmentedButtons.Controller,
    'restrict': 'EA',
    'require': ['jfkSegmentedButtonGroup', '?ngModel'],
    'link': function($scope, $element, $attrs, ctrl) {
      $element.addClass('jfk-segmented-button-group');

      // Two way bind.
      if (ctrl[1]) {
        ctrl[0].dataBind(ctrl[1]);
      }

      // Update the collapsed state of the button borders
      ctrl[0].updateCollapsedBorders();

      if ($attrs['ngDisabled']) {
        // Listen for changes to the disabled state and update the contained
        // buttons.
        $scope.$watch($attrs['ngDisabled'], function(value) {
          ctrl[0].setEnabled(!value);
        });
      }
    }
  };
});

/*
 * An individual segmented button.
 */
SegmentedButtons.directive('jfkSegmentedButton', [
  'jfkCommon',
  function(jfkCommon) {
    var widthEnumValues = {
      'NORMAL': Button.Width.NORMAL,
      'NARROW': Button.Width.NARROW
    };

    return {
      'restrict': 'EA',
      'scope': true,
      'require': '^jfkSegmentedButtonGroup',
      'link': function($scope, $element, $attrs, buttonGroupCtrl) {
        $element.addClass('goog-inline-block');

        // Remove the contents from the DOM, but keep a reference to add it
        // back.
        var children = googArray.clone($element[0].childNodes);
        dom.removeChildren($element[0]);

        var button = Button.createToggleButton(null);
        button.render($element[0]);

        // Restore the contents.
        var contentElement = button.getContentElement();
        if (contentElement) {
          dom.append(contentElement, children);
        }

        // Primarily to set the jfk-model-value.
        jfkCommon.componentLink($scope, $attrs, button);

        // Support jfk-button-width="NARROW" for individual segmented buttons.
        if ($attrs.hasOwnProperty('jfkButtonWidth')) {
          $attrs.$observe('jfkButtonWidth', function(newWidth) {
            button.setWidth(widthEnumValues[newWidth]);
          });
        }

        buttonGroupCtrl.add(button);

        $scope.$on('$destroy', function() {
          buttonGroupCtrl.remove(button);
          button.dispose();
        });
      }
    };
  }
]);

exports = SegmentedButtons;

;return exports;});

//javascript/angular/components/checkbox/toggle_directive.js
'use strict';
goog.provide('ng.g.ToggleDirective');
goog.provide('ng.g.toggle.directive');

goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.ui.Component');
goog.require('ng.g.GoogAdapter');



/**
 * Function which initialize toggle directive.
 * @typedef {function(!angular.$parse, !ng.g.GoogAdapter): !angular.Directive}
 */
ng.g.ToggleDirective;


/**
 * Create a directive function for toggle components:
 * check box, star toggle, slide toggle.
 *
 * @package
 * @param {function(new:goog.ui.Component)} componentClass Constructor function
 *     for the JFK widget.
 * @param {goog.ui.Component.EventType} actionEventType Event type to listen
 *     for when the widget value toggles.
 * @return {!ng.g.ToggleDirective} A directive wrapper function for the
 *     configured directive.
 */
ng.g.toggle.directive = function(componentClass, actionEventType) {
  /**
   * Returns a tristate value (nullable boolean) given a value.
   *
   * @param {*} value
   * @return {?boolean}
   */
  var toTristate = function(value) {
    return value == null || isNaN(value) ? null : !!value;
  };

  /**
   * Set a component's label, so clicks on the label toggle the component.
   *
   * Emulate label behavior for components that don't have a setLabel() method.
   *
   * @param {!goog.ui.Component} component
   * @param {!Element} label
   * @param {!ng.g.GoogAdapter} gGoogAdapter
   * @param {!angular.Scope} scope
   */
  var setLabel = function(component, label, gGoogAdapter, scope) {
    if (component.setLabel) {
      component.setLabel(label);
    } else if (component.setChecked) {
      gGoogAdapter.listenUntilDestroy(
          scope, label, goog.events.EventType.CLICK, function(event) {
            // Ignore clicks on the component or its children that bubble up to
            // the label, to avoid double-toggling the component's state.
            if (!goog.dom.contains(component.getElement(), event.target) &&
                component.isEnabled()) {
              component.setChecked(!component.isChecked());
              component.dispatchEvent(actionEventType);
            }
          });
    }
  };

  return function($parse, gGoogAdapter) {
    // Determine the tristate property name based on whether the component is
    // being used from Angular Components or JFK Wrappers.
    // TODO(idos): Remove this condition an use gCheckboxTristate once the JFK
    // Wrappers components are deprecated.
    var tristatePropertyName = gGoogAdapter.prefixed('') === 'g' ?
        'gCheckboxTristate' : 'tristate';

    return {
      'priority': ng.g.GoogAdapter.PRIORITY_BEFORE_NG_MODEL,
      'replace': true,
      'require': '?ngModel',
      'restrict': 'EAM',
      'template': '<span></span>',
      'link': function(scope, element, attrs, ngModel) {
        // Disable the default behavior of inputDirective.
        element.unbind('click');

        var checkbox = new componentClass();

        var isTristate = attrs.hasOwnProperty(tristatePropertyName);

        // Even without the "unbind" above, clicks seems to be getting swallowed
        // by jfk.Checkbox, which breaks ng-click. So manually restore it
        // whenever the primary action occurs.
        if (attrs['ngClick']) {
          var ngClickFn = $parse(attrs['ngClick']);
          gGoogAdapter.listenUntilDestroy(
              scope, checkbox, actionEventType, function(e) {
                scope.$apply(function() { ngClickFn(scope, {'$event': e}); });
              });
        }

        // If the component has a label element ancestor, use that as its label.
        for (var parent = element[0].parentNode; parent;
             parent = parent.parentNode) {
          if (parent.tagName && parent.tagName == 'LABEL') {
            setLabel(checkbox, parent, gGoogAdapter, scope);
            break;
          }
        }

        // Watch for labels associated directly with this component via for=id.
        attrs.$observe('id', function(value) {
          if (value) {
            setTimeout(function() {
              var label = document.querySelector('label[for=' + value + ']');
              if (label) {
                setLabel(checkbox, label, gGoogAdapter, scope);
              }
            }, 0);
          }
        });

        // Hook up common functions.
        gGoogAdapter.componentLink(scope, attrs, checkbox);

        // Render.
        checkbox.render(element[0]);

        // Hook up the model. (Two-way binding)
        if (ngModel) {

          // Tristate checkboxes need custom formatters and no parser on the
          // model.
          if (isTristate) {
            // Removes input's coersion to boolean.
            goog.array.clear(ngModel.$formatters);
            goog.array.clear(ngModel.$parsers);

            // Model value should be formatted to a tristate value.
            ngModel.$formatters.push(toTristate);
          }

          ngModel.$render = function() {
            checkbox.setChecked(isTristate ?
                ngModel.$viewValue : !!ngModel.$viewValue);
          };

          gGoogAdapter.listenUntilDestroy(scope, checkbox, actionEventType,
              function() {
            // The state for a standard toggle, or null for a tristate toggle
            // which is in undetermined state.
            var value = checkbox.isChecked() ||
                isTristate && checkbox.isUndetermined() && null;

            scope.$apply(function() {
              ngModel.$setViewValue(value);
            });
          });
        }

        // Hook up the model. (One-way binding)
        if (attrs['ngChecked']) {
          scope.$watch(attrs['ngChecked'], function(newValue) {
            checkbox.setChecked(isTristate ? toTristate(newValue) : !!newValue);
          });
        }
      }
    };
  };
};

//javascript/jfk/checkbox/checkbox.soy.js
// This file was automatically generated by the Soy compiler.
// Please don't edit this file by hand.
// source: javascript/jfk/checkbox/checkbox.soy

/**
 * @fileoverview Templates in namespace jfk.templates.checkbox.
 * @suppress {missingRequire} TODO(b/152440355)
 * @requirecss {jfk.checkbox}
 * @public
 */

goog.provide('jfk.templates.checkbox');

goog.require('goog.soy');
goog.require('soy');


/**
 * @param {?jfk.templates.checkbox.main.Params=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 */
jfk.templates.checkbox.main = function(opt_data, opt_ijData) {
  opt_data = opt_data || {};
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.checkbox.main$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.attributes, opt_data.classes, opt_data.checked, opt_data.disabled, opt_data.id, opt_data.tabindex, opt_data.undetermined, opt_data.ariaLabel, opt_data.ariaLabelledBy);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?=} attributes
 * @param {?=} classes
 * @param {?=} checked
 * @param {?=} disabled
 * @param {?=} id
 * @param {?=} tabindex
 * @param {?=} undetermined
 * @param {?=} ariaLabel
 * @param {?=} ariaLabelledBy
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.checkbox.main$ = function($$areYouAnInternalCaller, $ijData, attributes, classes, checked, disabled, id, tabindex, undetermined, ariaLabel, ariaLabelledBy) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.checkbox.main']) {
    return soy.$$stubsMap['jfk.templates.checkbox.main']({attributes: attributes, classes: classes, checked: checked, disabled: disabled, id: id, tabindex: tabindex, undetermined: undetermined, ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy}, $ijData);
  }
  let $tmp;
  if (undetermined) {
    $tmp = ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox-undetermined'));
  } else if (checked) {
    $tmp = ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox-checked'));
  } else {
    $tmp = ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox-unchecked'));
  }
  let $tmp$$1;
  if (undetermined) {
    $tmp$$1 = 'mixed';
  } else if (checked) {
    $tmp$$1 = 'true';
  } else {
    $tmp$$1 = 'false';
  }
  let $tmp$$2;
  if (ariaLabelledBy) {
    $tmp$$2 = ' aria-labelledby="' + soy.$$escapeHtmlAttribute(ariaLabelledBy) + '"';
  } else if (ariaLabel) {
    $tmp$$2 = ' aria-label="' + soy.$$escapeHtmlAttribute(ariaLabel) + '"';
  } else {
    $tmp$$2 = '';
  }
  return soy.VERY_UNSAFE.ordainSanitizedHtml('<span class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox')) + ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('goog-inline-block')) + $tmp + (disabled ? ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox-disabled')) : '') + (classes ? ' ' + soy.$$escapeHtmlAttribute(classes) : '') + '" role="checkbox" aria-checked="' + $tmp$$1 + '"' + $tmp$$2 + (id ? ' id="' + soy.$$escapeHtmlAttribute(id) + '"' : '') + (disabled ? ' aria-disabled="true" tabindex="-1"' : ' tabindex="' + (tabindex ? soy.$$escapeHtmlAttribute(tabindex) : '0') + '"') + (attributes ? soy.$$whitespaceHtmlAttributes(soy.$$filterHtmlAttributes(attributes)) : '') + ' dir="ltr"' + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.checkbox.main javascript/jfk/checkbox/checkbox.soy:28"' : '') + '><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-checkbox-checkmark')) + '" role="presentation"></div></span>');
};
/**
 * @typedef {{
 *  attributes: (?|undefined),
 *  classes: (?|undefined),
 *  checked: (?|undefined),
 *  disabled: (?|undefined),
 *  id: (?|undefined),
 *  tabindex: (?|undefined),
 *  undetermined: (?|undefined),
 *  ariaLabel: (?|undefined),
 *  ariaLabelledBy: (?|undefined),
 * }}
 */
jfk.templates.checkbox.main.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.checkbox.main.soyTemplateName = 'jfk.templates.checkbox.main';
}

//third_party/javascript/closure/ui/checkboxrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Default renderer for {@link goog.ui.Checkbox}s.
 */

goog.provide('goog.ui.CheckboxRenderer');

goog.forwardDeclare('goog.ui.Checkbox.State');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.object');
goog.require('goog.ui.ControlRenderer');



/**
 * Default renderer for {@link goog.ui.Checkbox}s.  Extends the superclass
 * to support checkbox states:
 * @constructor
 * @extends {goog.ui.ControlRenderer}
 */
goog.ui.CheckboxRenderer = function() {
  'use strict';
  goog.ui.CheckboxRenderer.base(this, 'constructor');
};
goog.inherits(goog.ui.CheckboxRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.CheckboxRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.CheckboxRenderer.CSS_CLASS = goog.getCssName('goog-checkbox');


/** @override */
goog.ui.CheckboxRenderer.prototype.createDom = function(checkbox) {
  'use strict';
  var element = checkbox.getDomHelper().createDom(
      goog.dom.TagName.SPAN, this.getClassNames(checkbox).join(' '));

  var state = checkbox.getChecked();
  this.setCheckboxState(element, state);

  return element;
};


/** @override */
goog.ui.CheckboxRenderer.prototype.decorate = function(checkbox, element) {
  'use strict';
  // The superclass implementation takes care of common attributes; we only
  // need to set the checkbox state.
  element = goog.ui.CheckboxRenderer.base(this, 'decorate', checkbox, element);
  goog.asserts.assert(element);
  var classes = goog.dom.classlist.get(element);
  // Update the checked state of the element based on its css classNames
  // with the following order: undetermined -> checked -> unchecked.
  var checked =
      /** @suppress {missingRequire} */ (goog.ui.Checkbox.State.UNCHECKED);
  if (goog.array.contains(
          classes, this.getClassForCheckboxState(
                       /** @suppress {missingRequire} */
                       goog.ui.Checkbox.State.UNDETERMINED))) {
    checked =
        (/** @suppress {missingRequire} */
         goog.ui.Checkbox.State.UNDETERMINED);
  } else if (
      goog.array.contains(
          classes, this.getClassForCheckboxState(
                       /** @suppress {missingRequire} */ goog.ui.Checkbox.State
                           .CHECKED))) {
    checked = /** @suppress {missingRequire} */ goog.ui.Checkbox.State.CHECKED;
  } else if (goog.array.contains(classes,
      this.getClassForCheckboxState(/** @suppress {missingRequire} */
          goog.ui.Checkbox.State.UNCHECKED))) {
    checked =
        (/** @suppress {missingRequire} */
         goog.ui.Checkbox.State.UNCHECKED);
  }
  checkbox.setCheckedInternal(checked);
  goog.asserts.assert(element, 'The element cannot be null.');
  goog.a11y.aria.setState(
      element, goog.a11y.aria.State.CHECKED,
      this.ariaStateFromCheckState_(checked));

  return element;
};


/**
 * Returns the ARIA role to be applied to checkboxes.
 * @return {goog.a11y.aria.Role} ARIA role.
 * @override
 */
goog.ui.CheckboxRenderer.prototype.getAriaRole = function() {
  'use strict';
  return goog.a11y.aria.Role.CHECKBOX;
};


/**
 * Updates the appearance of the control in response to a checkbox state
 * change.
 * @param {Element} element Checkbox element.
 * @param {goog.ui.Checkbox.State} state Updated checkbox state.
 */
goog.ui.CheckboxRenderer.prototype.setCheckboxState = function(element, state) {
  'use strict';
  if (element) {
    goog.asserts.assert(element);
    var classToAdd = this.getClassForCheckboxState(state);
    goog.asserts.assert(classToAdd);
    goog.asserts.assert(element);
    if (goog.dom.classlist.contains(element, classToAdd)) {
      return;
    }
    goog.object.forEach(
        /** @suppress {missingRequire} */ goog.ui.Checkbox.State,
        function(state) {
          'use strict';
          var className = this.getClassForCheckboxState(state);
          goog.asserts.assert(element);
          goog.dom.classlist.enable(
              element, className, className == classToAdd);
        },
        this);
    goog.a11y.aria.setState(
        element, goog.a11y.aria.State.CHECKED,
        this.ariaStateFromCheckState_(state));
  }
};


/**
 * Gets the checkbox's ARIA (accessibility) state from its checked state.
 * @param {goog.ui.Checkbox.State} state Checkbox state.
 * @return {string} The value of goog.a11y.aria.state.CHECKED. Either 'true',
 *     'false', or 'mixed'.
 * @private
 */
goog.ui.CheckboxRenderer.prototype.ariaStateFromCheckState_ = function(state) {
  'use strict';
  if (state ==
      /** @suppress {missingRequire} */ goog.ui.Checkbox.State.UNDETERMINED) {
    return 'mixed';
  } else if (
      state ==
      /** @suppress {missingRequire} */ goog.ui.Checkbox.State.CHECKED) {
    return 'true';
  } else {
    return 'false';
  }
};


/** @override */
goog.ui.CheckboxRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.CheckboxRenderer.CSS_CLASS;
};


/**
 * Takes a single {@link goog.ui.Checkbox.State}, and returns the
 * corresponding CSS class name.
 * @param {goog.ui.Checkbox.State} state Checkbox state.
 * @return {string} CSS class representing the given state.
 * @protected
 * @suppress {missingRequire} goog.ui.Checkbox
 */
goog.ui.CheckboxRenderer.prototype.getClassForCheckboxState = function(state) {
  'use strict';
  var baseClass = this.getStructuralCssClass();
  if (state == goog.ui.Checkbox.State.CHECKED) {
    return goog.getCssName(baseClass, 'checked');
  } else if (state == goog.ui.Checkbox.State.UNCHECKED) {
    return goog.getCssName(baseClass, 'unchecked');
  } else if (state == goog.ui.Checkbox.State.UNDETERMINED) {
    return goog.getCssName(baseClass, 'undetermined');
  }
  throw new Error('Invalid checkbox state: ' + state);
};

//third_party/javascript/closure/ui/checkbox.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Tristate checkbox widget.
 *
 * @see ../demos/checkbox.html
 */

goog.provide('goog.ui.Checkbox');
goog.provide('goog.ui.Checkbox.State');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.string');
goog.require('goog.ui.CheckboxRenderer');
goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.BrowserEvent');



/**
 * 3-state checkbox widget. Fires CHECK or UNCHECK events before toggled and
 * CHANGE event after toggled by user.
 * The checkbox can also be enabled/disabled and get focused and highlighted.
 *
 * @param {goog.ui.Checkbox.State=} opt_checked Checked state to set.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @param {goog.ui.CheckboxRenderer=} opt_renderer Renderer used to render or
 *     decorate the checkbox; defaults to {@link goog.ui.CheckboxRenderer}.
 * @constructor
 * @extends {goog.ui.Control}
 */
goog.ui.Checkbox = function(opt_checked, opt_domHelper, opt_renderer) {
  'use strict';
  var renderer = opt_renderer || goog.ui.CheckboxRenderer.getInstance();
  goog.ui.Control.call(this, null, renderer, opt_domHelper);
  // The checkbox maintains its own tri-state CHECKED state.
  // The control class maintains DISABLED, ACTIVE, and FOCUSED (which enable tab
  // navigation, and keyHandling with SPACE).

  /**
   * Checked state of the checkbox.
   * @type {goog.ui.Checkbox.State}
   * @private
   */
  this.checked_ = (opt_checked !== undefined) ?
      opt_checked :
      goog.ui.Checkbox.State.UNCHECKED;
};
goog.inherits(goog.ui.Checkbox, goog.ui.Control);


/**
 * Possible checkbox states.
 * @enum {?boolean}
 */
goog.ui.Checkbox.State = {
  CHECKED: true,
  UNCHECKED: false,
  UNDETERMINED: null
};


/**
 * Label element bound to the checkbox.
 * @type {?Element}
 * @private
 */
goog.ui.Checkbox.prototype.label_ = null;


/**
 * @return {goog.ui.Checkbox.State} Checked state of the checkbox.
 */
goog.ui.Checkbox.prototype.getChecked = function() {
  'use strict';
  return this.checked_;
};


/**
 * @return {boolean} Whether the checkbox is checked.
 * @override
 */
goog.ui.Checkbox.prototype.isChecked = function() {
  'use strict';
  return this.checked_ == goog.ui.Checkbox.State.CHECKED;
};


/**
 * @return {boolean} Whether the checkbox is not checked.
 */
goog.ui.Checkbox.prototype.isUnchecked = function() {
  'use strict';
  return this.checked_ == goog.ui.Checkbox.State.UNCHECKED;
};


/**
 * @return {boolean} Whether the checkbox is in partially checked state.
 */
goog.ui.Checkbox.prototype.isUndetermined = function() {
  'use strict';
  return this.checked_ == goog.ui.Checkbox.State.UNDETERMINED;
};


/**
 * Sets the checked state of the checkbox.
 * @param {?boolean} checked The checked state to set.
 * @override
 */
goog.ui.Checkbox.prototype.setChecked = function(checked) {
  'use strict';
  if (checked != this.checked_) {
    this.checked_ = /** @type {goog.ui.Checkbox.State} */ (checked);
    this.getRenderer().setCheckboxState(this.getElement(), this.checked_);
  }
};


/**
 * Sets the checked state for the checkbox.  Unlike {@link #setChecked},
 * doesn't update the checkbox's DOM.  Considered protected; to be called
 * only by renderer code during element decoration.
 * @param {goog.ui.Checkbox.State} checked New checkbox state.
 */
goog.ui.Checkbox.prototype.setCheckedInternal = function(checked) {
  'use strict';
  this.checked_ = checked;
};


/**
 * Binds an HTML element to the checkbox which if clicked toggles the checkbox.
 * Behaves the same way as the 'label' HTML tag. The label element has to be the
 * direct or non-direct ancestor of the checkbox element because it will get the
 * focus when keyboard support is implemented.
 * Note: Control#enterDocument also sets aria-label on the element but
 * Checkbox#enterDocument sets aria-labeledby on the same element which
 * overrides the aria-label in all modern screen readers.
 *
 * @param {?Element} label The label control to set. If null, only the checkbox
 *     reacts to clicks.
 */
goog.ui.Checkbox.prototype.setLabel = function(label) {
  'use strict';
  if (this.isInDocument()) {
    var wasFocused = this.isFocused();
    this.exitDocument();
    this.label_ = label;
    this.enterDocument();
    if (wasFocused) {
      this.getElementStrict().focus();
    }
  } else {
    this.label_ = label;
  }
};


/**
 * Toggles the checkbox. State transitions:
 * <ul>
 *   <li>unchecked -> checked
 *   <li>undetermined -> checked
 *   <li>checked -> unchecked
 * </ul>
 */
goog.ui.Checkbox.prototype.toggle = function() {
  'use strict';
  this.setChecked(
      this.checked_ ? goog.ui.Checkbox.State.UNCHECKED :
                      goog.ui.Checkbox.State.CHECKED);
};


/** @override */
goog.ui.Checkbox.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Checkbox.base(this, 'enterDocument');
  if (this.isHandleMouseEvents()) {
    var handler = this.getHandler();
    // Listen to the label, if it was set.
    if (this.label_) {
      // Any mouse events that happen to the associated label should have the
      // same effect on the checkbox as if they were happening to the checkbox
      // itself.
      handler
          .listen(
              this.label_, goog.events.EventType.CLICK,
              this.handleClickOrSpace_)
          .listen(
              this.label_, goog.events.EventType.MOUSEOVER,
              this.handleMouseOver)
          .listen(
              this.label_, goog.events.EventType.MOUSEOUT, this.handleMouseOut)
          .listen(
              this.label_, goog.events.EventType.MOUSEDOWN,
              this.handleMouseDown)
          .listen(
              this.label_, goog.events.EventType.MOUSEUP, this.handleMouseUp);
    }
    // Checkbox needs to explicitly listen for click event.
    handler.listen(
        this.getElement(), goog.events.EventType.CLICK,
        this.handleClickOrSpace_);
  }

  // Set aria label.
  var checkboxElement = this.getElementStrict();
  if (this.label_ && checkboxElement != this.label_ &&
      goog.string.isEmptyOrWhitespace(
          goog.a11y.aria.getLabel(checkboxElement))) {
    if (!this.label_.id) {
      this.label_.id = this.makeId('lbl');
    }
    goog.a11y.aria.setState(
        checkboxElement, goog.a11y.aria.State.LABELLEDBY, this.label_.id);
  }
};


/**
 * Handles the click event.
 * @param {!goog.events.BrowserEvent} e The event.
 * @private
 */
goog.ui.Checkbox.prototype.handleClickOrSpace_ = function(e) {
  'use strict';
  e.stopPropagation();
  var eventType = this.checked_ ? goog.ui.Component.EventType.UNCHECK :
                                  goog.ui.Component.EventType.CHECK;
  if (this.isEnabled() && !e.target.href && this.dispatchEvent(eventType)) {
    e.preventDefault();  // Prevent scrolling in Chrome if SPACE is pressed.
    this.toggle();
    this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
  }
};


/** @override */
goog.ui.Checkbox.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  if (e.keyCode == goog.events.KeyCodes.SPACE) {
    this.performActionInternal(e);
    this.handleClickOrSpace_(e);
  }
  return false;
};


/**
 * Register this control so it can be created from markup.
 */
goog.ui.registry.setDecoratorByClassName(
    goog.ui.CheckboxRenderer.CSS_CLASS, function() {
      'use strict';
      return new goog.ui.Checkbox();
    });

//javascript/jfk/checkbox/checkbox.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Checkbox implemented in the Kennedy style.  Extends the Closure
 * checkbox by adding a different root css name.
 * @author gkuznetsov@google.com (Gleb Kuznetsov)
 */

goog.provide('jfk.Checkbox');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.soy');
goog.require('goog.ui.Checkbox');
goog.require('goog.ui.CheckboxRenderer');
goog.require('goog.ui.Component');
goog.require('goog.ui.ControlRenderer');
goog.require('jfk.templates.checkbox');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.Event');



/** @unrestricted */
jfk.Checkbox = class extends goog.ui.Checkbox {
  /**
   * @param {goog.ui.Checkbox.State=} opt_checked Initial checked state.
   * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM hepler, used for
   *     document interaction.
   */
  constructor(opt_checked, opt_domHelper) {
    var renderer = /** @type {goog.ui.CheckboxRenderer} */ (
        goog.ui.ControlRenderer.getCustomRenderer(
            goog.ui.CheckboxRenderer, jfk.Checkbox.CSS_NAME));
    super(opt_checked, opt_domHelper, renderer);
    this.setSupportedState(goog.ui.Component.State.ACTIVE, true);
  }

  /** @override */
  createDom() {
    this.setElementInternal(goog.soy.renderAsElement(
        jfk.templates.checkbox.main, {
          checked: this.isChecked(),
          disabled: !this.isEnabled(),
          undetermined: this.isUndetermined()
        },
        undefined, this.getDomHelper()));
  }

  /**
   * Decorates the checkbox. This relies on the DOM structure
   * defined in checkbox.soy.
   * @param {Element} element Element to decorate.
   * @protected
   * @override
   */
  decorateInternal(element) {
    super.decorateInternal(element);
    goog.dom.classlist.add(element, goog.getCssName('goog-inline-block'));
    this.getElement().dir = 'ltr';
    var checkmarkClass = goog.getCssName(jfk.Checkbox.CSS_NAME, 'checkmark');
    if (!this.getElementByClass(checkmarkClass)) {
      this.createCheckmarkDiv_();
    }
    // Set role=presentation so NVDA 2014.1 x FF 30 announces checked changes
    // properly (b/13520884).
    goog.a11y.aria.setRole(
        this.getRequiredElementByClass(checkmarkClass),
        goog.a11y.aria.Role.PRESENTATION);
  }

  /**
   * Creates the div which holds the checkmark image and can be offset for
   * proper display.  Attaches it to the element.
   * @private
   */
  createCheckmarkDiv_() {
    var checkmarkElement = this.getDomHelper().createDom(
        goog.dom.TagName.DIV,
        goog.getCssName(jfk.Checkbox.CSS_NAME, 'checkmark'));
    this.getElement().appendChild(checkmarkElement);
  }

  /** @override */
  setFocused(focused) {
    super.setFocused(focused);

    // Style should be cleared whenever focus is changed.  Mouse event
    // should change it back.
    this.setNoFocusOutline_(false);
  }

  /**
   * Clears the outline style on mouse down, on top of the standard mouse down
   * handling of the superclass.  This will cause the button to have outline
   * style when tabbed to, but not when clicked with the mouse.  Focus event is
   * fired before mousedown.
   * @param {goog.events.Event} e Mouse event to handle.
   * @override
   */
  handleMouseDown(e) {
    super.handleMouseDown(e);
    if (this.isEnabled()) {
      this.setNoFocusOutline_(true);
    }
  }

  /**
   * Set class to clear the focus outline.
   * @param {boolean} enable Whether to enable the class.
   * @private
   */
  setNoFocusOutline_(enable) {
    if (this.getElement()) {
      goog.dom.classlist.enable(
          this.getElement(),
          goog.getCssName(jfk.Checkbox.CSS_NAME, 'clearOutline'), enable);
    }
  }
};



/**
 * Css class name.
 * @type {string}
 * @const
 */
jfk.Checkbox.CSS_NAME = goog.getCssName('jfk-checkbox');



// TODO(chrishenry): Check for usages of decoration for jfk.Checkbox and ensure
// they are using checkbox.soy or equivalent DOM.



// TODO(chrishenry): The following 3 methods are taken almost verbatim
// from jfk.Button. We should figure out a way to extract this logic
// (maybe to goog.ui.Control).

//javascript/angular/components/checkbox/checkbox_directive.js
'use strict';
goog.provide('ng.g.checkbox.directive');

goog.require('goog.ui.Component');
goog.require('jfk.Checkbox');
goog.require('ng.g.ToggleDirective');
goog.require('ng.g.toggle.directive');



/** @type {!ng.g.ToggleDirective} */
ng.g.checkbox.directive = ng.g.toggle.directive(
    jfk.Checkbox, goog.ui.Component.EventType.CHANGE);

//javascript/jfk/button/slidetoggle.soy.js
// This file was automatically generated by the Soy compiler.
// Please don't edit this file by hand.
// source: javascript/jfk/button/slidetoggle.soy

/**
 * @fileoverview Templates in namespace jfk.templates.slideToggle.
 * @suppress {missingRequire} TODO(b/152440355)
 * @requirecss {jfk.button.slideToggle}
 * @public
 */

goog.provide('jfk.templates.slideToggle');

goog.require('goog.soy');
goog.require('soy');


/**
 * @param {?jfk.templates.slideToggle.main.Params=} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 */
jfk.templates.slideToggle.main = function(opt_data, opt_ijData) {
  opt_data = opt_data || {};
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.slideToggle.main$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.checked);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?=} checked
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.slideToggle.main$ = function($$areYouAnInternalCaller, $ijData, checked) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.slideToggle.main']) {
    return soy.$$stubsMap['jfk.templates.slideToggle.main']({checked: checked}, $ijData);
  }
  let $output = '<div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-slideToggle')) + ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('goog-inline-block')) + (checked ? ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-slideToggle-checked')) : '') + '"' + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.slideToggle.main javascript/jfk/button/slidetoggle.soy:8"' : '') + '><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-slideToggle-on')) + '">';
  /** @desc The label shown when the slide toggle is in the 'on' or 'enabled' position. */
  const MSG_UNNAMED = goog.getMsg('on', {}, {html: true});
  $output += MSG_UNNAMED;
  $output += '</div><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-slideToggle-off')) + '">';
  /** @desc The label shown when the slide toggle is in the 'off' or 'disabled' position. */
  const MSG_UNNAMED$$1 = goog.getMsg('off', {}, {html: true});
  $output += MSG_UNNAMED$$1;
  $output += '</div><div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-slideToggle-thumb')) + '"></div></div>';
  return soy.VERY_UNSAFE.ordainSanitizedHtml($output);
};
/**
 * @typedef {{
 *  checked: (?|undefined),
 * }}
 */
jfk.templates.slideToggle.main.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.slideToggle.main.soyTemplateName = 'jfk.templates.slideToggle.main';
}

//javascript/jfk/button/slidetoggle.js
goog.loadModule(function(exports) {'use strict';/** @fileoverview Sliding toggle widget. */

goog.module('jfk.SlideToggle');
goog.module.declareLegacyNamespace();

const Button = goog.require('goog.ui.Button');
const ButtonRenderer = goog.require('goog.ui.ButtonRenderer');
const Component = goog.require('goog.ui.Component');
const DomHelper = goog.requireType('goog.dom.DomHelper');
const GoogEvent = goog.requireType('goog.events.Event');
const classlist = goog.require('goog.dom.classlist');
const singleton = goog.require('goog.singleton');
const slideToggle = goog.require('jfk.templates.slideToggle');
const soy = goog.require('goog.soy');

/**
 * An implementation of the Kennedy sliding toggle component.
 *
 * @param {!DomHelper=} opt_domHelper An optional DOM helper.
 * @constructor
 * @extends {Button}
 */
function SlideToggle(opt_domHelper) {
  SlideToggle.base(
      this, 'constructor', '', SlideToggle.Renderer_.getInstance(),
      opt_domHelper);

  this.setSupportedState(Component.State.CHECKED, true);
}
goog.inherits(SlideToggle, Button);

/**
 * Class name for the slide toggle.
 * @const
 * @private
 */
SlideToggle.CSS_NAME_ = goog.getCssName('jfk-slideToggle');

/** @override */
SlideToggle.prototype.setFocused = function(focused) {
  SlideToggle.base(this, 'setFocused', focused);

  // Style should be cleared whenever focus is changed.  Mouse event
  // should change it back.
  this.setNoFocusOutline_(false);
};

/**
 * Clears the outline style on mouse down, on top of the standard mouse down
 * handling of the superclass.  This will cause the toggle to have outline style
 * when tabbed to, but not when clicked with the mouse.  Focus event is fired
 * before mousedown.
 * @param {GoogEvent} e Mouse event to handle.
 * @override
 */
SlideToggle.prototype.handleMouseDown = function(e) {
  SlideToggle.base(this, 'handleMouseDown', e);
  if (this.isEnabled()) {
    this.setNoFocusOutline_(true);
  }
};

/**
 * Set class to clear the focus outline.
 * @param {boolean} enable Whether to enable the class.
 * @private
 */
SlideToggle.prototype.setNoFocusOutline_ = function(enable) {
  if (this.getElement()) {
    classlist.enable(
        this.getElement(),
        goog.getCssName(SlideToggle.CSS_NAME_, 'clearOutline'), enable);
  }
};

/**
 * Renderer for the Slide Toggle UI component.
 *
 * @constructor
 * @extends {ButtonRenderer}
 * @private
 */
SlideToggle.Renderer_ = function() {
  SlideToggle.Renderer_.base(this, 'constructor');
};
goog.inherits(SlideToggle.Renderer_, ButtonRenderer);

/**
 * @return {!SlideToggle.Renderer_}
 * @nocollapse
 */
SlideToggle.Renderer_.getInstance = function() {
  return singleton.getInstance(SlideToggle.Renderer_);
};

/** @override */
SlideToggle.Renderer_.prototype.createDom = function(toggle) {
  return soy.renderAsElement(
      slideToggle.main, {checked: toggle.isChecked()}, undefined,
      toggle.getDomHelper());
};

/** @override */
SlideToggle.Renderer_.prototype.canDecorate = function(element) {
  return false;
};

/** @override */
SlideToggle.Renderer_.prototype.getCssClass = function() {
  return SlideToggle.CSS_NAME_;
};

exports = SlideToggle;

;return exports;});

//javascript/angular/components/checkbox/slidetoggle_directive.js
'use strict';
goog.provide('ng.g.slideToggle.directive');

goog.require('goog.ui.Component');
goog.require('jfk.SlideToggle');
goog.require('ng.g.ToggleDirective');
goog.require('ng.g.toggle.directive');



/** @type {!ng.g.ToggleDirective} */
ng.g.slideToggle.directive = ng.g.toggle.directive(
    jfk.SlideToggle, goog.ui.Component.EventType.ACTION);


//javascript/jfk/star/star.soy.js
// This file was automatically generated by the Soy compiler.
// Please don't edit this file by hand.
// source: javascript/jfk/star/star.soy

/**
 * @fileoverview Templates in namespace jfk.templates.star.
 * @suppress {missingRequire} TODO(b/152440355)
 * @public
 */

goog.provide('jfk.templates.star');

goog.require('goog.soy');
goog.require('soy');


/**
 * @param {!jfk.templates.star.main.Params} opt_data
 * @param {(?goog.soy.IjData|?Object<string, *>)=} opt_ijData
 * @return {!goog.soy.data.SanitizedHtml}
 */
jfk.templates.star.main = function(opt_data, opt_ijData) {
  const $ijData = /** @type {!goog.soy.IjData} */ (opt_ijData);
  return jfk.templates.star.main$(soy.$$internalCallMarkerDoNotUse, $ijData, opt_data.checked);
};
/**
 * @param {!Object} $$areYouAnInternalCaller
 * @param {!goog.soy.IjData} $ijData
 * @param {?} checked
 * @return {!goog.soy.data.SanitizedHtml}
 * @suppress {checkTypes}
 */
jfk.templates.star.main$ = function($$areYouAnInternalCaller, $ijData, checked) {
  soy.$$areYouAnInternalCaller($$areYouAnInternalCaller);
  if (goog.DEBUG && soy.$$stubsMap['jfk.templates.star.main']) {
    return soy.$$stubsMap['jfk.templates.star.main']({checked: checked}, $ijData);
  }
  let $output = '<div class="' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-star')) + (checked ? ' ' + soy.$$escapeHtmlAttribute(goog.getCssName('jfk-star-checked')) : '') + '" role="button" aria-label="';
  /** @desc Star an item button (such as GMail conversation, Maps place) */
  const MSG_UNNAMED = goog.getMsg('Toggle star');
  $output += soy.$$normalizeHtml(MSG_UNNAMED);
  $output += '" aria-checked="' + (checked ? 'true' : 'false') + '"' + (goog.DEBUG && soy.$$getDebugSoyTemplateInfo() ? ' data-debug-soy="jfk.templates.star.main javascript/jfk/star/star.soy:15"' : '') + '></div>';
  return soy.VERY_UNSAFE.ordainSanitizedHtml($output);
};
/**
 * @typedef {{
 *  checked: ?,
 * }}
 */
jfk.templates.star.main.Params;
if (goog.DEBUG) {
  /** @type {string} */
  jfk.templates.star.main.soyTemplateName = 'jfk.templates.star.main';
}

//third_party/javascript/closure/ui/cssnames.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Common CSS class name constants.
 */

goog.provide('goog.ui.INLINE_BLOCK_CLASSNAME');


/**
 * CSS class name for applying the "display: inline-block" property in a
 * cross-browser way.
 * @type {string}
 */
goog.ui.INLINE_BLOCK_CLASSNAME = goog.getCssName('goog-inline-block');

//third_party/javascript/closure/ui/custombuttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A custom button renderer that uses CSS voodoo to render a
 * button-like object with fake rounded corners.
 */

goog.provide('goog.ui.CustomButtonRenderer');

goog.require('goog.a11y.aria.Role');
goog.require('goog.asserts');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.string');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.INLINE_BLOCK_CLASSNAME');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');



/**
 * Custom renderer for {@link goog.ui.Button}s.  Custom buttons can contain
 * almost arbitrary HTML content, will flow like inline elements, but can be
 * styled like block-level elements.
 *
 * @constructor
 * @extends {goog.ui.ButtonRenderer}
 */
goog.ui.CustomButtonRenderer = function() {
  'use strict';
  goog.ui.ButtonRenderer.call(this);
};
goog.inherits(goog.ui.CustomButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.CustomButtonRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.CustomButtonRenderer.CSS_CLASS = goog.getCssName('goog-custom-button');


/**
 * Returns the button's contents wrapped in the following DOM structure:
 *
 *    <div class="goog-inline-block goog-custom-button">
 *      <div class="goog-inline-block goog-custom-button-outer-box">
 *        <div class="goog-inline-block goog-custom-button-inner-box">
 *          Contents...
 *        </div>
 *      </div>
 *    </div>
 *
 * Overrides {@link goog.ui.ButtonRenderer#createDom}.
 * @param {goog.ui.Control} control goog.ui.Button to render.
 * @return {!Element} Root element for the button.
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.createDom = function(control) {
  'use strict';
  var button = /** @type {goog.ui.Button} */ (control);
  var classNames = this.getClassNames(button);
  var buttonElement = button.getDomHelper().createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' + classNames.join(' '),
      this.createButton(button.getContent(), button.getDomHelper()));
  this.setTooltip(buttonElement, /** @type {string}*/ (button.getTooltip()));

  return buttonElement;
};


/**
 * Returns the ARIA role to be applied to custom buttons.
 * @return {goog.a11y.aria.Role|undefined} ARIA role.
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.getAriaRole = function() {
  'use strict';
  return goog.a11y.aria.Role.BUTTON;
};


/**
 * Takes the button's root element and returns the parent element of the
 * button's contents.  Overrides the superclass implementation by taking
 * the nested DIV structure of custom buttons into account.
 * @param {Element} element Root element of the button whose content
 *     element is to be returned.
 * @return {Element} The button's content element (if any).
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return element && element.firstChild &&
      /** @type {Element} */ (element.firstChild.firstChild);
};


/**
 * Takes a text caption or existing DOM structure, and returns the content
 * wrapped in a pseudo-rounded-corner box.  Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-custom-button-outer-box">
 *      <div class="goog-inline-block goog-custom-button-inner-box">
 *        Contents...
 *      </div>
 *    </div>
 *
 * Used by both {@link #createDom} and {@link #decorate}.  To be overridden
 * by subclasses.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to wrap
 *     in a box.
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Pseudo-rounded-corner box containing the content.
 */
goog.ui.CustomButtonRenderer.prototype.createButton = function(content, dom) {
  'use strict';
  return dom.createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
          goog.getCssName(this.getCssClass(), 'outer-box'),
      dom.createDom(
          goog.dom.TagName.DIV,
          goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
              goog.getCssName(this.getCssClass(), 'inner-box'),
          content));
};


/**
 * Returns true if this renderer can decorate the element.  Overrides
 * {@link goog.ui.ButtonRenderer#canDecorate} by returning true if the
 * element is a DIV, false otherwise.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return element.tagName == goog.dom.TagName.DIV;
};


/**
 * Check if the button's element has a box structure.
 * @param {goog.ui.Button} button Button instance whose structure is being
 *     checked.
 * @param {Element} element Element of the button.
 * @return {boolean} Whether the element has a box structure.
 * @protected
 */
goog.ui.CustomButtonRenderer.prototype.hasBoxStructure = function(
    button, element) {
  'use strict';
  var outer = button.getDomHelper().getFirstElementChild(element);
  var outerClassName = goog.getCssName(this.getCssClass(), 'outer-box');
  if (outer && goog.dom.classlist.contains(outer, outerClassName)) {
    var inner = button.getDomHelper().getFirstElementChild(outer);
    var innerClassName = goog.getCssName(this.getCssClass(), 'inner-box');
    if (inner && goog.dom.classlist.contains(inner, innerClassName)) {
      // We have a proper box structure.
      return true;
    }
  }
  return false;
};


/**
 * Takes an existing element and decorates it with the custom button control.
 * Initializes the control's ID, content, tooltip, value, and state based
 * on the ID of the element, its child nodes, and its CSS classes, respectively.
 * Returns the element.  Overrides {@link goog.ui.ButtonRenderer#decorate}.
 * @param {goog.ui.Control} control Button instance to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.decorate = function(control, element) {
  'use strict';
  goog.asserts.assert(element);

  var button = /** @type {goog.ui.Button} */ (control);
  // Trim text nodes in the element's child node list; otherwise madness
  // ensues (i.e. on Gecko, buttons will flicker and shift when moused over).
  goog.ui.CustomButtonRenderer.trimTextNodes_(element, true);
  goog.ui.CustomButtonRenderer.trimTextNodes_(element, false);

  // Create the buttom dom if it has not been created.
  if (!this.hasBoxStructure(button, element)) {
    element.appendChild(
        /** @type {!Node} */ (
            this.createButton(element.childNodes, button.getDomHelper())));
  }

  goog.dom.classlist.addAll(
      element, [goog.ui.INLINE_BLOCK_CLASSNAME, this.getCssClass()]);
  return goog.ui.CustomButtonRenderer.superClass_.decorate.call(
      this, button, element);
};


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.CustomButtonRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.CustomButtonRenderer.CSS_CLASS;
};


/**
 * Takes an element and removes leading or trailing whitespace from the start
 * or the end of its list of child nodes.  The Boolean argument determines
 * whether to trim from the start or the end of the node list.  Empty text
 * nodes are removed, and the first non-empty text node is trimmed from the
 * left or the right as appropriate.  For example,
 *
 *    <div class="goog-inline-block">
 *      #text ""
 *      #text "\n    Hello "
 *      <span>...</span>
 *      #text " World!    \n"
 *      #text ""
 *    </div>
 *
 * becomes
 *
 *    <div class="goog-inline-block">
 *      #text "Hello "
 *      <span>...</span>
 *      #text " World!"
 *    </div>
 *
 * This is essential for Gecko, where leading/trailing whitespace messes with
 * the layout of elements with -moz-inline-box (used in goog-inline-block), and
 * optional but harmless for non-Gecko.
 *
 * @param {Element} element Element whose child node list is to be trimmed.
 * @param {boolean} fromStart Whether to trim from the start or from the end.
 * @private
 */
goog.ui.CustomButtonRenderer.trimTextNodes_ = function(element, fromStart) {
  'use strict';
  if (element) {
    var node = fromStart ? element.firstChild : element.lastChild, next;
    // Tag soup HTML may result in a DOM where siblings have different parents.
    while (node && node.parentNode == element) {
      // Get the next/previous sibling here, since the node may be removed.
      next = fromStart ? node.nextSibling : node.previousSibling;
      if (node.nodeType == goog.dom.NodeType.TEXT) {
        // Found a text node.
        var text = node.nodeValue;
        if (goog.string.trim(text) == '') {
          // Found an empty text node; remove it.
          element.removeChild(node);
        } else {
          // Found a non-empty text node; trim from the start/end, then exit.
          node.nodeValue = fromStart ? goog.string.trimLeft(text) :
                                       goog.string.trimRight(text);
          break;
        }
      } else {
        // Found a non-text node; done.
        break;
      }
      node = next;
    }
  }
};

//third_party/javascript/closure/ui/togglebutton.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A toggle button control.  Extends {@link goog.ui.Button} by
 * providing checkbox-like semantics.
 */

goog.provide('goog.ui.ToggleButton');

goog.require('goog.ui.Button');
goog.require('goog.ui.Component');
goog.require('goog.ui.CustomButtonRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.ui.ButtonRenderer');
goog.requireType('goog.ui.ControlContent');



/**
 * A toggle button, with checkbox-like semantics.  Rendered using
 * {@link goog.ui.CustomButtonRenderer} by default, though any
 * {@link goog.ui.ButtonRenderer} would work.
 *
 * @param {goog.ui.ControlContent} content Text caption or existing DOM
 *     structure to display as the button's caption.
 * @param {goog.ui.ButtonRenderer=} opt_renderer Renderer used to render or
 *     decorate the button; defaults to {@link goog.ui.CustomButtonRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @constructor
 * @extends {goog.ui.Button}
 */
goog.ui.ToggleButton = function(content, opt_renderer, opt_domHelper) {
  'use strict';
  goog.ui.Button.call(
      this, content, opt_renderer || goog.ui.CustomButtonRenderer.getInstance(),
      opt_domHelper);
  this.setSupportedState(goog.ui.Component.State.CHECKED, true);
};
goog.inherits(goog.ui.ToggleButton, goog.ui.Button);


// Register a decorator factory function for goog.ui.ToggleButtons.
goog.ui.registry.setDecoratorByClassName(
    goog.getCssName('goog-toggle-button'), function() {
      'use strict';
      // ToggleButton defaults to using CustomButtonRenderer.
      return new goog.ui.ToggleButton(null);
    });

//javascript/jfk/star/star.js
// Copyright 2011 Google Inc. All Rights Reserved.

/**
 * @fileoverview Star component implementation. The star component is
 * a simple extension over `goog.ui.ToggleButton`.
 *
 * WARNING(chrishenry): This is still in experimental stage.
 *
 * @author chrishenry@google.com (Chris Henry)
 */

goog.provide('jfk.Star');
goog.provide('jfk.StarRenderer');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.singleton');
goog.require('goog.soy');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.Component');
goog.require('goog.ui.ToggleButton');
goog.require('jfk.templates.star');
goog.requireType('goog.dom.DomHelper');



/**
 * Creates a new star component.
 * @unrestricted
 */
jfk.Star = class extends goog.ui.ToggleButton {
  /**
   * @param {goog.ui.ButtonRenderer=} opt_renderer Optional renderer to be
   *     used to render this component; defaults to `jfk.StarRenderer`.
   * @param {goog.dom.DomHelper=} opt_domHelper Optional DomHelper.
   */
  constructor(opt_renderer, opt_domHelper) {
    super('', opt_renderer || jfk.StarRenderer.getInstance(), opt_domHelper);
  }
};

/**
 * Star renderers. Requires {@code //javascript/jfk/gss/star.gss}.
 * @unrestricted
 */
jfk.StarRenderer = class extends goog.ui.ButtonRenderer {
  constructor() {
    super();
  }

  /** @override */
  getCssClass() {
    return goog.getCssName('jfk-star');
  }

  /** @override */
  createDom(star) {
    return goog.soy.renderAsElement(
        jfk.templates.star.main, {checked: star.isChecked()}, undefined,
        star.getDomHelper());
  }

  /** @override */
  getAriaRole() {
    return goog.a11y.aria.Role.CHECKBOX;
  }

  /** @override */
  updateAriaState(element, state, enable) {
    if (state == goog.ui.Component.State.CHECKED) {
      goog.asserts.assert(element, 'The button DOM element cannot be null.');
      goog.a11y.aria.setState(element, goog.a11y.aria.State.CHECKED, enable);
    } else {
      super.updateAriaState(element, state, enable);
    }
  }

  /**
   * @return {!jfk.StarRenderer}
   * @nocollapse
   */
  static getInstance() {
    return goog.singleton.getInstance(jfk.StarRenderer);
  }
};

//javascript/angular/components/checkbox/star_directive.js
'use strict';
goog.provide('ng.g.star.directive');

goog.require('goog.ui.Component');
goog.require('jfk.Star');
goog.require('ng.g.ToggleDirective');
goog.require('ng.g.toggle.directive');



/** @type {!ng.g.ToggleDirective} */
ng.g.star.directive = ng.g.toggle.directive(
    jfk.Star, goog.ui.Component.EventType.ACTION);

//javascript/angular/jfkwrappers/checkbox/checkbox.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Angular directive "jfk-checkbox". Apply to any vanilla HTML
 * checkbox to give it Kennedy style and behavior.
 * <p>
 * Example:<br>
 * <code><pre>
 *   &lt;input type=checkbox jfk-checkbox ng-model="foo.bar.enabled"
 *       id="checkbox1"&gt;
 *   &lt;label for="checkbox1"&gt;Dear {{name}}, do you consent?&lt;/label&gt;
 * </pre></code>
 * End example.
 * @requirecss {ng.jfk.checkbox}
 */
goog.module('ng.jfk.Checkbox');
goog.module.declareLegacyNamespace();

const Common = goog.require('ng.jfk.Common');
const directive = goog.require('ng.g.checkbox.directive');
const slideToggleDirective = goog.require('ng.g.slideToggle.directive');
const starDirective = goog.require('ng.g.star.directive');

/** @type {!angular.Module} */
const Checkbox = angular.module('jfkCheckbox', [Common.name]);

Checkbox.directive('jfkCheckbox', ['$parse', 'jfkCommon', directive]);

Checkbox.directive(
    'jfkSlideToggle', ['$parse', 'jfkCommon', slideToggleDirective]);

Checkbox.directive('jfkStar', ['$parse', 'jfkCommon', starDirective]);

exports = Checkbox;

;return exports;});

//third_party/javascript/closure/ui/labelinput.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview This behavior is applied to a text input and it shows a text
 * message inside the element if the user hasn't entered any text.
 *
 * This uses the HTML5 placeholder attribute where it is supported.
 *
 * This is ported from http://go/labelinput.js
 *
 * Known issue: Safari does not allow you get to the window object from a
 * document. We need that to listen to the onload event. For now we hard code
 * the window to the current window.
 *
 * Known issue: We need to listen to the form submit event but we attach the
 * event only once (when created or when it is changed) so if you move the DOM
 * node to another form it will not be cleared correctly before submitting.
 *
 * @see ../demos/labelinput.html
 */

goog.provide('goog.ui.LabelInput');

goog.require('goog.Timer');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.InputType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.events.EventHandler');
goog.require('goog.events.EventType');
goog.require('goog.ui.Component');
goog.require('goog.userAgent');
goog.requireType('goog.events.BrowserEvent');
goog.requireType('goog.events.Event');



/**
 * This creates the label input object.
 * @param {string=} opt_label The text to show as the label.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 * @extends {goog.ui.Component}
 * @constructor
 */
goog.ui.LabelInput = function(opt_label, opt_domHelper) {
  'use strict';
  goog.ui.Component.call(this, opt_domHelper);

  /**
   * The text to show as the label.
   * @type {string}
   * @private
   */
  this.label_ = opt_label || '';
};
goog.inherits(goog.ui.LabelInput, goog.ui.Component);


/**
 * Variable used to store the element value on keydown and restore it on
 * keypress.  See {@link #handleEscapeKeys_}
 * @type {?string}
 * @private
 */
goog.ui.LabelInput.prototype.ffKeyRestoreValue_ = null;


/**
 * The label restore delay after leaving the input.
 * @type {number} Delay for restoring the label.
 * @protected
 */
goog.ui.LabelInput.prototype.labelRestoreDelayMs = 10;


/** @private {boolean} */
goog.ui.LabelInput.prototype.inFocusAndSelect_;


/** @private {boolean} */
goog.ui.LabelInput.prototype.formAttached_;


/**
 * Indicates whether the browser supports the placeholder attribute, new in
 * HTML5.
 * @type {?boolean}
 * @private
 */
goog.ui.LabelInput.supportsPlaceholder_;


/**
 * Checks browser support for placeholder attribute.
 * @return {boolean} Whether placeholder attribute is supported.
 * @private
 */
goog.ui.LabelInput.isPlaceholderSupported_ = function() {
  'use strict';
  if (goog.ui.LabelInput.supportsPlaceholder_ == null) {
    goog.ui.LabelInput.supportsPlaceholder_ =
        ('placeholder' in goog.dom.createElement(goog.dom.TagName.INPUT));
  }
  return goog.ui.LabelInput.supportsPlaceholder_;
};


/**
 * @type {goog.events.EventHandler}
 * @private
 */
goog.ui.LabelInput.prototype.eventHandler_;


/**
 * @type {boolean}
 * @private
 */
goog.ui.LabelInput.prototype.hasFocus_ = false;


/**
 * Creates the DOM nodes needed for the label input.
 * @override
 */
goog.ui.LabelInput.prototype.createDom = function() {
  'use strict';
  this.setElementInternal(this.getDomHelper().createDom(
      goog.dom.TagName.INPUT, {'type': goog.dom.InputType.TEXT}));
};


/**
 * Decorates an existing HTML input element as a label input. If the element
 * has a "label" attribute then that will be used as the label property for the
 * label input object.
 * @param {Element} element The HTML input element to decorate.
 * @override
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.decorateInternal = function(element) {
  'use strict';
  goog.ui.LabelInput.superClass_.decorateInternal.call(this, element);
  if (!this.label_) {
    this.label_ = element.getAttribute('label') || '';
  }

  // Check if we're attaching to an element that already has focus.
  if (goog.dom.getActiveElement(goog.dom.getOwnerDocument(element)) ==
      element) {
    this.hasFocus_ = true;
    var el = this.getElement();
    goog.asserts.assert(el);
    goog.dom.classlist.remove(el, this.labelCssClassName);
  }

  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    this.getElement().placeholder = this.label_;
  }
  var labelInputElement = this.getElement();
  goog.asserts.assert(
      labelInputElement, 'The label input element cannot be null.');
  goog.a11y.aria.setState(
      labelInputElement, goog.a11y.aria.State.LABEL, this.label_);
};


/**
 * @override
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.enterDocument = function() {
  'use strict';
  goog.ui.LabelInput.superClass_.enterDocument.call(this);
  this.attachEvents_();
  this.check_();

  // Make it easy for other closure widgets to play nicely with inputs using
  // LabelInput:
  this.getElement().labelInput_ = this;
};


/**
 * @override
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.exitDocument = function() {
  'use strict';
  goog.ui.LabelInput.superClass_.exitDocument.call(this);
  this.detachEvents_();

  this.getElement().labelInput_ = null;
};


/**
 * Attaches the events we need to listen to.
 * @private
 */
goog.ui.LabelInput.prototype.attachEvents_ = function() {
  'use strict';
  var eh = new goog.events.EventHandler(this);
  eh.listen(this.getElement(), goog.events.EventType.FOCUS, this.handleFocus_);
  eh.listen(this.getElement(), goog.events.EventType.BLUR, this.handleBlur_);

  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    this.eventHandler_ = eh;
    return;
  }

  if (goog.userAgent.GECKO) {
    eh.listen(
        this.getElement(),
        [
          goog.events.EventType.KEYPRESS, goog.events.EventType.KEYDOWN,
          goog.events.EventType.KEYUP
        ],
        this.handleEscapeKeys_);
  }

  // IE sets defaultValue upon load so we need to test that as well.
  var d = goog.dom.getOwnerDocument(this.getElement());
  var w = goog.dom.getWindow(d);
  eh.listen(w, goog.events.EventType.LOAD, this.handleWindowLoad_);

  this.eventHandler_ = eh;
  this.attachEventsToForm_();
};


/**
 * Adds a listener to the form so that we can clear the input before it is
 * submitted.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.attachEventsToForm_ = function() {
  'use strict';
  // in case we have are in a form we need to make sure the label is not
  // submitted
  if (!this.formAttached_ && this.eventHandler_ && this.getElement().form) {
    this.eventHandler_.listen(
        this.getElement().form, goog.events.EventType.SUBMIT,
        this.handleFormSubmit_);
    this.formAttached_ = true;
  }
};


/**
 * Stops listening to the events.
 * @private
 */
goog.ui.LabelInput.prototype.detachEvents_ = function() {
  'use strict';
  if (this.eventHandler_) {
    this.eventHandler_.dispose();
    this.eventHandler_ = null;
  }
};


/** @override */
goog.ui.LabelInput.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.LabelInput.superClass_.disposeInternal.call(this);
  this.detachEvents_();
};


/**
 * The CSS class name to add to the input when the user has not entered a
 * value.
 * @type {string}
 */
goog.ui.LabelInput.prototype.labelCssClassName =
    goog.getCssName('label-input-label');


/**
 * Handler for the focus event.
 * @param {goog.events.Event} e The event object passed in to the event handler.
 * @private
 */
goog.ui.LabelInput.prototype.handleFocus_ = function(e) {
  'use strict';
  this.hasFocus_ = true;
  var el = this.getElement();
  goog.asserts.assert(el);
  goog.dom.classlist.remove(el, this.labelCssClassName);
  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    return;
  }
  if (!this.hasChanged() && !this.inFocusAndSelect_) {
    var me = this;
    /** @suppress {strictMissingProperties} Part of the go/strict_warnings_migration */
    var clearValue = function() {
      'use strict';
      // Component could be disposed by the time this is called.
      if (me.getElement()) {
        me.getElement().value = '';
      }
    };
    if (goog.userAgent.IE) {
      goog.Timer.callOnce(clearValue, 10);
    } else {
      clearValue();
    }
  }
};


/**
 * Handler for the blur event.
 * @param {goog.events.Event} e The event object passed in to the event handler.
 * @private
 */
goog.ui.LabelInput.prototype.handleBlur_ = function(e) {
  'use strict';
  // We listen to the click event when we enter focusAndSelect mode so we can
  // fake an artificial focus when the user clicks on the input box. However,
  // if the user clicks on something else (and we lose focus), there is no
  // need for an artificial focus event.
  if (!goog.ui.LabelInput.isPlaceholderSupported_()) {
    this.eventHandler_.unlisten(
        this.getElement(), goog.events.EventType.CLICK, this.handleFocus_);
    this.ffKeyRestoreValue_ = null;
  }
  this.hasFocus_ = false;
  this.check_();
};


/**
 * Handler for key events in Firefox.
 *
 * If the escape key is pressed when a text input has not been changed manually
 * since being focused, the text input will revert to its previous value.
 * Firefox does not honor preventDefault for the escape key. The revert happens
 * after the keydown event and before every keypress. We therefore store the
 * element's value on keydown and restore it on keypress. The restore value is
 * nullified on keyup so that {@link #getValue} returns the correct value.
 *
 * IE and Chrome don't have this problem, Opera blurs in the input box
 * completely in a way that preventDefault on the escape key has no effect.
 * @param {goog.events.BrowserEvent} e The event object passed in to
 *     the event handler.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.handleEscapeKeys_ = function(e) {
  'use strict';
  if (e.keyCode == 27) {
    if (e.type == goog.events.EventType.KEYDOWN) {
      this.ffKeyRestoreValue_ = this.getElement().value;
    } else if (e.type == goog.events.EventType.KEYPRESS) {
      this.getElement().value = /** @type {string} */ (this.ffKeyRestoreValue_);
    } else if (e.type == goog.events.EventType.KEYUP) {
      this.ffKeyRestoreValue_ = null;
    }
    e.preventDefault();
  }
};


/**
 * Handler for the submit event of the form element.
 * @param {goog.events.Event} e The event object passed in to the event handler.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.handleFormSubmit_ = function(e) {
  'use strict';
  if (!this.hasChanged()) {
    this.getElement().value = '';
    // allow form to be sent before restoring value
    goog.Timer.callOnce(this.handleAfterSubmit_, 10, this);
  }
};


/**
 * Restore value after submit
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.handleAfterSubmit_ = function() {
  'use strict';
  if (!this.hasChanged()) {
    this.getElement().value = this.label_;
  }
};


/**
 * Handler for the load event the window. This is needed because
 * IE sets defaultValue upon load.
 * @param {Event} e The event object passed in to the event handler.
 * @private
 */
goog.ui.LabelInput.prototype.handleWindowLoad_ = function(e) {
  'use strict';
  this.check_();
};


/**
 * @return {boolean} Whether the control is currently focused on.
 */
goog.ui.LabelInput.prototype.hasFocus = function() {
  'use strict';
  return this.hasFocus_;
};


/**
 * @return {boolean} Whether the value has been changed by the user.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.hasChanged = function() {
  'use strict';
  return !!this.getElement() && this.getElement().value != '' &&
      this.getElement().value != this.label_;
};


/**
 * Clears the value of the input element without resetting the default text.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.clear = function() {
  'use strict';
  this.getElement().value = '';

  // Reset ffKeyRestoreValue_ when non-null
  if (this.ffKeyRestoreValue_ != null) {
    this.ffKeyRestoreValue_ = '';
  }
};


/**
 * Clears the value of the input element and resets the default text.
 */
goog.ui.LabelInput.prototype.reset = function() {
  'use strict';
  if (this.hasChanged()) {
    this.clear();
    this.check_();
  }
};


/**
 * Use this to set the value through script to ensure that the label state is
 * up to date
 * @param {string} s The new value for the input.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.setValue = function(s) {
  'use strict';
  if (this.ffKeyRestoreValue_ != null) {
    this.ffKeyRestoreValue_ = s;
  }
  this.getElement().value = s;
  this.check_();
};


/**
 * Returns the current value of the text box, returning an empty string if the
 * search box is the default value
 * @return {string} The value of the input box.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.getValue = function() {
  'use strict';
  if (this.ffKeyRestoreValue_ != null) {
    // Fix the Firefox from incorrectly reporting the value to calling code
    // that attached the listener to keypress before the labelinput
    return this.ffKeyRestoreValue_;
  }
  return this.hasChanged() ? /** @type {string} */ (this.getElement().value) :
                                                   '';
};


/**
 * Sets the label text as aria-label, and placeholder when supported.
 * @param {string} label The text to show as the label.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.setLabel = function(label) {
  'use strict';
  var labelInputElement = this.getElement();

  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    if (labelInputElement) {
      labelInputElement.placeholder = label;
    }
    this.label_ = label;
  } else if (!this.hasChanged()) {
    // The this.hasChanged() call relies on non-placeholder behavior checking
    // prior to setting this.label_ - it also needs to happen prior to the
    // this.restoreLabel_() call.
    if (labelInputElement) {
      labelInputElement.value = '';
    }
    this.label_ = label;
    this.restoreLabel_();
  }
  // Check if this has been called before DOM structure building
  if (labelInputElement) {
    goog.a11y.aria.setState(
        labelInputElement, goog.a11y.aria.State.LABEL, this.label_);
  }
};


/**
 * @return {string} The text to show as the label.
 */
goog.ui.LabelInput.prototype.getLabel = function() {
  'use strict';
  return this.label_;
};


/**
 * Checks the state of the input element
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.check_ = function() {
  'use strict';
  var labelInputElement = this.getElement();
  goog.asserts.assert(
      labelInputElement, 'The label input element cannot be null.');
  if (!goog.ui.LabelInput.isPlaceholderSupported_()) {
    // if we haven't got a form yet try now
    this.attachEventsToForm_();
  } else if (this.getElement().placeholder != this.label_) {
    this.getElement().placeholder = this.label_;
  }
  goog.a11y.aria.setState(
      labelInputElement, goog.a11y.aria.State.LABEL, this.label_);

  if (!this.hasChanged()) {
    if (!this.inFocusAndSelect_ && !this.hasFocus_) {
      var el = this.getElement();
      goog.asserts.assert(el);
      goog.dom.classlist.add(el, this.labelCssClassName);
    }

    // Allow browser to catchup with CSS changes before restoring the label.
    if (!goog.ui.LabelInput.isPlaceholderSupported_()) {
      goog.Timer.callOnce(this.restoreLabel_, this.labelRestoreDelayMs, this);
    }
  } else {
    var el = this.getElement();
    goog.asserts.assert(el);
    goog.dom.classlist.remove(el, this.labelCssClassName);
  }
};


/**
 * This method focuses the input and selects all the text. If the value hasn't
 * changed it will set the value to the label so that the label text is
 * selected.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.focusAndSelect = function() {
  'use strict';
  // We need to check whether the input has changed before focusing
  var hc = this.hasChanged();
  this.inFocusAndSelect_ = true;
  this.getElement().focus();
  if (!hc && !goog.ui.LabelInput.isPlaceholderSupported_()) {
    this.getElement().value = this.label_;
  }
  this.getElement().select();

  // Since the object now has focus, we won't get a focus event when they
  // click in the input element. The expected behavior when you click on
  // the default text is that it goes away and allows you to type...so we
  // have to fire an artificial focus event when we're in focusAndSelect mode.
  if (goog.ui.LabelInput.isPlaceholderSupported_()) {
    return;
  }
  if (this.eventHandler_) {
    this.eventHandler_.listenOnce(
        this.getElement(), goog.events.EventType.CLICK, this.handleFocus_);
  }

  // set to false in timer to let IE trigger the focus event
  goog.Timer.callOnce(this.focusAndSelect_, 10, this);
};


/**
 * Enables/Disables the label input.
 * @param {boolean} enabled Whether to enable (true) or disable (false) the
 *     label input.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.setEnabled = function(enabled) {
  'use strict';
  this.getElement().disabled = !enabled;
  var el = this.getElement();
  goog.asserts.assert(el);
  goog.dom.classlist.enable(
      el, goog.getCssName(this.labelCssClassName, 'disabled'), !enabled);
};


/**
 * @return {boolean} True if the label input is enabled, false otherwise.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.isEnabled = function() {
  'use strict';
  return !this.getElement().disabled;
};


/**
 * @private
 */
goog.ui.LabelInput.prototype.focusAndSelect_ = function() {
  'use strict';
  this.inFocusAndSelect_ = false;
};


/**
 * Sets the value of the input element to label.
 * @private
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.LabelInput.prototype.restoreLabel_ = function() {
  'use strict';
  // Check again in case something changed since this was scheduled.
  // We check that the element is still there since this is called by a timer
  // and the dispose method may have been called prior to this.
  if (this.getElement() && !this.hasChanged() && !this.hasFocus_) {
    this.getElement().value = this.label_;
  }
};

//javascript/angular/jfkwrappers/input/input.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Angular directive "jfk-input". Behaves like
 * &lt;input type="text"> but with JFK styling and the 'placeholder' attribute
 * emulated on older browsers.
 * <p>
 * Example:<pre>
 *   &lt;input jfk-input placeholder="Foo" ng-model="foo"&gt;
 * </pre>
 * End example.
 */
goog.module('ng.jfk.Input');
goog.module.declareLegacyNamespace();

const Common = goog.require('ng.jfk.Common');
const LabelInput = goog.require('goog.ui.LabelInput');

/**
 * @type {!angular.Module}
 */
const Input = angular.module('jfkInput', [Common.name]);

Input.directive('jfkInput', [
  'jfkCommon',
  function(jfkCommon) {
    return {
      'link': function($scope, $element, $attrs) {
        var element = $element[0];
        if ('INPUT' != element.tagName) {
          throw new Error(
              'jfkInput directive must be on an INPUT tag, not ' +
              element.tagName);
        }
        $element.addClass(goog.getCssName('jfk-textinput'));
        var labelInput = new LabelInput();
        labelInput.decorate(element);
        // The component interferes with the standard placeholder behaviour.
        $attrs.$observe('placeholder', function(text) {
          labelInput.setLabel(text || '');
        });
        jfkCommon.componentLink($scope, $attrs, labelInput);
      }
    };
  }
]);

exports = Input;

;return exports;});

//third_party/javascript/closure/ui/flatbuttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Similar functionality of {@link goog.ui.ButtonRenderer},
 * but uses a <div> element instead of a <button> or <input> element.
 */

goog.provide('goog.ui.FlatButtonRenderer');

goog.require('goog.a11y.aria.Role');
goog.require('goog.asserts');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.ui.Button');
goog.require('goog.ui.ButtonRenderer');
goog.require('goog.ui.INLINE_BLOCK_CLASSNAME');
goog.require('goog.ui.registry');
goog.requireType('goog.ui.Control');



/**
 * Flat renderer for {@link goog.ui.Button}s.  Flat buttons can contain
 * almost arbitrary HTML content, will flow like inline elements, but can be
 * styled like block-level elements.
 * @constructor
 * @extends {goog.ui.ButtonRenderer}
 */
goog.ui.FlatButtonRenderer = function() {
  'use strict';
  goog.ui.ButtonRenderer.call(this);
};
goog.inherits(goog.ui.FlatButtonRenderer, goog.ui.ButtonRenderer);
goog.addSingletonGetter(goog.ui.FlatButtonRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.FlatButtonRenderer.CSS_CLASS = goog.getCssName('goog-flat-button');


/**
 * Returns the control's contents wrapped in a div element, with
 * the renderer's own CSS class and additional state-specific classes applied
 * to it, and the button's disabled attribute set or cleared as needed.
 * Overrides {@link goog.ui.ButtonRenderer#createDom}.
 * @param {goog.ui.Control} button Button to render.
 * @return {!Element} Root element for the button.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.createDom = function(button) {
  'use strict';
  var classNames = this.getClassNames(button);
  var element = button.getDomHelper().createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' + classNames.join(' '),
      button.getContent());
  this.setTooltip(element, button.getTooltip());
  return element;
};


/**
 * Returns the ARIA role to be applied to flat buttons.
 * @return {goog.a11y.aria.Role|undefined} ARIA role.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.getAriaRole = function() {
  'use strict';
  return goog.a11y.aria.Role.BUTTON;
};


/**
 * Returns true if this renderer can decorate the element.  Overrides
 * {@link goog.ui.ButtonRenderer#canDecorate} by returning true if the
 * element is a DIV, false otherwise.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return element.tagName == goog.dom.TagName.DIV;
};


/**
 * Takes an existing element and decorates it with the flat button control.
 * Initializes the control's ID, content, tooltip, value, and state based
 * on the ID of the element, its child nodes, and its CSS classes, respectively.
 * Returns the element.  Overrides {@link goog.ui.ButtonRenderer#decorate}.
 * @param {goog.ui.Control} button Button instance to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.decorate = function(button, element) {
  'use strict';
  goog.asserts.assert(element);
  goog.dom.classlist.add(element, goog.ui.INLINE_BLOCK_CLASSNAME);
  return goog.ui.FlatButtonRenderer.superClass_.decorate.call(
      this, button, element);
};


/**
 * Flat buttons can't use the value attribute since they are div elements.
 * Overrides {@link goog.ui.ButtonRenderer#getValue} to prevent trying to
 * access the element's value.
 * @param {Element} element The button control's root element.
 * @return {string} Value not valid for flat buttons.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.getValue = function(element) {
  'use strict';
  // Flat buttons don't store their value in the DOM.
  return '';
};


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.FlatButtonRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.FlatButtonRenderer.CSS_CLASS;
};


// Register a decorator factory function for Flat Buttons.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.FlatButtonRenderer.CSS_CLASS, function() {
      'use strict';
      // Uses goog.ui.Button, but with FlatButtonRenderer.
      return new goog.ui.Button(null, goog.ui.FlatButtonRenderer.getInstance());
    });

//third_party/javascript/closure/ui/containerrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base class for container renderers.
 */

goog.provide('goog.ui.ContainerRenderer');

goog.forwardDeclare('goog.ui.Container');
goog.forwardDeclare('goog.ui.Container.Orientation');
goog.require('goog.a11y.aria');
goog.require('goog.asserts');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.string');
goog.require('goog.style');
goog.require('goog.ui.registry');
goog.require('goog.userAgent');
goog.requireType('goog.ui.Control');



/**
 * Default renderer for {@link goog.ui.Container}.  Can be used as-is, but
 * subclasses of Container will probably want to use renderers specifically
 * tailored for them by extending this class.
 * @param {string=} opt_ariaRole Optional ARIA role used for the element.
 * @constructor
 */
goog.ui.ContainerRenderer = function(opt_ariaRole) {
  'use strict';
  // By default, the ARIA role is unspecified.
  /** @private {string|undefined} */
  this.ariaRole_ = opt_ariaRole;
};
goog.addSingletonGetter(goog.ui.ContainerRenderer);


/**
 * Constructs a new renderer and sets the CSS class that the renderer will use
 * as the base CSS class to apply to all elements rendered by that renderer.
 * An example to use this function using a menu is:
 *
 * <pre>
 * var myCustomRenderer = goog.ui.ContainerRenderer.getCustomRenderer(
 *     goog.ui.MenuRenderer, 'my-special-menu');
 * var newMenu = new goog.ui.Menu(opt_domHelper, myCustomRenderer);
 * </pre>
 *
 * Your styles for the menu can now be:
 * <pre>
 * .my-special-menu { }
 * </pre>
 *
 * <em>instead</em> of
 * <pre>
 * .CSS_MY_SPECIAL_MENU .goog-menu { }
 * </pre>
 *
 * You would want to use this functionality when you want an instance of a
 * component to have specific styles different than the other components of the
 * same type in your application.  This avoids using descendant selectors to
 * apply the specific styles to this component.
 *
 * @param {Function} ctor The constructor of the renderer you want to create.
 * @param {string} cssClassName The name of the CSS class for this renderer.
 * @return {goog.ui.ContainerRenderer} An instance of the desired renderer with
 *     its getCssClass() method overridden to return the supplied custom CSS
 *     class name.
 */
goog.ui.ContainerRenderer.getCustomRenderer = function(ctor, cssClassName) {
  'use strict';
  var renderer = new ctor();

  /**
   * Returns the CSS class to be applied to the root element of components
   * rendered using this renderer.
   * @return {string} Renderer-specific CSS class.
   */
  renderer.getCssClass = function() {
    'use strict';
    return cssClassName;
  };

  return renderer;
};


/**
 * Default CSS class to be applied to the root element of containers rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.ContainerRenderer.CSS_CLASS = goog.getCssName('goog-container');


/**
 * Returns the ARIA role to be applied to the container.
 * See http://wiki/Main/ARIA for more info.
 * @return {undefined|string} ARIA role.
 */
goog.ui.ContainerRenderer.prototype.getAriaRole = function() {
  'use strict';
  return this.ariaRole_;
};


/**
 * Enables or disables the tab index of the element.  Only elements with a
 * valid tab index can receive focus.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to add or remove the element's tab index.
 */
goog.ui.ContainerRenderer.prototype.enableTabIndex = function(element, enable) {
  'use strict';
  if (element) {
    element.tabIndex = enable ? 0 : -1;
  }
};


/**
 * Creates and returns the container's root element.  The default
 * simply creates a DIV and applies the renderer's own CSS class name to it.
 * To be overridden in subclasses.
 * @param {goog.ui.Container} container Container to render.
 * @return {Element} Root element for the container.
 */
goog.ui.ContainerRenderer.prototype.createDom = function(container) {
  'use strict';
  return container.getDomHelper().createDom(
      goog.dom.TagName.DIV, this.getClassNames(container).join(' '));
};


/**
 * Returns the DOM element into which child components are to be rendered,
 * or null if the container hasn't been rendered yet.
 * @param {Element} element Root element of the container whose content element
 *     is to be returned.
 * @return {Element} Element to contain child elements (null if none).
 */
goog.ui.ContainerRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return element;
};


/**
 * Default implementation of `canDecorate`; returns true if the element
 * is a DIV, false otherwise.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 */
goog.ui.ContainerRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return element.tagName == 'DIV';
};


/**
 * Default implementation of `decorate` for {@link goog.ui.Container}s.
 * Decorates the element with the container, and attempts to decorate its child
 * elements.  Returns the decorated element.
 * @param {goog.ui.Container} container Container to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {!Element} Decorated element.
 */
goog.ui.ContainerRenderer.prototype.decorate = function(container, element) {
  'use strict';
  // Set the container's ID to the decorated element's DOM ID, if any.
  if (element.id) {
    container.setId(element.id);
  }

  // Configure the container's state based on the CSS class names it has.
  var baseClass = this.getCssClass();
  var hasBaseClass = false;
  var classNames = goog.dom.classlist.get(element);
  if (classNames) {
    Array.prototype.forEach.call(classNames, function(className) {
      'use strict';
      if (className == baseClass) {
        hasBaseClass = true;
      } else {
        if (className) {
          this.setStateFromClassName(container, className, baseClass);
        }
      }
    }, this);
  }

  if (!hasBaseClass) {
    // Make sure the container's root element has the renderer's own CSS class.
    goog.dom.classlist.add(element, baseClass);
  }

  // Decorate the element's children, if applicable.  This should happen after
  // the container's own state has been initialized, since how children are
  // decorated may depend on the state of the container.
  this.decorateChildren(container, this.getContentElement(element));

  return element;
};


/**
 * Sets the container's state based on the given CSS class name, encountered
 * during decoration.  CSS class names that don't represent container states
 * are ignored.  Considered protected; subclasses should override this method
 * to support more states and CSS class names.
 * @param {goog.ui.Container} container Container to update.
 * @param {string} className CSS class name.
 * @param {string} baseClass Base class name used as the root of state-specific
 *     class names (typically the renderer's own class name).
 * @protected
 * @suppress {missingRequire} goog.ui.Container
 */
goog.ui.ContainerRenderer.prototype.setStateFromClassName = function(
    container, className, baseClass) {
  'use strict';
  if (className == goog.getCssName(baseClass, 'disabled')) {
    container.setEnabled(false);
  } else if (className == goog.getCssName(baseClass, 'horizontal')) {
    container.setOrientation(goog.ui.Container.Orientation.HORIZONTAL);
  } else if (className == goog.getCssName(baseClass, 'vertical')) {
    container.setOrientation(goog.ui.Container.Orientation.VERTICAL);
  }
};


/**
 * Takes a container and an element that may contain child elements, decorates
 * the child elements, and adds the corresponding components to the container
 * as child components.  Any non-element child nodes (e.g. empty text nodes
 * introduced by line breaks in the HTML source) are removed from the element.
 * @param {goog.ui.Container} container Container whose children are to be
 *     discovered.
 * @param {Element} element Element whose children are to be decorated.
 * @param {Element=} opt_firstChild the first child to be decorated.
 */
goog.ui.ContainerRenderer.prototype.decorateChildren = function(
    container, element, opt_firstChild) {
  'use strict';
  if (element) {
    var node = opt_firstChild || element.firstChild, next;
    // Tag soup HTML may result in a DOM where siblings have different parents.
    while (node && node.parentNode == element) {
      // Get the next sibling here, since the node may be replaced or removed.
      next = node.nextSibling;
      if (node.nodeType == goog.dom.NodeType.ELEMENT) {
        // Decorate element node.
        var child = this.getDecoratorForChild(/** @type {!Element} */ (node));
        if (child) {
          // addChild() may need to look at the element.
          child.setElementInternal(/** @type {!Element} */ (node));
          // If the container is disabled, mark the child disabled too.  See
          // bug 1263729.  Note that this must precede the call to addChild().
          if (!container.isEnabled()) {
            child.setEnabled(false);
          }
          container.addChild(child);
          child.decorate(/** @type {!Element} */ (node));
        }
      } else if (!node.nodeValue || goog.string.trim(node.nodeValue) == '') {
        // Remove empty text node, otherwise madness ensues (e.g. controls that
        // use goog-inline-block will flicker and shift on hover on Gecko).
        element.removeChild(node);
      }
      node = next;
    }
  }
};


/**
 * Inspects the element, and creates an instance of {@link goog.ui.Control} or
 * an appropriate subclass best suited to decorate it.  Returns the control (or
 * null if no suitable class was found).  This default implementation uses the
 * element's CSS class to find the appropriate control class to instantiate.
 * May be overridden in subclasses.
 * @param {Element} element Element to decorate.
 * @return {goog.ui.Control?} A new control suitable to decorate the element
 *     (null if none).
 */
goog.ui.ContainerRenderer.prototype.getDecoratorForChild = function(element) {
  'use strict';
  return /** @type {goog.ui.Control} */ (
      goog.ui.registry.getDecorator(element));
};


/**
 * Initializes the container's DOM when the container enters the document.
 * Called from {@link goog.ui.Container#enterDocument}.
 * @param {goog.ui.Container} container Container whose DOM is to be initialized
 *     as it enters the document.
 */
goog.ui.ContainerRenderer.prototype.initializeDom = function(container) {
  'use strict';
  var elem = container.getElement();
  goog.asserts.assert(elem, 'The container DOM element cannot be null.');
  // Make sure the container's element isn't selectable.  On Gecko, recursively
  // marking each child element unselectable is expensive and unnecessary, so
  // only mark the root element unselectable.
  goog.style.setUnselectable(elem, true, goog.userAgent.GECKO);

  // IE doesn't support outline:none, so we have to use the hideFocus property.
  if (goog.userAgent.IE) {
    elem.hideFocus = true;
  }

  // Set the ARIA role.
  var ariaRole = this.getAriaRole();
  if (ariaRole) {
    goog.a11y.aria.setRole(elem, ariaRole);
  }
};


/**
 * Returns the element within the container's DOM that should receive keyboard
 * focus (null if none).  The default implementation returns the container's
 * root element.
 * @param {goog.ui.Container} container Container whose key event target is
 *     to be returned.
 * @return {Element} Key event target (null if none).
 */
goog.ui.ContainerRenderer.prototype.getKeyEventTarget = function(container) {
  'use strict';
  return container.getElement();
};


/**
 * Returns the CSS class to be applied to the root element of containers
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 */
goog.ui.ContainerRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.ContainerRenderer.CSS_CLASS;
};


/**
 * Returns all CSS class names applicable to the given container, based on its
 * state.  The array of class names returned includes the renderer's own CSS
 * class, followed by a CSS class indicating the container's orientation,
 * followed by any state-specific CSS classes.
 * @param {goog.ui.Container} container Container whose CSS classes are to be
 *     returned.
 * @return {!Array<string>} Array of CSS class names applicable to the
 *     container.
 */
goog.ui.ContainerRenderer.prototype.getClassNames = function(container) {
  'use strict';
  var baseClass = this.getCssClass();
  var isHorizontal =
      container.getOrientation() == goog.ui.Container.Orientation.HORIZONTAL;
  var classNames = [
    baseClass, (isHorizontal ? goog.getCssName(baseClass, 'horizontal') :
                               goog.getCssName(baseClass, 'vertical'))
  ];
  if (!container.isEnabled()) {
    classNames.push(goog.getCssName(baseClass, 'disabled'));
  }
  return classNames;
};


/**
 * Returns the default orientation of containers rendered or decorated by this
 * renderer.  The base class implementation returns `VERTICAL`.
 * @return {goog.ui.Container.Orientation} Default orientation for containers
 *     created or decorated by this renderer.
 * @suppress {missingRequire} goog.ui.Container
 */
goog.ui.ContainerRenderer.prototype.getDefaultOrientation = function() {
  'use strict';
  return goog.ui.Container.Orientation.VERTICAL;
};

//third_party/javascript/closure/ui/container.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Base class for containers that host {@link goog.ui.Control}s,
 * such as menus and toolbars.  Provides default keyboard and mouse event
 * handling and child management, based on a generalized version of
 * {@link goog.ui.Menu}.
 *
 * @see ../demos/container.html
 */
// TODO(attila):  Fix code/logic duplication between this and goog.ui.Control.
// TODO(attila):  Maybe pull common stuff all the way up into Component...?

goog.provide('goog.ui.Container');
goog.provide('goog.ui.Container.EventType');
goog.provide('goog.ui.Container.Orientation');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyHandler');
goog.require('goog.object');
goog.require('goog.style');
goog.require('goog.ui.Component');
goog.require('goog.ui.ComponentUtil');
goog.require('goog.ui.ContainerRenderer');
goog.require('goog.ui.Control');
goog.requireType('goog.events.BrowserEvent');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.KeyEvent');



/**
 * Base class for containers.  Extends {@link goog.ui.Component} by adding
 * the following:
 *  <ul>
 *    <li>a {@link goog.events.KeyHandler}, to simplify keyboard handling,
 *    <li>a pluggable <em>renderer</em> framework, to simplify the creation of
 *        containers without the need to subclass this class,
 *    <li>methods to manage child controls hosted in the container,
 *    <li>default mouse and keyboard event handling methods.
 *  </ul>
 * @param {?goog.ui.Container.Orientation=} opt_orientation Container
 *     orientation; defaults to `VERTICAL`.
 * @param {goog.ui.ContainerRenderer=} opt_renderer Renderer used to render or
 *     decorate the container; defaults to {@link goog.ui.ContainerRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper DOM helper, used for document
 *     interaction.
 * @extends {goog.ui.Component}
 * @constructor
 */
goog.ui.Container = function(opt_orientation, opt_renderer, opt_domHelper) {
  'use strict';
  goog.ui.Component.call(this, opt_domHelper);
  this.renderer_ = opt_renderer || goog.ui.ContainerRenderer.getInstance();
  this.orientation_ = opt_orientation || this.renderer_.getDefaultOrientation();
};
goog.inherits(goog.ui.Container, goog.ui.Component);


/**
 * Container-specific events.
 * @enum {string}
 */
goog.ui.Container.EventType = {
  /**
   * Dispatched after a goog.ui.Container becomes visible. Non-cancellable.
   * NOTE(bloom): This event really shouldn't exist, because the
   * goog.ui.Component.EventType.SHOW event should behave like this one. But the
   * SHOW event for containers has been behaving as other components'
   * BEFORE_SHOW event for a long time, and too much code relies on that old
   * behavior to fix it now.
   */
  AFTER_SHOW: 'aftershow',

  /**
   * Dispatched after a goog.ui.Container becomes invisible. Non-cancellable.
   */
  AFTER_HIDE: 'afterhide'
};


/**
 * Container orientation constants.
 * @enum {string}
 */
goog.ui.Container.Orientation = {
  HORIZONTAL: 'horizontal',
  VERTICAL: 'vertical'
};


/**
 * Allows an alternative element to be set to receive key events, otherwise
 * defers to the renderer's element choice.
 * @type {?Element|undefined}
 * @private
 */
goog.ui.Container.prototype.keyEventTarget_ = null;


/**
 * Keyboard event handler.
 * @type {goog.events.KeyHandler?}
 * @private
 */
goog.ui.Container.prototype.keyHandler_ = null;


/**
 * Renderer for the container.  Defaults to {@link goog.ui.ContainerRenderer}.
 * @type {goog.ui.ContainerRenderer?}
 * @private
 */
goog.ui.Container.prototype.renderer_ = null;


/**
 * Container orientation; determines layout and default keyboard navigation.
 * @type {?goog.ui.Container.Orientation}
 * @private
 */
goog.ui.Container.prototype.orientation_ = null;


/**
 * Whether the container is set to be visible.  Defaults to true.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.visible_ = true;


/**
 * Whether the container is enabled and reacting to keyboard and mouse events.
 * Defaults to true.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.enabled_ = true;


/**
 * Whether the container supports keyboard focus.  Defaults to true.  Focusable
 * containers have a `tabIndex` and can be navigated to via the keyboard.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.focusable_ = true;


/**
 * The 0-based index of the currently highlighted control in the container
 * (-1 if none).
 * @type {number}
 * @private
 */
goog.ui.Container.prototype.highlightedIndex_ = -1;


/**
 * The currently open (expanded) control in the container (null if none).
 * @type {goog.ui.Control?}
 * @private
 */
goog.ui.Container.prototype.openItem_ = null;


/**
 * Whether the mouse button is held down.  Defaults to false.  This flag is set
 * when the user mouses down over the container, and remains set until they
 * release the mouse button.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.mouseButtonPressed_ = false;


/**
 * Whether focus of child components should be allowed.  Only effective if
 * focusable_ is set to false.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.allowFocusableChildren_ = false;


/**
 * Whether highlighting a child component should also open it.
 * @type {boolean}
 * @private
 */
goog.ui.Container.prototype.openFollowsHighlight_ = true;


/**
 * Map of DOM IDs to child controls.  Each key is the DOM ID of a child
 * control's root element; each value is a reference to the child control
 * itself.  Used for looking up the child control corresponding to a DOM
 * node in O(1) time.
 * @type {?Object}
 * @private
 */
goog.ui.Container.prototype.childElementIdMap_ = null;


// Event handler and renderer management.


/**
 * Returns the DOM element on which the container is listening for keyboard
 * events (null if none).
 * @return {Element} Element on which the container is listening for key
 *     events.
 */
goog.ui.Container.prototype.getKeyEventTarget = function() {
  'use strict';
  // Delegate to renderer, unless we've set an explicit target.
  return this.keyEventTarget_ || this.renderer_.getKeyEventTarget(this);
};


/**
 * Attaches an element on which to listen for key events.
 * @param {Element|undefined} element The element to attach, or null/undefined
 *     to attach to the default element.
 */
goog.ui.Container.prototype.setKeyEventTarget = function(element) {
  'use strict';
  if (this.focusable_) {
    var oldTarget = this.getKeyEventTarget();
    var inDocument = this.isInDocument();

    this.keyEventTarget_ = element;
    var newTarget = this.getKeyEventTarget();

    if (inDocument) {
      // Unlisten for events on the old key target.  Requires us to reset
      // key target state temporarily.
      this.keyEventTarget_ = oldTarget;
      this.enableFocusHandling_(false);
      this.keyEventTarget_ = element;

      // Listen for events on the new key target.
      this.getKeyHandler().attach(newTarget);
      this.enableFocusHandling_(true);
    }
  } else {
    throw new Error(
        'Can\'t set key event target for container ' +
        'that doesn\'t support keyboard focus!');
  }
};


/**
 * Returns the keyboard event handler for this container, lazily created the
 * first time this method is called.  The keyboard event handler listens for
 * keyboard events on the container's key event target, as determined by its
 * renderer.
 * @return {!goog.events.KeyHandler} Keyboard event handler for this container.
 */
goog.ui.Container.prototype.getKeyHandler = function() {
  'use strict';
  return this.keyHandler_ ||
      (this.keyHandler_ = new goog.events.KeyHandler(this.getKeyEventTarget()));
};


/**
 * Returns the renderer used by this container to render itself or to decorate
 * an existing element.
 * @return {goog.ui.ContainerRenderer} Renderer used by the container.
 */
goog.ui.Container.prototype.getRenderer = function() {
  'use strict';
  return this.renderer_;
};


/**
 * Registers the given renderer with the container.  Changing renderers after
 * the container has already been rendered or decorated is an error.
 * @param {goog.ui.ContainerRenderer} renderer Renderer used by the container.
 */
goog.ui.Container.prototype.setRenderer = function(renderer) {
  'use strict';
  if (this.getElement()) {
    // Too late.
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  this.renderer_ = renderer;
};


// Standard goog.ui.Component implementation.


/**
 * Creates the container's DOM.
 * @override
 */
goog.ui.Container.prototype.createDom = function() {
  'use strict';
  // Delegate to renderer.
  this.setElementInternal(this.renderer_.createDom(this));
};


/**
 * Returns the DOM element into which child components are to be rendered,
 * or null if the container itself hasn't been rendered yet.  Overrides
 * {@link goog.ui.Component#getContentElement} by delegating to the renderer.
 * @return {Element} Element to contain child elements (null if none).
 * @override
 */
goog.ui.Container.prototype.getContentElement = function() {
  'use strict';
  // Delegate to renderer.
  return this.renderer_.getContentElement(this.getElement());
};


/**
 * Returns true if the given element can be decorated by this container.
 * Overrides {@link goog.ui.Component#canDecorate}.
 * @param {Element} element Element to decorate.
 * @return {boolean} True iff the element can be decorated.
 * @override
 */
goog.ui.Container.prototype.canDecorate = function(element) {
  'use strict';
  // Delegate to renderer.
  return this.renderer_.canDecorate(element);
};


/**
 * Decorates the given element with this container. Overrides {@link
 * goog.ui.Component#decorateInternal}.  Considered protected.
 * @param {Element} element Element to decorate.
 * @override
 */
goog.ui.Container.prototype.decorateInternal = function(element) {
  'use strict';
  // Delegate to renderer.
  this.setElementInternal(this.renderer_.decorate(this, element));
  // Check whether the decorated element is explicitly styled to be invisible.
  if (element.style.display == 'none') {
    this.visible_ = false;
  }
};


/**
 * Configures the container after its DOM has been rendered, and sets up event
 * handling.  Overrides {@link goog.ui.Component#enterDocument}.
 * @override
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.Container.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Container.superClass_.enterDocument.call(this);

  this.forEachChild(function(child) {
    'use strict';
    if (child.isInDocument()) {
      this.registerChildId_(child);
    }
  }, this);

  var elem = this.getElement();

  // Call the renderer's initializeDom method to initialize the container's DOM.
  this.renderer_.initializeDom(this);

  // Initialize visibility (opt_force = true, so we don't dispatch events).
  this.setVisible(this.visible_, true);

  var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);

  // Handle events dispatched by child controls.
  this.getHandler()
      .listen(this, goog.ui.Component.EventType.ENTER, this.handleEnterItem)
      .listen(
          this, goog.ui.Component.EventType.HIGHLIGHT, this.handleHighlightItem)
      .listen(
          this, goog.ui.Component.EventType.UNHIGHLIGHT,
          this.handleUnHighlightItem)
      .listen(this, goog.ui.Component.EventType.OPEN, this.handleOpenItem)
      .listen(this, goog.ui.Component.EventType.CLOSE, this.handleCloseItem)

      // Handle mouse events.
      .listen(elem, MouseEventType.MOUSEDOWN, this.handleMouseDown)
      .listen(
          goog.dom.getOwnerDocument(elem),
          [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL],
          this.handleDocumentMouseUp)

      // Handle mouse events on behalf of controls in the container.
      .listen(
          elem,
          [
            MouseEventType.MOUSEDOWN, MouseEventType.MOUSEUP,
            MouseEventType.MOUSECANCEL, goog.events.EventType.MOUSEOVER,
            goog.events.EventType.MOUSEOUT, goog.events.EventType.CONTEXTMENU
          ],
          this.handleChildMouseEvents);

  if (this.pointerEventsEnabled()) {
    // Prevent pointer events from capturing the target element so they behave
    // more like mouse events.
    this.getHandler().listen(
        elem, goog.events.EventType.GOTPOINTERCAPTURE,
        this.preventPointerCapture_);
  }

  // If the container is focusable, set up keyboard event handling.
  if (this.isFocusable()) {
    this.enableFocusHandling_(true);
  }
};


/**
 * @param {!goog.events.BrowserEvent} e Event to handle.
 * @private
 */
goog.ui.Container.prototype.preventPointerCapture_ = function(e) {
  'use strict';
  var elem = /** @type {!Element} */ (e.target);
  if (!!elem.releasePointerCapture) {
    elem.releasePointerCapture(e.pointerId);
  }
};


/**
 * Sets up listening for events applicable to focusable containers.
 * @param {boolean} enable Whether to enable or disable focus handling.
 * @private
 */
goog.ui.Container.prototype.enableFocusHandling_ = function(enable) {
  'use strict';
  var handler = this.getHandler();
  var keyTarget = this.getKeyEventTarget();
  if (enable) {
    handler.listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus)
        .listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur)
        .listen(
            this.getKeyHandler(), goog.events.KeyHandler.EventType.KEY,
            this.handleKeyEvent);
  } else {
    handler.unlisten(keyTarget, goog.events.EventType.FOCUS, this.handleFocus)
        .unlisten(keyTarget, goog.events.EventType.BLUR, this.handleBlur)
        .unlisten(
            this.getKeyHandler(), goog.events.KeyHandler.EventType.KEY,
            this.handleKeyEvent);
  }
};


/**
 * Cleans up the container before its DOM is removed from the document, and
 * removes event handlers.  Overrides {@link goog.ui.Component#exitDocument}.
 * @override
 */
goog.ui.Container.prototype.exitDocument = function() {
  'use strict';
  // {@link #setHighlightedIndex} has to be called before
  // {@link goog.ui.Component#exitDocument}, otherwise it has no effect.
  this.setHighlightedIndex(-1);

  if (this.openItem_) {
    this.openItem_.setOpen(false);
  }

  this.mouseButtonPressed_ = false;

  goog.ui.Container.superClass_.exitDocument.call(this);
};


/** @override */
goog.ui.Container.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.Container.superClass_.disposeInternal.call(this);

  if (this.keyHandler_) {
    this.keyHandler_.dispose();
    this.keyHandler_ = null;
  }

  this.keyEventTarget_ = null;
  this.childElementIdMap_ = null;
  this.openItem_ = null;
  this.renderer_ = null;
};


// Default event handlers.


/**
 * Handles ENTER events raised by child controls when they are navigated to.
 * @param {goog.events.Event} e ENTER event to handle.
 * @return {boolean} Whether to prevent handleMouseOver from handling
 *    the event.
 */
goog.ui.Container.prototype.handleEnterItem = function(e) {
  'use strict';
  // Allow the Control to highlight itself.
  return true;
};


/**
 * Handles HIGHLIGHT events dispatched by items in the container when
 * they are highlighted.
 * @param {goog.events.Event} e Highlight event to handle.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.Container.prototype.handleHighlightItem = function(e) {
  'use strict';
  var index = this.indexOfChild(/** @type {goog.ui.Control} */ (e.target));
  if (index > -1 && index != this.highlightedIndex_) {
    var item = this.getHighlighted();
    if (item) {
      // Un-highlight previously highlighted item.
      item.setHighlighted(false);
    }

    this.highlightedIndex_ = index;
    item = this.getHighlighted();

    if (this.isMouseButtonPressed()) {
      // Activate item when mouse button is pressed, to allow MacOS-style
      // dragging to choose menu items.  Although this should only truly
      // happen if the highlight is due to mouse movements, there is little
      // harm in doing it for keyboard or programmatic highlights.
      item.setActive(true);
    }

    // Update open item if open item needs follow highlight.
    if (this.openFollowsHighlight_ && this.openItem_ &&
        item != this.openItem_) {
      if (item.isSupportedState(goog.ui.Component.State.OPENED)) {
        item.setOpen(true);
      } else {
        this.openItem_.setOpen(false);
      }
    }
  }

  var element = this.getElement();
  goog.asserts.assert(
      element, 'The DOM element for the container cannot be null.');
  if (e.target.getElement() != null) {
    goog.a11y.aria.setState(
        element, goog.a11y.aria.State.ACTIVEDESCENDANT,
        e.target.getElement().id);
  }
};


/**
 * Handles UNHIGHLIGHT events dispatched by items in the container when
 * they are unhighlighted.
 * @param {goog.events.Event} e Unhighlight event to handle.
 */
goog.ui.Container.prototype.handleUnHighlightItem = function(e) {
  'use strict';
  if (e.target == this.getHighlighted()) {
    this.highlightedIndex_ = -1;
  }
  var element = this.getElement();
  goog.asserts.assert(
      element, 'The DOM element for the container cannot be null.');
  // Setting certain ARIA attributes to empty strings is problematic.
  // Just remove the attribute instead.
  goog.a11y.aria.removeState(element, goog.a11y.aria.State.ACTIVEDESCENDANT);
};


/**
 * Handles OPEN events dispatched by items in the container when they are
 * opened.
 * @param {goog.events.Event} e Open event to handle.
 */
goog.ui.Container.prototype.handleOpenItem = function(e) {
  'use strict';
  var item = /** @type {goog.ui.Control} */ (e.target);
  if (item && item != this.openItem_ && item.getParent() == this) {
    if (this.openItem_) {
      this.openItem_.setOpen(false);
    }
    this.openItem_ = item;
  }
};


/**
 * Handles CLOSE events dispatched by items in the container when they are
 * closed.
 * @param {goog.events.Event} e Close event to handle.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.Container.prototype.handleCloseItem = function(e) {
  'use strict';
  if (e.target == this.openItem_) {
    this.openItem_ = null;
  }

  var element = this.getElement();
  var targetEl = e.target.getElement();
  // Set the active descendant to the menu item when its submenu is closed and
  // it is still highlighted. This can sometimes be called when the menuitem is
  // unhighlighted because the focus moved elsewhere, do nothing at that point.
  if (element && e.target.isHighlighted() && targetEl) {
    goog.a11y.aria.setActiveDescendant(element, targetEl);
  }
};


/**
 * Handles mousedown events over the container.  The default implementation
 * sets the "mouse button pressed" flag and, if the container is focusable,
 * grabs keyboard focus.
 * @param {goog.events.BrowserEvent} e Mousedown event to handle.
 */
goog.ui.Container.prototype.handleMouseDown = function(e) {
  'use strict';
  if (this.enabled_) {
    this.setMouseButtonPressed(true);
  }

  var keyTarget = this.getKeyEventTarget();
  if (keyTarget && goog.dom.isFocusableTabIndex(keyTarget)) {
    // The container is configured to receive keyboard focus.
    keyTarget.focus();
  } else {
    // The control isn't configured to receive keyboard focus; prevent it
    // from stealing focus or destroying the selection.
    e.preventDefault();
  }
};


/**
 * Handles mouseup events over the document.  The default implementation
 * clears the "mouse button pressed" flag.
 * @param {goog.events.BrowserEvent} e Mouseup event to handle.
 */
goog.ui.Container.prototype.handleDocumentMouseUp = function(e) {
  'use strict';
  this.setMouseButtonPressed(false);
};


/**
 * Handles mouse events originating from nodes belonging to the controls hosted
 * in the container.  Locates the child control based on the DOM node that
 * dispatched the event, and forwards the event to the control for handling.
 * @param {goog.events.BrowserEvent} e Mouse event to handle.
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.Container.prototype.handleChildMouseEvents = function(e) {
  'use strict';
  var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);

  var control = this.getOwnerControl(/** @type {Node} */ (e.target));
  if (control) {
    // Child control identified; forward the event.
    switch (e.type) {
      case MouseEventType.MOUSEDOWN:
        control.handleMouseDown(e);
        break;
      case MouseEventType.MOUSEUP:
      case MouseEventType.MOUSECANCEL:
        control.handleMouseUp(e);
        break;
      case goog.events.EventType.MOUSEOVER:
        control.handleMouseOver(e);
        break;
      case goog.events.EventType.MOUSEOUT:
        control.handleMouseOut(e);
        break;
      case goog.events.EventType.CONTEXTMENU:
        control.handleContextMenu(e);
        break;
    }
  }
};


/**
 * Returns the child control that owns the given DOM node, or null if no such
 * control is found.
 * @param {Node} node DOM node whose owner is to be returned.
 * @return {goog.ui.Control?} Control hosted in the container to which the node
 *     belongs (if found).
 * @protected
 * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration
 */
goog.ui.Container.prototype.getOwnerControl = function(node) {
  'use strict';
  // Ensure that this container actually has child controls before
  // looking up the owner.
  if (this.childElementIdMap_) {
    var elem = this.getElement();
    // See http://b/2964418 . IE9 appears to evaluate '!=' incorrectly, so
    // using '!==' instead.
    // TODO(zhyder): Possibly revert this change if/when IE9 fixes the issue.
    while (node && node !== elem) {
      var id = node.id;
      if (id in this.childElementIdMap_) {
        return this.childElementIdMap_[id];
      }
      node = node.parentNode;
    }
  }
  return null;
};


/**
 * Handles focus events raised when the container's key event target receives
 * keyboard focus.
 * @param {goog.events.BrowserEvent} e Focus event to handle.
 */
goog.ui.Container.prototype.handleFocus = function(e) {
  // No-op in the base class.
};


/**
 * Handles blur events raised when the container's key event target loses
 * keyboard focus.  The default implementation clears the highlight index.
 * @param {goog.events.BrowserEvent} e Blur event to handle.
 */
goog.ui.Container.prototype.handleBlur = function(e) {
  'use strict';
  this.setHighlightedIndex(-1);
  this.setMouseButtonPressed(false);
  // If the container loses focus, and one of its children is open, close it.
  if (this.openItem_) {
    this.openItem_.setOpen(false);
  }
};


/**
 * Attempts to handle a keyboard event, if the control is enabled, by calling
 * {@link handleKeyEventInternal}.  Considered protected; should only be used
 * within this package and by subclasses.
 * @param {goog.events.KeyEvent} e Key event to handle.
 * @return {boolean} Whether the key event was handled.
 */
goog.ui.Container.prototype.handleKeyEvent = function(e) {
  'use strict';
  if (this.isEnabled() && this.isVisible() &&
      (this.getChildCount() != 0 || this.keyEventTarget_) &&
      this.handleKeyEventInternal(e)) {
    e.preventDefault();
    e.stopPropagation();
    return true;
  }
  return false;
};


/**
 * Attempts to handle a keyboard event; returns true if the event was handled,
 * false otherwise.  If the container is enabled, and a child is highlighted,
 * calls the child control's `handleKeyEvent` method to give the control
 * a chance to handle the event first.
 * @param {goog.events.KeyEvent} e Key event to handle.
 * @return {boolean} Whether the event was handled by the container (or one of
 *     its children).
 */
goog.ui.Container.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  // Give the highlighted control the chance to handle the key event.
  var highlighted = this.getHighlighted();
  if (highlighted && typeof highlighted.handleKeyEvent == 'function' &&
      highlighted.handleKeyEvent(e)) {
    return true;
  }

  // Give the open control the chance to handle the key event.
  if (this.openItem_ && this.openItem_ != highlighted &&
      typeof this.openItem_.handleKeyEvent == 'function' &&
      this.openItem_.handleKeyEvent(e)) {
    return true;
  }

  // Do not handle the key event if any modifier key is pressed.
  if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) {
    return false;
  }

  // Either nothing is highlighted, or the highlighted control didn't handle
  // the key event, so attempt to handle it here.
  switch (e.keyCode) {
    case goog.events.KeyCodes.ESC:
      if (this.isFocusable()) {
        this.getKeyEventTarget().blur();
      } else {
        return false;
      }
      break;

    case goog.events.KeyCodes.HOME:
      this.highlightFirst();
      break;

    case goog.events.KeyCodes.END:
      this.highlightLast();
      break;

    case goog.events.KeyCodes.UP:
      if (this.orientation_ == goog.ui.Container.Orientation.VERTICAL) {
        this.highlightPrevious();
      } else {
        return false;
      }
      break;

    case goog.events.KeyCodes.LEFT:
      if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL) {
        if (this.isRightToLeft()) {
          this.highlightNext();
        } else {
          this.highlightPrevious();
        }
      } else {
        return false;
      }
      break;

    case goog.events.KeyCodes.DOWN:
      if (this.orientation_ == goog.ui.Container.Orientation.VERTICAL) {
        this.highlightNext();
      } else {
        return false;
      }
      break;

    case goog.events.KeyCodes.RIGHT:
      if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL) {
        if (this.isRightToLeft()) {
          this.highlightPrevious();
        } else {
          this.highlightNext();
        }
      } else {
        return false;
      }
      break;

    default:
      return false;
  }

  return true;
};


// Child component management.


/**
 * Creates a DOM ID for the child control and registers it to an internal
 * hash table to be able to find it fast by id.
 * @param {goog.ui.Component} child The child control. Its root element has
 *     to be created yet.
 * @private
 */
goog.ui.Container.prototype.registerChildId_ = function(child) {
  'use strict';
  // Map the DOM ID of the control's root element to the control itself.
  var childElem = child.getElement();

  // If the control's root element doesn't have a DOM ID assign one.
  var id = childElem.id || (childElem.id = child.getId());

  // Lazily create the child element ID map on first use.
  if (!this.childElementIdMap_) {
    this.childElementIdMap_ = {};
  }
  this.childElementIdMap_[id] = child;
};


/**
 * Adds the specified control as the last child of this container.  See
 * {@link goog.ui.Container#addChildAt} for detailed semantics.
 * @param {goog.ui.Component} child The new child control.
 * @param {boolean=} opt_render Whether the new child should be rendered
 *     immediately after being added (defaults to false).
 * @override
 */
goog.ui.Container.prototype.addChild = function(child, opt_render) {
  'use strict';
  goog.asserts.assertInstanceof(
      child, goog.ui.Control, 'The child of a container must be a control');
  goog.ui.Container.superClass_.addChild.call(this, child, opt_render);
};


/**
 * Overrides {@link goog.ui.Container#getChild} to make it clear that it
 * only returns {@link goog.ui.Control}s.
 * @param {string} id Child component ID.
 * @return {goog.ui.Control} The child with the given ID; null if none.
 * @override
 */
goog.ui.Container.prototype.getChild;


/**
 * Overrides {@link goog.ui.Container#getChildAt} to make it clear that it
 * only returns {@link goog.ui.Control}s.
 * @param {number} index 0-based index.
 * @return {goog.ui.Control} The child with the given ID; null if none.
 * @override
 */
goog.ui.Container.prototype.getChildAt;


/**
 * Adds the control as a child of this container at the given 0-based index.
 * Overrides {@link goog.ui.Component#addChildAt} by also updating the
 * container's highlight index.  Since {@link goog.ui.Component#addChild} uses
 * {@link #addChildAt} internally, we only need to override this method.
 * @param {goog.ui.Component} control New child.
 * @param {number} index Index at which the new child is to be added.
 * @param {boolean=} opt_render Whether the new child should be rendered
 *     immediately after being added (defaults to false).
 * @override
 */
goog.ui.Container.prototype.addChildAt = function(control, index, opt_render) {
  'use strict';
  goog.asserts.assertInstanceof(control, goog.ui.Control);

  // Make sure the child control dispatches HIGHLIGHT, UNHIGHLIGHT, OPEN, and
  // CLOSE events, and that it doesn't steal keyboard focus.
  control.setDispatchTransitionEvents(goog.ui.Component.State.HOVER, true);
  control.setDispatchTransitionEvents(goog.ui.Component.State.OPENED, true);
  if (this.isFocusable() || !this.isFocusableChildrenAllowed()) {
    control.setSupportedState(goog.ui.Component.State.FOCUSED, false);
  }

  // Disable mouse event handling by child controls.
  control.setHandleMouseEvents(false);

  var srcIndex =
      (control.getParent() == this) ? this.indexOfChild(control) : -1;

  // Let the superclass implementation do the work.
  goog.ui.Container.superClass_.addChildAt.call(
      this, control, index, opt_render);

  if (control.isInDocument() && this.isInDocument()) {
    this.registerChildId_(control);
  }

  this.updateHighlightedIndex_(srcIndex, index);
};


/**
 * Updates the highlighted index when children are added or moved.
 * @param {number} fromIndex Index of the child before it was moved, or -1 if
 *     the child was added.
 * @param {number} toIndex Index of the child after it was moved or added.
 * @private
 */
goog.ui.Container.prototype.updateHighlightedIndex_ = function(
    fromIndex, toIndex) {
  'use strict';
  if (fromIndex == -1) {
    fromIndex = this.getChildCount();
  }
  if (fromIndex == this.highlightedIndex_) {
    // The highlighted element itself was moved.
    this.highlightedIndex_ = Math.min(this.getChildCount() - 1, toIndex);
  } else if (
      fromIndex > this.highlightedIndex_ && toIndex <= this.highlightedIndex_) {
    // The control was added or moved behind the highlighted index.
    this.highlightedIndex_++;
  } else if (
      fromIndex < this.highlightedIndex_ && toIndex > this.highlightedIndex_) {
    // The control was moved from before to behind the highlighted index.
    this.highlightedIndex_--;
  }
};


/**
 * Removes a child control.  Overrides {@link goog.ui.Component#removeChild} by
 * updating the highlight index.  Since {@link goog.ui.Component#removeChildAt}
 * uses {@link #removeChild} internally, we only need to override this method.
 * @param {string|goog.ui.Component} control The ID of the child to remove, or
 *     the control itself.
 * @param {boolean=} opt_unrender Whether to call `exitDocument` on the
 *     removed control, and detach its DOM from the document (defaults to
 *     false).
 * @return {?goog.ui.Control} The removed control, if any.
 * @override
 */
goog.ui.Container.prototype.removeChild = function(control, opt_unrender) {
  'use strict';
  control = (typeof control === 'string') ? this.getChild(control) : control;
  goog.asserts.assertInstanceof(control, goog.ui.Control);

  if (control) {
    var index = this.indexOfChild(control);
    if (index != -1) {
      if (index == this.highlightedIndex_) {
        control.setHighlighted(false);
        this.highlightedIndex_ = -1;
      } else if (index < this.highlightedIndex_) {
        this.highlightedIndex_--;
      }
    }

    // Remove the mapping from the child element ID map.
    var childElem = control.getElement();
    if (childElem && childElem.id && this.childElementIdMap_) {
      goog.object.remove(this.childElementIdMap_, childElem.id);
    }
  }

  control = /** @type {!goog.ui.Control} */ (
      goog.ui.Container.superClass_.removeChild.call(
          this, control, opt_unrender));

  // Re-enable mouse event handling (in case the control is reused elsewhere).
  control.setHandleMouseEvents(true);

  return control;
};


// Container state management.


/**
 * Returns the container's orientation.
 * @return {?goog.ui.Container.Orientation} Container orientation.
 */
goog.ui.Container.prototype.getOrientation = function() {
  'use strict';
  return this.orientation_;
};


/**
 * Sets the container's orientation.
 * @param {goog.ui.Container.Orientation} orientation Container orientation.
 */
// TODO(attila): Do we need to support containers with dynamic orientation?
goog.ui.Container.prototype.setOrientation = function(orientation) {
  'use strict';
  if (this.getElement()) {
    // Too late.
    throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
  }

  this.orientation_ = orientation;
};


/**
 * Returns true if the container's visibility is set to visible, false if
 * it is set to hidden.  A container that is set to hidden is guaranteed
 * to be hidden from the user, but the reverse isn't necessarily true.
 * A container may be set to visible but can otherwise be obscured by another
 * element, rendered off-screen, or hidden using direct CSS manipulation.
 * @return {boolean} Whether the container is set to be visible.
 */
goog.ui.Container.prototype.isVisible = function() {
  'use strict';
  return this.visible_;
};


/**
 * Shows or hides the container.  Does nothing if the container already has
 * the requested visibility.  Otherwise, dispatches a SHOW or HIDE event as
 * appropriate, giving listeners a chance to prevent the visibility change.
 * @param {boolean} visible Whether to show or hide the container.
 * @param {boolean=} opt_force If true, doesn't check whether the container
 *     already has the requested visibility, and doesn't dispatch any events.
 * @return {boolean} Whether the visibility was changed.
 */
goog.ui.Container.prototype.setVisible = function(visible, opt_force) {
  'use strict';
  if (opt_force ||
      (this.visible_ != visible &&
       this.dispatchEvent(
           visible ? goog.ui.Component.EventType.SHOW :
                     goog.ui.Component.EventType.HIDE))) {
    this.visible_ = visible;

    var elem = this.getElement();
    if (elem) {
      goog.style.setElementShown(elem, visible);
      if (this.isFocusable()) {
        // Enable keyboard access only for enabled & visible containers.
        this.renderer_.enableTabIndex(
            this.getKeyEventTarget(), this.enabled_ && this.visible_);
      }
      if (!opt_force) {
        this.dispatchEvent(
            this.visible_ ? goog.ui.Container.EventType.AFTER_SHOW :
                            goog.ui.Container.EventType.AFTER_HIDE);
      }
    }

    return true;
  }

  return false;
};


/**
 * Returns true if the container is enabled, false otherwise.
 * @return {boolean} Whether the container is enabled.
 */
goog.ui.Container.prototype.isEnabled = function() {
  'use strict';
  return this.enabled_;
};


/**
 * Enables/disables the container based on the `enable` argument.
 * Dispatches an `ENABLED` or `DISABLED` event prior to changing
 * the container's state, which may be caught and canceled to prevent the
 * container from changing state.  Also enables/disables child controls.
 * @param {boolean} enable Whether to enable or disable the container.
 */
goog.ui.Container.prototype.setEnabled = function(enable) {
  'use strict';
  if (this.enabled_ != enable &&
      this.dispatchEvent(
          enable ? goog.ui.Component.EventType.ENABLE :
                   goog.ui.Component.EventType.DISABLE)) {
    if (enable) {
      // Flag the container as enabled first, then update children.  This is
      // because controls can't be enabled if their parent is disabled.
      this.enabled_ = true;
      this.forEachChild(function(child) {
        'use strict';
        // Enable child control unless it is flagged.
        if (child.wasDisabled) {
          delete child.wasDisabled;
        } else {
          child.setEnabled(true);
        }
      });
    } else {
      // Disable children first, then flag the container as disabled.  This is
      // because controls can't be disabled if their parent is already disabled.
      this.forEachChild(function(child) {
        'use strict';
        // Disable child control, or flag it if it's already disabled.
        if (child.isEnabled()) {
          child.setEnabled(false);
        } else {
          child.wasDisabled = true;
        }
      });
      this.enabled_ = false;
      this.setMouseButtonPressed(false);
    }

    if (this.isFocusable()) {
      // Enable keyboard access only for enabled & visible components.
      this.renderer_.enableTabIndex(
          this.getKeyEventTarget(), enable && this.visible_);
    }
  }
};


/**
 * Returns true if the container is focusable, false otherwise.  The default
 * is true.  Focusable containers always have a tab index and allocate a key
 * handler to handle keyboard events while focused.
 * @return {boolean} Whether the component is focusable.
 */
goog.ui.Container.prototype.isFocusable = function() {
  'use strict';
  return this.focusable_;
};


/**
 * Sets whether the container is focusable.  The default is true.  Focusable
 * containers always have a tab index and allocate a key handler to handle
 * keyboard events while focused.
 * @param {boolean} focusable Whether the component is to be focusable.
 */
goog.ui.Container.prototype.setFocusable = function(focusable) {
  'use strict';
  if (focusable != this.focusable_ && this.isInDocument()) {
    this.enableFocusHandling_(focusable);
  }
  this.focusable_ = focusable;
  if (this.enabled_ && this.visible_) {
    this.renderer_.enableTabIndex(this.getKeyEventTarget(), focusable);
  }
};


/**
 * Returns true if the container allows children to be focusable, false
 * otherwise.  Only effective if the container is not focusable.
 * @return {boolean} Whether children should be focusable.
 */
goog.ui.Container.prototype.isFocusableChildrenAllowed = function() {
  'use strict';
  return this.allowFocusableChildren_;
};


/**
 * Sets whether the container allows children to be focusable, false
 * otherwise.  Only effective if the container is not focusable.
 * @param {boolean} focusable Whether the children should be focusable.
 */
goog.ui.Container.prototype.setFocusableChildrenAllowed = function(focusable) {
  'use strict';
  this.allowFocusableChildren_ = focusable;
};


/**
 * @return {boolean} Whether highlighting a child component should also open it.
 */
goog.ui.Container.prototype.isOpenFollowsHighlight = function() {
  'use strict';
  return this.openFollowsHighlight_;
};


/**
 * Sets whether highlighting a child component should also open it.
 * @param {boolean} follow Whether highlighting a child component also opens it.
 */
goog.ui.Container.prototype.setOpenFollowsHighlight = function(follow) {
  'use strict';
  this.openFollowsHighlight_ = follow;
};


// Highlight management.


/**
 * Returns the index of the currently highlighted item (-1 if none).
 * @return {number} Index of the currently highlighted item.
 */
goog.ui.Container.prototype.getHighlightedIndex = function() {
  'use strict';
  return this.highlightedIndex_;
};


/**
 * Highlights the item at the given 0-based index (if any).  If another item
 * was previously highlighted, it is un-highlighted.
 * @param {number} index Index of item to highlight (-1 removes the current
 *     highlight).
 */
goog.ui.Container.prototype.setHighlightedIndex = function(index) {
  'use strict';
  var child = this.getChildAt(index);
  if (child) {
    child.setHighlighted(true);
  } else if (this.highlightedIndex_ > -1) {
    this.getHighlighted().setHighlighted(false);
  }
};


/**
 * Highlights the given item if it exists and is a child of the container;
 * otherwise un-highlights the currently highlighted item.
 * @param {goog.ui.Control} item Item to highlight.
 */
goog.ui.Container.prototype.setHighlighted = function(item) {
  'use strict';
  this.setHighlightedIndex(this.indexOfChild(item));
};


/**
 * Returns the currently highlighted item (if any).
 * @return {goog.ui.Control?} Highlighted item (null if none).
 */
goog.ui.Container.prototype.getHighlighted = function() {
  'use strict';
  return this.getChildAt(this.highlightedIndex_);
};


/**
 * Highlights the first highlightable item in the container
 */
goog.ui.Container.prototype.highlightFirst = function() {
  'use strict';
  this.highlightHelper(function(index, max) {
    'use strict';
    return (index + 1) % max;
  }, this.getChildCount() - 1);
};


/**
 * Highlights the last highlightable item in the container.
 */
goog.ui.Container.prototype.highlightLast = function() {
  'use strict';
  this.highlightHelper(function(index, max) {
    'use strict';
    index--;
    return index < 0 ? max - 1 : index;
  }, 0);
};


/**
 * Highlights the next highlightable item (or the first if nothing is currently
 * highlighted).
 */
goog.ui.Container.prototype.highlightNext = function() {
  'use strict';
  this.highlightHelper(function(index, max) {
    'use strict';
    return (index + 1) % max;
  }, this.highlightedIndex_);
};


/**
 * Highlights the previous highlightable item (or the last if nothing is
 * currently highlighted).
 */
goog.ui.Container.prototype.highlightPrevious = function() {
  'use strict';
  this.highlightHelper(function(index, max) {
    'use strict';
    index--;
    return index < 0 ? max - 1 : index;
  }, this.highlightedIndex_);
};


/**
 * Helper function that manages the details of moving the highlight among
 * child controls in response to keyboard events.
 * @param {function(this: goog.ui.Container, number, number) : number} fn
 *     Function that accepts the current and maximum indices, and returns the
 *     next index to check.
 * @param {number} startIndex Start index.
 * @return {boolean} Whether the highlight has changed.
 * @protected
 */
goog.ui.Container.prototype.highlightHelper = function(fn, startIndex) {
  'use strict';
  // If the start index is -1 (meaning there's nothing currently highlighted),
  // try starting from the currently open item, if any.
  var curIndex =
      startIndex < 0 ? this.indexOfChild(this.openItem_) : startIndex;
  var numItems = this.getChildCount();

  curIndex = fn.call(this, curIndex, numItems);
  var visited = 0;
  while (visited <= numItems) {
    var control = this.getChildAt(curIndex);
    if (control && this.canHighlightItem(control)) {
      this.setHighlightedIndexFromKeyEvent(curIndex);
      return true;
    }
    visited++;
    curIndex = fn.call(this, curIndex, numItems);
  }
  return false;
};


/**
 * Returns whether the given item can be highlighted.
 * @param {goog.ui.Control} item The item to check.
 * @return {boolean} Whether the item can be highlighted.
 * @protected
 */
goog.ui.Container.prototype.canHighlightItem = function(item) {
  'use strict';
  return item.isVisible() && item.isEnabled() &&
      item.isSupportedState(goog.ui.Component.State.HOVER);
};


/**
 * Helper method that sets the highlighted index to the given index in response
 * to a keyboard event.  The base class implementation simply calls the
 * {@link #setHighlightedIndex} method, but subclasses can override this
 * behavior as needed.
 * @param {number} index Index of item to highlight.
 * @protected
 */
goog.ui.Container.prototype.setHighlightedIndexFromKeyEvent = function(index) {
  'use strict';
  this.setHighlightedIndex(index);
};


/**
 * Returns the currently open (expanded) control in the container (null if
 * none).
 * @return {goog.ui.Control?} The currently open control.
 */
goog.ui.Container.prototype.getOpenItem = function() {
  'use strict';
  return this.openItem_;
};


/**
 * Returns true if the mouse button is pressed, false otherwise.
 * @return {boolean} Whether the mouse button is pressed.
 */
goog.ui.Container.prototype.isMouseButtonPressed = function() {
  'use strict';
  return this.mouseButtonPressed_;
};


/**
 * Sets or clears the "mouse button pressed" flag.
 * @param {boolean} pressed Whether the mouse button is presed.
 */
goog.ui.Container.prototype.setMouseButtonPressed = function(pressed) {
  'use strict';
  this.mouseButtonPressed_ = pressed;
};

//third_party/javascript/closure/ui/menuheaderrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.MenuHeader}s.
 */

goog.provide('goog.ui.MenuHeaderRenderer');

goog.require('goog.ui.ControlRenderer');



/**
 * Renderer for menu headers.
 * @constructor
 * @extends {goog.ui.ControlRenderer}
 */
goog.ui.MenuHeaderRenderer = function() {
  'use strict';
  goog.ui.ControlRenderer.call(this);
};
goog.inherits(goog.ui.MenuHeaderRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuHeaderRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.MenuHeaderRenderer.CSS_CLASS = goog.getCssName('goog-menuheader');


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.MenuHeaderRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.MenuHeaderRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/menuheader.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class for representing menu headers.
 * @see goog.ui.Menu
 */

goog.provide('goog.ui.MenuHeader');

goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.MenuHeaderRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.ui.ControlContent');



/**
 * Class representing a menu header.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to
 *     display as the content of the item (use to add icons or styling to
 *     menus).
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper used for
 *     document interactions.
 * @param {goog.ui.MenuHeaderRenderer=} opt_renderer Optional renderer.
 * @constructor
 * @extends {goog.ui.Control}
 */
goog.ui.MenuHeader = function(content, opt_domHelper, opt_renderer) {
  'use strict';
  goog.ui.Control.call(
      this, content, opt_renderer || goog.ui.MenuHeaderRenderer.getInstance(),
      opt_domHelper);

  this.setSupportedState(goog.ui.Component.State.DISABLED, false);
  this.setSupportedState(goog.ui.Component.State.HOVER, false);
  this.setSupportedState(goog.ui.Component.State.ACTIVE, false);
  this.setSupportedState(goog.ui.Component.State.FOCUSED, false);

  // Headers are always considered disabled.
  this.setStateInternal(goog.ui.Component.State.DISABLED);
};
goog.inherits(goog.ui.MenuHeader, goog.ui.Control);


// Register a decorator factory function for goog.ui.MenuHeaders.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.MenuHeaderRenderer.CSS_CLASS, function() {
      'use strict';
      // MenuHeader defaults to using MenuHeaderRenderer.
      return new goog.ui.MenuHeader(null);
    });

//third_party/javascript/closure/ui/menuitemrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.MenuItem}s.
 */

goog.provide('goog.ui.MenuItemRenderer');

goog.require('goog.a11y.aria.Role');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.ui.Component');
goog.require('goog.ui.ControlRenderer');
goog.requireType('goog.ui.ControlContent');



/**
 * Default renderer for {@link goog.ui.MenuItem}s.  Each item has the following
 * structure:
 *
 *    <div class="goog-menuitem">
 *      <div class="goog-menuitem-content">
 *        ...(menu item contents)...
 *      </div>
 *    </div>
 *
 * @constructor
 * @extends {goog.ui.ControlRenderer}
 */
goog.ui.MenuItemRenderer = function() {
  'use strict';
  goog.ui.ControlRenderer.call(this);

  /**
   * Commonly used CSS class names, cached here for convenience (and to avoid
   * unnecessary string concatenation).
   * @type {!Array<string>}
   * @private
   */
  this.classNameCache_ = [];
};
goog.inherits(goog.ui.MenuItemRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuItemRenderer);


/**
 * CSS class name the renderer applies to menu item elements.
 * @type {string}
 */
goog.ui.MenuItemRenderer.CSS_CLASS = goog.getCssName('goog-menuitem');


/**
 * Constants for referencing composite CSS classes.
 * @enum {number}
 * @private
 */
goog.ui.MenuItemRenderer.CompositeCssClassIndex_ = {
  HOVER: 0,
  CHECKBOX: 1,
  CONTENT: 2
};


/**
 * Returns the composite CSS class by using the cached value or by constructing
 * the value from the base CSS class and the passed index.
 * @param {goog.ui.MenuItemRenderer.CompositeCssClassIndex_} index Index for the
 *     CSS class - could be highlight, checkbox or content in usual cases.
 * @return {string} The composite CSS class.
 * @private
 */
goog.ui.MenuItemRenderer.prototype.getCompositeCssClass_ = function(index) {
  'use strict';
  var result = this.classNameCache_[index];
  if (!result) {
    switch (index) {
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER:
        result = goog.getCssName(this.getStructuralCssClass(), 'highlight');
        break;
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX:
        result = goog.getCssName(this.getStructuralCssClass(), 'checkbox');
        break;
      case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT:
        result = goog.getCssName(this.getStructuralCssClass(), 'content');
        break;
    }
    this.classNameCache_[index] = result;
  }

  return result;
};


/** @override */
goog.ui.MenuItemRenderer.prototype.getAriaRole = function() {
  'use strict';
  return goog.a11y.aria.Role.MENU_ITEM;
};


/**
 * Overrides {@link goog.ui.ControlRenderer#createDom} by adding extra markup
 * and stying to the menu item's element if it is selectable or checkable.
 * @param {goog.ui.Control} item Menu item to render.
 * @return {!Element} Root element for the item.
 * @override
 */
goog.ui.MenuItemRenderer.prototype.createDom = function(item) {
  'use strict';
  var element = item.getDomHelper().createDom(
      goog.dom.TagName.DIV, this.getClassNames(item).join(' '),
      this.createContent(item.getContent(), item.getDomHelper()));
  this.setEnableCheckBoxStructure(
      item, element, item.isSupportedState(goog.ui.Component.State.SELECTED) ||
          item.isSupportedState(goog.ui.Component.State.CHECKED));
  return element;
};


/** @override */
goog.ui.MenuItemRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return /** @type {Element} */ (element && element.firstChild);
};


/**
 * Overrides {@link goog.ui.ControlRenderer#decorate} by initializing the
 * menu item to checkable based on whether the element to be decorated has
 * extra stying indicating that it should be.
 * @param {goog.ui.Control} item Menu item instance to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 * @override
 */
goog.ui.MenuItemRenderer.prototype.decorate = function(item, element) {
  'use strict';
  goog.asserts.assert(element);
  if (!this.hasContentStructure(element)) {
    element.appendChild(
        /** @type {!Node} */ (
            this.createContent(element.childNodes, item.getDomHelper())));
  }
  if (goog.dom.classlist.contains(element, goog.getCssName('goog-option'))) {
    (/** @type {goog.ui.MenuItem} */ (item)).setCheckable(true);
    this.setCheckable(item, element, true);
  }
  return goog.ui.MenuItemRenderer.superClass_.decorate.call(
      this, item, element);
};


/**
 * Takes a menu item's root element, and sets its content to the given text
 * caption or DOM structure.  Overrides the superclass immplementation by
 * making sure that the checkbox structure (for selectable/checkable menu
 * items) is preserved.
 * @param {Element} element The item's root element.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to be
 *     set as the item's content.
 * @override
 */
goog.ui.MenuItemRenderer.prototype.setContent = function(element, content) {
  'use strict';
  // Save the checkbox element, if present.
  var contentElement = this.getContentElement(element);
  var checkBoxElement =
      this.hasCheckBoxStructure(element) ? contentElement.firstChild : null;
  goog.ui.MenuItemRenderer.superClass_.setContent.call(this, element, content);
  if (checkBoxElement && !this.hasCheckBoxStructure(element)) {
    // The call to setContent() blew away the checkbox element; reattach it.
    contentElement.insertBefore(
        checkBoxElement, contentElement.firstChild || null);
  }
};


/**
 * Returns true if the element appears to have a proper menu item structure by
 * checking whether its first child has the appropriate structural class name.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element appears to have a proper menu item DOM.
 * @protected
 */
goog.ui.MenuItemRenderer.prototype.hasContentStructure = function(element) {
  'use strict';
  var child = goog.dom.getFirstElementChild(element);
  var contentClassName = this.getCompositeCssClass_(
      goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
  return !!child && goog.dom.classlist.contains(child, contentClassName);
};


/**
 * Wraps the given text caption or existing DOM node(s) in a structural element
 * containing the menu item's contents.
 * @param {goog.ui.ControlContent} content Menu item contents.
 * @param {goog.dom.DomHelper} dom DOM helper for document interaction.
 * @return {!Element} Menu item content element.
 * @protected
 */
goog.ui.MenuItemRenderer.prototype.createContent = function(content, dom) {
  'use strict';
  var contentClassName = this.getCompositeCssClass_(
      goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
  return dom.createDom(goog.dom.TagName.DIV, contentClassName, content);
};


/**
 * Enables/disables radio button semantics on the menu item.
 * @param {goog.ui.Control} item Menu item to update.
 * @param {Element} element Menu item element to update (may be null if the
 *     item hasn't been rendered yet).
 * @param {boolean} selectable Whether the item should be selectable.
 */
goog.ui.MenuItemRenderer.prototype.setSelectable = function(
    item, element, selectable) {
  'use strict';
  if (item && element) {
    this.setEnableCheckBoxStructure(item, element, selectable);
  }
};


/**
 * Enables/disables checkbox semantics on the menu item.
 * @param {goog.ui.Control} item Menu item to update.
 * @param {Element} element Menu item element to update (may be null if the
 *     item hasn't been rendered yet).
 * @param {boolean} checkable Whether the item should be checkable.
 */
goog.ui.MenuItemRenderer.prototype.setCheckable = function(
    item, element, checkable) {
  'use strict';
  if (item && element) {
    this.setEnableCheckBoxStructure(item, element, checkable);
  }
};


/**
 * Determines whether the item contains a checkbox element.
 * @param {Element} element Menu item root element.
 * @return {boolean} Whether the element contains a checkbox element.
 * @protected
 */
goog.ui.MenuItemRenderer.prototype.hasCheckBoxStructure = function(element) {
  'use strict';
  var contentElement = this.getContentElement(element);
  if (contentElement) {
    var child = contentElement.firstChild;
    var checkboxClassName = this.getCompositeCssClass_(
        goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
    return !!child && goog.dom.isElement(child) &&
        goog.dom.classlist.contains(
            /** @type {!Element} */ (child), checkboxClassName);
  }
  return false;
};


/**
 * Adds or removes extra markup and CSS styling to the menu item to make it
 * selectable or non-selectable, depending on the value of the
 * `selectable` argument.
 * @param {!goog.ui.Control} item Menu item to update.
 * @param {!Element} element Menu item element to update.
 * @param {boolean} enable Whether to add or remove the checkbox structure.
 * @protected
 */
goog.ui.MenuItemRenderer.prototype.setEnableCheckBoxStructure = function(
    item, element, enable) {
  'use strict';
  this.setAriaRole(element, item.getPreferredAriaRole());
  this.setAriaStates(item, element);
  if (enable != this.hasCheckBoxStructure(element)) {
    goog.dom.classlist.enable(element, goog.getCssName('goog-option'), enable);
    var contentElement = this.getContentElement(element);
    if (enable) {
      // Insert checkbox structure.
      var checkboxClassName = this.getCompositeCssClass_(
          goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
      contentElement.insertBefore(
          item.getDomHelper().createDom(
              goog.dom.TagName.DIV, checkboxClassName),
          contentElement.firstChild || null);
    } else {
      // Remove checkbox structure.
      contentElement.removeChild(
          /** @type {!Node} */ (contentElement.firstChild));
    }
  }
};


/**
 * Takes a single {@link goog.ui.Component.State}, and returns the
 * corresponding CSS class name (null if none).  Overrides the superclass
 * implementation by using 'highlight' as opposed to 'hover' as the CSS
 * class name suffix for the HOVER state, for backwards compatibility.
 * @param {goog.ui.Component.State} state Component state.
 * @return {string|undefined} CSS class representing the given state
 *     (undefined if none).
 * @override
 */
goog.ui.MenuItemRenderer.prototype.getClassForState = function(state) {
  'use strict';
  switch (state) {
    case goog.ui.Component.State.HOVER:
      // We use 'highlight' as the suffix, for backwards compatibility.
      return this.getCompositeCssClass_(
          goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
    case goog.ui.Component.State.CHECKED:
    case goog.ui.Component.State.SELECTED:
      // We use 'goog-option-selected' as the class, for backwards
      // compatibility.
      return goog.getCssName('goog-option-selected');
    default:
      return goog.ui.MenuItemRenderer.superClass_.getClassForState.call(
          this, state);
  }
};


/**
 * Takes a single CSS class name which may represent a component state, and
 * returns the corresponding component state (0x00 if none).  Overrides the
 * superclass implementation by treating 'goog-option-selected' as special,
 * for backwards compatibility.
 * @param {string} className CSS class name, possibly representing a component
 *     state.
 * @return {goog.ui.Component.State} state Component state corresponding
 *     to the given CSS class (0x00 if none).
 * @override
 */
goog.ui.MenuItemRenderer.prototype.getStateFromClass = function(className) {
  'use strict';
  var hoverClassName = this.getCompositeCssClass_(
      goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
  switch (className) {
    case goog.getCssName('goog-option-selected'):
      return goog.ui.Component.State.CHECKED;
    case hoverClassName:
      return goog.ui.Component.State.HOVER;
    default:
      return goog.ui.MenuItemRenderer.superClass_.getStateFromClass.call(
          this, className);
  }
};


/** @override */
goog.ui.MenuItemRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.MenuItemRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/menuitem.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class for representing items in menus.
 * @see goog.ui.Menu
 * @see ../demos/menuitem.html
 */

goog.provide('goog.ui.MenuItem');

goog.forwardDeclare('goog.ui.Menu');
goog.require('goog.a11y.aria.Role');
goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.math.Coordinate');
goog.require('goog.string');
goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.MenuItemRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.events.KeyCodes');
goog.requireType('goog.ui.ControlContent');  // circular



/**
 * Class representing an item in a menu.
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to
 *     display as the content of the item (use to add icons or styling to
 *     menus).
 * @param {*=} opt_model Data/model associated with the menu item.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper used for
 *     document interactions.
 * @param {goog.ui.MenuItemRenderer=} opt_renderer Optional renderer.
 * @constructor
 * @extends {goog.ui.Control}
 */
goog.ui.MenuItem = function(content, opt_model, opt_domHelper, opt_renderer) {
  'use strict';
  goog.ui.Control.call(
      this, content, opt_renderer || goog.ui.MenuItemRenderer.getInstance(),
      opt_domHelper);
  this.setValue(opt_model);
};
goog.inherits(goog.ui.MenuItem, goog.ui.Control);


/**
 * The access key for this menu item. This key allows the user to quickly
 * trigger this item's action with they keyboard. For example, setting the
 * mnenomic key to 70 (F), when the user opens the menu and hits "F," the
 * menu item is triggered.
 *
 * @type {goog.events.KeyCodes}
 * @private
 */
goog.ui.MenuItem.prototype.mnemonicKey_;


/**
 * The class set on an element that contains a parenthetical mnemonic key hint.
 * Parenthetical hints are added to items in which the mnemonic key is not found
 * within the menu item's caption itself. For example, if you have a menu item
 * with the caption "Record," but its mnemonic key is "I", the caption displayed
 * in the menu will appear as "Record (I)".
 *
 * @type {string}
 * @private
 */
goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_ =
    goog.getCssName('goog-menuitem-mnemonic-separator');


/**
 * The class set on an element that contains a keyboard accelerator hint.
 * @type {string}
 */
goog.ui.MenuItem.ACCELERATOR_CLASS = goog.getCssName('goog-menuitem-accel');


// goog.ui.Component and goog.ui.Control implementation.


/**
 * Returns the value associated with the menu item.  The default implementation
 * returns the model object associated with the item (if any), or its caption.
 * @return {*} Value associated with the menu item, if any, or its caption.
 */
goog.ui.MenuItem.prototype.getValue = function() {
  'use strict';
  var model = this.getModel();
  return model != null ? model : this.getCaption();
};


/**
 * Sets the value associated with the menu item.  The default implementation
 * stores the value as the model of the menu item.
 * @param {*} value Value to be associated with the menu item.
 */
goog.ui.MenuItem.prototype.setValue = function(value) {
  'use strict';
  this.setModel(value);
};


/** @override */
goog.ui.MenuItem.prototype.setSupportedState = function(state, support) {
  'use strict';
  goog.ui.MenuItem.base(this, 'setSupportedState', state, support);
  switch (state) {
    case goog.ui.Component.State.SELECTED:
      this.setSelectableInternal_(support);
      break;
    case goog.ui.Component.State.CHECKED:
      this.setCheckableInternal_(support);
      break;
  }
};


/**
 * Sets the menu item to be selectable or not.  Set to true for menu items
 * that represent selectable options.
 * @param {boolean} selectable Whether the menu item is selectable.
 */
goog.ui.MenuItem.prototype.setSelectable = function(selectable) {
  'use strict';
  this.setSupportedState(goog.ui.Component.State.SELECTED, selectable);
};


/**
 * Sets the menu item to be selectable or not.
 * @param {boolean} selectable  Whether the menu item is selectable.
 * @private
 */
goog.ui.MenuItem.prototype.setSelectableInternal_ = function(selectable) {
  'use strict';
  if (this.isChecked() && !selectable) {
    this.setChecked(false);
  }

  var element = this.getElement();
  if (element) {
    this.getRenderer().setSelectable(this, element, selectable);
  }
};


/**
 * Sets the menu item to be checkable or not.  Set to true for menu items
 * that represent checkable options.
 * @param {boolean} checkable Whether the menu item is checkable.
 */
goog.ui.MenuItem.prototype.setCheckable = function(checkable) {
  'use strict';
  this.setSupportedState(goog.ui.Component.State.CHECKED, checkable);
};


/**
 * Sets the menu item to be checkable or not.
 * @param {boolean} checkable Whether the menu item is checkable.
 * @private
 */
goog.ui.MenuItem.prototype.setCheckableInternal_ = function(checkable) {
  'use strict';
  var element = this.getElement();
  if (element) {
    this.getRenderer().setCheckable(this, element, checkable);
  }
};


/**
 * Returns the text caption of the component while ignoring accelerators.
 * @override
 */
goog.ui.MenuItem.prototype.getCaption = function() {
  'use strict';
  var content = this.getContent();
  if (Array.isArray(content)) {
    var acceleratorClass = goog.ui.MenuItem.ACCELERATOR_CLASS;
    var mnemonicWrapClass = goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_;
    var caption =
        goog.array
            .map(
                content,
                function(node) {
                  'use strict';
                  if (goog.dom.isElement(node) &&
                      (goog.dom.classlist.contains(
                           /** @type {!Element} */ (node), acceleratorClass) ||
                       goog.dom.classlist.contains(
                           /** @type {!Element} */ (node),
                           mnemonicWrapClass))) {
                    return '';
                  } else {
                    return goog.dom.getRawTextContent(node);
                  }
                })
            .join('');
    return goog.string.collapseBreakingSpaces(caption);
  }
  return goog.ui.MenuItem.superClass_.getCaption.call(this);
};


/**
 * @return {?string} The keyboard accelerator text, or null if the menu item
 *     doesn't have one.
 */
goog.ui.MenuItem.prototype.getAccelerator = function() {
  'use strict';
  var dom = this.getDomHelper();
  var content = this.getContent();
  if (Array.isArray(content)) {
    var acceleratorEl = goog.array.find(content, function(e) {
      'use strict';
      return goog.dom.classlist.contains(
          /** @type {!Element} */ (e), goog.ui.MenuItem.ACCELERATOR_CLASS);
    });
    if (acceleratorEl) {
      return dom.getTextContent(acceleratorEl);
    }
  }
  return null;
};


/** @override */
goog.ui.MenuItem.prototype.handleMouseUp = function(e) {
  'use strict';
  var parentMenu = /** @type {goog.ui.Menu} */ (this.getParent());

  if (parentMenu) {
    var oldCoords = parentMenu.openingCoords;
    // Clear out the saved opening coords immediately so they're not used twice.
    parentMenu.openingCoords = null;

    if (oldCoords && typeof e.clientX === 'number') {
      var newCoords = new goog.math.Coordinate(e.clientX, e.clientY);
      if (goog.math.Coordinate.equals(oldCoords, newCoords)) {
        // This menu was opened by a mousedown and we're handling the consequent
        // mouseup. The coords haven't changed, meaning this was a simple click,
        // not a click and drag. Don't do the usual behavior because the menu
        // just popped up under the mouse and the user didn't mean to activate
        // this item.
        return;
      }
    }
  }

  goog.ui.MenuItem.base(this, 'handleMouseUp', e);
};


/** @override */
goog.ui.MenuItem.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  if (e.keyCode == this.getMnemonic() && this.performActionInternal(e)) {
    return true;
  } else {
    return goog.ui.MenuItem.base(this, 'handleKeyEventInternal', e);
  }
};


/**
 * Sets the mnemonic key code. The mnemonic is the key associated with this
 * action.
 * @param {goog.events.KeyCodes} key The key code.
 */
goog.ui.MenuItem.prototype.setMnemonic = function(key) {
  'use strict';
  this.mnemonicKey_ = key;
};


/**
 * Gets the mnemonic key code. The mnemonic is the key associated with this
 * action.
 * @return {goog.events.KeyCodes} The key code of the mnemonic key.
 */
goog.ui.MenuItem.prototype.getMnemonic = function() {
  'use strict';
  return this.mnemonicKey_;
};


// Register a decorator factory function for goog.ui.MenuItems.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.MenuItemRenderer.CSS_CLASS, function() {
      'use strict';
      // MenuItem defaults to using MenuItemRenderer.
      return new goog.ui.MenuItem(null);
    });


/**
 * @override
 */
goog.ui.MenuItem.prototype.getPreferredAriaRole = function() {
  'use strict';
  if (this.isSupportedState(goog.ui.Component.State.CHECKED)) {
    return goog.a11y.aria.Role.MENU_ITEM_CHECKBOX;
  }
  if (this.isSupportedState(goog.ui.Component.State.SELECTED)) {
    return goog.a11y.aria.Role.MENU_ITEM_RADIO;
  }
  return goog.ui.MenuItem.base(this, 'getPreferredAriaRole');
};


/**
 * @override
 * @return {goog.ui.Menu}
 */
goog.ui.MenuItem.prototype.getParent = function() {
  'use strict';
  return /** @type {goog.ui.Menu} */ (
      goog.ui.Control.prototype.getParent.call(this));
};


/**
 * @override
 * @return {goog.ui.Menu}
 */
goog.ui.MenuItem.prototype.getParentEventTarget = function() {
  'use strict';
  return /** @type {goog.ui.Menu} */ (
      goog.ui.Control.prototype.getParentEventTarget.call(this));
};

//third_party/javascript/closure/ui/menuseparatorrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.MenuSeparator}s.
 */

goog.provide('goog.ui.MenuSeparatorRenderer');

goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.ui.ControlRenderer');
goog.requireType('goog.ui.ControlContent');



/**
 * Renderer for menu separators.
 * @constructor
 * @extends {goog.ui.ControlRenderer}
 */
goog.ui.MenuSeparatorRenderer = function() {
  'use strict';
  goog.ui.ControlRenderer.call(this);
};
goog.inherits(goog.ui.MenuSeparatorRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuSeparatorRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.MenuSeparatorRenderer.CSS_CLASS = goog.getCssName('goog-menuseparator');


/**
 * Returns an empty, styled menu separator DIV.  Overrides {@link
 * goog.ui.ControlRenderer#createDom}.
 * @param {goog.ui.Control} separator goog.ui.Separator to render.
 * @return {!Element} Root element for the separator.
 * @override
 */
goog.ui.MenuSeparatorRenderer.prototype.createDom = function(separator) {
  'use strict';
  return separator.getDomHelper().createDom(
      goog.dom.TagName.DIV, this.getCssClass());
};


/**
 * Takes an existing element, and decorates it with the separator.  Overrides
 * {@link goog.ui.ControlRenderer#decorate}.
 * @param {goog.ui.Control} separator goog.ui.MenuSeparator to decorate the
 *     element.
 * @param {Element} element Element to decorate.
 * @return {!Element} Decorated element.
 * @override
 */
goog.ui.MenuSeparatorRenderer.prototype.decorate = function(
    separator, element) {
  'use strict';
  // Normally handled in the superclass. But we don't call the superclass.
  if (element.id) {
    separator.setId(element.id);
  }

  if (element.tagName == goog.dom.TagName.HR) {
    // Replace HR with separator.
    var hr = element;
    element = this.createDom(separator);
    goog.dom.insertSiblingBefore(element, hr);
    goog.dom.removeNode(hr);
  } else {
    goog.dom.classlist.add(element, this.getCssClass());
  }
  return element;
};


/**
 * Overrides {@link goog.ui.ControlRenderer#setContent} to do nothing, since
 * separators are empty.
 * @param {Element} separator The separator's root element.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to be
 *    set as the separators's content (ignored).
 * @override
 */
goog.ui.MenuSeparatorRenderer.prototype.setContent = function(
    separator, content) {
  // Do nothing.  Separators are empty.
};


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.MenuSeparatorRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.MenuSeparatorRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/separator.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class for representing a separator, with renderers for both
 * horizontal (menu) and vertical (toolbar) separators.
 */

goog.provide('goog.ui.Separator');

goog.require('goog.a11y.aria');
goog.require('goog.asserts');
goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.MenuSeparatorRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');



/**
 * Class representing a separator.  Although it extends {@link goog.ui.Control},
 * the Separator class doesn't allocate any event handlers, nor does it change
 * its appearance on mouseover, etc.
 * @param {goog.ui.MenuSeparatorRenderer=} opt_renderer Renderer to render or
 *    decorate the separator; defaults to {@link goog.ui.MenuSeparatorRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *    document interaction.
 * @constructor
 * @extends {goog.ui.Control}
 */
goog.ui.Separator = function(opt_renderer, opt_domHelper) {
  'use strict';
  goog.ui.Control.call(
      this, null, opt_renderer || goog.ui.MenuSeparatorRenderer.getInstance(),
      opt_domHelper);

  this.setSupportedState(goog.ui.Component.State.DISABLED, false);
  this.setSupportedState(goog.ui.Component.State.HOVER, false);
  this.setSupportedState(goog.ui.Component.State.ACTIVE, false);
  this.setSupportedState(goog.ui.Component.State.FOCUSED, false);

  // Separators are always considered disabled.
  this.setStateInternal(goog.ui.Component.State.DISABLED);
};
goog.inherits(goog.ui.Separator, goog.ui.Control);


/**
 * Configures the component after its DOM has been rendered.  Overrides
 * {@link goog.ui.Control#enterDocument} by making sure no event handler
 * is allocated.
 * @override
 */
goog.ui.Separator.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Separator.superClass_.enterDocument.call(this);
  var element = this.getElement();
  goog.asserts.assert(
      element, 'The DOM element for the separator cannot be null.');
  goog.a11y.aria.setRole(element, 'separator');
};


// Register a decorator factory function for goog.ui.MenuSeparators.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
      'use strict';
      // Separator defaults to using MenuSeparatorRenderer.
      return new goog.ui.Separator();
    });

//third_party/javascript/closure/ui/menurenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.Menu}s.
 */

goog.provide('goog.ui.MenuRenderer');

goog.forwardDeclare('goog.ui.Menu');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.ui.ContainerRenderer');
goog.require('goog.ui.Separator');
goog.requireType('goog.ui.Control');



/**
 * Default renderer for {@link goog.ui.Menu}s, based on {@link
 * goog.ui.ContainerRenderer}.
 * @param {string=} opt_ariaRole Optional ARIA role used for the element.
 * @constructor
 * @extends {goog.ui.ContainerRenderer}
 */
goog.ui.MenuRenderer = function(opt_ariaRole) {
  'use strict';
  goog.ui.ContainerRenderer.call(
      this, opt_ariaRole || goog.a11y.aria.Role.MENU);
};
goog.inherits(goog.ui.MenuRenderer, goog.ui.ContainerRenderer);
goog.addSingletonGetter(goog.ui.MenuRenderer);


/**
 * Default CSS class to be applied to the root element of toolbars rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.MenuRenderer.CSS_CLASS = goog.getCssName('goog-menu');


/**
 * Returns whether the element is a UL or acceptable to our superclass.
 * @param {Element} element Element to decorate.
 * @return {boolean} Whether the renderer can decorate the element.
 * @override
 */
goog.ui.MenuRenderer.prototype.canDecorate = function(element) {
  'use strict';
  return element.tagName == goog.dom.TagName.UL ||
      goog.ui.MenuRenderer.superClass_.canDecorate.call(this, element);
};


/**
 * Inspects the element, and creates an instance of {@link goog.ui.Control} or
 * an appropriate subclass best suited to decorate it.  Overrides the superclass
 * implementation by recognizing HR elements as separators.
 * @param {Element} element Element to decorate.
 * @return {goog.ui.Control?} A new control suitable to decorate the element
 *     (null if none).
 * @override
 */
goog.ui.MenuRenderer.prototype.getDecoratorForChild = function(element) {
  'use strict';
  return element.tagName == goog.dom.TagName.HR ?
      new goog.ui.Separator() :
      goog.ui.MenuRenderer.superClass_.getDecoratorForChild.call(this, element);
};


/**
 * Returns whether the given element is contained in the menu's DOM.
 * @param {goog.ui.Menu} menu The menu to test.
 * @param {Element} element The element to test.
 * @return {boolean} Whether the given element is contained in the menu.
 */
goog.ui.MenuRenderer.prototype.containsElement = function(menu, element) {
  'use strict';
  return goog.dom.contains(menu.getElement(), element);
};


/**
 * Returns the CSS class to be applied to the root element of containers
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.MenuRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.MenuRenderer.CSS_CLASS;
};


/** @override */
goog.ui.MenuRenderer.prototype.initializeDom = function(container) {
  'use strict';
  goog.ui.MenuRenderer.superClass_.initializeDom.call(this, container);

  var element = container.getElement();
  goog.asserts.assert(element, 'The menu DOM element cannot be null.');
  goog.a11y.aria.setState(element, goog.a11y.aria.State.HASPOPUP, 'true');
};

//third_party/javascript/closure/ui/menuseparator.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class for representing menu separators.
 * @see goog.ui.Menu
 */

goog.provide('goog.ui.MenuSeparator');

goog.require('goog.ui.MenuSeparatorRenderer');
goog.require('goog.ui.Separator');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');



/**
 * Class representing a menu separator.  A menu separator extends {@link
 * goog.ui.Separator} by always setting its renderer to {@link
 * goog.ui.MenuSeparatorRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper used for
 *     document interactions.
 * @constructor
 * @extends {goog.ui.Separator}
 */
goog.ui.MenuSeparator = function(opt_domHelper) {
  'use strict';
  goog.ui.Separator.call(
      this, goog.ui.MenuSeparatorRenderer.getInstance(), opt_domHelper);
};
goog.inherits(goog.ui.MenuSeparator, goog.ui.Separator);


// Register a decorator factory function for goog.ui.MenuSeparators.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
      'use strict';
      // Separator defaults to using MenuSeparatorRenderer.
      return new goog.ui.Separator();
    });

//third_party/javascript/closure/ui/menu.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A base menu class that supports key and mouse events. The menu
 * can be bound to an existing HTML structure or can generate its own DOM.
 *
 * To decorate, the menu should be bound to an element containing children
 * with the classname 'goog-menuitem'.  HRs will be classed as separators.
 *
 * Decorate Example:
 * <div id="menu" class="goog-menu" tabIndex="0">
 *   <div class="goog-menuitem">Google</div>
 *   <div class="goog-menuitem">Yahoo</div>
 *   <div class="goog-menuitem">MSN</div>
 *   <hr>
 *   <div class="goog-menuitem">New...</div>
 * </div>
 * <script>
 *
 * var menu = new goog.ui.Menu();
 * menu.decorate(goog.dom.getElement('menu'));
 *
 * TESTED=FireFox 2.0, IE6, Opera 9, Chrome.
 * TODO(pupius): Key handling is flaky in Opera and Chrome
 * TODO(pupius): Rename all references of "item" to child since menu is
 * essentially very generic and could, in theory, host a date or color picker.
 *
 * @see ../demos/menu.html
 * @see ../demos/menus.html
 */

goog.provide('goog.ui.Menu');
goog.provide('goog.ui.Menu.EventType');

goog.require('goog.dom.TagName');
goog.require('goog.math.Coordinate');
goog.require('goog.string');
goog.require('goog.style');
goog.require('goog.ui.Component.EventType');
goog.require('goog.ui.Component.State');
goog.require('goog.ui.Container');
goog.require('goog.ui.Container.Orientation');
goog.require('goog.ui.MenuHeader');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.MenuRenderer');
goog.require('goog.ui.MenuSeparator');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.Event');

// The dependencies MenuHeader, MenuItem, and MenuSeparator are implicit.
// There are no references in the code, but we need to load these
// classes before goog.ui.Menu.



// TODO(robbyw): Reverse constructor argument order for consistency.
/**
 * A basic menu class.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper.
 * @param {goog.ui.MenuRenderer=} opt_renderer Renderer used to render or
 *     decorate the container; defaults to {@link goog.ui.MenuRenderer}.
 * @constructor
 * @extends {goog.ui.Container}
 */
goog.ui.Menu = function(opt_domHelper, opt_renderer) {
  'use strict';
  goog.ui.Container.call(
      this, goog.ui.Container.Orientation.VERTICAL,
      opt_renderer || goog.ui.MenuRenderer.getInstance(), opt_domHelper);

  // Unlike Containers, Menus aren't keyboard-accessible by default.  This line
  // preserves backwards compatibility with code that depends on menus not
  // receiving focus - e.g. `goog.ui.MenuButton`.
  this.setFocusable(false);
};
goog.inherits(goog.ui.Menu, goog.ui.Container);


// TODO(robbyw): Remove this and all references to it.
// Please ensure that BEFORE_SHOW behavior is not disrupted as a result.
/**
 * Event types dispatched by the menu.
 * @enum {string}
 * @deprecated Use goog.ui.Component.EventType.
 */
goog.ui.Menu.EventType = {
  /** Dispatched before the menu becomes visible */
  BEFORE_SHOW: goog.ui.Component.EventType.BEFORE_SHOW,

  /** Dispatched when the menu is shown */
  SHOW: goog.ui.Component.EventType.SHOW,

  /** Dispatched before the menu becomes hidden */
  BEFORE_HIDE: goog.ui.Component.EventType.HIDE,

  /** Dispatched when the menu is hidden */
  HIDE: goog.ui.Component.EventType.HIDE
};


// TODO(robbyw): Remove this and all references to it.
/**
 * CSS class for menus.
 * @type {string}
 * @deprecated Use goog.ui.MenuRenderer.CSS_CLASS.
 */
goog.ui.Menu.CSS_CLASS = goog.ui.MenuRenderer.CSS_CLASS;


/**
 * Coordinates of the mousedown event that caused this menu to be made visible.
 * Used to prevent the consequent mouseup event due to a simple click from
 * activating a menu item immediately. Considered protected; should only be used
 * within this package or by subclasses.
 * @type {goog.math.Coordinate|undefined}
 */
goog.ui.Menu.prototype.openingCoords;


/**
 * Whether the menu can move the focus to its key event target when it is
 * shown.  Default = true
 * @type {boolean}
 * @private
 */
goog.ui.Menu.prototype.allowAutoFocus_ = true;


/**
 * Whether the menu should use windows style behavior and allow disabled menu
 * items to be highlighted (though not selectable).  Defaults to false
 * @type {boolean}
 * @private
 */
goog.ui.Menu.prototype.allowHighlightDisabled_ = false;


/**
 * Returns the CSS class applied to menu elements, also used as the prefix for
 * derived styles, if any.  Subclasses should override this method as needed.
 * Considered protected.
 * @return {string} The CSS class applied to menu elements.
 * @protected
 * @deprecated Use getRenderer().getCssClass().
 */
goog.ui.Menu.prototype.getCssClass = function() {
  'use strict';
  return this.getRenderer().getCssClass();
};


/**
 * Returns whether the provided element is to be considered inside the menu for
 * purposes such as dismissing the menu on an event.  This is so submenus can
 * make use of elements outside their own DOM.
 * @param {Element} element The element to test for.
 * @return {boolean} Whether the provided element is to be considered inside
 *     the menu.
 */
goog.ui.Menu.prototype.containsElement = function(element) {
  'use strict';
  if (this.getRenderer().containsElement(this, element)) {
    return true;
  }

  for (var i = 0, count = this.getChildCount(); i < count; i++) {
    var child = this.getChildAt(i);
    if (typeof child.containsElement == 'function' &&
        child.containsElement(element)) {
      return true;
    }
  }

  return false;
};


/**
 * Adds a new menu item at the end of the menu.
 * @param {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu
 *     item to add to the menu.
 * @deprecated Use {@link #addChild} instead, with true for the second argument.
 */
goog.ui.Menu.prototype.addItem = function(item) {
  'use strict';
  this.addChild(item, true);
};


/**
 * Adds a new menu item at a specific index in the menu.
 * @param {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu
 *     item to add to the menu.
 * @param {number} n Index at which to insert the menu item.
 * @deprecated Use {@link #addChildAt} instead, with true for the third
 *     argument.
 */
goog.ui.Menu.prototype.addItemAt = function(item, n) {
  'use strict';
  this.addChildAt(item, n, true);
};


/**
 * Removes an item from the menu and disposes of it.
 * @param {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator} item The
 *     menu item to remove.
 * @deprecated Use {@link #removeChild} instead.
 */
goog.ui.Menu.prototype.removeItem = function(item) {
  'use strict';
  var removedChild = this.removeChild(item, true);
  if (removedChild) {
    removedChild.dispose();
  }
};


/**
 * Removes a menu item at a given index in the menu and disposes of it.
 * @param {number} n Index of item.
 * @deprecated Use {@link #removeChildAt} instead.
 */
goog.ui.Menu.prototype.removeItemAt = function(n) {
  'use strict';
  var removedChild = this.removeChildAt(n, true);
  if (removedChild) {
    removedChild.dispose();
  }
};


/**
 * Returns a reference to the menu item at a given index.
 * @param {number} n Index of menu item.
 * @return {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator|null}
 *     Reference to the menu item.
 * @deprecated Use {@link #getChildAt} instead.
 */
goog.ui.Menu.prototype.getItemAt = function(n) {
  'use strict';
  return /** @type {goog.ui.MenuItem?} */ (this.getChildAt(n));
};


/**
 * Returns the number of items in the menu (including separators).
 * @return {number} The number of items in the menu.
 * @deprecated Use {@link #getChildCount} instead.
 */
goog.ui.Menu.prototype.getItemCount = function() {
  'use strict';
  return this.getChildCount();
};


/**
 * Returns an array containing the menu items contained in the menu.
 * @return {!Array<goog.ui.MenuItem>} An array of menu items.
 * @deprecated Use getChildAt, forEachChild, and getChildCount.
 */
goog.ui.Menu.prototype.getItems = function() {
  'use strict';
  // TODO(pupius): Remove reference to getItems and instead use getChildAt,
  // forEachChild, and getChildCount
  var children = [];
  this.forEachChild(function(child) {
    'use strict';
    children.push(child);
  });
  return children;
};


/**
 * Sets the position of the menu relative to the view port.
 * @param {number|goog.math.Coordinate} x Left position or coordinate obj.
 * @param {number=} opt_y Top position.
 */
goog.ui.Menu.prototype.setPosition = function(x, opt_y) {
  'use strict';
  // NOTE(pupius): It is necessary to temporarily set the display from none, so
  // that the position gets set correctly.
  var visible = this.isVisible();
  if (!visible) {
    goog.style.setElementShown(this.getElement(), true);
  }
  goog.style.setPageOffset(this.getElement(), x, opt_y);
  if (!visible) {
    goog.style.setElementShown(this.getElement(), false);
  }
};


/**
 * Gets the page offset of the menu, or null if the menu isn't visible
 * @return {goog.math.Coordinate?} Object holding the x-y coordinates of the
 *     menu or null if the menu is not visible.
 */
goog.ui.Menu.prototype.getPosition = function() {
  'use strict';
  return this.isVisible() ? goog.style.getPageOffset(this.getElement()) : null;
};


/**
 * Sets whether the menu can automatically move focus to its key event target
 * when it is set to visible.
 * @param {boolean} allow Whether the menu can automatically move focus to its
 *     key event target when it is set to visible.
 */
goog.ui.Menu.prototype.setAllowAutoFocus = function(allow) {
  'use strict';
  this.allowAutoFocus_ = allow;
  if (allow) {
    this.setFocusable(true);
  }
};


/**
 * @return {boolean} Whether the menu can automatically move focus to its key
 *     event target when it is set to visible.
 */
goog.ui.Menu.prototype.getAllowAutoFocus = function() {
  'use strict';
  return this.allowAutoFocus_;
};


/**
 * Sets whether the menu will highlight disabled menu items or skip to the next
 * active item.
 * @param {boolean} allow Whether the menu will highlight disabled menu items or
 *     skip to the next active item.
 */
goog.ui.Menu.prototype.setAllowHighlightDisabled = function(allow) {
  'use strict';
  this.allowHighlightDisabled_ = allow;
};


/**
 * @return {boolean} Whether the menu will highlight disabled menu items or skip
 *     to the next active item.
 */
goog.ui.Menu.prototype.getAllowHighlightDisabled = function() {
  'use strict';
  return this.allowHighlightDisabled_;
};


/**
 * @override
 * @param {boolean} show Whether to show or hide the menu.
 * @param {boolean=} opt_force If true, doesn't check whether the menu
 *     already has the requested visibility, and doesn't dispatch any events.
 * @param {goog.events.Event=} opt_e Mousedown event that caused this menu to
 *     be made visible (ignored if show is false).
 */
goog.ui.Menu.prototype.setVisible = function(show, opt_force, opt_e) {
  'use strict';
  var visibilityChanged =
      goog.ui.Menu.superClass_.setVisible.call(this, show, opt_force);
  if (visibilityChanged && show && this.isInDocument() &&
      this.allowAutoFocus_) {
    this.getKeyEventTarget().focus();
  }
  if (show && opt_e && typeof opt_e.clientX === 'number') {
    this.openingCoords = new goog.math.Coordinate(opt_e.clientX, opt_e.clientY);
  } else {
    this.openingCoords = null;
  }
  return visibilityChanged;
};


/** @override */
goog.ui.Menu.prototype.handleEnterItem = function(e) {
  'use strict';
  if (this.allowAutoFocus_) {
    this.getKeyEventTarget().focus();
  }

  return goog.ui.Menu.superClass_.handleEnterItem.call(this, e);
};


/**
 * Highlights the next item that begins with the specified string.  If no
 * (other) item begins with the given string, the selection is unchanged.
 * @param {string} charStr The prefix to match.
 * @return {boolean} Whether a matching prefix was found.
 */
goog.ui.Menu.prototype.highlightNextPrefix = function(charStr) {
  'use strict';
  var re = new RegExp('^' + goog.string.regExpEscape(charStr), 'i');
  return this.highlightHelper(function(index, max) {
    'use strict';
    // Index is >= -1 because it is set to -1 when nothing is selected.
    var start = index < 0 ? 0 : index;
    var wrapped = false;

    // We always start looking from one after the current, because we
    // keep the current selection only as a last resort. This makes the
    // loop a little awkward in the case where there is no current
    // selection, as we need to stop somewhere but can't just stop
    // when index == start, which is why we need the 'wrapped' flag.
    do {
      ++index;
      if (index == max) {
        index = 0;
        wrapped = true;
      }
      var name = this.getChildAt(index).getCaption();
      if (name && name.match(re)) {
        return index;
      }
    } while (!wrapped || index != start);
    return this.getHighlightedIndex();
  }, this.getHighlightedIndex());
};


/** @override */
goog.ui.Menu.prototype.canHighlightItem = function(item) {
  'use strict';
  return (this.allowHighlightDisabled_ || item.isEnabled()) &&
      item.isVisible() && item.isSupportedState(goog.ui.Component.State.HOVER);
};


/** @override */
goog.ui.Menu.prototype.decorateInternal = function(element) {
  'use strict';
  this.decorateContent(element);
  goog.ui.Menu.superClass_.decorateInternal.call(this, element);
};


/** @override */
goog.ui.Menu.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  var handled = goog.ui.Menu.base(this, 'handleKeyEventInternal', e);
  if (!handled) {
    // Loop through all child components, and for each menu item call its
    // key event handler so that keyboard mnemonics can be handled.
    this.forEachChild(function(menuItem) {
      'use strict';
      if (!handled && menuItem.getMnemonic &&
          menuItem.getMnemonic() == e.keyCode) {
        if (this.isEnabled()) {
          this.setHighlighted(menuItem);
        }
        // We still delegate to handleKeyEvent, so that it can handle
        // enabled/disabled state.
        handled = menuItem.handleKeyEvent(e);
      }
    }, this);
  }
  return handled;
};


/** @override */
goog.ui.Menu.prototype.setHighlightedIndex = function(index) {
  'use strict';
  goog.ui.Menu.base(this, 'setHighlightedIndex', index);

  // Bring the highlighted item into view. This has no effect if the menu is not
  // scrollable.
  var child = this.getChildAt(index);
  if (child) {
    goog.style.scrollIntoContainerView(child.getElement(), this.getElement());
  }
};


/**
 * Decorate menu items located in any descendant node which as been explicitly
 * marked as a 'content' node.
 * @param {Element} element Element to decorate.
 * @protected
 */
goog.ui.Menu.prototype.decorateContent = function(element) {
  'use strict';
  var renderer = this.getRenderer();
  var contentElements = this.getDomHelper().getElementsByTagNameAndClass(
      goog.dom.TagName.DIV, goog.getCssName(renderer.getCssClass(), 'content'),
      element);

  // Some versions of IE do not like it when you access this nodeList
  // with invalid indices. See
  // http://code.google.com/p/closure-library/issues/detail?id=373
  var length = contentElements.length;
  for (var i = 0; i < length; i++) {
    renderer.decorateChildren(this, contentElements[i]);
  }
};

//third_party/javascript/closure/positioning/anchoredposition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Client positioning class.
 */

goog.provide('goog.positioning.AnchoredPosition');

goog.require('goog.positioning');
goog.require('goog.positioning.AbstractPosition');
goog.requireType('goog.math.Box');
goog.requireType('goog.math.Size');



/**
 * Encapsulates a popup position where the popup is anchored at a corner of
 * an element.
 *
 * When using AnchoredPosition, it is recommended that the popup element
 * specified in the Popup constructor or Popup.setElement be absolutely
 * positioned.
 *
 * @param {Element} anchorElement Element the movable element should be
 *     anchored against.
 * @param {goog.positioning.Corner} corner Corner of anchored element the
 *     movable element should be positioned at.
 * @param {number=} opt_overflow Overflow handling mode. Defaults to IGNORE if
 *     not specified. Bitmap, {@see goog.positioning.Overflow}.
 * @constructor
 * @extends {goog.positioning.AbstractPosition}
 */
goog.positioning.AnchoredPosition = function(
    anchorElement, corner, opt_overflow) {
  'use strict';
  /**
   * Element the movable element should be anchored against.
   * @type {Element}
   */
  this.element = anchorElement;

  /**
   * Corner of anchored element the movable element should be positioned at.
   * @type {goog.positioning.Corner}
   */
  this.corner = corner;

  /**
   * Overflow handling mode. Defaults to IGNORE if not specified.
   * Bitmap, {@see goog.positioning.Overflow}.
   * @type {number|undefined}
   * @private
   */
  this.overflow_ = opt_overflow;
};
goog.inherits(
    goog.positioning.AnchoredPosition, goog.positioning.AbstractPosition);


/**
 * Repositions the movable element.
 *
 * @param {Element} movableElement Element to position.
 * @param {goog.positioning.Corner} movableCorner Corner of the movable element
 *     that should be positioned adjacent to the anchored element.
 * @param {goog.math.Box=} opt_margin A margin specifin pixels.
 * @param {goog.math.Size=} opt_preferredSize PreferredSize of the
 *     movableElement (unused in this class).
 * @override
 */
goog.positioning.AnchoredPosition.prototype.reposition = function(
    movableElement, movableCorner, opt_margin, opt_preferredSize) {
  'use strict';
  goog.positioning.positionAtAnchor(
      this.element, this.corner, movableElement, movableCorner, undefined,
      opt_margin, this.overflow_);
};

//third_party/javascript/closure/positioning/anchoredviewportposition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Anchored viewport positioning class.
 */

goog.provide('goog.positioning.AnchoredViewportPosition');

goog.require('goog.positioning');
goog.require('goog.positioning.AnchoredPosition');
goog.require('goog.positioning.Overflow');
goog.require('goog.positioning.OverflowStatus');
goog.requireType('goog.math.Box');
goog.requireType('goog.math.Size');



/**
 * Encapsulates a popup position where the popup is anchored at a corner of
 * an element. The corners are swapped if dictated by the viewport. For instance
 * if a popup is anchored with its top left corner to the bottom left corner of
 * the anchor the popup is either displayed below the anchor (as specified) or
 * above it if there's not enough room to display it below.
 *
 * When using this positioning object it's recommended that the movable element
 * be absolutely positioned.
 *
 * @param {Element} anchorElement Element the movable element should be
 *     anchored against.
 * @param {goog.positioning.Corner} corner Corner of anchored element the
 *     movable element should be positioned at.
 * @param {boolean=} opt_adjust Whether the positioning should be adjusted until
 *     the element fits inside the viewport even if that means that the anchored
 *     corners are ignored.
 * @param {goog.math.Box=} opt_overflowConstraint Box object describing the
 *     dimensions in which the movable element could be shown.
 * @constructor
 * @extends {goog.positioning.AnchoredPosition}
 */
goog.positioning.AnchoredViewportPosition = function(
    anchorElement, corner, opt_adjust, opt_overflowConstraint) {
  'use strict';
  goog.positioning.AnchoredPosition.call(this, anchorElement, corner);

  /**
   * The last resort algorithm to use if the algorithm can't fit inside
   * the viewport.
   *
   * IGNORE = do nothing, just display at the preferred position.
   *
   * ADJUST_X | ADJUST_Y = Adjust until the element fits, even if that means
   * that the anchored corners are ignored.
   *
   * @type {number}
   * @private
   */
  this.lastResortOverflow_ = opt_adjust ? (goog.positioning.Overflow.ADJUST_X |
                                           goog.positioning.Overflow.ADJUST_Y) :
                                          goog.positioning.Overflow.IGNORE;

  /**
   * The dimensions in which the movable element could be shown.
   * @type {goog.math.Box|undefined}
   * @private
   */
  this.overflowConstraint_ = opt_overflowConstraint || undefined;
};
goog.inherits(
    goog.positioning.AnchoredViewportPosition,
    goog.positioning.AnchoredPosition);


/**
 * @return {goog.math.Box|undefined} The box object describing the
 *     dimensions in which the movable element will be shown.
 */
goog.positioning.AnchoredViewportPosition.prototype.getOverflowConstraint =
    function() {
  'use strict';
  return this.overflowConstraint_;
};


/**
 * @param {goog.math.Box|undefined} overflowConstraint Box object describing the
 *     dimensions in which the movable element could be shown.
 */
goog.positioning.AnchoredViewportPosition.prototype.setOverflowConstraint =
    function(overflowConstraint) {
  'use strict';
  this.overflowConstraint_ = overflowConstraint;
};


/**
 * @return {number} A bitmask for the "last resort" overflow.
 */
goog.positioning.AnchoredViewportPosition.prototype.getLastResortOverflow =
    function() {
  'use strict';
  return this.lastResortOverflow_;
};


/**
 * @param {number} lastResortOverflow A bitmask for the "last resort" overflow,
 *     if we fail to fit the element on-screen.
 */
goog.positioning.AnchoredViewportPosition.prototype.setLastResortOverflow =
    function(lastResortOverflow) {
  'use strict';
  this.lastResortOverflow_ = lastResortOverflow;
};


/**
 * Repositions the movable element.
 *
 * @param {Element} movableElement Element to position.
 * @param {goog.positioning.Corner} movableCorner Corner of the movable element
 *     that should be positioned adjacent to the anchored element.
 * @param {goog.math.Box=} opt_margin A margin specified in pixels.
 * @param {goog.math.Size=} opt_preferredSize The preferred size of the
 *     movableElement.
 * @override
 */
goog.positioning.AnchoredViewportPosition.prototype.reposition = function(
    movableElement, movableCorner, opt_margin, opt_preferredSize) {
  'use strict';
  var status = goog.positioning.positionAtAnchor(
      this.element, this.corner, movableElement, movableCorner, null,
      opt_margin,
      goog.positioning.Overflow.FAIL_X | goog.positioning.Overflow.FAIL_Y,
      opt_preferredSize, this.overflowConstraint_);

  // If the desired position is outside the viewport try mirroring the corners
  // horizontally or vertically.
  if (status & goog.positioning.OverflowStatus.FAILED) {
    var cornerFallback = this.adjustCorner(status, this.corner);
    var movableCornerFallback = this.adjustCorner(status, movableCorner);

    status = goog.positioning.positionAtAnchor(
        this.element, cornerFallback, movableElement, movableCornerFallback,
        null, opt_margin,
        goog.positioning.Overflow.FAIL_X | goog.positioning.Overflow.FAIL_Y,
        opt_preferredSize, this.overflowConstraint_);

    if (status & goog.positioning.OverflowStatus.FAILED) {
      // If that also fails, pick the best corner from the two tries,
      // and adjust the position until it fits.
      cornerFallback = this.adjustCorner(status, cornerFallback);
      movableCornerFallback = this.adjustCorner(status, movableCornerFallback);

      goog.positioning.positionAtAnchor(
          this.element, cornerFallback, movableElement, movableCornerFallback,
          null, opt_margin, this.getLastResortOverflow(), opt_preferredSize,
          this.overflowConstraint_);
    }
  }
};


/**
 * Adjusts the corner if X or Y positioning failed.
 * @param {number} status The status of the last positionAtAnchor call.
 * @param {goog.positioning.Corner} corner The corner to adjust.
 * @return {goog.positioning.Corner} The adjusted corner.
 * @protected
 */
goog.positioning.AnchoredViewportPosition.prototype.adjustCorner = function(
    status, corner) {
  'use strict';
  if (status & goog.positioning.OverflowStatus.FAILED_HORIZONTAL) {
    corner = goog.positioning.flipCornerHorizontal(corner);
  }

  if (status & goog.positioning.OverflowStatus.FAILED_VERTICAL) {
    corner = goog.positioning.flipCornerVertical(corner);
  }

  return corner;
};

//third_party/javascript/closure/positioning/menuanchoredposition.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Anchored viewport positioning class with both adjust and
 *     resize options for the popup.
 */

goog.provide('goog.positioning.MenuAnchoredPosition');

goog.require('goog.positioning.AnchoredViewportPosition');
goog.require('goog.positioning.Overflow');
goog.requireType('goog.positioning.Corner');



/**
 * Encapsulates a popup position where the popup is anchored at a corner of
 * an element.  The positioning behavior changes based on the values of
 * opt_adjust and opt_resize.
 *
 * When using this positioning object it's recommended that the movable element
 * be absolutely positioned.
 *
 * @param {Element} anchorElement Element the movable element should be
 *     anchored against.
 * @param {goog.positioning.Corner} corner Corner of anchored element the
 *     movable element should be positioned at.
 * @param {boolean=} opt_adjust Whether the positioning should be adjusted until
 *     the element fits inside the viewport even if that means that the anchored
 *     corners are ignored.
 * @param {boolean=} opt_resize Whether the positioning should be adjusted until
 *     the element fits inside the viewport on the X axis and its height is
 *     resized so if fits in the viewport. This take precedence over opt_adjust.
 * @constructor
 * @extends {goog.positioning.AnchoredViewportPosition}
 */
goog.positioning.MenuAnchoredPosition = function(
    anchorElement, corner, opt_adjust, opt_resize) {
  'use strict';
  goog.positioning.AnchoredViewportPosition.call(
      this, anchorElement, corner, opt_adjust || opt_resize);

  if (opt_adjust || opt_resize) {
    var overflowX = goog.positioning.Overflow.ADJUST_X_EXCEPT_OFFSCREEN;
    var overflowY = opt_resize ?
        goog.positioning.Overflow.RESIZE_HEIGHT :
        goog.positioning.Overflow.ADJUST_Y_EXCEPT_OFFSCREEN;
    this.setLastResortOverflow(overflowX | overflowY);
  }
};
goog.inherits(
    goog.positioning.MenuAnchoredPosition,
    goog.positioning.AnchoredViewportPosition);

//third_party/javascript/closure/ui/menubuttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.MenuButton}s and subclasses.
 */

goog.provide('goog.ui.MenuButtonRenderer');

goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.style');
goog.require('goog.ui.CustomButtonRenderer');
goog.require('goog.ui.INLINE_BLOCK_CLASSNAME');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuRenderer');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');



/**
 * Renderer for {@link goog.ui.MenuButton}s.  This implementation overrides
 * {@link goog.ui.CustomButtonRenderer#createButton} to create a separate
 * caption and dropdown element.
 * @constructor
 * @extends {goog.ui.CustomButtonRenderer}
 */
goog.ui.MenuButtonRenderer = function() {
  'use strict';
  goog.ui.CustomButtonRenderer.call(this);
};
goog.inherits(goog.ui.MenuButtonRenderer, goog.ui.CustomButtonRenderer);
goog.addSingletonGetter(goog.ui.MenuButtonRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.MenuButtonRenderer.CSS_CLASS = goog.getCssName('goog-menu-button');


/**
 * Takes the button's root element and returns the parent element of the
 * button's contents.  Overrides the superclass implementation by taking
 * the nested DIV structure of menu buttons into account.
 * @param {Element} element Root element of the button whose content element
 *     is to be returned.
 * @return {Element} The button's content element.
 * @override
 */
goog.ui.MenuButtonRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return goog.ui.MenuButtonRenderer.superClass_.getContentElement.call(
      this,
      /** @type {Element} */ (element && element.firstChild));
};


/**
 * Takes an element, decorates it with the menu button control, and returns
 * the element.  Overrides {@link goog.ui.CustomButtonRenderer#decorate} by
 * looking for a child element that can be decorated by a menu, and if it
 * finds one, decorates it and attaches it to the menu button.
 * @param {goog.ui.Control} control goog.ui.MenuButton to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 * @override
 */
goog.ui.MenuButtonRenderer.prototype.decorate = function(control, element) {
  'use strict';
  var button = /** @type {goog.ui.MenuButton} */ (control);
  // TODO(attila):  Add more robust support for subclasses of goog.ui.Menu.
  var menuElem = goog.dom.getElementsByTagNameAndClass(
      '*', goog.ui.MenuRenderer.CSS_CLASS, element)[0];
  if (menuElem) {
    // Move the menu element directly under the body (but hide it first to
    // prevent flicker; see bug 1089244).
    goog.style.setElementShown(menuElem, false);
    goog.dom.appendChild(goog.dom.getOwnerDocument(menuElem).body, menuElem);

    // Decorate the menu and attach it to the button.
    var menu = new goog.ui.Menu();
    menu.decorate(menuElem);
    button.setMenu(menu);
  }

  // Let the superclass do the rest.
  return goog.ui.MenuButtonRenderer.superClass_.decorate.call(
      this, button, element);
};


/**
 * Takes a text caption or existing DOM structure, and returns the content and
 * a dropdown arrow element wrapped in a pseudo-rounded-corner box.  Creates
 * the following DOM structure:
 *
 *    <div class="goog-inline-block goog-menu-button-outer-box">
 *      <div class="goog-inline-block goog-menu-button-inner-box">
 *        <div class="goog-inline-block goog-menu-button-caption">
 *          Contents...
 *        </div>
 *        <div class="goog-inline-block goog-menu-button-dropdown">
 *          &nbsp;
 *        </div>
 *      </div>
 *    </div>
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure
 *     to wrap in a box.
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Pseudo-rounded-corner box containing the content.
 * @override
 */
goog.ui.MenuButtonRenderer.prototype.createButton = function(content, dom) {
  'use strict';
  return goog.ui.MenuButtonRenderer.superClass_.createButton.call(
      this, [this.createCaption(content, dom), this.createDropdown(dom)], dom);
};


/**
 * Takes a text caption or existing DOM structure, and returns it wrapped in
 * an appropriately-styled DIV.  Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-menu-button-caption">
 *      Contents...
 *    </div>
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure
 *     to wrap in a box.
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Caption element.
 */
goog.ui.MenuButtonRenderer.prototype.createCaption = function(content, dom) {
  'use strict';
  return goog.ui.MenuButtonRenderer.wrapCaption(
      content, this.getCssClass(), dom);
};


/**
 * Takes a text caption or existing DOM structure, and returns it wrapped in
 * an appropriately-styled DIV.  Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-menu-button-caption">
 *      Contents...
 *    </div>
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure
 *     to wrap in a box.
 * @param {string} cssClass The CSS class for the renderer.
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Caption element.
 */
goog.ui.MenuButtonRenderer.wrapCaption = function(content, cssClass, dom) {
  'use strict';
  return dom.createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
          goog.getCssName(cssClass, 'caption'),
      content);
};


/**
 * Returns an appropriately-styled DIV containing a dropdown arrow element.
 * Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-menu-button-dropdown">
 *      &nbsp;
 *    </div>
 *
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Dropdown element.
 */
goog.ui.MenuButtonRenderer.prototype.createDropdown = function(dom) {
  'use strict';
  // 00A0 is &nbsp;
  return dom.createDom(
      goog.dom.TagName.DIV, goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
          goog.getCssName(this.getCssClass(), 'dropdown'),
      '\u00A0');
};


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.MenuButtonRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.MenuButtonRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/submenurenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.SubMenu}s.
 */

goog.provide('goog.ui.SubMenuRenderer');

goog.forwardDeclare('goog.ui.SubMenu');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classlist');
goog.require('goog.style');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuItemRenderer');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');



/**
 * Default renderer for {@link goog.ui.SubMenu}s.  Each item has the following
 * structure:
 *
 *    <div class="goog-submenu">
 *      ...(menuitem content)...
 *      <div class="goog-menu">
 *        ... (submenu content) ...
 *      </div>
 *    </div>
 *
 * @constructor
 * @extends {goog.ui.MenuItemRenderer}
 */
goog.ui.SubMenuRenderer = function() {
  'use strict';
  goog.ui.MenuItemRenderer.call(this);
};
goog.inherits(goog.ui.SubMenuRenderer, goog.ui.MenuItemRenderer);
goog.addSingletonGetter(goog.ui.SubMenuRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.SubMenuRenderer.CSS_CLASS = goog.getCssName('goog-submenu');


/**
 * The CSS class for submenus that displays the submenu arrow.
 * @type {string}
 * @private
 */
goog.ui.SubMenuRenderer.CSS_CLASS_SUBMENU_ =
    goog.getCssName('goog-submenu-arrow');


/**
 * Overrides {@link goog.ui.MenuItemRenderer#createDom} by adding
 * the additional class 'goog-submenu' to the created element,
 * and passes the element to {@link goog.ui.SubMenuItemRenderer#addArrow_}
 * to add an child element that can be styled to show an arrow.
 * @param {goog.ui.Control} control goog.ui.SubMenu to render.
 * @return {!Element} Root element for the item.
 * @override
 */
goog.ui.SubMenuRenderer.prototype.createDom = function(control) {
  'use strict';
  var subMenu = /** @type {goog.ui.SubMenu} */ (control);
  var element =
      goog.ui.SubMenuRenderer.superClass_.createDom.call(this, subMenu);
  goog.asserts.assert(element);
  goog.dom.classlist.add(element, goog.ui.SubMenuRenderer.CSS_CLASS);
  this.addArrow_(subMenu, element);
  return element;
};


/**
 * Overrides {@link goog.ui.MenuItemRenderer#decorate} by adding
 * the additional class 'goog-submenu' to the decorated element,
 * and passing the element to {@link goog.ui.SubMenuItemRenderer#addArrow_}
 * to add a child element that can be styled to show an arrow.
 * Also searches the element for a child with the class goog-menu. If a
 * matching child element is found, creates a goog.ui.Menu, uses it to
 * decorate the child element, and passes that menu to subMenu.setMenu.
 * @param {goog.ui.Control} control goog.ui.SubMenu to render.
 * @param {Element} element Element to decorate.
 * @return {!Element} Root element for the item.
 * @override
 */
goog.ui.SubMenuRenderer.prototype.decorate = function(control, element) {
  'use strict';
  var subMenu = /** @type {goog.ui.SubMenu} */ (control);
  element =
      goog.ui.SubMenuRenderer.superClass_.decorate.call(this, subMenu, element);
  goog.asserts.assert(element);
  goog.dom.classlist.add(element, goog.ui.SubMenuRenderer.CSS_CLASS);
  this.addArrow_(subMenu, element);

  // Search for a child menu and decorate it.
  var childMenuEls = goog.dom.getElementsByTagNameAndClass(
      goog.dom.TagName.DIV, goog.getCssName('goog-menu'), element);
  if (childMenuEls.length) {
    var childMenu = new goog.ui.Menu(subMenu.getDomHelper());
    var childMenuEl = childMenuEls[0];
    // Hide the menu element before attaching it to the document body; see
    // bug 1089244.
    goog.style.setElementShown(childMenuEl, false);
    subMenu.getDomHelper().getDocument().body.appendChild(childMenuEl);
    childMenu.decorate(childMenuEl);
    subMenu.setMenu(childMenu, true);
  }
  return element;
};


/**
 * Takes a menu item's root element, and sets its content to the given text
 * caption or DOM structure.  Overrides the superclass immplementation by
 * making sure that the submenu arrow structure is preserved.
 * @param {Element} element The item's root element.
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to be
 *     set as the item's content.
 * @override
 */
goog.ui.SubMenuRenderer.prototype.setContent = function(element, content) {
  'use strict';
  // Save the submenu arrow element, if present.
  var contentElement = this.getContentElement(element);
  var arrowElement = contentElement && contentElement.lastChild;
  goog.ui.SubMenuRenderer.superClass_.setContent.call(this, element, content);
  // If the arrowElement was there, is no longer there, and really was an arrow,
  // reappend it.
  if (arrowElement && contentElement.lastChild != arrowElement &&
      goog.dom.classlist.contains(
          /** @type {!Element} */ (arrowElement),
          goog.ui.SubMenuRenderer.CSS_CLASS_SUBMENU_)) {
    contentElement.appendChild(arrowElement);
  }
};


/**
 * Overrides {@link goog.ui.MenuItemRenderer#initializeDom} to tweak
 * the DOM structure for the span.goog-submenu-arrow element
 * depending on the text direction (LTR or RTL). When the SubMenu is RTL
 * the arrow will be given the additional class of goog-submenu-arrow-rtl,
 * and the arrow will be moved up to be the first child in the SubMenu's
 * element. Otherwise the arrow will have the class goog-submenu-arrow-ltr,
 * and be kept as the last child of the SubMenu's element.
 * @param {goog.ui.Control} control goog.ui.SubMenu whose DOM is to be
 *     initialized as it enters the document.
 * @override
 */
goog.ui.SubMenuRenderer.prototype.initializeDom = function(control) {
  'use strict';
  var subMenu = /** @type {goog.ui.SubMenu} */ (control);
  goog.ui.SubMenuRenderer.superClass_.initializeDom.call(this, subMenu);
  var element = subMenu.getContentElement();
  var arrow = subMenu.getDomHelper().getElementsByTagNameAndClass(
      goog.dom.TagName.SPAN, goog.ui.SubMenuRenderer.CSS_CLASS_SUBMENU_,
      element)[0];
  goog.ui.SubMenuRenderer.setArrowTextContent_(subMenu, arrow);
  if (arrow != element.lastChild) {
    element.appendChild(arrow);
  }
  var subMenuElement = subMenu.getElement();
  goog.asserts.assert(
      subMenuElement, 'The sub menu DOM element cannot be null.');
  goog.a11y.aria.setState(
      subMenuElement, goog.a11y.aria.State.HASPOPUP, 'true');
};


/**
 * Appends a child node with the class goog.getCssName('goog-submenu-arrow') or
 * 'goog-submenu-arrow-rtl' which can be styled to show an arrow.
 * @param {goog.ui.SubMenu} subMenu SubMenu to render.
 * @param {Element} element Element to decorate.
 * @private
 */
goog.ui.SubMenuRenderer.prototype.addArrow_ = function(subMenu, element) {
  'use strict';
  var arrow = subMenu.getDomHelper().createDom(goog.dom.TagName.SPAN);
  arrow.className = goog.ui.SubMenuRenderer.CSS_CLASS_SUBMENU_;
  goog.ui.SubMenuRenderer.setArrowTextContent_(subMenu, arrow);
  this.getContentElement(element).appendChild(arrow);
};


/**
 * The unicode char for a left arrow.
 * @type {string}
 * @private
 */
goog.ui.SubMenuRenderer.LEFT_ARROW_ = '\u25C4';


/**
 * The unicode char for a right arrow.
 * @type {string}
 * @private
 */
goog.ui.SubMenuRenderer.RIGHT_ARROW_ = '\u25BA';


/**
 * Set the text content of an arrow.
 * @param {goog.ui.SubMenu} subMenu The sub menu that owns the arrow.
 * @param {Element} arrow The arrow element.
 * @private
 */
goog.ui.SubMenuRenderer.setArrowTextContent_ = function(subMenu, arrow) {
  'use strict';
  // Fix arrow rtl
  var leftArrow = goog.ui.SubMenuRenderer.LEFT_ARROW_;
  var rightArrow = goog.ui.SubMenuRenderer.RIGHT_ARROW_;

  goog.asserts.assert(arrow);

  if (subMenu.isRightToLeft()) {
    goog.dom.classlist.add(arrow, goog.getCssName('goog-submenu-arrow-rtl'));
    // Unicode character - Black left-pointing pointer iff aligned to end.
    goog.dom.setTextContent(
        arrow, subMenu.isAlignedToEnd() ? leftArrow : rightArrow);
  } else {
    goog.dom.classlist.remove(arrow, goog.getCssName('goog-submenu-arrow-rtl'));
    // Unicode character - Black right-pointing pointer iff aligned to end.
    goog.dom.setTextContent(
        arrow, subMenu.isAlignedToEnd() ? rightArrow : leftArrow);
  }
};

//third_party/javascript/closure/ui/submenu.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class representing menu items that open a submenu.
 * @see goog.ui.Menu
 *
 * @see ../demos/submenus.html
 * @see ../demos/submenus2.html
 */

goog.provide('goog.ui.SubMenu');

goog.require('goog.Timer');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.events.KeyCodes');
goog.require('goog.positioning.AnchoredViewportPosition');
goog.require('goog.positioning.Corner');
goog.require('goog.style');
goog.require('goog.ui.Component');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.SubMenuRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.events.BrowserEvent');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.KeyEvent');
goog.requireType('goog.ui.ControlContent');
goog.requireType('goog.ui.MenuHeader');
goog.requireType('goog.ui.MenuItemRenderer');
goog.requireType('goog.ui.MenuSeparator');



/**
 * Class representing a submenu that can be added as an item to other menus.
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to
 *     display as the content of the submenu (use to add icons or styling to
 *     menus).
 * @param {*=} opt_model Data/model associated with the menu item.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional dom helper used for dom
 *     interactions.
 * @param {goog.ui.MenuItemRenderer=} opt_renderer Renderer used to render or
 *     decorate the component; defaults to {@link goog.ui.SubMenuRenderer}.
 * @constructor
 * @extends {goog.ui.MenuItem}
 */
goog.ui.SubMenu = function(content, opt_model, opt_domHelper, opt_renderer) {
  'use strict';
  goog.ui.MenuItem.call(
      this, content, opt_model, opt_domHelper,
      opt_renderer || goog.ui.SubMenuRenderer.getInstance());
};
goog.inherits(goog.ui.SubMenu, goog.ui.MenuItem);


/**
 * The delay before opening the sub menu in milliseconds.
 * @type {number}
 */
goog.ui.SubMenu.MENU_DELAY_MS = 218;


/**
 * Timer used to dismiss the submenu when the item becomes unhighlighted.
 * @type {?number}
 * @private
 */
goog.ui.SubMenu.prototype.dismissTimer_ = null;


/**
 * Timer used to show the submenu on mouseover.
 * @type {?number}
 * @private
 */
goog.ui.SubMenu.prototype.showTimer_ = null;


/**
 * Whether the submenu believes the menu is visible.
 * @type {boolean}
 * @private
 */
goog.ui.SubMenu.prototype.menuIsVisible_ = false;


/**
 * The lazily created sub menu.
 * @type {goog.ui.Menu?}
 * @private
 */
goog.ui.SubMenu.prototype.subMenu_ = null;


/**
 * Whether or not the sub-menu was set explicitly.
 * @type {boolean}
 * @private
 */
goog.ui.SubMenu.prototype.externalSubMenu_ = false;


/**
 * Whether or not to align the submenu at the end of the parent menu.
 * If true, the menu expands to the right in LTR languages and to the left
 * in RTL langauges.
 * @type {boolean}
 * @private
 */
goog.ui.SubMenu.prototype.alignToEnd_ = true;


/**
 * Whether the position of this submenu may be adjusted to fit
 * the visible area, as in {@link goog.ui.Popup.positionAtCoordinate}.
 * @type {boolean}
 * @private
 */
goog.ui.SubMenu.prototype.isPositionAdjustable_ = false;


/** @override */
goog.ui.SubMenu.prototype.enterDocument = function() {
  'use strict';
  goog.ui.SubMenu.superClass_.enterDocument.call(this);

  this.getHandler().listen(
      this.getParent(), goog.ui.Component.EventType.HIDE, this.onParentHidden_);

  if (this.subMenu_) {
    this.setMenuListenersEnabled_(this.subMenu_, true);
  }
};


/** @override */
goog.ui.SubMenu.prototype.exitDocument = function() {
  'use strict';
  this.getHandler().unlisten(
      this.getParent(), goog.ui.Component.EventType.HIDE, this.onParentHidden_);

  if (this.subMenu_) {
    this.setMenuListenersEnabled_(this.subMenu_, false);
    if (!this.externalSubMenu_) {
      this.subMenu_.exitDocument();
      goog.dom.removeNode(this.subMenu_.getElement());
    }
  }

  goog.ui.SubMenu.superClass_.exitDocument.call(this);
};


/** @override */
goog.ui.SubMenu.prototype.disposeInternal = function() {
  'use strict';
  if (this.subMenu_ && !this.externalSubMenu_) {
    this.subMenu_.dispose();
  }
  this.subMenu_ = null;
  goog.ui.SubMenu.superClass_.disposeInternal.call(this);
};


/**
 * @override
 * Dismisses the submenu on a delay, with the result that the user needs less
 * accuracy when moving to submenus.  Alternate implementations could use
 * geometry instead of a timer.
 * @param {boolean} highlight Whether item should be highlighted.
 * @param {boolean=} opt_btnPressed Whether the mouse button is held down.
 */
goog.ui.SubMenu.prototype.setHighlighted = function(highlight, opt_btnPressed) {
  'use strict';
  goog.ui.SubMenu.superClass_.setHighlighted.call(this, highlight);

  if (opt_btnPressed) {
    this.getMenu().setMouseButtonPressed(true);
  }

  if (!highlight) {
    if (this.dismissTimer_) {
      goog.Timer.clear(this.dismissTimer_);
    }
    this.dismissTimer_ =
        goog.Timer.callOnce(this.dismissSubMenu, this.getMenuDelay(), this);
  }
};


/**
 * Show the submenu and ensure that all siblings are hidden.
 */
goog.ui.SubMenu.prototype.showSubMenu = function() {
  'use strict';
  // Only show the menu if this item is still selected. This is called on a
  // timeout, so make sure our parent still exists.
  var parent = this.getParent();
  if (parent && parent.getHighlighted() == this) {
    this.setSubMenuVisible_(true);
    this.dismissSiblings_();
  }
};


/**
 * Dismisses the menu and all further submenus.
 */
goog.ui.SubMenu.prototype.dismissSubMenu = function() {
  'use strict';
  // Because setHighlighted calls this function on a timeout, we need to make
  // sure that the sub menu hasn't been disposed when we come back.
  var subMenu = this.subMenu_;
  if (subMenu && subMenu.getParent() == this) {
    this.setSubMenuVisible_(false);
    subMenu.forEachChild(function(child) {
      'use strict';
      if (typeof child.dismissSubMenu == 'function') {
        child.dismissSubMenu();
      }
    });
  }
};


/**
 * Clears the show and hide timers for the sub menu.
 */
goog.ui.SubMenu.prototype.clearTimers = function() {
  'use strict';
  if (this.dismissTimer_) {
    goog.Timer.clear(this.dismissTimer_);
  }
  if (this.showTimer_) {
    goog.Timer.clear(this.showTimer_);
  }
};


/**
 * Sets the menu item to be visible or invisible.
 * @param {boolean} visible Whether to show or hide the component.
 * @param {boolean=} opt_force If true, doesn't check whether the component
 *     already has the requested visibility, and doesn't dispatch any events.
 * @return {boolean} Whether the visibility was changed.
 * @override
 */
goog.ui.SubMenu.prototype.setVisible = function(visible, opt_force) {
  'use strict';
  var visibilityChanged =
      goog.ui.SubMenu.superClass_.setVisible.call(this, visible, opt_force);
  // For menus that allow menu items to be hidden (i.e. ComboBox) ensure that
  // the submenu is hidden.
  if (visibilityChanged && !this.isVisible()) {
    this.dismissSubMenu();
  }
  return visibilityChanged;
};


/**
 * Dismiss all the sub menus of sibling menu items.
 * @private
 */
goog.ui.SubMenu.prototype.dismissSiblings_ = function() {
  'use strict';
  this.getParent().forEachChild(function(child) {
    'use strict';
    if (child != this && typeof child.dismissSubMenu == 'function') {
      child.dismissSubMenu();
      child.clearTimers();
    }
  }, this);
};


/**
 * Handles a key event that is passed to the menu item from its parent because
 * it is highlighted.  If the arrow keys or enter key is pressed the sub menu
 * takes control and delegates further key events to its menu until it is
 * dismissed.
 * @param {goog.events.KeyEvent} e A key event.
 * @return {boolean} Whether the event was handled.
 * @override
 */
goog.ui.SubMenu.prototype.handleKeyEvent = function(e) {
  'use strict';
  var keyCode = e.keyCode;
  var arrowOpenKeyCode = this.isRightToLeft() ? goog.events.KeyCodes.LEFT :
                                                goog.events.KeyCodes.RIGHT;
  var closeKeyCode = this.isRightToLeft() ? goog.events.KeyCodes.RIGHT :
                                            goog.events.KeyCodes.LEFT;

  if (!this.menuIsVisible_) {
    // Menu item doesn't have keyboard control and the correct key was pressed.
    // So open take keyboard control and open the sub menu.
    if (this.isEnabled() &&
        (keyCode == arrowOpenKeyCode || keyCode == goog.events.KeyCodes.ENTER ||
         keyCode == this.getMnemonic())) {
      this.showSubMenu();
      this.getMenu().highlightFirst();
      this.clearTimers();

      // The menu item doesn't currently care about the key events so let the
      // parent menu handle them accordingly .
    } else {
      return false;
    }

    // Menu item has control, so let its menu try to handle the keys (this may
    // in turn be handled by sub-sub menus).
  } else if (this.getMenu().handleKeyEvent(e)) {
    // Nothing to do

    // The menu has control and the key hasn't yet been handled, on left arrow
    // we turn off key control.
  } else if (keyCode == closeKeyCode) {
    this.dismissSubMenu();

  } else {
    // Submenu didn't handle the key so let the parent decide what to do.
    return false;
  }

  e.preventDefault();
  return true;
};


/**
 * Listens to the sub menus items and ensures that this menu item is selected
 * while dismissing the others.  This handles the case when the user mouses
 * over other items on their way to the sub menu.
 * @param {goog.events.Event} e Enter event to handle.
 * @private
 */
goog.ui.SubMenu.prototype.onChildEnter_ = function(e) {
  'use strict';
  if (this.subMenu_.getParent() == this) {
    this.clearTimers();
    this.getParentEventTarget().setHighlighted(this);
    this.dismissSiblings_();
  }
};


/**
 * Listens to the parent menu's hide event and ensures that all submenus are
 * hidden at the same time.
 * @param {goog.events.Event} e The event.
 * @private
 */
goog.ui.SubMenu.prototype.onParentHidden_ = function(e) {
  'use strict';
  // Ignore propagated events
  if (e.target == this.getParentEventTarget()) {
    // TODO(pupius): Using an event for this is expensive.  Consider having a
    // generalized interface that the parent menu calls on its children when
    // it is hidden.
    this.dismissSubMenu();
    this.clearTimers();
  }
};


/**
 * @override
 * Sets a timer to show the submenu and then dispatches an ENTER event to the
 * parent menu.
 * @param {goog.events.BrowserEvent} e Mouse event to handle.
 */
goog.ui.SubMenu.prototype.handleMouseOver = function(e) {
  'use strict';
  if (this.isEnabled()) {
    this.clearTimers();
    this.showTimer_ =
        goog.Timer.callOnce(this.showSubMenu, this.getMenuDelay(), this);
  }
  goog.ui.SubMenu.superClass_.handleMouseOver.call(this, e);
};


/**
 * Returns the delay before opening or closing the menu in milliseconds.
 * @return {number}
 * @protected
 */
goog.ui.SubMenu.prototype.getMenuDelay = function() {
  'use strict';
  return goog.ui.SubMenu.MENU_DELAY_MS;
};


/**
 * Overrides the default mouseup event handler, so that the ACTION isn't
 * dispatched for the submenu itself, instead the submenu is shown instantly.
 * @param {goog.events.Event} e The browser event.
 * @return {boolean} True if the action was allowed to proceed, false otherwise.
 * @override
 */
goog.ui.SubMenu.prototype.performActionInternal = function(e) {
  'use strict';
  this.clearTimers();
  var shouldHandleClick =
      this.isSupportedState(goog.ui.Component.State.SELECTED) ||
      this.isSupportedState(goog.ui.Component.State.CHECKED);
  if (shouldHandleClick) {
    return goog.ui.SubMenu.superClass_.performActionInternal.call(this, e);
  } else {
    this.showSubMenu();
    return true;
  }
};


/**
 * Sets the visiblility of the sub menu.
 * @param {boolean} visible Whether to show menu.
 * @private
 */
goog.ui.SubMenu.prototype.setSubMenuVisible_ = function(visible) {
  'use strict';
  // Unhighlighting the menuitems if closing the menu so the event handlers can
  // determine the correct state.
  if (!visible && this.getMenu()) {
    this.getMenu().setHighlightedIndex(-1);
  }

  // Dispatch OPEN event before calling getMenu(), so we can create the menu
  // lazily on first access.
  this.dispatchEvent(
      goog.ui.Component.getStateTransitionEvent(
          goog.ui.Component.State.OPENED, visible));
  var subMenu = this.getMenu();
  if (visible != this.menuIsVisible_) {
    goog.dom.classlist.enable(
        goog.asserts.assert(this.getElement()),
        goog.getCssName('goog-submenu-open'), visible);
  }
  if (visible != subMenu.isVisible()) {
    if (visible) {
      // Lazy-render menu when first shown, if needed.
      if (!subMenu.isInDocument()) {
        subMenu.render();
      }
      subMenu.setHighlightedIndex(-1);
    }
    subMenu.setVisible(visible);
    // We must position after the menu is visible, otherwise positioning logic
    // breaks in RTL.
    if (visible) {
      this.positionSubMenu();
    }
  }
  this.menuIsVisible_ = visible;
};


/**
 * Attaches or detaches menu event listeners to/from the given menu.  Called
 * each time a menu is attached to or detached from the submenu.
 * @param {goog.ui.Menu} menu Menu on which to listen for events.
 * @param {boolean} attach Whether to attach or detach event listeners.
 * @private
 */
goog.ui.SubMenu.prototype.setMenuListenersEnabled_ = function(menu, attach) {
  'use strict';
  var handler = this.getHandler();
  var method = attach ? handler.listen : handler.unlisten;
  method.call(
      handler, menu, goog.ui.Component.EventType.ENTER, this.onChildEnter_);
};


/**
 * Sets whether the submenu is aligned at the end of the parent menu.
 * @param {boolean} alignToEnd True to align to end, false to align to start.
 */
goog.ui.SubMenu.prototype.setAlignToEnd = function(alignToEnd) {
  'use strict';
  if (alignToEnd != this.alignToEnd_) {
    this.alignToEnd_ = alignToEnd;
    if (this.isInDocument()) {
      // Completely re-render the widget.
      var oldElement = this.getElement();
      this.exitDocument();

      if (oldElement.nextSibling) {
        this.renderBefore(/** @type {!Element} */ (oldElement.nextSibling));
      } else {
        this.render(/** @type {Element} */ (oldElement.parentNode));
      }
    }
  }
};


/**
 * Determines whether the submenu is aligned at the end of the parent menu.
 * @return {boolean} True if aligned to the end (the default), false if
 *     aligned to the start.
 */
goog.ui.SubMenu.prototype.isAlignedToEnd = function() {
  'use strict';
  return this.alignToEnd_;
};


/**
 * Positions the submenu. This method should be called if the sub menu is
 * opened and the menu element's size changes (e.g., when adding/removing items
 * to an opened sub menu).
 */
goog.ui.SubMenu.prototype.positionSubMenu = function() {
  'use strict';
  var position = new goog.positioning.AnchoredViewportPosition(
      this.getElement(),
      this.isAlignedToEnd() ? goog.positioning.Corner.TOP_END :
                              goog.positioning.Corner.TOP_START,
      this.isPositionAdjustable_);

  // TODO(pupius): Clean up popup code and have this be a one line call
  var subMenu = this.getMenu();
  var el = subMenu.getElement();
  if (!subMenu.isVisible()) {
    el.style.visibility = 'hidden';
    goog.style.setElementShown(el, true);
  }

  position.reposition(
      el, this.isAlignedToEnd() ? goog.positioning.Corner.TOP_START :
                                  goog.positioning.Corner.TOP_END);

  if (!subMenu.isVisible()) {
    goog.style.setElementShown(el, false);
    el.style.visibility = 'visible';
  }
};


// Methods delegated to sub-menu but accessible here for convinience


/**
 * Adds a new menu item at the end of the menu.
 * @param {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu
 *     item to add to the menu.
 */
goog.ui.SubMenu.prototype.addItem = function(item) {
  'use strict';
  this.getMenu().addChild(item, true);
};


/**
 * Adds a new menu item at a specific index in the menu.
 * @param {goog.ui.MenuHeader|goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu
 *     item to add to the menu.
 * @param {number} n Index at which to insert the menu item.
 */
goog.ui.SubMenu.prototype.addItemAt = function(item, n) {
  'use strict';
  this.getMenu().addChildAt(item, n, true);
};


/**
 * Removes an item from the menu and disposes it.
 * @param {goog.ui.MenuItem} item The menu item to remove.
 */
goog.ui.SubMenu.prototype.removeItem = function(item) {
  'use strict';
  var child = this.getMenu().removeChild(item, true);
  if (child) {
    child.dispose();
  }
};


/**
 * Removes a menu item at a given index in the menu and disposes it.
 * @param {number} n Index of item.
 */
goog.ui.SubMenu.prototype.removeItemAt = function(n) {
  'use strict';
  var child = this.getMenu().removeChildAt(n, true);
  if (child) {
    child.dispose();
  }
};


/**
 * Returns a reference to the menu item at a given index.
 * @param {number} n Index of menu item.
 * @return {goog.ui.Component} Reference to the menu item.
 */
goog.ui.SubMenu.prototype.getItemAt = function(n) {
  'use strict';
  return this.getMenu().getChildAt(n);
};


/**
 * Returns the number of items in the sub menu (including separators).
 * @return {number} The number of items in the menu.
 */
goog.ui.SubMenu.prototype.getItemCount = function() {
  'use strict';
  return this.getMenu().getChildCount();
};


/**
 * Returns the menu items contained in the sub menu.
 * @return {!Array<!goog.ui.MenuItem>} An array of menu items.
 * @deprecated Use getItemAt/getItemCount instead.
 */
goog.ui.SubMenu.prototype.getItems = function() {
  'use strict';
  return this.getMenu().getItems();
};


/**
 * Gets a reference to the submenu's actual menu.
 * @return {!goog.ui.Menu} Reference to the object representing the sub menu.
 */
goog.ui.SubMenu.prototype.getMenu = function() {
  'use strict';
  if (!this.subMenu_) {
    this.setMenu(
        new goog.ui.Menu(this.getDomHelper()), /* opt_internal */ true);
  } else if (this.externalSubMenu_ && this.subMenu_.getParent() != this) {
    // Since it is possible for the same popup menu to be attached to multiple
    // submenus, we need to ensure that it has the correct parent event target.
    this.subMenu_.setParent(this);
  }
  // Always create the menu DOM, for backward compatibility.
  if (!this.subMenu_.getElement()) {
    this.subMenu_.createDom();
  }
  return this.subMenu_;
};


/**
 * Sets the submenu to a specific menu.
 * @param {goog.ui.Menu} menu The menu to show when this item is selected.
 * @param {boolean=} opt_internal Whether this menu is an "internal" menu, and
 *     should be disposed of when this object is disposed of.
 */
goog.ui.SubMenu.prototype.setMenu = function(menu, opt_internal) {
  'use strict';
  var oldMenu = this.subMenu_;
  if (menu != oldMenu) {
    if (oldMenu) {
      this.dismissSubMenu();
      if (this.isInDocument()) {
        this.setMenuListenersEnabled_(oldMenu, false);
      }
    }

    this.subMenu_ = menu;
    this.externalSubMenu_ = !opt_internal;

    if (menu) {
      menu.setParent(this);
      // There's no need to dispatch a HIDE event during submenu construction.
      menu.setVisible(false, /* opt_force */ true);
      menu.setAllowAutoFocus(false);
      menu.setFocusable(false);
      if (this.isInDocument()) {
        this.setMenuListenersEnabled_(menu, true);
      }
    }
  }
};


/**
 * Returns true if the provided element is to be considered inside the menu for
 * purposes such as dismissing the menu on an event.  This is so submenus can
 * make use of elements outside their own DOM.
 * @param {Element} element The element to test for.
 * @return {boolean} Whether or not the provided element is contained.
 */
goog.ui.SubMenu.prototype.containsElement = function(element) {
  'use strict';
  return this.getMenu().containsElement(element);
};


/**
 * @param {boolean} isAdjustable Whether this submenu is adjustable.
 */
goog.ui.SubMenu.prototype.setPositionAdjustable = function(isAdjustable) {
  'use strict';
  this.isPositionAdjustable_ = !!isAdjustable;
};


/**
 * @return {boolean} Whether this submenu is adjustable.
 */
goog.ui.SubMenu.prototype.isPositionAdjustable = function() {
  'use strict';
  return this.isPositionAdjustable_;
};


// Register a decorator factory function for goog.ui.SubMenus.
goog.ui.registry.setDecoratorByClassName(
    goog.getCssName('goog-submenu'), function() {
      'use strict';
      return new goog.ui.SubMenu(null);
    });

//third_party/javascript/closure/ui/menubutton.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A menu button control.
 *
 * @see ../demos/menubutton.html
 */

goog.provide('goog.ui.MenuButton');

goog.require('goog.Timer');
goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.State');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.events.EventType');
goog.require('goog.events.KeyCodes');
goog.require('goog.events.KeyHandler');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.positioning');
goog.require('goog.positioning.Corner');
goog.require('goog.positioning.MenuAnchoredPosition');
goog.require('goog.positioning.Overflow');
goog.require('goog.style');
goog.require('goog.ui.Button');
goog.require('goog.ui.Component');
goog.require('goog.ui.IdGenerator');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuButtonRenderer');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.MenuRenderer');
goog.require('goog.ui.SubMenu');
goog.require('goog.ui.registry');
goog.requireType('goog.events.BrowserEvent');
goog.requireType('goog.events.Event');
goog.requireType('goog.events.EventTarget');
goog.requireType('goog.math.Size');
goog.requireType('goog.positioning.AnchoredPosition');
goog.requireType('goog.ui.ButtonRenderer');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');
goog.requireType('goog.ui.MenuSeparator');



/**
 * A menu button control.  Extends {@link goog.ui.Button} by composing a button
 * with a dropdown arrow and a popup menu.
 *
 * @param {goog.ui.ControlContent=} opt_content Text caption or existing DOM
 *     structure to display as the button's caption (if any).
 * @param {goog.ui.Menu=} opt_menu Menu to render under the button when clicked.
 * @param {goog.ui.ButtonRenderer=} opt_renderer Renderer used to render or
 *     decorate the menu button; defaults to {@link goog.ui.MenuButtonRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @param {!goog.ui.MenuRenderer=} opt_menuRenderer Renderer used to render or
 *     decorate the menu; defaults to {@link goog.ui.MenuRenderer}.
 * @constructor
 * @extends {goog.ui.Button}
 */
goog.ui.MenuButton = function(
    opt_content, opt_menu, opt_renderer, opt_domHelper, opt_menuRenderer) {
  'use strict';
  goog.ui.Button.call(
      this, opt_content,
      opt_renderer || goog.ui.MenuButtonRenderer.getInstance(), opt_domHelper);

  // Menu buttons support the OPENED state.
  this.setSupportedState(goog.ui.Component.State.OPENED, true);

  /**
   * The menu position on this button.
   * @type {!goog.positioning.AnchoredPosition}
   * @private
   */
  this.menuPosition_ = new goog.positioning.MenuAnchoredPosition(
      null, goog.positioning.Corner.BOTTOM_START);

  if (opt_menu) {
    this.setMenu(opt_menu);
  }
  this.menuMargin_ = null;
  this.timer_ = new goog.Timer(500);  // 0.5 sec

  /**
   * Whether the enter or space key should close the menu, if it is already
   * open. This should be true for accessibility reasons, but is provided as an
   * option for backward compatibility.
   * @private {boolean}
   */
  this.closeOnEnterOrSpace_ = true;

  /** @private {!goog.ui.MenuRenderer} */
  this.menuRenderer_ = opt_menuRenderer || goog.ui.MenuRenderer.getInstance();
};
goog.inherits(goog.ui.MenuButton, goog.ui.Button);


/**
 * The menu.
 * @type {goog.ui.Menu|undefined}
 * @private
 */
goog.ui.MenuButton.prototype.menu_;


/**
 * The position element.  If set, use positionElement_ to position the
 * popup menu instead of the default which is to use the menu button element.
 * @type {Element|undefined}
 * @private
 */
goog.ui.MenuButton.prototype.positionElement_;


/**
 * The margin to apply to the menu's position when it is shown.  If null, no
 * margin will be applied.
 * @type {goog.math.Box}
 * @private
 */
goog.ui.MenuButton.prototype.menuMargin_;


/**
 * Whether the attached popup menu is focusable or not (defaults to false).
 * Popup menus attached to menu buttons usually don't need to be focusable,
 * i.e. the button retains keyboard focus, and forwards key events to the
 * menu for processing.  However, menus like {@link goog.ui.FilteredMenu}
 * need to be focusable.
 * @type {boolean}
 * @private
 */
goog.ui.MenuButton.prototype.isFocusablePopupMenu_ = false;


/**
 * A Timer to correct menu position.
 * @type {goog.Timer}
 * @private
 */
goog.ui.MenuButton.prototype.timer_;


/**
 * The bounding rectangle of the button element.
 * @type {goog.math.Rect}
 * @private
 */
goog.ui.MenuButton.prototype.buttonRect_;


/**
 * The viewport rectangle.
 * @type {goog.math.Box}
 * @private
 */
goog.ui.MenuButton.prototype.viewportBox_;


/**
 * The original size.
 * @type {goog.math.Size|undefined}
 * @private
 */
goog.ui.MenuButton.prototype.originalSize_;


/**
 * Do we render the drop down menu as a sibling to the label, or at the end
 * of the current dom?
 * @type {boolean}
 * @private
 */
goog.ui.MenuButton.prototype.renderMenuAsSibling_ = false;


/**
 * Whether to select the first item in the menu when it is opened using
 * enter or space. By default, the first item is selected only when
 * opened by a key up or down event. When this is on, the first item will
 * be selected due to any of the four events.
 * @private
 */
goog.ui.MenuButton.prototype.selectFirstOnEnterOrSpace_ = false;


/**
 * Sets up event handlers specific to menu buttons.
 * @override
 */
goog.ui.MenuButton.prototype.enterDocument = function() {
  'use strict';
  goog.ui.MenuButton.superClass_.enterDocument.call(this);
  this.attachKeyDownEventListener_(true);
  if (this.menu_) {
    this.attachMenuEventListeners_(this.menu_, true);
  }
  goog.a11y.aria.setState(
      this.getElementStrict(), goog.a11y.aria.State.HASPOPUP, !!this.menu_);
};


/**
 * Removes event handlers specific to menu buttons, and ensures that the
 * attached menu also exits the document.
 * @override
 */
goog.ui.MenuButton.prototype.exitDocument = function() {
  'use strict';
  goog.ui.MenuButton.superClass_.exitDocument.call(this);
  this.attachKeyDownEventListener_(false);
  if (this.menu_) {
    this.setOpen(false);
    this.menu_.exitDocument();
    this.attachMenuEventListeners_(this.menu_, false);

    var menuElement = this.menu_.getElement();
    if (menuElement) {
      goog.dom.removeNode(menuElement);
    }
  }
};


/** @override */
goog.ui.MenuButton.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.MenuButton.superClass_.disposeInternal.call(this);
  if (this.menu_) {
    this.menu_.dispose();
    delete this.menu_;
  }
  delete this.positionElement_;
  this.timer_.dispose();
};


/**
 * Handles mousedown events.  Invokes the superclass implementation to dispatch
 * an ACTIVATE event and activate the button.  Also toggles the visibility of
 * the attached menu.
 * @param {goog.events.Event} e Mouse event to handle.
 * @override
 * @protected
 */
goog.ui.MenuButton.prototype.handleMouseDown = function(e) {
  'use strict';
  goog.ui.MenuButton.superClass_.handleMouseDown.call(this, e);
  if (this.isActive()) {
    // The component was allowed to activate; toggle menu visibility.
    this.setOpen(!this.isOpen(), e);
    if (this.menu_) {
      this.menu_.setMouseButtonPressed(this.isOpen());
    }
  }
};


/**
 * Handles mouseup events.  Invokes the superclass implementation to dispatch
 * an ACTION event and deactivate the button.
 * @param {goog.events.Event} e Mouse event to handle.
 * @override
 * @protected
 */
goog.ui.MenuButton.prototype.handleMouseUp = function(e) {
  'use strict';
  goog.ui.MenuButton.superClass_.handleMouseUp.call(this, e);
  if (this.menu_ && !this.isActive()) {
    this.menu_.setMouseButtonPressed(false);
  }
};


/**
 * Performs the appropriate action when the menu button is activated by the
 * user.  Overrides the superclass implementation by not dispatching an
 * `ACTION` event, because menu buttons exist only to reveal menus, not to
 * perform actions themselves.  Calls {@link #setActive} to deactivate the
 * button.
 * @param {goog.events.Event} e Mouse or key event that triggered the action.
 * @return {boolean} Whether the action was allowed to proceed.
 * @override
 * @protected
 */
goog.ui.MenuButton.prototype.performActionInternal = function(e) {
  'use strict';
  this.setActive(false);
  return true;
};


/**
 * Handles mousedown events over the document.  If the mousedown happens over
 * an element unrelated to the component, hides the menu.
 * TODO(attila): Reconcile this with goog.ui.Popup (and handle frames/windows).
 * @param {goog.events.BrowserEvent} e Mouse event to handle.
 * @protected
 */
goog.ui.MenuButton.prototype.handleDocumentMouseDown = function(e) {
  'use strict';
  if (this.menu_ && this.menu_.isVisible() &&
      !this.containsElement(/** @type {Element} */ (e.target))) {
    // User clicked somewhere else in the document while the menu was visible;
    // dismiss menu.
    this.setOpen(false);
  }
};


/**
 * Returns true if the given element is to be considered part of the component,
 * even if it isn't a DOM descendant of the component's root element.
 * @param {Element} element Element to test (if any).
 * @return {boolean} Whether the element is considered part of the component.
 * @protected
 */
goog.ui.MenuButton.prototype.containsElement = function(element) {
  'use strict';
  return element && goog.dom.contains(this.getElement(), element) ||
      this.menu_ && this.menu_.containsElement(element) || false;
};


/** @override */
goog.ui.MenuButton.prototype.handleKeyEventInternal = function(e) {
  'use strict';
  // Handle SPACE on keyup and all other keys on keypress.
  if (e.keyCode == goog.events.KeyCodes.SPACE) {
    // Prevent page scrolling in Chrome.
    e.preventDefault();
    if (e.type != goog.events.EventType.KEYUP) {
      // Ignore events because KeyCodes.SPACE is handled further down.
      return true;
    }
  } else if (e.type != goog.events.KeyHandler.EventType.KEY) {
    return false;
  }

  if (this.menu_ && this.menu_.isVisible()) {
    // Menu is open.
    const isEnterOrSpace = e.keyCode == goog.events.KeyCodes.ENTER ||
        e.keyCode == goog.events.KeyCodes.SPACE;
    const handledByMenu = this.menu_.handleKeyEvent(e);
    // If the submenu has handled the key event, then defer to it to close the
    // menu if necessary and do not close it here. This is needed because the
    // enter key should keep the submenu open, but should close other types of
    // menu items.
    // Check for this.menu_ again here because some widgets set this.dispose
    // after handleKeyEvent. Example: go/widget-dispose-ex
    const handledBySubMenu = handledByMenu && this.menu_ &&
        this.menu_.getOpenItem() instanceof goog.ui.SubMenu;
    if (!handledBySubMenu &&
        (e.keyCode == goog.events.KeyCodes.ESC ||
         (isEnterOrSpace && this.closeOnEnterOrSpace_))) {
      // Dismiss the menu.
      this.setOpen(false);
      return true;
    }
    return handledByMenu;
  }

  if (e.keyCode == goog.events.KeyCodes.DOWN ||
      e.keyCode == goog.events.KeyCodes.UP ||
      e.keyCode == goog.events.KeyCodes.SPACE ||
      e.keyCode == goog.events.KeyCodes.ENTER) {
    // Menu is closed, and the user hit the down/up/space/enter key; open menu.
    this.setOpen(true, e);
    return true;
  }

  // Key event wasn't handled by the component.
  return false;
};


/**
 * Handles `ACTION` events dispatched by an activated menu item.
 * @param {goog.events.Event} e Action event to handle.
 * @protected
 */
goog.ui.MenuButton.prototype.handleMenuAction = function(e) {
  'use strict';
  // Close the menu on click.
  this.setOpen(false);
};


/**
 * Handles `BLUR` events dispatched by the popup menu by closing it.
 * Only registered if the menu is focusable.
 * @param {goog.events.Event} e Blur event dispatched by a focusable menu.
 */
goog.ui.MenuButton.prototype.handleMenuBlur = function(e) {
  'use strict';
  // Close the menu when it reports that it lost focus, unless the button is
  // pressed (active).
  if (!this.isActive()) {
    this.setOpen(false);
  }
};


/**
 * Handles blur events dispatched by the button's key event target when it
 * loses keyboard focus by closing the popup menu (unless it is focusable).
 * Only registered if the button is focusable.
 * @param {goog.events.Event} e Blur event dispatched by the menu button.
 * @override
 * @protected
 */
goog.ui.MenuButton.prototype.handleBlur = function(e) {
  'use strict';
  if (!this.isFocusablePopupMenu()) {
    this.setOpen(false);
  }
  goog.ui.MenuButton.superClass_.handleBlur.call(this, e);
};


/**
 * Returns the menu attached to the button.  If no menu is attached, creates a
 * new empty menu.
 * @return {goog.ui.Menu} Popup menu attached to the menu button.
 */
goog.ui.MenuButton.prototype.getMenu = function() {
  'use strict';
  if (!this.menu_) {
    this.setMenu(new goog.ui.Menu(this.getDomHelper(), this.menuRenderer_));
  }
  return this.menu_ || null;
};


/**
 * Replaces the menu attached to the button with the argument, and returns the
 * previous menu (if any).
 * @param {goog.ui.Menu?} menu New menu to be attached to the menu button (null
 *     to remove the menu).
 * @return {goog.ui.Menu|undefined} Previous menu (undefined if none).
 */
goog.ui.MenuButton.prototype.setMenu = function(menu) {
  'use strict';
  var oldMenu = this.menu_;

  // Do nothing unless the new menu is different from the current one.
  if (menu != oldMenu) {
    if (oldMenu) {
      this.setOpen(false);
      if (this.isInDocument()) {
        this.attachMenuEventListeners_(oldMenu, false);
      }
      delete this.menu_;
    }
    if (this.isInDocument()) {
      goog.a11y.aria.setState(
          this.getElementStrict(), goog.a11y.aria.State.HASPOPUP, !!menu);
    }
    if (menu) {
      this.menu_ = menu;
      menu.setParent(this);
      menu.setVisible(false);
      menu.setAllowAutoFocus(this.isFocusablePopupMenu());
      if (this.isInDocument()) {
        this.attachMenuEventListeners_(menu, true);
      }
    }
  }

  return oldMenu;
};


/**
 * Specify which positioning algorithm to use.
 *
 * This method is preferred over the fine-grained positioning methods like
 * setPositionElement, setAlignMenuToStart, and setScrollOnOverflow. Calling
 * this method will override settings by those methods.
 *
 * @param {goog.positioning.AnchoredPosition} position The position of the
 *     Menu the button. If the position has a null anchor, we will use the
 *     menubutton element as the anchor.
 */
goog.ui.MenuButton.prototype.setMenuPosition = function(position) {
  'use strict';
  if (position) {
    this.menuPosition_ = position;
    this.positionElement_ = position.element;
  }
};


/**
 * Sets an element for anchoring the menu.
 * @param {Element} positionElement New element to use for
 *     positioning the dropdown menu.  Null to use the default behavior
 *     of positioning to this menu button.
 */
goog.ui.MenuButton.prototype.setPositionElement = function(positionElement) {
  'use strict';
  this.positionElement_ = positionElement;
  this.positionMenu();
};


/**
 * Sets a margin that will be applied to the menu's position when it is shown.
 * If null, no margin will be applied.
 * @param {goog.math.Box} margin Margin to apply.
 */
goog.ui.MenuButton.prototype.setMenuMargin = function(margin) {
  'use strict';
  this.menuMargin_ = margin;
};

/**
 * Sets whether the enter or space key should close the menu, if it is already
 * open. By default, only the ESC key will close an open menu.
 * @param {boolean} close Whether pressing Enter or Space when the button has
 *     focus will close the menu if it is already open.
 */
goog.ui.MenuButton.prototype.setCloseOnEnterOrSpace = function(close) {
  this.closeOnEnterOrSpace_ = close;
};

/**
 * Sets whether to select the first item in the menu when it is opened using
 * enter or space. By default, the first item is selected only when
 * opened by a key up or down event. When this is on, the first item will
 * be selected due to any of the four events.
 * @param {boolean} select
 */
goog.ui.MenuButton.prototype.setSelectFirstOnEnterOrSpace = function(select) {
  'use strict';
  this.selectFirstOnEnterOrSpace_ = select;
};


/**
 * Adds a new menu item at the end of the menu.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator|goog.ui.Control} item Menu
 *     item to add to the menu.
 */
goog.ui.MenuButton.prototype.addItem = function(item) {
  'use strict';
  this.getMenu().addChild(item, true);
};


/**
 * Adds a new menu item at the specific index in the menu.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu item to add to the
 *     menu.
 * @param {number} index Index at which to insert the menu item.
 */
goog.ui.MenuButton.prototype.addItemAt = function(item, index) {
  'use strict';
  this.getMenu().addChildAt(item, index, true);
};


/**
 * Removes the item from the menu and disposes of it.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator} item The menu item to remove.
 */
goog.ui.MenuButton.prototype.removeItem = function(item) {
  'use strict';
  var child = this.getMenu().removeChild(item, true);
  if (child) {
    child.dispose();
  }
};


/**
 * Removes the menu item at a given index in the menu and disposes of it.
 * @param {number} index Index of item.
 */
goog.ui.MenuButton.prototype.removeItemAt = function(index) {
  'use strict';
  var child = this.getMenu().removeChildAt(index, true);
  if (child) {
    child.dispose();
  }
};


/**
 * Returns the menu item at a given index.
 * @param {number} index Index of menu item.
 * @return {goog.ui.MenuItem?} Menu item (null if not found).
 */
goog.ui.MenuButton.prototype.getItemAt = function(index) {
  'use strict';
  return this.menu_ ?
      /** @type {goog.ui.MenuItem} */ (this.menu_.getChildAt(index)) :
      null;
};


/**
 * Returns the number of items in the menu (including separators).
 * @return {number} The number of items in the menu.
 */
goog.ui.MenuButton.prototype.getItemCount = function() {
  'use strict';
  return this.menu_ ? this.menu_.getChildCount() : 0;
};


/**
 * Shows/hides the menu button based on the value of the argument.  Also hides
 * the popup menu if the button is being hidden.
 * @param {boolean} visible Whether to show or hide the button.
 * @param {boolean=} opt_force If true, doesn't check whether the component
 *     already has the requested visibility, and doesn't dispatch any events.
 * @return {boolean} Whether the visibility was changed.
 * @override
 */
goog.ui.MenuButton.prototype.setVisible = function(visible, opt_force) {
  'use strict';
  var visibilityChanged =
      goog.ui.MenuButton.superClass_.setVisible.call(this, visible, opt_force);
  if (visibilityChanged && !this.isVisible()) {
    this.setOpen(false);
  }
  return visibilityChanged;
};


/**
 * Enables/disables the menu button based on the value of the argument, and
 * updates its CSS styling.  Also hides the popup menu if the button is being
 * disabled.
 * @param {boolean} enable Whether to enable or disable the button.
 * @override
 */
goog.ui.MenuButton.prototype.setEnabled = function(enable) {
  'use strict';
  goog.ui.MenuButton.superClass_.setEnabled.call(this, enable);
  if (!this.isEnabled()) {
    this.setOpen(false);
  }
};


// TODO(nicksantos): AlignMenuToStart and ScrollOnOverflow and PositionElement
// should all be deprecated, in favor of people setting their own
// AnchoredPosition with the parameters they need. Right now, we try
// to be backwards-compatible as possible, but this is incomplete because
// the APIs are non-orthogonal.


/**
 * @return {boolean} Whether the menu is aligned to the start of the button
 *     (left if the render direction is left-to-right, right if the render
 *     direction is right-to-left).
 */
goog.ui.MenuButton.prototype.isAlignMenuToStart = function() {
  'use strict';
  var corner = this.menuPosition_.corner;
  return corner == goog.positioning.Corner.BOTTOM_START ||
      corner == goog.positioning.Corner.TOP_START;
};


/**
 * Sets whether the menu is aligned to the start or the end of the button.
 * @param {boolean} alignToStart Whether the menu is to be aligned to the start
 *     of the button (left if the render direction is left-to-right, right if
 *     the render direction is right-to-left).
 */
goog.ui.MenuButton.prototype.setAlignMenuToStart = function(alignToStart) {
  'use strict';
  this.menuPosition_.corner = alignToStart ?
      goog.positioning.Corner.BOTTOM_START :
      goog.positioning.Corner.BOTTOM_END;
};


/**
 * Sets whether the menu should scroll when it's too big to fix vertically on
 * the screen.  The css of the menu element should have overflow set to auto.
 * Note: Adding or removing items while the menu is open will not work correctly
 * if scrollOnOverflow is on.
 * @param {boolean} scrollOnOverflow Whether the menu should scroll when too big
 *     to fit on the screen.  If false, adjust logic will be used to try and
 *     reposition the menu to fit.
 */
goog.ui.MenuButton.prototype.setScrollOnOverflow = function(scrollOnOverflow) {
  'use strict';
  if (this.menuPosition_.setLastResortOverflow) {
    var overflowX = goog.positioning.Overflow.ADJUST_X;
    var overflowY = scrollOnOverflow ? goog.positioning.Overflow.RESIZE_HEIGHT :
                                       goog.positioning.Overflow.ADJUST_Y;
    this.menuPosition_.setLastResortOverflow(overflowX | overflowY);
  }
};


/**
 * @return {boolean} Whether the menu will scroll when it's to big to fit
 *     vertically on the screen.
 */
goog.ui.MenuButton.prototype.isScrollOnOverflow = function() {
  'use strict';
  return this.menuPosition_.getLastResortOverflow &&
      !!(this.menuPosition_.getLastResortOverflow() &
         goog.positioning.Overflow.RESIZE_HEIGHT);
};


/**
 * @return {boolean} Whether the attached menu is focusable.
 */
goog.ui.MenuButton.prototype.isFocusablePopupMenu = function() {
  'use strict';
  return this.isFocusablePopupMenu_;
};


/**
 * Sets whether the attached popup menu is focusable.  If the popup menu is
 * focusable, it may steal keyboard focus from the menu button, so the button
 * will not hide the menu on blur.
 * @param {boolean} focusable Whether the attached menu is focusable.
 */
goog.ui.MenuButton.prototype.setFocusablePopupMenu = function(focusable) {
  'use strict';
  // TODO(attila):  The menu itself should advertise whether it is focusable.
  this.isFocusablePopupMenu_ = focusable;
};


/**
 * Sets whether to render the menu as a sibling element of the button.
 * Normally, the menu is a child of document.body.  This option is useful if
 * you need the menu to inherit styles from a common parent element, or if you
 * otherwise need it to share a parent element for desired event handling.  One
 * example of the latter is if the parent is in a goog.ui.Popup, to ensure that
 * clicks on the menu are considered being within the popup.
 * @param {boolean} renderMenuAsSibling Whether we render the menu at the end
 *     of the dom or as a sibling to the button/label that renders the drop
 *     down.
 */
goog.ui.MenuButton.prototype.setRenderMenuAsSibling = function(
    renderMenuAsSibling) {
  'use strict';
  this.renderMenuAsSibling_ = renderMenuAsSibling;
};


/**
 * Reveals the menu and hooks up menu-specific event handling.
 * @deprecated Use {@link #setOpen} instead.
 */
goog.ui.MenuButton.prototype.showMenu = function() {
  'use strict';
  this.setOpen(true);
};


/**
 * Hides the menu and cleans up menu-specific event handling.
 * @deprecated Use {@link #setOpen} instead.
 */
goog.ui.MenuButton.prototype.hideMenu = function() {
  'use strict';
  this.setOpen(false);
};


/**
 * Opens or closes the attached popup menu.
 * @param {boolean} open Whether to open or close the menu.
 * @param {goog.events.Event=} opt_e Event that caused the menu to be opened.
 * @override
 */
goog.ui.MenuButton.prototype.setOpen = function(open, opt_e) {
  'use strict';
  goog.ui.MenuButton.superClass_.setOpen.call(this, open);
  if (this.menu_ && this.hasState(goog.ui.Component.State.OPENED) == open) {
    if (open) {
      if (!this.menu_.isInDocument()) {
        if (this.renderMenuAsSibling_) {
          // When we render the menu in the same parent as this button, we
          // prefer to add it immediately after the button. This way, the screen
          // readers will go to the menu on the very next element after the
          // button is read.
          var nextElementSibling =
              goog.dom.getNextElementSibling(this.getElement());
          if (nextElementSibling) {
            this.menu_.renderBefore(nextElementSibling);
          } else {
            this.menu_.render(
                /** @type {Element} */ (this.getElement().parentNode));
          }
        } else {
          this.menu_.render();
        }
      }
      this.viewportBox_ =
          goog.style.getVisibleRectForElement(this.getElement());
      this.buttonRect_ = goog.style.getBounds(this.getElement());
      this.positionMenu();

      // As per aria spec, highlight the first element in the menu when
      // keyboarding up or down. Thus, the first menu item will be announced
      // for screen reader users. If selectFirstOnEnterOrSpace is set, do this
      // for enter or space as well.
      var isEnterOrSpace =
          !!opt_e && (opt_e.keyCode == goog.events.KeyCodes.ENTER ||
                      opt_e.keyCode == goog.events.KeyCodes.SPACE);
      var isUpOrDown = !!opt_e && (opt_e.keyCode == goog.events.KeyCodes.DOWN ||
                                   opt_e.keyCode == goog.events.KeyCodes.UP);
      var focus =
          isUpOrDown || (isEnterOrSpace && this.selectFirstOnEnterOrSpace_);
      if (focus) {
        this.menu_.highlightFirst();
      } else {
        this.menu_.setHighlightedIndex(-1);
      }
    } else {
      this.setActive(false);
      this.menu_.setMouseButtonPressed(false);

      var element = this.getElement();
      // Clear any remaining a11y state.
      if (element) {
        goog.a11y.aria.setState(
            element, goog.a11y.aria.State.ACTIVEDESCENDANT, '');
        goog.a11y.aria.setState(element, goog.a11y.aria.State.OWNS, '');
      }

      // Clear any sizes that might have been stored.
      if (this.originalSize_ != null) {
        this.originalSize_ = undefined;
        var elem = this.menu_.getElement();
        if (elem) {
          goog.style.setSize(elem, '', '');
        }
      }
    }
    this.menu_.setVisible(open, false, opt_e);
    // In Pivot Tables the menu button somehow gets disposed of during the
    // setVisible call, causing attachPopupListeners_ to fail.
    // TODO(ziegs): Debug what happens.
    if (!this.isDisposed()) {
      this.attachPopupListeners_(open);
    }
  }
  if (this.menu_ && this.menu_.getElement()) {
    // Remove the aria-hidden state on the menu element so that it won't be
    // hidden to screen readers if it's inside a dialog (see b/17610491).
    goog.a11y.aria.removeState(
        this.menu_.getElementStrict(), goog.a11y.aria.State.HIDDEN);
  }
};


/**
 * Resets the MenuButton's size.  This is useful for cases where items are added
 * or removed from the menu and scrollOnOverflow is on.  In those cases the
 * menu will not behave correctly and resize itself unless this is called
 * (usually followed by positionMenu()).
 */
goog.ui.MenuButton.prototype.invalidateMenuSize = function() {
  'use strict';
  this.originalSize_ = undefined;
};


/**
 * Positions the menu under the button.  May be called directly in cases when
 * the menu size is known to change.
 */
goog.ui.MenuButton.prototype.positionMenu = function() {
  'use strict';
  if (!this.menu_.isInDocument()) {
    return;
  }

  var positionElement = this.positionElement_ || this.getElement();
  var position = this.menuPosition_;
  this.menuPosition_.element = positionElement;

  var elem = this.menu_.getElement();
  if (!this.menu_.isVisible()) {
    elem.style.visibility = 'hidden';
    goog.style.setElementShown(elem, true);
  }

  if (!this.originalSize_ && this.isScrollOnOverflow()) {
    this.originalSize_ = goog.style.getSize(elem);
  }
  var popupCorner = goog.positioning.flipCornerVertical(position.corner);
  position.reposition(elem, popupCorner, this.menuMargin_, this.originalSize_);

  if (!this.menu_.isVisible()) {
    goog.style.setElementShown(elem, false);
    elem.style.visibility = 'visible';
  }
};


/**
 * Periodically repositions the menu while it is visible.
 *
 * @param {goog.events.Event} e An event object.
 * @private
 */
goog.ui.MenuButton.prototype.onTick_ = function(e) {
  'use strict';
  // Call positionMenu() only if the button position or size was
  // changed, or if the window's viewport was changed.
  var currentButtonRect = goog.style.getBounds(this.getElement());
  var currentViewport = goog.style.getVisibleRectForElement(this.getElement());
  if (goog.math.Rect.equals(this.buttonRect_, currentButtonRect) &&
      goog.math.Box.equals(this.viewportBox_, currentViewport)) {
    return;
  }

  // Reduction in the viewport width (e.g. due to increasing the zoom) can
  // cause the menu to get squashed against the right edge, distorting its
  // shape. When we move the menu back where it belongs, we risk using the
  // distorted size, causing mispositioning. To be safe, start by moving the
  // menu to the top left to let it reassume its true shape.
  if (this.menu_.isInDocument() && currentViewport && this.viewportBox_ &&
      (currentViewport.getWidth() < this.viewportBox_.getWidth())) {
    var elem = this.menu_.getElement();
    if (!this.menu_.isVisible()) {
      elem.style.visibility = 'hidden';
      goog.style.setElementShown(elem, true);
    }

    goog.style.setPosition(elem, new goog.math.Coordinate(0, 0));
  }

  this.buttonRect_ = currentButtonRect;
  this.viewportBox_ = currentViewport;
  this.positionMenu();
};


/**
 * Attaches or detaches menu event listeners to/from the given menu.
 * Called each time a menu is attached to or detached from the button.
 * @param {goog.ui.Menu} menu Menu on which to listen for events.
 * @param {boolean} attach Whether to attach or detach event listeners.
 * @private
 */
goog.ui.MenuButton.prototype.attachMenuEventListeners_ = function(
    menu, attach) {
  'use strict';
  var handler = this.getHandler();
  var method = attach ? handler.listen : handler.unlisten;

  // Handle events dispatched by menu items.
  method.call(
      handler, menu, goog.ui.Component.EventType.ACTION, this.handleMenuAction);
  method.call(
      handler, menu, goog.ui.Component.EventType.CLOSE, this.handleCloseItem);
  method.call(
      handler, menu, goog.ui.Component.EventType.HIGHLIGHT,
      this.handleHighlightItem);
  method.call(
      handler, menu, goog.ui.Component.EventType.UNHIGHLIGHT,
      this.handleUnHighlightItem);
};


/**
 * Attaches or detaches a keydown event listener to/from the given element.
 * Called each time the button enters or exits the document.
 * @param {boolean} attach Whether to attach or detach the event listener.
 * @private
 */
goog.ui.MenuButton.prototype.attachKeyDownEventListener_ = function(attach) {
  'use strict';
  var handler = this.getHandler();
  var method = attach ? handler.listen : handler.unlisten;

  // Handle keydown events dispatched by the button.
  method.call(
      handler, this.getElement(), goog.events.EventType.KEYDOWN,
      this.handleKeyDownEvent_);
};


/**
 * Handles `HIGHLIGHT` events dispatched by the attached menu.
 * @param {goog.events.Event} e Highlight event to handle.
 */
goog.ui.MenuButton.prototype.handleHighlightItem = function(e) {
  'use strict';
  var targetEl = e.target.getElement();
  if (targetEl) {
    this.setAriaActiveDescendant_(targetEl);
  }
};


/**
 * Handles `KEYDOWN` events dispatched by the button element. When the
 * button is focusable and the menu is present and visible, prevents the event
 * from propagating since the desired behavior is only to close the menu.
 * @param {goog.events.Event} e KeyDown event to handle.
 * @private
 */
goog.ui.MenuButton.prototype.handleKeyDownEvent_ = function(e) {
  'use strict';
  if (this.isSupportedState(goog.ui.Component.State.FOCUSED) &&
      this.getKeyEventTarget() && this.menu_ && this.menu_.isVisible()) {
    e.stopPropagation();
  }
};


/**
 * Handles UNHIGHLIGHT events dispatched by the associated menu.
 * @param {goog.events.Event} e Unhighlight event to handle.
 */
goog.ui.MenuButton.prototype.handleUnHighlightItem = function(e) {
  'use strict';
  if (!this.menu_.getHighlighted()) {
    var element = this.getElement();
    goog.asserts.assert(element, 'The menu button DOM element cannot be null.');
    goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, '');
    goog.a11y.aria.setState(element, goog.a11y.aria.State.OWNS, '');
  }
};


/**
 * Handles `CLOSE` events dispatched by the associated menu.
 * @param {goog.events.Event} e Close event to handle.
 */
goog.ui.MenuButton.prototype.handleCloseItem = function(e) {
  'use strict';
  // When a submenu is closed by pressing left arrow, no highlight event is
  // dispatched because the newly focused item was already highlighted, so this
  // scenario is handled by listening for the submenu close event instead.
  if (this.isOpen() && e.target instanceof goog.ui.MenuItem) {
    var menuItem = /** @type {!goog.ui.MenuItem} */ (e.target);
    var menuItemEl = menuItem.getElement();
    if (menuItem.isVisible() && menuItem.isHighlighted() &&
        menuItemEl != null) {
      this.setAriaActiveDescendant_(menuItemEl);
    }
  }
};


/**
 * Updates the aria-activedescendant attribute to the given target element.
 * @param {!Element} targetEl The target element.
 * @private
 */
goog.ui.MenuButton.prototype.setAriaActiveDescendant_ = function(targetEl) {
  'use strict';
  var element = this.getElement();
  goog.asserts.assert(element, 'The menu button DOM element cannot be null.');

  // If target element has an activedescendant, then set this control's
  // activedescendant to that, otherwise set it to the target element. This is
  // a workaround for some screen readers which do not handle
  // aria-activedescendant redirection properly.
  var targetActiveDescendant = goog.a11y.aria.getActiveDescendant(targetEl);
  var activeDescendant = targetActiveDescendant || targetEl;

  if (!activeDescendant.id) {
    // Create an id if there isn't one already.
    var idGenerator = goog.ui.IdGenerator.getInstance();
    activeDescendant.id = idGenerator.getNextUniqueId();
  }

  goog.a11y.aria.setActiveDescendant(element, activeDescendant);
  goog.a11y.aria.setState(
      element, goog.a11y.aria.State.OWNS, activeDescendant.id);
};


/**
 * Attaches or detaches event listeners depending on whether the popup menu
 * is being shown or hidden.  Starts listening for document mousedown events
 * and for menu blur events when the menu is shown, and stops listening for
 * these events when it is hidden.  Called from {@link #setOpen}.
 * @param {boolean} attach Whether to attach or detach event listeners.
 * @private
 */
goog.ui.MenuButton.prototype.attachPopupListeners_ = function(attach) {
  'use strict';
  var handler = this.getHandler();
  var method = attach ? handler.listen : handler.unlisten;

  // Listen for document mousedown events in the capture phase, because
  // the target may stop propagation of the event in the bubble phase.
  method.call(
      handler, this.getDomHelper().getDocument(),
      goog.events.EventType.MOUSEDOWN, this.handleDocumentMouseDown, true);

  // Only listen for blur events dispatched by the menu if it is focusable.
  if (this.isFocusablePopupMenu()) {
    method.call(
        handler, /** @type {!goog.events.EventTarget} */ (this.menu_),
        goog.ui.Component.EventType.BLUR, this.handleMenuBlur);
  }

  method.call(handler, this.timer_, goog.Timer.TICK, this.onTick_);
  if (attach) {
    this.timer_.start();
  } else {
    this.timer_.stop();
  }
};


// Register a decorator factory function for goog.ui.MenuButtons.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.MenuButtonRenderer.CSS_CLASS, function() {
      'use strict';
      // MenuButton defaults to using MenuButtonRenderer.
      return new goog.ui.MenuButton(null);
    });

//third_party/javascript/closure/ui/flatmenubuttonrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Similar functionality of {@link goog.ui.MenuButtonRenderer},
 * but inherits from {@link goog.ui.FlatButtonRenderer} instead of
 * {@link goog.ui.CustomButtonRenderer}. This creates a simpler menu button
 * that will look more like a traditional <select> menu.
 */

goog.provide('goog.ui.FlatMenuButtonRenderer');

goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.style');
goog.require('goog.ui.FlatButtonRenderer');
goog.require('goog.ui.INLINE_BLOCK_CLASSNAME');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuButton');
goog.require('goog.ui.MenuRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.ui.Button');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');



/**
 * Flat Menu Button renderer. Creates a simpler version of
 * {@link goog.ui.MenuButton} that doesn't look like a button and
 * doesn't have rounded corners. Uses just a `<div>` and looks more like
 * a traditional `<select>` element.
 * @constructor
 * @extends {goog.ui.FlatButtonRenderer}
 */
goog.ui.FlatMenuButtonRenderer = function() {
  'use strict';
  goog.ui.FlatButtonRenderer.call(this);
};
goog.inherits(goog.ui.FlatMenuButtonRenderer, goog.ui.FlatButtonRenderer);
goog.addSingletonGetter(goog.ui.FlatMenuButtonRenderer);


/**
 * Default CSS class to be applied to the root element of components rendered
 * by this renderer.
 * @type {string}
 */
goog.ui.FlatMenuButtonRenderer.CSS_CLASS =
    goog.getCssName('goog-flat-menu-button');


/**
 * Returns the button's contents wrapped in the following DOM structure:
 *
 *    <div class="goog-inline-block goog-flat-menu-button">
 *        <div class="goog-inline-block goog-flat-menu-button-caption">
 *          Contents...
 *        </div>
 *        <div class="goog-inline-block goog-flat-menu-button-dropdown">
 *          &nbsp;
 *        </div>
 *    </div>
 *
 * Overrides {@link goog.ui.FlatButtonRenderer#createDom}.
 * @param {goog.ui.Control} control Button to render.
 * @return {!Element} Root element for the button.
 * @override
 */
goog.ui.FlatMenuButtonRenderer.prototype.createDom = function(control) {
  'use strict';
  var button = /** @type {goog.ui.Button} */ (control);
  var classNames = this.getClassNames(button);
  var element = button.getDomHelper().createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' + classNames.join(' '), [
        this.createCaption(button.getContent(), button.getDomHelper()),
        this.createDropdown(button.getDomHelper())
      ]);
  this.setTooltip(element, /** @type {string}*/ (button.getTooltip()));
  return element;
};


/**
 * Takes the button's root element and returns the parent element of the
 * button's contents.
 * @param {Element} element Root element of the button whose content
 * element is to be returned.
 * @return {Element} The button's content element (if any).
 * @override
 */
goog.ui.FlatMenuButtonRenderer.prototype.getContentElement = function(element) {
  'use strict';
  return element && /** @type {Element} */ (element.firstChild);
};


/**
 * Takes an element, decorates it with the menu button control, and returns
 * the element.  Overrides {@link goog.ui.CustomButtonRenderer#decorate} by
 * looking for a child element that can be decorated by a menu, and if it
 * finds one, decorates it and attaches it to the menu button.
 * @param {goog.ui.Control} button Menu button to decorate the element.
 * @param {Element} element Element to decorate.
 * @return {Element} Decorated element.
 * @override
 */
goog.ui.FlatMenuButtonRenderer.prototype.decorate = function(button, element) {
  'use strict';
  // TODO(brianp): MenuButtonRenderer uses the exact same code.
  // Refactor this block to its own module where both can use it.
  var menuElem = goog.dom.getElementsByTagNameAndClass(
      '*', goog.ui.MenuRenderer.CSS_CLASS, element)[0];
  if (menuElem) {
    // Move the menu element directly under the body, but hide it first; see
    // bug 1089244.
    goog.style.setElementShown(menuElem, false);
    button.getDomHelper().getDocument().body.appendChild(menuElem);

    // Decorate the menu and attach it to the button.
    var menu = new goog.ui.Menu();
    menu.decorate(menuElem);
    button.setMenu(menu);
  }

  // Add the caption if it's not already there.
  var captionElem = goog.dom.getElementsByTagNameAndClass(
      '*', goog.getCssName(this.getCssClass(), 'caption'), element)[0];
  if (!captionElem) {
    element.appendChild(
        /** @type {!Node} */ (
            this.createCaption(element.childNodes, button.getDomHelper())));
  }

  // Add the dropdown icon if it's not already there.
  var dropdownElem = goog.dom.getElementsByTagNameAndClass(
      '*', goog.getCssName(this.getCssClass(), 'dropdown'), element)[0];
  if (!dropdownElem) {
    element.appendChild(this.createDropdown(button.getDomHelper()));
  }

  // Let the superclass do the rest.
  return goog.ui.FlatMenuButtonRenderer.superClass_.decorate.call(
      this, button, element);
};


/**
 * Takes a text caption or existing DOM structure, and returns it wrapped in
 * an appropriately-styled DIV.  Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-flat-menu-button-caption">
 *      Contents...
 *    </div>
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to wrap
 *     in a box.
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Caption element.
 */
goog.ui.FlatMenuButtonRenderer.prototype.createCaption = function(
    content, dom) {
  'use strict';
  return dom.createDom(
      goog.dom.TagName.DIV,
      goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
          goog.getCssName(this.getCssClass(), 'caption'),
      content);
};


/**
 * Returns an appropriately-styled DIV containing a dropdown arrow element.
 * Creates the following DOM structure:
 *
 *    <div class="goog-inline-block goog-flat-menu-button-dropdown">
 *      &nbsp;
 *    </div>
 *
 * @param {goog.dom.DomHelper} dom DOM helper, used for document interaction.
 * @return {!Element} Dropdown element.
 */
goog.ui.FlatMenuButtonRenderer.prototype.createDropdown = function(dom) {
  'use strict';
  // 00A0 is &nbsp;
  return dom.createDom(
      goog.dom.TagName.DIV, {
        'class': goog.ui.INLINE_BLOCK_CLASSNAME + ' ' +
            goog.getCssName(this.getCssClass(), 'dropdown'),
        'aria-hidden': true
      },
      '\u00A0');
};


/**
 * Returns the CSS class to be applied to the root element of components
 * rendered using this renderer.
 * @return {string} Renderer-specific CSS class.
 * @override
 */
goog.ui.FlatMenuButtonRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.FlatMenuButtonRenderer.CSS_CLASS;
};


// Register a decorator factory function for Flat Menu Buttons.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.FlatMenuButtonRenderer.CSS_CLASS, function() {
      'use strict';
      // Uses goog.ui.MenuButton, but with FlatMenuButtonRenderer.
      return new goog.ui.MenuButton(
          null, null, goog.ui.FlatMenuButtonRenderer.getInstance());
    });

//third_party/javascript/closure/ui/select.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A class that supports single selection from a dropdown menu,
 * with semantics similar to the native HTML <code>&lt;select&gt;</code>
 * element.
 *
 * @see ../demos/select.html
 */

goog.provide('goog.ui.Select');

goog.require('goog.a11y.aria');
goog.require('goog.a11y.aria.Role');
goog.require('goog.a11y.aria.State');
goog.require('goog.events.EventType');
goog.require('goog.ui.Component');
goog.require('goog.ui.IdGenerator');
goog.require('goog.ui.MenuButton');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.MenuRenderer');
goog.require('goog.ui.SelectionModel');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.events.Event');
goog.requireType('goog.ui.ButtonRenderer');
goog.requireType('goog.ui.Control');
goog.requireType('goog.ui.ControlContent');
goog.requireType('goog.ui.Menu');
goog.requireType('goog.ui.MenuSeparator');



/**
 * A selection control.  Extends {@link goog.ui.MenuButton} by composing a
 * menu with a selection model, and automatically updating the button's caption
 * based on the current selection.
 *
 * Select fires the following events:
 *   CHANGE - after selection changes.
 *
 * @param {goog.ui.ControlContent=} opt_caption Default caption or existing DOM
 *     structure to display as the button's caption when nothing is selected.
 *     Defaults to no caption.
 * @param {goog.ui.Menu=} opt_menu Menu containing selection options.
 * @param {goog.ui.ButtonRenderer=} opt_renderer Renderer used to render or
 *     decorate the control; defaults to {@link goog.ui.MenuButtonRenderer}.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper, used for
 *     document interaction.
 * @param {!goog.ui.MenuRenderer=} opt_menuRenderer Renderer used to render or
 *     decorate the menu; defaults to {@link goog.ui.MenuRenderer}.
 * @constructor
 * @extends {goog.ui.MenuButton}
 */
goog.ui.Select = function(
    opt_caption, opt_menu, opt_renderer, opt_domHelper, opt_menuRenderer) {
  'use strict';
  goog.ui.Select.base(
      this, 'constructor', opt_caption, opt_menu, opt_renderer, opt_domHelper,
      opt_menuRenderer ||
          new goog.ui.MenuRenderer(goog.a11y.aria.Role.LISTBOX));
  /**
   * Default caption to show when no option is selected.
   * @private {goog.ui.ControlContent}
   */
  this.defaultCaption_ = this.getContent();

  /**
   * The initial value of the aria label of the content element. This will be
   * null until the caption is first populated and will be non-null thereafter.
   * @private {?string}
   */
  this.initialAriaLabel_ = null;

  this.setPreferredAriaRole(goog.a11y.aria.Role.LISTBOX);
};
goog.inherits(goog.ui.Select, goog.ui.MenuButton);


/**
 * The selection model controlling the items in the menu.
 * @type {?goog.ui.SelectionModel}
 * @private
 */
goog.ui.Select.prototype.selectionModel_ = null;


/** @override */
goog.ui.Select.prototype.enterDocument = function() {
  'use strict';
  goog.ui.Select.superClass_.enterDocument.call(this);
  this.updateCaption();
  this.listenToSelectionModelEvents_();
};


/**
 * Decorates the given element with this control.  Overrides the superclass
 * implementation by initializing the default caption on the select button.
 * @param {Element} element Element to decorate.
 * @override
 */
goog.ui.Select.prototype.decorateInternal = function(element) {
  'use strict';
  goog.ui.Select.superClass_.decorateInternal.call(this, element);
  var caption = this.getCaption();
  if (caption) {
    // Initialize the default caption.
    this.setDefaultCaption(caption);
  } else if (!this.getSelectedItem()) {
    // If there is no default caption and no selected item, select the first
    // option (this is technically an arbitrary choice, but what most people
    // would expect to happen).
    this.setSelectedIndex(0);
  }
};


/** @override */
goog.ui.Select.prototype.disposeInternal = function() {
  'use strict';
  goog.ui.Select.superClass_.disposeInternal.call(this);

  if (this.selectionModel_) {
    this.selectionModel_.dispose();
    this.selectionModel_ = null;
  }

  this.defaultCaption_ = null;
};


/**
 * Handles {@link goog.ui.Component.EventType.ACTION} events dispatched by
 * the menu item clicked by the user.  Updates the selection model, calls
 * the superclass implementation to hide the menu, stops the propagation of
 * the event, and dispatches an ACTION event on behalf of the select control
 * itself.  Overrides {@link goog.ui.MenuButton#handleMenuAction}.
 * @param {goog.events.Event} e Action event to handle.
 * @override
 */
goog.ui.Select.prototype.handleMenuAction = function(e) {
  'use strict';
  this.setSelectedItem(/** @type {goog.ui.MenuItem} */ (e.target));
  goog.ui.Select.base(this, 'handleMenuAction', e);

  // NOTE(chrishenry): We should not stop propagation and then fire
  // our own ACTION event. Fixing this without breaking anyone
  // relying on this event is hard though.
  e.stopPropagation();
  this.dispatchEvent(goog.ui.Component.EventType.ACTION);
};


/**
 * Handles {@link goog.events.EventType.SELECT} events raised by the
 * selection model when the selection changes.  Updates the contents of the
 * select button.
 * @param {goog.events.Event} e Selection event to handle.
 */
goog.ui.Select.prototype.handleSelectionChange = function(e) {
  'use strict';
  var item = this.getSelectedItem();
  goog.ui.Select.superClass_.setValue.call(this, item && item.getValue());
  this.updateCaption();
};


/**
 * Replaces the menu currently attached to the control (if any) with the given
 * argument, and updates the selection model.  Does nothing if the new menu is
 * the same as the old one.  Overrides {@link goog.ui.MenuButton#setMenu}.
 * @param {goog.ui.Menu} menu New menu to be attached to the menu button.
 * @return {goog.ui.Menu|undefined} Previous menu (undefined if none).
 * @override
 */
goog.ui.Select.prototype.setMenu = function(menu) {
  'use strict';
  // Call superclass implementation to replace the menu.
  var oldMenu = goog.ui.Select.superClass_.setMenu.call(this, menu);

  // Do nothing unless the new menu is different from the current one.
  if (menu != oldMenu) {
    // Clear the old selection model (if any).
    if (this.selectionModel_) {
      this.selectionModel_.clear();
    }

    // Initialize new selection model (unless the new menu is null).
    if (menu) {
      if (this.selectionModel_) {
        menu.forEachChild(function(child, index) {
          'use strict';
          this.setCorrectAriaRole_(
              /** @type {goog.ui.MenuItem|goog.ui.MenuSeparator} */ (child));
          this.selectionModel_.addItem(child);
        }, this);
      } else {
        this.createSelectionModel_(menu);
      }
    }
  }

  return oldMenu;
};


/**
 * Returns the default caption to be shown when no option is selected.
 * @return {goog.ui.ControlContent} Default caption.
 */
goog.ui.Select.prototype.getDefaultCaption = function() {
  'use strict';
  return this.defaultCaption_;
};


/**
 * Sets the default caption to the given string or DOM structure.
 * @param {goog.ui.ControlContent} caption Default caption to be shown
 *    when no option is selected.
 */
goog.ui.Select.prototype.setDefaultCaption = function(caption) {
  'use strict';
  this.defaultCaption_ = caption;
  this.updateCaption();
};


/**
 * Adds a new menu item at the end of the menu.
 * @param {goog.ui.Control} item Menu item to add to the menu.
 * @override
 */
goog.ui.Select.prototype.addItem = function(item) {
  'use strict';
  this.setCorrectAriaRole_(
      /** @type {goog.ui.MenuItem|goog.ui.MenuSeparator} */ (item));
  goog.ui.Select.superClass_.addItem.call(this, item);

  if (this.selectionModel_) {
    this.selectionModel_.addItem(item);
  } else {
    this.createSelectionModel_(this.getMenu());
  }
  this.updateAriaActiveDescendant_();
};


/**
 * Adds a new menu item at a specific index in the menu.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator} item Menu item to add to the
 *     menu.
 * @param {number} index Index at which to insert the menu item.
 * @override
 */
goog.ui.Select.prototype.addItemAt = function(item, index) {
  'use strict';
  this.setCorrectAriaRole_(
      /** @type {goog.ui.MenuItem|goog.ui.MenuSeparator} */ (item));
  goog.ui.Select.superClass_.addItemAt.call(this, item, index);

  if (this.selectionModel_) {
    this.selectionModel_.addItemAt(item, index);
  } else {
    this.createSelectionModel_(this.getMenu());
  }
};


/**
 * Removes an item from the menu and disposes it.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator} item The menu item to remove.
 * @override
 */
goog.ui.Select.prototype.removeItem = function(item) {
  'use strict';
  goog.ui.Select.superClass_.removeItem.call(this, item);
  if (this.selectionModel_) {
    this.selectionModel_.removeItem(item);
  }
};


/**
 * Removes a menu item at a given index in the menu and disposes it.
 * @param {number} index Index of item.
 * @override
 */
goog.ui.Select.prototype.removeItemAt = function(index) {
  'use strict';
  goog.ui.Select.superClass_.removeItemAt.call(this, index);
  if (this.selectionModel_) {
    this.selectionModel_.removeItemAt(index);
  }
};


/**
 * Selects the specified option (assumed to be in the select menu), and
 * deselects the previously selected option, if any.  A null argument clears
 * the selection.
 * @param {goog.ui.MenuItem} item Option to be selected (null to clear
 *     the selection).
 */
goog.ui.Select.prototype.setSelectedItem = function(item) {
  'use strict';
  if (this.selectionModel_) {
    var prevItem = this.getSelectedItem();
    this.selectionModel_.setSelectedItem(item);

    if (item != prevItem) {
      this.dispatchEvent(goog.ui.Component.EventType.CHANGE);
    }
  }
};


/**
 * Selects the option at the specified index, or clears the selection if the
 * index is out of bounds.
 * @param {number} index Index of the option to be selected.
 */
goog.ui.Select.prototype.setSelectedIndex = function(index) {
  'use strict';
  if (this.selectionModel_) {
    this.setSelectedItem(/** @type {goog.ui.MenuItem} */
        (this.selectionModel_.getItemAt(index)));
  }
};


/**
 * Selects the first option found with an associated value equal to the
 * argument, or clears the selection if no such option is found.  A null
 * argument also clears the selection.  Overrides {@link
 * goog.ui.Button#setValue}.
 * @param {*} value Value of the option to be selected (null to clear
 *     the selection).
 * @override
 */
goog.ui.Select.prototype.setValue = function(value) {
  'use strict';
  if (value != null && this.selectionModel_) {
    for (var i = 0, item; item = this.selectionModel_.getItemAt(i); i++) {
      if (item && typeof item.getValue == 'function' &&
          item.getValue() == value) {
        this.setSelectedItem(/** @type {!goog.ui.MenuItem} */ (item));
        return;
      }
    }
  }

  this.setSelectedItem(null);
};


/**
 * Gets the value associated with the currently selected option (null if none).
 *
 * Note that unlike {@link goog.ui.Button#getValue} which this method overrides,
 * the "value" of a Select instance is the value of its selected menu item, not
 * its own value. This makes a difference because the "value" of a Button is
 * reset to the value of the element it decorates when it's added to the DOM
 * (via ButtonRenderer), whereas the value of the selected item is unaffected.
 * So while setValue() has no effect on a Button before it is added to the DOM,
 * it will make a persistent change to a Select instance (which is consistent
 * with any changes made by {@link goog.ui.Select#setSelectedItem} and
 * {@link goog.ui.Select#setSelectedIndex}).
 *
 * @override
 */
goog.ui.Select.prototype.getValue = function() {
  'use strict';
  var selectedItem = this.getSelectedItem();
  return selectedItem ? selectedItem.getValue() : null;
};


/**
 * Returns the currently selected option.
 * @return {goog.ui.MenuItem} The currently selected option (null if none).
 */
goog.ui.Select.prototype.getSelectedItem = function() {
  'use strict';
  return this.selectionModel_ ?
      /** @type {goog.ui.MenuItem} */ (this.selectionModel_.getSelectedItem()) :
      null;
};


/**
 * Returns the index of the currently selected option.
 * @return {number} 0-based index of the currently selected option (-1 if none).
 */
goog.ui.Select.prototype.getSelectedIndex = function() {
  'use strict';
  return this.selectionModel_ ? this.selectionModel_.getSelectedIndex() : -1;
};


/**
 * @return {goog.ui.SelectionModel} The selection model.
 * @protected
 */
goog.ui.Select.prototype.getSelectionModel = function() {
  'use strict';
  return this.selectionModel_;
};


/**
 * Creates a new selection model and sets up an event listener to handle
 * {@link goog.events.EventType.SELECT} events dispatched by it.
 * @param {goog.ui.Component=} opt_component If provided, will add the
 *     component's children as items to the selection model.
 * @private
 */
goog.ui.Select.prototype.createSelectionModel_ = function(opt_component) {
  'use strict';
  this.selectionModel_ = new goog.ui.SelectionModel();
  if (opt_component) {
    opt_component.forEachChild(function(child, index) {
      'use strict';
      this.setCorrectAriaRole_(
          /** @type {goog.ui.MenuItem|goog.ui.MenuSeparator} */ (child));
      this.selectionModel_.addItem(child);
    }, this);
  }
  this.listenToSelectionModelEvents_();
};


/**
 * Subscribes to events dispatched by the selection model.
 * @private
 */
goog.ui.Select.prototype.listenToSelectionModelEvents_ = function() {
  'use strict';
  if (this.selectionModel_) {
    this.getHandler().listen(
        this.selectionModel_, goog.events.EventType.SELECT,
        this.handleSelectionChange);
  }
};


/**
 * Updates the caption to be shown in the select button.  If no option is
 * selected and a default caption is set, sets the caption to the default
 * caption; otherwise to the empty string.
 * @protected
 */
goog.ui.Select.prototype.updateCaption = function() {
  'use strict';
  var item = this.getSelectedItem();
  this.setContent(item ? item.getCaption() : this.defaultCaption_);

  var contentElement = this.getRenderer().getContentElement(this.getElement());
  // Despite the ControlRenderer interface indicating the return value is
  // {Element}, many renderers cast element.firstChild to {Element} when it is
  // really {Node}. Checking tagName verifies this is an {!Element}.
  if (contentElement && this.getDomHelper().isElement(contentElement)) {
    if (this.initialAriaLabel_ == null) {
      this.initialAriaLabel_ = goog.a11y.aria.getLabel(contentElement);
    }
    var itemElement = item ? item.getElement() : null;
    goog.a11y.aria.setLabel(
        contentElement, itemElement ? goog.a11y.aria.getLabel(itemElement) :
                                      this.initialAriaLabel_);
    this.updateAriaActiveDescendant_();
  }
};


/**
 * Updates the aria active descendant attribute.
 * @private
 */
goog.ui.Select.prototype.updateAriaActiveDescendant_ = function() {
  'use strict';
  var renderer = this.getRenderer();
  if (renderer) {
    var contentElement = renderer.getContentElement(this.getElement());
    if (contentElement) {
      var buttonElement = this.getElementStrict();
      if (!contentElement.id) {
        contentElement.id = goog.ui.IdGenerator.getInstance().getNextUniqueId();
      }
      goog.a11y.aria.setRole(contentElement, goog.a11y.aria.Role.OPTION);
      // Set 'aria-selected' to true since the content element represents the
      // currently selected option.
      goog.a11y.aria.setState(
          contentElement, goog.a11y.aria.State.SELECTED, true);
      goog.a11y.aria.setState(
          buttonElement, goog.a11y.aria.State.ACTIVEDESCENDANT,
          contentElement.id);
      if (this.selectionModel_) {
        // We can't use selectionmodel's getItemCount here because we need to
        // skip separators.
        var items = this.selectionModel_.getItems();
        goog.a11y.aria.setState(
            contentElement, goog.a11y.aria.State.SETSIZE,
            this.getNumMenuItems_(items));
        // Set a human-readable selection index, excluding menu separators.
        var index = this.selectionModel_.getSelectedIndex();
        goog.a11y.aria.setState(
            contentElement, goog.a11y.aria.State.POSINSET,
            index >= 0 ? this.getNumMenuItems_(items.slice(0, index + 1)) : 0);
      }
    }
  }
};


/**
 * Gets the number of menu items in the array.
 * @param {!Array<?Object>} items The items.
 * @return {number}
 * @private
 */
goog.ui.Select.prototype.getNumMenuItems_ = function(items) {
  'use strict';
  return items
      .filter(function(item) {
        'use strict';
        return item instanceof goog.ui.MenuItem;
      })
      .length;
};


/**
 * Sets the correct ARIA role for the menu item or separator.
 * @param {goog.ui.MenuItem|goog.ui.MenuSeparator} item The item to set.
 * @private
 */
goog.ui.Select.prototype.setCorrectAriaRole_ = function(item) {
  'use strict';
  item.setPreferredAriaRole(
      item instanceof goog.ui.MenuItem ? goog.a11y.aria.Role.OPTION :
                                         goog.a11y.aria.Role.SEPARATOR);
};


/**
 * Opens or closes the menu.  Overrides {@link goog.ui.MenuButton#setOpen} by
 * highlighting the currently selected option on open.
 * @param {boolean} open Whether to open or close the menu.
 * @param {goog.events.Event=} opt_e Mousedown event that caused the menu to
 *     be opened.
 * @override
 */
goog.ui.Select.prototype.setOpen = function(open, opt_e) {
  'use strict';
  goog.ui.Select.superClass_.setOpen.call(this, open, opt_e);

  if (this.isOpen()) {
    this.getMenu().setHighlightedIndex(this.getSelectedIndex());
  } else {
    this.updateAriaActiveDescendant_();
  }
};


// Register a decorator factory function for goog.ui.Selects.
goog.ui.registry.setDecoratorByClassName(
    goog.getCssName('goog-select'), function() {
      'use strict';
      // Select defaults to using MenuButtonRenderer, since it shares its L&F.
      return new goog.ui.Select(null);
    });

//javascript/jfk/menu/select.js
goog.loadModule(function(exports) {'use strict';// Copyright 2011 Google, Inc. All Rights Reserved.

/**
 * @fileoverview Definition of the Select class, a control that looks like
 * a styled button but has semantics similar to <select> tags.
 * @author zhyder@google.com (Zohair Hyder)
 */

goog.module('jfk.Select');
goog.module.declareLegacyNamespace();

const ControlContent = goog.requireType('goog.ui.ControlContent');
const Coordinate = goog.require('goog.math.Coordinate');
const Corner = goog.require('goog.positioning.Corner');
const Delay = goog.require('goog.async.Delay');
const Disposable = goog.require('goog.Disposable');
const DomHelper = goog.requireType('goog.dom.DomHelper');
const FlatMenuButtonRenderer = goog.require('goog.ui.FlatMenuButtonRenderer');
const KeyCodes = goog.require('goog.events.KeyCodes');
const KeyHandler = goog.require('goog.events.KeyHandler');
const Menu = goog.requireType('goog.ui.Menu');
const Overflow = goog.require('goog.positioning.Overflow');
const UiSelect = goog.require('goog.ui.Select');
const asserts = goog.require('goog.asserts');
const classlist = goog.require('goog.dom.classlist');
const googMath = goog.require('goog.math');
const googString = goog.require('goog.string');
const positioning = goog.require('goog.positioning');
const style = goog.require('goog.style');

/**
 * A selection button. Automatically updates the caption based on the current
 * selection. Upon click, opens a selection menu that's positioned so that the
 * current selected menu item appears directly over the button itself. This
 * behavior is similar to that of <select> tags on Mac browsers.
 *
 * @param {ControlContent=} opt_caption Default caption or existing DOM
 *     structure to display as the button's caption when nothing is selected.
 * @param {Menu=} opt_menu Menu containing selection options.
 * @param {DomHelper=} opt_domHelper Optional DOM hepler, used for
 *     document interaction.
 * @constructor
 * @extends {UiSelect}
 */
function Select(opt_caption, opt_menu, opt_domHelper) {
  Select.base(
      this, 'constructor', opt_caption, opt_menu,
      FlatMenuButtonRenderer.getInstance(), opt_domHelper);

  /**
   * @type {Select.PrefixTracker_}
   * @private
   */
  this.prefixTracker_ =
      new Select.PrefixTracker_(Select.PREFIX_MATCHING_RESET_DELAY_MS_);
  this.registerDisposable(this.prefixTracker_);
}
goog.inherits(Select, UiSelect);

/**
 * Delays before resetting prefix matching string back to empty string.
 * This delays is used by keyboard handling mechanism.
 * @type {number}
 * @const
 * @private
 */
Select.PREFIX_MATCHING_RESET_DELAY_MS_ = 1000;

/**
 * When computing how to place the menu, use this for padding on the viewport.
 * Works around some layout issues on IE7.
 * @type {number}
 * @const
 * @private
 */
Select.VIEWPORT_PADDING_ = 2;

/** @override */
Select.prototype.createDom = function() {
  Select.base(this, 'createDom');
  classlist.add(this.getElement(), goog.getCssName('jfk-select'));
};

/**
 * Positions the menu under the button. May be called directly in cases when
 * the menu size is known to change. The positioning logic is similar to that
 * found in goog.ui.MenuButton, except that a y offset is applied based on the
 * current selection.
 * @override
 */
Select.prototype.positionMenu = function() {
  if (!this.getMenu().isInDocument()) {
    return;
  }

  var buttonElement = this.getButtonElement();

  // NOTE: Unlike goog.ui.MenuButton, using TOP_START/END as anchor corners.
  var buttonCorner =
      this.isAlignMenuToStart() ? Corner.TOP_START : Corner.TOP_END;

  var menuEl = this.getMenu().getElement();
  var opening = false;
  // If invisible, make element visible for measurement.
  if (!this.getMenu().isVisible()) {
    opening = true;
    menuEl.style.visibility = 'hidden';
    style.setElementShown(menuEl, true);
  }

  // POSITIONING ALGORITHM:
  // Priority #1) Get as much of the menu as possible on-screen.
  // Priority #2) Align the selected item with the menubutton.

  var selectedIndex = Math.max(this.getSelectedIndex(), 0);
  var selectedItem = this.getMenu().getChildAt(selectedIndex);

  // If we plan to scroll the menu, save the user's scroll position before we
  // stretch the menu out so that the positioning code will work correctly.
  var userScrollOffset = 0;
  if (this.isScrollOnOverflow()) {
    var oldScrollTop = menuEl.scrollTop;
    menuEl.style.overflowY = 'visible';
    menuEl.style.height = 'auto';

    if (!opening) {
      let oldExpectedScrollTop = 0;
      if (selectedItem) {
        oldExpectedScrollTop =
            (style.getClientPosition(selectedItem.getElement()).y -
             style.getClientPosition(buttonElement).y);
      }
      userScrollOffset = oldScrollTop - oldExpectedScrollTop;
    }
  }

  // Apply the offset based on current selection.
  var selectedItemOffset = selectedItem ?
      (/** @type {!HTMLElement} */ (selectedItem.getElement())).offsetTop :
      0;

  // If the button is visible, make sure the select menu is visible, too.
  var buttonVisibleRect = style.getVisibleRectForElement(buttonElement);
  var expectedOffset = 0;
  if (buttonVisibleRect) {
    var menuElVisibleRect = style.getVisibleRectForElement(menuEl);
    // Ensure that the document position of the selected item is in view
    var buttonPositionY = googMath.clamp(
        buttonVisibleRect.top, menuElVisibleRect.top + Select.VIEWPORT_PADDING_,
        menuElVisibleRect.bottom - Select.VIEWPORT_PADDING_);
    expectedOffset = buttonPositionY - buttonVisibleRect.top;
  }

  var offset = new Coordinate(0, expectedOffset - selectedItemOffset);
  var popupCorner =
      this.isAlignMenuToStart() ? Corner.TOP_START : Corner.TOP_END;

  positioning.positionAtAnchor(
      buttonElement, buttonCorner, menuEl, popupCorner, offset, null,
      (Overflow.ADJUST_X_EXCEPT_OFFSCREEN |
       (this.isScrollOnOverflow() ? Overflow.RESIZE_HEIGHT :
                                    Overflow.ADJUST_Y_EXCEPT_OFFSCREEN)),
      null /* preferredSize */);

  // Reset overflow from above and set the scroll position based on the menu
  // position and any scrolling the user has done.
  if (this.isScrollOnOverflow()) {
    let expectedScrollTop = 0;
    if (selectedItem) {
      expectedScrollTop =
          (style.getClientPosition(selectedItem.getElement()).y -
           style.getClientPosition(buttonElement).y);
    }

    menuEl.style.overflowY = 'auto';

    menuEl.scrollTop = userScrollOffset + expectedScrollTop;
  }

  // Reset visibility from above.
  if (!this.getMenu().isVisible()) {
    style.setElementShown(menuEl, false);
    menuEl.style.visibility = 'visible';
  }
};

/** @return {!Element} The button element. */
Select.prototype.getButtonElement = function() {
  return this.getElementStrict();
};

/**
 * Handles key events that allow users to navigate through the attached
 * menu by typing letter keys corresponding to the desired item.
 * @override
 */
Select.prototype.handleKeyEventInternal = function(e) {
  var handled = Select.base(this, 'handleKeyEventInternal', e);

  if (e.type != KeyHandler.EventType.KEY || !this.getMenu()) {
    // We only handle events on KEY.
    return handled;
  }

  if (e.altKey || e.ctrlKey || e.metaKey || e.platformModifierKey) {
    // Don't capture menu accelerators.
    return handled;
  }

  if (!this.isOpen() && e.keyCode == KeyCodes.SPACE) {
    // If the menu is not opened and space is pressed, we reset our prefix
    // matching (if any) and delegate to superclass to handle opening
    // of the menu.
    this.prefixTracker_.resetPrefix();
    return handled;
  }

  // If parent class method already handled the key, we just need to
  // make sure that the highlighted item is visible after typing UP/DOWN.
  if (handled) {
    if (this.isOpen() &&
        (e.keyCode == KeyCodes.UP || e.keyCode == KeyCodes.DOWN)) {
      this.ensureHighlightedItemIsVisible_();
    }
    return true;
  }

  var isCharacterKey = KeyCodes.isCharacterKey(e.keyCode);
  if (isCharacterKey) {
    var currentChar = e.charCode ? String.fromCharCode(e.charCode) : ' ';
    this.prefixTracker_.add(currentChar);
    var prefix = this.prefixTracker_.getCurrentPrefix();
    if (this.prefixTracker_.isCycling()) {
      // If the user types the same letter, we try to cycle between
      // different items with the same first character. Once we start
      // cycling, the only acceptable matching would be to cycle (until
      // PREFIX_MATCHING_RESET_DELAY_MS is met).
      this.findNextPrefix_(currentChar, false);
    } else {
      // If we are starting a new prefix-matching, we should not allow
      // matching with currently selected item.
      var matchCurrent = prefix.length > 1;
      this.findNextPrefix_(prefix, matchCurrent);
    }

    // We consider that this function handles all character key.
    return true;
  }

  return false;
};

/**
 * Ensures that the currently highlighted item is visible, scrolling
 * the menu if necessary.
 * @private
 */
Select.prototype.ensureHighlightedItemIsVisible_ = function() {
  var highlightedItem = this.getMenu().getHighlighted();
  if (highlightedItem) {
    style.scrollIntoContainerView(
        highlightedItem.getElement(), this.getMenu().getContentElement());
  }
};

/**
 * Finds the next item after the currently selected menu in the select
 * list with the matching prefix. If the select menu is open, we also
 * highlight the new item, otherwise we set the selection to the new
 * item.
 * @param {string} prefix The prefix to match.
 * @param {boolean} matchCurrent Whether we can match current
 *     selection first. If false, we try to match starting from one
 *     item after currentIndex instead.
 * @private
 */
Select.prototype.findNextPrefix_ = function(prefix, matchCurrent) {
  var currentIndex = this.isOpen() ?
      this.getMenu().getHighlightedIndex() : this.getSelectedIndex();
  var re = new RegExp('^' + googString.regExpEscape(prefix), 'i');

  // If we do not allow matching currently selected index, we start
  // from the next one instead.
  if (!matchCurrent) {
    ++currentIndex;
  }
  var start = currentIndex < 0 ? 0 : currentIndex;

  var menu = this.getMenu();
  for (var i = 0, max = menu.getChildCount(); i < max; ++i) {
    var nextIndex = (start + i) % max;
    var menuItem = menu.getChildAt(nextIndex);
    var name = menuItem.getCaption();
    if (menuItem.isEnabled() && name && re.test(name)) {
      this.setSelectedOrHighlightedIndex_(nextIndex);
      return;
    }
  }
};

/**
 * Sets currently selected or highlighted index depending on whether
 * the select menu is opened or closed. If the menu is opened, we set
 * the highlighted index of the select menu; otherwise, we set the
 * selected index of this select.
 * @param {number} index The new index to select/highlight.
 * @private
 */
Select.prototype.setSelectedOrHighlightedIndex_ = function(index) {
  if (this.isOpen()) {
    this.getMenu().setHighlightedIndex(index);
    this.ensureHighlightedItemIsVisible_();
  } else {
    this.setSelectedIndex(index);
  }
};

/**
 * A prefix string tracker that resets (to empty string) after a
 * specified delay. This class also contains specific logic to keep
 * track of whether we should be 'cycling'. Cycling occurs when
 * user types the same character multiple times in quick succession.
 * Instead of performing the normal prefix-matching, we instead
 * cycles over items with the same prefixes.
 * @param {number} resetDelay The reset delay in ms.
 * @extends {Disposable}
 * @constructor
 * @private
 */
Select.PrefixTracker_ = function(resetDelay) {
  Select.PrefixTracker_.base(this, 'constructor');

  /**
   * @type {Delay}
   * @private
   */
  this.delay_ = new Delay(this.resetPrefix, resetDelay, this);
  this.registerDisposable(this.delay_);
};
goog.inherits(Select.PrefixTracker_, Disposable);

/**
 * Adds letters to the end of the current prefix and reset the reset
 * delay.
 * @param {string} nextLetter Letter to add to the end of the
 *     prefix.
 */
Select.PrefixTracker_.prototype.add = function(nextLetter) {
  asserts.assert(
      nextLetter.length == 1,
      'nextLetter: \'' + nextLetter + '\' must be a single character');

  if (nextLetter == this.currentPrefix_) {
    this.cycling_ = true;
  } else if (!this.cycling_) {
    this.currentPrefix_ += nextLetter;
  }

  // Starts or resets the delay.
  this.delay_.start();
};

/**
 * @return {string} The current prefix.
 */
Select.PrefixTracker_.prototype.getCurrentPrefix = function() {
  return this.currentPrefix_;
};

/**
 * @return {boolean} Whether we should perform prefix matching by
 *     'cycling'.
 */
Select.PrefixTracker_.prototype.isCycling = function() {
  return this.cycling_;
};

/**
 * Resets the prefix back to empty string.
 */
Select.PrefixTracker_.prototype.resetPrefix = function() {
  this.currentPrefix_ = '';
  this.cycling_ = false;
};

/**
 * @type {boolean}
 * @private
 */
Select.PrefixTracker_.prototype.cycling_ = false;

/**
 * @type {string}
 * @private
 */
Select.PrefixTracker_.prototype.currentPrefix_ = '';

exports = Select;

;return exports;});

//third_party/javascript/closure/ui/checkboxmenuitem.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A menu item class that supports checkbox semantics.
 */

goog.provide('goog.ui.CheckBoxMenuItem');

goog.require('goog.ui.MenuItem');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.ui.ControlContent');



/**
 * Class representing a checkbox menu item.  This is just a convenience class
 * that extends {@link goog.ui.MenuItem} by making it checkable.
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure to
 *     display as the content of the item (use to add icons or styling to
 *     menus).
 * @param {*=} opt_model Data/model associated with the menu item.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper used for
 *     document interactions.
 * @constructor
 * @extends {goog.ui.MenuItem}
 */
goog.ui.CheckBoxMenuItem = function(content, opt_model, opt_domHelper) {
  'use strict';
  goog.ui.MenuItem.call(this, content, opt_model, opt_domHelper);
  this.setCheckable(true);
};
goog.inherits(goog.ui.CheckBoxMenuItem, goog.ui.MenuItem);


// Register a decorator factory function for goog.ui.CheckBoxMenuItems.
goog.ui.registry.setDecoratorByClassName(
    goog.getCssName('goog-checkbox-menuitem'), function() {
      'use strict';
      // CheckBoxMenuItem defaults to using MenuItemRenderer.
      return new goog.ui.CheckBoxMenuItem(null);
    });

//third_party/javascript/closure/ui/tristatemenuitemrenderer.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Renderer for {@link goog.ui.TriStateMenuItem}s.
 */

goog.provide('goog.ui.TriStateMenuItemRenderer');

goog.require('goog.asserts');
goog.require('goog.dom.classlist');
goog.require('goog.ui.MenuItemRenderer');



/**
 * Default renderer for {@link goog.ui.TriStateMenuItemRenderer}s. Each item has
 * the following structure:
 *
 *    <div class="goog-tristatemenuitem">
 *        <div class="goog-tristatemenuitem-checkbox"></div>
 *        <div>...(content)...</div>
 *    </div>
 *
 * @constructor
 * @extends {goog.ui.MenuItemRenderer}
 * @final
 */
goog.ui.TriStateMenuItemRenderer = function() {
  'use strict';
  goog.ui.MenuItemRenderer.call(this);
};
goog.inherits(goog.ui.TriStateMenuItemRenderer, goog.ui.MenuItemRenderer);
goog.addSingletonGetter(goog.ui.TriStateMenuItemRenderer);


/**
 * CSS class name the renderer applies to menu item elements.
 * @type {string}
 */
goog.ui.TriStateMenuItemRenderer.CSS_CLASS =
    goog.getCssName('goog-tristatemenuitem');


/**
 * Overrides {@link goog.ui.ControlRenderer#decorate} by initializing the
 * menu item to checkable based on whether the element to be decorated has
 * extra styling indicating that it should be.
 * @param {goog.ui.Control} item goog.ui.TriStateMenuItem to decorate
 *     the element.
 * @param {Element} element Element to decorate.
 * @return {!Element} Decorated element.
 * @override
 */
goog.ui.TriStateMenuItemRenderer.prototype.decorate = function(item, element) {
  'use strict';
  element = goog.ui.TriStateMenuItemRenderer.superClass_.decorate.call(
      this, item, element);
  this.setCheckable(item, element, true);

  goog.asserts.assert(element);

  if (goog.dom.classlist.contains(
          element, goog.getCssName(this.getCssClass(), 'fully-checked'))) {
    item.setCheckedState(/** @suppress {missingRequire} */
        goog.ui.TriStateMenuItem.State.FULLY_CHECKED);
  } else if (
      goog.dom.classlist.contains(
          element, goog.getCssName(this.getCssClass(), 'partially-checked'))) {
    /** @suppress {missingRequire} */
    item.setCheckedState(goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED);
  } else {
    /** @suppress {missingRequire} */
    item.setCheckedState(goog.ui.TriStateMenuItem.State.NOT_CHECKED);
  }

  return element;
};


/** @override */
goog.ui.TriStateMenuItemRenderer.prototype.getCssClass = function() {
  'use strict';
  return goog.ui.TriStateMenuItemRenderer.CSS_CLASS;
};

//third_party/javascript/closure/ui/tristatemenuitem.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A menu item class that supports three state checkbox semantics.
 */

goog.provide('goog.ui.TriStateMenuItem');
goog.provide('goog.ui.TriStateMenuItem.State');

goog.require('goog.dom.classlist');
goog.require('goog.ui.Component');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.TriStateMenuItemRenderer');
goog.require('goog.ui.registry');
goog.requireType('goog.dom.DomHelper');
goog.requireType('goog.ui.ControlContent');
goog.requireType('goog.ui.MenuItemRenderer');



/**
 * Class representing a three state checkbox menu item.
 *
 * @param {goog.ui.ControlContent} content Text caption or DOM structure
 *     to display as the content of the item (use to add icons or styling to
 *     menus).
 * @param {Object=} opt_model Data/model associated with the menu item.
 * @param {goog.dom.DomHelper=} opt_domHelper Optional DOM helper used for
 *     document interactions.
 * @param {goog.ui.MenuItemRenderer=} opt_renderer Optional renderer.
 * @param {boolean=} opt_alwaysAllowPartial  If true, always allow partial
 *     state.
 * @constructor
 * @extends {goog.ui.MenuItem}
 * TODO(attila): Figure out how to better integrate this into the
 * goog.ui.Control state management framework.
 * @final
 */
goog.ui.TriStateMenuItem = function(
    content, opt_model, opt_domHelper, opt_renderer, opt_alwaysAllowPartial) {
  'use strict';
  goog.ui.MenuItem.call(
      this, content, opt_model, opt_domHelper,
      opt_renderer || new goog.ui.TriStateMenuItemRenderer());
  this.setCheckable(true);
  this.alwaysAllowPartial_ = opt_alwaysAllowPartial || false;
};
goog.inherits(goog.ui.TriStateMenuItem, goog.ui.MenuItem);


/**
 * Checked states for component.
 * @enum {number}
 */
goog.ui.TriStateMenuItem.State = {
  /**
   * Component is not checked.
   */
  NOT_CHECKED: 0,

  /**
   * Component is partially checked.
   */
  PARTIALLY_CHECKED: 1,

  /**
   * Component is fully checked.
   */
  FULLY_CHECKED: 2
};


/**
 * Menu item's checked state.
 * @type {goog.ui.TriStateMenuItem.State}
 * @private
 */
goog.ui.TriStateMenuItem.prototype.checkState_ =
    goog.ui.TriStateMenuItem.State.NOT_CHECKED;


/**
 * Whether the partial state can be toggled.
 * @type {boolean}
 * @private
 */
goog.ui.TriStateMenuItem.prototype.allowPartial_ = false;


/**
 * Used to override allowPartial_ to force the third state to always be
 * permitted.
 * @type {boolean}
 * @private
 */
goog.ui.TriStateMenuItem.prototype.alwaysAllowPartial_ = false;


/**
 * @return {goog.ui.TriStateMenuItem.State} The menu item's check state.
 */
goog.ui.TriStateMenuItem.prototype.getCheckedState = function() {
  'use strict';
  return this.checkState_;
};


/**
 * Sets the checked state.
 * @param {goog.ui.TriStateMenuItem.State} state The checked state.
 */
goog.ui.TriStateMenuItem.prototype.setCheckedState = function(state) {
  'use strict';
  this.setCheckedState_(state);
  this.allowPartial_ =
      state == goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED;
};


/**
 * Sets the checked state and updates the CSS styling. Dispatches a
 * `CHECK` or `UNCHECK` event prior to changing the component's
 * state, which may be caught and canceled to prevent the component from
 * changing state.
 * @param {goog.ui.TriStateMenuItem.State} state The checked state.
 * @private
 */
goog.ui.TriStateMenuItem.prototype.setCheckedState_ = function(state) {
  'use strict';
  if (this.dispatchEvent(
          state != goog.ui.TriStateMenuItem.State.NOT_CHECKED ?
              goog.ui.Component.EventType.CHECK :
              goog.ui.Component.EventType.UNCHECK)) {
    this.setState(
        goog.ui.Component.State.CHECKED,
        state != goog.ui.TriStateMenuItem.State.NOT_CHECKED);
    this.checkState_ = state;
    this.updatedCheckedStateClassNames_();
  }
};


/** @override */
goog.ui.TriStateMenuItem.prototype.performActionInternal = function(e) {
  'use strict';
  switch (this.getCheckedState()) {
    case goog.ui.TriStateMenuItem.State.NOT_CHECKED:
      this.setCheckedState_(
          this.alwaysAllowPartial_ || this.allowPartial_ ?
              goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED :
              goog.ui.TriStateMenuItem.State.FULLY_CHECKED);
      break;
    case goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED:
      this.setCheckedState_(goog.ui.TriStateMenuItem.State.FULLY_CHECKED);
      break;
    case goog.ui.TriStateMenuItem.State.FULLY_CHECKED:
      this.setCheckedState_(goog.ui.TriStateMenuItem.State.NOT_CHECKED);
      break;
  }

  var checkboxClass =
      goog.getCssName(this.getRenderer().getCssClass(), 'checkbox');
  var clickOnCheckbox = e.target &&
      goog.dom.classlist.contains(
          /** @type {!Element} */ (e.target), checkboxClass);

  return this.dispatchEvent(
      clickOnCheckbox || this.allowPartial_ ?
          goog.ui.Component.EventType.CHANGE :
          goog.ui.Component.EventType.ACTION);
};


/**
 * Updates the extra class names applied to the menu item element.
 * @private
 */
goog.ui.TriStateMenuItem.prototype.updatedCheckedStateClassNames_ = function() {
  'use strict';
  var renderer = this.getRenderer();
  renderer.enableExtraClassName(
      this, goog.getCssName(renderer.getCssClass(), 'partially-checked'),
      this.getCheckedState() ==
          goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED);
  renderer.enableExtraClassName(
      this, goog.getCssName(renderer.getCssClass(), 'fully-checked'),
      this.getCheckedState() == goog.ui.TriStateMenuItem.State.FULLY_CHECKED);
};


// Register a decorator factory function for goog.ui.TriStateMenuItemRenderer.
goog.ui.registry.setDecoratorByClassName(
    goog.ui.TriStateMenuItemRenderer.CSS_CLASS, function() {
      'use strict';
      // TriStateMenuItem defaults to using TriStateMenuItemRenderer.
      return new goog.ui.TriStateMenuItem(null);
    });

//javascript/angular/jfkwrappers/menu/menu.js
/**
 * @fileoverview Implements directives for goog.ui.Menu{,Item,Separator} and
 * goog.ui.CheckBoxMenuItem.
 *
 * A menu can contain menu items (clickable menu entries), separators, check box
 * menu items, sub menus (with a nested menu), or arbitrary controls by wrapping
 * them in a "menu child":
 * <pre>
 * &lt;div jfk-menu>
 *   &lt;div jfk-menu-item>Menu Item&lt;/div>
 *   &lt;div jfk-menu-separator>&lt;/div>
 *   &lt;div jfk-check-box-menu-item>Checkbox&lt;/div>
 *   &lt;div jfk-menu-child
 *           jfk-close-on-action='true'>Arbitrary further content&lt;/div>
 *   &lt;div jfk-sub-menu>
 *     &lt;span>Sub Menu Caption&lt;/div>
 *     &lt;div jfk-menu>
 *       &lt;div jfk-menu-item>Sub Menu Item&lt;/div>
 *     &lt;/div>
 *   &lt;/div>
 * &lt;/div>
 * </pre>
 *
 * Note that a menu item is a very specific control like File -> Open in many
 * applications, including a visual style.
 *
 *
 * Menu child is a generic container that allows you to add other, arbitrary
 * controls (see the colorpicker for an example).
 *
 * Components that can appear within the menu take an optional attribute
 * `jfk-close-on-action` - if false (which is the default for menu child, but
 * not for the others), the menu won't close on click/action.
 */
'use strict';

goog.provide('ng.jfk.Menu');

goog.require('goog.array');
goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.ui.CheckBoxMenuItem');
goog.require('goog.ui.Component');
goog.require('goog.ui.Control');
goog.require('goog.ui.Menu');
goog.require('goog.ui.MenuItem');
goog.require('goog.ui.MenuSeparator');
goog.require('goog.ui.SubMenu');
goog.require('goog.ui.TriStateMenuItem');
goog.require('jfk.Select');
goog.require('ng.jfk.Common');
goog.requireType('ng.jfk.CommonService');

/**
 * For instances of angular.Module that are used as a namespace, like in this
 * file, we delcare a subtype of angular.Module to make it clear that other
 * angular.Module instances cannot have these properties.
 * @interface @extends {angular.Module}
 */
ng.jfk.MenuModuleType = function() {};

/**
 * Angular module for the jfk-menu directive.
 * @type {!ng.jfk.MenuModuleType}
 */
ng.jfk.Menu = /** @type {!ng.jfk.MenuModuleType} */ (
    angular.module('jfkMenu', [ng.jfk.Common.name]));

goog.scope(function() {
var Menu = ng.jfk.Menu;

/**
 * Returns the title element for Menu Buttons and Selects or creates one if
 * necessary.
 * @param {!Element} parent The parent node for the title element.
 * @return {!Element} The DOM element created or found.
 */
Menu.getOrCreateTitleElement = function(parent) {
  var children = goog.dom.getChildren(parent);
  if (children.length <= 1) {
    // Append a node for the menu button's label.
    var titleElement = document.createElement('span');
    parent.insertBefore(titleElement, parent.firstChild);
    return titleElement;
  }
  return children[0];
};

/**
 * Sets up the menu element by setting the data `MENU_ITEM_MARKER_`.
 * @param {!angular.JQLite} element The jQuery element object.
 */
Menu.setItemMarker = function(element) {
  // Not using `element.data()` because full jQuery doesn't support the data
  // method on comment nodes, only element nodes.
  element[0][Menu.MENU_ITEM_MARKER_] = true;
};


/**
 * @typedef {{
 *   item: (goog.ui.MenuItem|goog.ui.MenuSeparator),
 *   element: !Node
 * }}
 */
Menu.menuItem;



/**
 * The (directive level) controller for a menu, essentially wrapping the
 * {@link goog.ui.Menu}.
 * @param {!ng.jfk.CommonService} jfkCommon
 * @constructor
 */
Menu.Controller = function(jfkCommon) {
  /** @private {!ng.jfk.CommonService} */
  this.jfkCommon_ = jfkCommon;

  /** @private {!goog.ui.Menu} */
  this.menu_ = new goog.ui.Menu();
  // Disable autofocus to prevent forcing browser layout when creating the menu.
  this.menu_.setAllowAutoFocus(false);

  /**
   * Container to check for changed children position.
   * @private {?Node}
   */
  this.menuItemParent_ = null;

  /**
   * These are all menu items for the menu.
   * @private {!Array<Menu.menuItem>}
   */
  this.menuItems_ = [];
};


/**
 * The key for the object position. This is added on every menu item and kept
 * up to date.
 * @const
 */
Menu.ITEM_POSITION = 'menuPosition';


/**
 * Returns the menu wrapped by this controller.
 * @return {!goog.ui.Menu} The wrapped menu.
 */
Menu.Controller.prototype.getMenu = function() {
  return this.menu_;
};


/**
 * Determines the number of menu items which have been reordered from their
 * previous positions. Returns -1 if menu items are still being added
 * asynchronously.
 * @return {number}
 */
Menu.Controller.prototype.getNumChangedPositions = function() {
  if (!this.menuItemParent_) {
    return 0;
  }
  var changes = 0;
  var current = this.menuItemParent_.firstChild;
  var index = 0;
  var numItemMarkers = 0;

  while (current) {
    if (current[Menu.MENU_ITEM_MARKER_]) {
      var prevIdx = current[Menu.ITEM_POSITION];
      if (prevIdx != index) {
        changes++;
      }
      numItemMarkers++;
    }
    index++;
    current = current.nextSibling;
  }

  if (numItemMarkers != this.menuItems_.length) {
    return -1;
  }
  return changes;
};


/**
 * Updates the position of every menu item in the menu.
 */
Menu.Controller.prototype.updateMenuPositions = function() {
  var menu = this.getMenu();
  for (var i = 0; i < this.menuItems_.length; i++) {
    var element = this.menuItems_[i].element;
    var item = this.menuItems_[i].item;
    var idx = Menu.getIndexInParent_(element, this.menu_);
    element[Menu.ITEM_POSITION] = idx;
    menu.addChildAt(item, idx, !item.isInDocument());
  }
};


/**
 * Inserts a new menu item onto the menu. Determines the initial position based
 * on DOM order, and saves the order for later in order to watch for
 * reorderings.
 * @param {Menu.menuItem} menuItem The menu item to insert.
 * @private
 */
Menu.Controller.prototype.insertMenuItem_ = function(menuItem) {
  var menu = this.getMenu();

  var element = menuItem.element;
  var item = menuItem.item;
  var idx = Menu.getIndexInParent_(element, menu);

  element[Menu.ITEM_POSITION] = idx;
  menu.addChildAt(item, idx, !item.isInDocument() /* opt_render */);

  // Save the parent element in order to watch for reordering of children.
  // Fine to overwrite since all menu items should have the same parent.
  this.menuItemParent_ = element.parentNode;

  // Save the elements themselves in order to update their positioning upon
  // reordering.
  this.menuItems_.push(menuItem);
};


/**
 * Gets the index in the parent using element data `MENU_ITEM_MARKER_`.
 * @param {!Node} containerNode The parent node.
 * @param {goog.ui.Menu} menu The menu.
 * @return {number} The 0 based index in the parent.
 * @private
 */
Menu.getIndexInParent_ = function(containerNode, menu) {
  // Linking functions can be called in any order, so the correct
  // insertion point for the menu item must be inferred from the DOM
  // position of the original node within the parent node.
  var index = 0;
  var current = containerNode.parentNode.firstChild;
  while (current) {
    // Count the preceding menu items to get the correct insertion point
    // for this menu item, stop at the current one.
    if (current === containerNode) {
      return Math.min(index, menu.getChildCount());
    }
    if (current[Menu.MENU_ITEM_MARKER_]) {
      index++;
    }
    current = current.nextSibling;
  }
  throw new Error('Could not find index of menu item');
};

/**
 * Links a menu element to the underlying Closure menu.
 * @param {!angular.Scope} scope The AngularJS scope.
 * @param {!angular.JQLite} element The menu element.
 * @param {!angular.Attributes} attrs The attributes for the menu element.
 * @param {ng.jfk.Menu.MenuHolder=} opt_menuHolderCtrl The optional menu holder
 *     controller.
 */
Menu.Controller.prototype.linkMenu = function(scope, element, attrs,
    opt_menuHolderCtrl) {
  var newElement = this.render(element[0]);
  var menu = this.getMenu();

  if (opt_menuHolderCtrl) {
    opt_menuHolderCtrl.setMenu(menu);
  } else {
    // This is a standalone menu on the page, so keyboard shortcuts are not
    // handled by some container (e.g. a menubutton).
    menu.setFocusable(true);
  }

  this.jfkCommon_.componentLink(scope, attrs, menu);
};

/**
 * Links an item to the underlying menu. Watches its index, updates its
 * position as required, and removes it from parent on $destroy. This will also
 * render the item when it is first added to the menu.
 * @param {!angular.Scope} scope The AngularJS scope.
 * @param {!Node} element The container element in the parent node.
 * @param {(goog.ui.MenuItem|goog.ui.MenuSeparator)} item The menu item.
 */
Menu.Controller.prototype.linkMenuItem = function(scope, element, item) {
  var menuItem = {item: item, element: element};

  // Insert menu item after children have been rendered.
  scope.$evalAsync(goog.bind(this.insertMenuItem_, this, menuItem));

  scope.$on('$destroy', goog.bind(function() {
    // Only remove the item if it has actually been added to the parent (block
    // above has ever executed) and the menu is not disposed (its $destroy event
    // can happen before children's $destroy)
    var menu = this.getMenu();
    if (item.getParent() && !menu.isDisposed()) {
      // Protect against scope $destroy and dispose() happening out of order
      menu.removeChild(item);
      goog.array.remove(this.menuItems_, menuItem);
    }
  }, this));
};

/**
 * Renders the menu into the given parent element.
 * @param {?Element} parent Node to render the component into.
 * @return {Element} The element created.
 */
Menu.Controller.prototype.render = function(parent) {
  var menu = this.getMenu();
  menu.render(parent);
  return menu.getElement();
};

/**
 * Simple holder for a goog.ui.Menu, so that parent components can provide this
 * as a controller and the menu directive can register itself with it.
 * @constructor
 */
Menu.MenuHolder = function() {
  /** @private {?goog.ui.Menu} */
  this.menu_ = null;

  /** @private {?function(!jfk.Select, !angular.Scope)} */
  this.registerSelect_ = null;
};

/**
 * The Angular Controller name, used in 'name' and 'require' tags of directives
 * to pass the menu holder around.
 * @const
 */
Menu.MenuHolder.CONTROLLER_NAME = 'jfkMenuHolder';

/**
 * Register the goog.ui.Menu to be used for this component.
 * @param {goog.ui.Menu} menu The menu to be used for this component.
 */
Menu.MenuHolder.prototype.setMenu = function(menu) {
  this.menu_ = menu;
};

/**
 * @return {goog.ui.Menu} The menu to be used for this component.
 */
Menu.MenuHolder.prototype.getMenu = function() {
  return this.menu_;
};

/**
 * Sets a function to be called when registering a select.
 * @param {function(!jfk.Select, !angular.Scope)} registerSelect
 */
Menu.MenuHolder.prototype.setRegisterSelect = function(registerSelect) {
  this.registerSelect_ = registerSelect;
};

/**
 * Registers a select for use with the menu.
 * @param {!jfk.Select} select The JFK select being used with the menu.
 * @param {!angular.Scope} scope The scope of the select.
 */
Menu.MenuHolder.prototype.registerSelect = function(select, scope) {
  if (this.registerSelect_) {
    this.registerSelect_(select, scope);
  }
};


Menu.directive('jfkMenu', function() {
  return {
    'require': ['jfkMenu', '^?' + Menu.MenuHolder.CONTROLLER_NAME],
    'controller': ['jfkCommon', Menu.Controller],
    'link': function(scope, element, attrs, ctrls) {
      var menuCtrl = /** @type {ng.jfk.Menu.Controller} */ (ctrls[0]);
      var menuHolder = /** @type {ng.jfk.Menu.MenuHolder} */ (ctrls[1]);
      menuCtrl.linkMenu(scope, element, attrs, menuHolder);

      // Update the order of items in case they change.
      // NOTE: This only updates menu positions if all menu items are fully
      // added as closure children, but should trigger after menu items are
      // added as $evalAsync will schedule another digest, and the watch
      // expression will switch from -1 to a nonnegative number.
      scope.$watch(goog.bind(menuCtrl.getNumChangedPositions, menuCtrl),
                   function(newCount) {
                     if (newCount !== -1) {
                       menuCtrl.updateMenuPositions();
                     }
                   });
    },
    'restrict': 'EAM'
  };
});

/**
 * String key to mark menu items in the parent container, see below.
 * @const
 * @private
 */
Menu.MENU_ITEM_MARKER_ = 'jfkMenuItemMarker';

/**
 * Function to construct linking functions for `jfkMenuItem` and
 * `jfkMenuSeparator` and `jfkCheckBoxMenuItem` and `jfkMenuChild`.
 * @param {function(Element, !angular.Scope=, !angular.Attributes=)} itemFactory
 *     Function that's called with the content element. Should return the newly
 *     created menu item to insert.
 * @param {boolean} stopPropagationByDefault Whether or not to stop ACTION
 *     event propagation by default.
 * @return {!Array} An Angular directive constructor function.
 * @private
 */
Menu.buildItemLinkFunction_ = function(itemFactory, stopPropagationByDefault) {
  return [
    'jfkCommon',
    function(jfkCommon) {
      return {
        'require': ['^jfkMenu'],
        'priority':
            200,  // Before attribute interpolation, so attributes don't try
                  // to assign values into comments.
        'terminal':
            true,  // Stop further directive linking (interpolation etc).
        'transclude': 'element',
        'compile': function(tElement, tAttrs, transcludeFn) {
          return function($scope, element, attrs, ctrls) {
            var menuCtrl = /** @type {ng.jfk.Menu.Controller} */ (ctrls[0]);

            Menu.setItemMarker(element);
            var containerNode = element[0];

            // Instantiate a node in the local scope. Passing an empty function
            // is
            // required for AngularJS to actually clone the element.
            var itemElement = transcludeFn($scope, function() {});
            var item = itemFactory(itemElement[0], $scope, attrs);

            // We only stop propagation if we don't have a value for
            // jfkCloseOnAction but we stopPropagationByDefault, or when we do
            // have
            // a value and it evaluates to false.
            var expr = attrs['jfkCloseOnAction'];
            goog.events.listen(
                item, goog.ui.Component.EventType.ACTION, function(e) {
                  if ((!expr && stopPropagationByDefault) ||
                      (expr && !$scope.$eval(expr))) {
                    e.stopPropagation();
                  }
                });
            menuCtrl.linkMenuItem($scope, containerNode, item);
            jfkCommon.componentLink($scope, attrs, item);
          };
        },
        'restrict': 'EAM'
      };
    }
  ];
};

Menu.directive('jfkMenuItem', Menu.buildItemLinkFunction_(function(element) {
  return new goog.ui.MenuItem(element);
}, false));

Menu.directive('jfkMenuChild', Menu.buildItemLinkFunction_(
    function(element, scope, attrs) {
  return new goog.ui.Control(element);
}, true));

Menu.directive('jfkCheckBoxMenuItem', Menu.buildItemLinkFunction_(
    function(element, scope, attrs) {
  var item = new goog.ui.CheckBoxMenuItem(element);

  // One-way binding.
  if (attrs['ngChecked']) {
    scope.$watch(attrs['ngChecked'], function(newValue) {
      item.setChecked(!!newValue);
    });
  }

  // Since CheckBoxMenuItem doesn't trigger check and uncheck events,
  // listen for the action event here and trigger the more appropriate events
  // to improve the directive interface. Using the item event handler ensures
  // the listener gets removed on dispose.
  item.listen(goog.ui.Component.EventType.ACTION,
      function() {
    if (item.isChecked()) {
      var event = new goog.events.Event(goog.ui.Component.EventType.CHECK);
      goog.events.dispatchEvent(item, event);
    } else {
      var event = new goog.events.Event(goog.ui.Component.EventType.UNCHECK);
      goog.events.dispatchEvent(item, event);
    }
  });

  return item;
}, false));

Menu.directive('jfkTriStateMenuItem',
    Menu.buildItemLinkFunction_(function(element, scope, attrs) {
  var item = new goog.ui.TriStateMenuItem(element);
  item.render(element[0]);

  // One-way binding.
  // We use ng-checked to determine which of the three states the menu item
  // has. A boolean true implies fully checked, a boolean false implies not
  // checked and any other value (i.e. any non-boolean value) would imply
  // partially checked.
  if (attrs['ngChecked']) {
    scope.$watch(attrs['ngChecked'], function(newValue) {
      if (newValue != null) {
        item.setCheckedState(newValue === true ?
            goog.ui.TriStateMenuItem.State.FULLY_CHECKED :
            (newValue === false ?
                goog.ui.TriStateMenuItem.State.NOT_CHECKED :
                goog.ui.TriStateMenuItem.State.PARTIALLY_CHECKED));
      }
    });
  }

  return item;
}, false));

Menu.directive('jfkSubMenu', [
  'jfkCommon',
  function(jfkCommon) {
    return {
      'name': Menu.MenuHolder.CONTROLLER_NAME,
      'require': ['^jfkMenu', Menu.MenuHolder.CONTROLLER_NAME],
      'priority':
          200,  // Before attribute interpolation, so attributes don't try
                // to assign values into comments.
      'controller': Menu.MenuHolder,
      'transclude': false,
      'compile': function(tElement, tAttrs) {
        return function($scope, element, attrs, ctrls) {
          var menuCtrl = /** @type {ng.jfk.Menu.Controller} */ (ctrls[0]);
          var menuHolder = /** @type {ng.jfk.Menu.MenuHolder} */ (ctrls[1]);

          Menu.setItemMarker(element);
          var containerNode = element[0];

          var caption = containerNode.children[0];
          if (caption['nodeName'] !== 'SPAN') {
            throw new Error(
                'SubMenu requires a SPAN with the caption as the first child');
          }

          var submenu = new goog.ui.SubMenu(caption);
          var menu = menuHolder.getMenu();

          // Used to remove the element we append to body. When the watch on
          // $destroy is called the menu can already be disposed and we can't
          // rely
          // on menu.getElement() in the watch.
          var addedElement = menu.getElement().parentElement;

          // The parent element is the one on which the jfk menu directive is
          // applied. We remove it from the DOM to keep the children of
          // jfkSubMenu
          // clean, and as expected by closure.
          goog.dom.removeNode(addedElement);
          // Menu elements render in place, we need to move it to the end of the
          // doc as expected by the closure component. SubMenus will render in
          // the
          // wrong place (not next to their parent) if this is not done.
          goog.dom.appendChild(goog.dom.getDocument().body, addedElement);
          // This is not a standalone menu, so events are handled by the
          // container, i.e., the parent sub menu.
          menu.setFocusable(false);

          submenu.setParent(menuCtrl.getMenu());
          submenu.setMenu(menu);

          menuCtrl.linkMenuItem($scope, containerNode, submenu);

          $scope.$on('$destroy', function() {
            // Delete the extra element we added at the end of the document.
            goog.dom.removeNode(addedElement);
          });
          jfkCommon.componentLink($scope, attrs, submenu);
        };
      },
      'restrict': 'EAM'
    };
  }
]);

Menu.directive('jfkMenuSeparator', Menu.buildItemLinkFunction_(
    function(element, $scope, $attrs) {
  var separator = new goog.ui.MenuSeparator();
  // Since separator does not keep a reference to element, the latter will not
  // be subject to normal cleanup during scope destruction as specified in
  // jfkCommon#componentLink(). To ensure any data previously associated with
  // it in jQuery is properly released for garbage collection, and also to mimic
  // the DOM structure of other menu items, we remove it ourselves here.
  angular.element(element).remove();
  return separator;
}, false));

});  // goog.scope

//javascript/angular/jfkwrappers/menu/menubutton.js
/**
 * @fileoverview Implements a directive for goog.ui.MenuButton.
 * Interacts with a nested goog.ui.Menu. Example:
 * <pre>
 * &lt;div jfk-menu-button>
 *   &lt;span>Menu Label&lt;/span>
 *   &lt;div jfk-menu>
 *     &lt;div jfk-menu-item
 *             jfk-on-action="doSomething()">Item 1&lt;/div>
 *     ...
 *   &lt;/div>
 * &lt;/div>
 * </pre>.
 *
 * Note that the label is optional.
 */
'use strict';
goog.provide('ng.jfk.MenuButton');

goog.require('goog.ui.FlatMenuButtonRenderer');
goog.require('goog.ui.MenuButton');
goog.require('ng.jfk.ButtonSide');
goog.require('ng.jfk.Common');
goog.require('ng.jfk.Menu');

/**
 * Angular Module for the jfk-menu-button directive.
 * @type {!angular.Module}
 */
ng.jfk.MenuButton = angular.module('jfkMenuButton',
    [ng.jfk.Menu.name, ng.jfk.Common.name]);

goog.scope(function() {
var Menu = ng.jfk.Menu;
var MenuButton = ng.jfk.MenuButton;


/**
 * @param {!angular.JQLite} $element
 * @param {!angular.Attributes} $attrs
 * @param {!goog.ui.MenuButton} menuButton
 */
function applyCollapsedStyle($element, $attrs, menuButton) {
  if ($attrs.hasOwnProperty('jfkMenuButtonCollapsed')) {
    $attrs.$observe('jfkMenuButtonCollapsed', function(newCollapsed) {
      menuButton.setCollapsed(ng.jfk.ButtonSide[newCollapsed]);
    });
  }
}

MenuButton.directive('jfkMenuButton', ['jfkCommon', function(jfkCommon) {
  return {
    'name': ng.jfk.Menu.MenuHolder.CONTROLLER_NAME,
    'controller': ng.jfk.Menu.MenuHolder,
    'require': ['jfkMenuHolder'],
    'restrict': 'EAM',
    'link': function($scope, $element, $attrs, ctrls) {
      var menuHolder = /** @type {ng.jfk.Menu.MenuHolder} */ (ctrls[0]);
      var menu = menuHolder.getMenu();
      var menuButton = new goog.ui.MenuButton(
          Menu.getOrCreateTitleElement($element[0]),
          menu,
          goog.ui.FlatMenuButtonRenderer.getInstance());
      // Support limiting the height through CSS to get scrolling.
      menuButton.setScrollOnOverflow(true);
      // Support controls in the menu that can receive clicks etc.
      menuButton.setFocusablePopupMenu(true);
      applyCollapsedStyle($element, $attrs, menuButton);

      // Render the button into the JFK element.
      menuButton.render($element[0]);

      jfkCommon.componentLink($scope, $attrs, menuButton);
    }
  };
}]);

});  // goog.scope

//javascript/angular/jfkwrappers/menu/select.js
/**
 * @fileoverview Implements a directive for jfk.Select, a drop down select based
 * on a menu. Interacts with a nested goog.ui.Menu. Items for the select are
 * explicitly built as menu items in the underlying menu; use the attribute
 * jfk-model-value to assign model values to menu items.
 *
 * <p>When nothing is selected, the select's label ("Choose Something" below) is
 * displayed, and once something is selected, it's impossible to un-select.
 * Alternatively, a `null` model value on an item represents the empty
 * selection.
 *
 * <p><b>WARNING</p>: The popup select menu will likely display _behind_ the
 * button unless a custom CSS rule like: '.goog-menu { z-index: 3 }' is added.
 *
 * Example:<pre>
 * &lt;div jfk-select>
 *   &lt;span>Choose Something&lt;/span>
 *   &lt;div jfk-menu>
 *     &lt;div ng-repeat="value in options"
 *             jfk-menu-item
 *             jfk-model-value="value">{{value.label}}&lt;/div>
 *     &lt;div jfk-menu-item
 *             jfk-model-value="null">(n/a)&lt;/div>
 *     ...
 *   &lt;/div>
 * &lt;/div>
 * </pre>
 *
 * Note that the label ('Choose Something' above) is optional.
 */
'use strict';
goog.provide('ng.jfk.Select');

goog.require('goog.ui.Component');
goog.require('jfk.Select');
goog.require('ng.jfk.Common');
goog.require('ng.jfk.Menu');

/**
 * Angular Module for the jfk-select directive.
 * @type {!angular.Module}
 */
ng.jfk.Select = angular.module('jfkSelect',
    [ng.jfk.Menu.name, ng.jfk.Common.name]);

goog.scope(function() {
var Menu = ng.jfk.Menu;
var Select = ng.jfk.Select;

Select.directive('jfkSelect', ['jfkCommon', function(jfkCommon) {
  return {
    'name': ng.jfk.Menu.MenuHolder.CONTROLLER_NAME,
    'controller': ng.jfk.Menu.MenuHolder,
    'require': ['jfkMenuHolder', '^?ngModel'],
    'restrict': 'EAM',
    'link': function($scope, $element, $attrs, ctrls) {
      var menuHolder = /** @type {ng.jfk.Menu.MenuHolder} */ (ctrls[0]);
      var menu = menuHolder.getMenu();
      // Keyboard interaction is handled by the menubutton.
      menu.setFocusable(false);
      var select = new jfk.Select(
          Menu.getOrCreateTitleElement($element[0]),
          menu);
      menuHolder.registerSelect(select, $scope);
      select.setScrollOnOverflow(true);
      select.render($element[0]);

      // Watch for changes of the menu items. goog.ui.Select must maintain a
      // selection model to work properly, Angular's dynamic adding and removing
      // of menu items conflicts.
      $scope.$watch(function() {
        // Watch the inputs to the selection model to make the model live.
        var selectionModelInputs = [];
        menu.forEachChild(function(child) {
          // Watching IDs is cheaper.
          selectionModelInputs.push(child.getId());
          // Also listen for the model objects changing.
          selectionModelInputs.push(child.getModel && child.getModel());
        });
        return selectionModelInputs;
      }, function() {
        // Maintain the open state of the menu when the data is changed.
        var isOpen = select.isOpen();
        // Force a re-build of the selection model.
        select.setMenu(null);
        select.setMenu(menu);
        // Update the selected value after changing the selection model.
        updateFromViewValue();
        select.setOpen(isOpen);
      }, true /* deep */);

      var ngModel = /** @type {angular.NgModelController} */ (ctrls[1]);
      var allowModelUpdates = true;
      if (ngModel) {
        ngModel.$render = updateFromViewValue;
        // Prevent the `select` component to try to update `ngModel` once the
        // $scope is destroyed.
        $scope.$on('$destroy', function() { ngModel = null; });

        jfkCommon.listenUntilDestroy(
            $scope,
            select,
            goog.ui.Component.EventType.CHANGE,
            function() {
              // Prevent recursive changed to the model. This can happen if
              // when an item is added to the menu and selected at the same
              // time. Render can be called before the item is properly synced
              // to the menu. The underlying select would then set the value to
              // null and sync that to the mode through this callback.
              if (allowModelUpdates) {
                jfkCommon.evalInDigest($scope, function() {
                    var value = jfkCommon.modelToValue(select.getValue());
                    ngModel.$setViewValue(value);
                  });
              }
            });
      }

      // Link jfk-on-change etc attributes after the binding setup above,
      // otherwise event handlers can observe stale values.
      jfkCommon.componentLink($scope, $attrs, select);

      function updateFromViewValue() {
        if (ngModel) {
          try {
            allowModelUpdates = false;
            // setValue sets the model value for the goog.ui.Select.
            select.setValue(jfkCommon.valueToModel(ngModel.$viewValue));
          } finally {
            allowModelUpdates = true;
          }
        }
      }
    }
  };
}]);

});  // goog.scope

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/recoverydirectives.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview Custom Angular directives.
 */

goog.module('recovery.directives');
goog.module.declareLegacyNamespace();

const recovery = goog.require('recovery');

/** Define the directives module */
var directives = angular.module('recoveryDirectives', []).config([
  '$controllerProvider',
  function($controllerProvider) {
    // Port legacy app from v1.2 to v1.3.
    $controllerProvider.allowGlobals();
  }
]);

/**
 * Set tabindex on the <div> with class name 'jfk-select' under a
 * <jfk-select> element.
 * @param {!HTMLElement} element The <jfk-select> element.
 * @param {number} tabindex The tabindex value.
 */
recovery.overrideJfkSelectTabIndex = function(element, tabindex) {
  // Use a Timeout because at the time this directive triggers the
  // <div> child element doesn't exist yet.
  // TODO(stephenlin): Figure out how to do this without a Timeout
  //   probably using angular directive priorities.
  setTimeout(function() {
    var el = element.getElementsByClassName('jfk-select')[0];
    el.setAttribute('tabindex', tabindex);
  }, 0);
};

/**
 * The jfk controls do not support setting a tabindex. This directive is a
 * hack to set the tabindex on jfk-menu-buttons.
 */
directives.directive('overrideJfkSelectTabindex', function() {
  return {
    link: function(scope, elements, attrs) {
      recovery.overrideJfkSelectTabIndex(
          elements[0], attrs['overrideJfkSelectTabindex']);
    }
  };
});

/**
 * Provides a directive for creating the footer of the page.  This includes the
 * Learn More link and forward/back buttons.
 */
directives.directive('appFooter', function() {
  return {
    restrict: 'E',
    scope: {
      disableForward: '=',
      disableBack: '=',
      forward: '&',
      back: '&',
      forwardText: '@',
      backText: '@',
      hideForward: '@',
      hideBack: '@'
    },
    templateUrl: 'html/footer.html'
  };
});

exports = directives;

;return exports;});

//third_party/javascript/closure/i18n/compactnumberformatsymbols.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Compact number formatting symbols.
 *
 * File generated from CLDR ver. 39
 * MOE:begin_intracomment_strip
 * This file is generated by
 *   //depot/google3/java/com/google/i18n/tools/generators/locale:locale
 *
 * See {@link go/js-locale-data-update} for details.
 *
 * To fix bugs here, you should follow the procedure detailed at
 * go/i-think-locale-data-is-wrong instead of sending a CL for this file.
 * MOE:end_intracomment_strip
 *
 * To reduce the file size (which may cause issues in some JS
 * developing environments), this file will only contain locales
 * that are frequently used by web applications. This is defined as
 * proto/closure_locales_data.txt and will change (most likely addition)
 * over time.  Rest of the data can be found in another file named
 * "compactnumberformatsymbolsext.js", which will be generated at
 * the same time together with this file.
 *
 * @suppress {const,useOfGoogProvide}
 */

// clang-format off

goog.provide('goog.i18n.CompactNumberFormatSymbols');
goog.provide('goog.i18n.CompactNumberFormatSymbols_af');
goog.provide('goog.i18n.CompactNumberFormatSymbols_am');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ar');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ar_DZ');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ar_EG');
goog.provide('goog.i18n.CompactNumberFormatSymbols_az');
goog.provide('goog.i18n.CompactNumberFormatSymbols_be');
goog.provide('goog.i18n.CompactNumberFormatSymbols_bg');
goog.provide('goog.i18n.CompactNumberFormatSymbols_bn');
goog.provide('goog.i18n.CompactNumberFormatSymbols_br');
goog.provide('goog.i18n.CompactNumberFormatSymbols_bs');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ca');
goog.provide('goog.i18n.CompactNumberFormatSymbols_chr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_cs');
goog.provide('goog.i18n.CompactNumberFormatSymbols_cy');
goog.provide('goog.i18n.CompactNumberFormatSymbols_da');
goog.provide('goog.i18n.CompactNumberFormatSymbols_de');
goog.provide('goog.i18n.CompactNumberFormatSymbols_de_AT');
goog.provide('goog.i18n.CompactNumberFormatSymbols_de_CH');
goog.provide('goog.i18n.CompactNumberFormatSymbols_el');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_AU');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_CA');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_GB');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_IE');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_IN');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_SG');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_US');
goog.provide('goog.i18n.CompactNumberFormatSymbols_en_ZA');
goog.provide('goog.i18n.CompactNumberFormatSymbols_es');
goog.provide('goog.i18n.CompactNumberFormatSymbols_es_419');
goog.provide('goog.i18n.CompactNumberFormatSymbols_es_ES');
goog.provide('goog.i18n.CompactNumberFormatSymbols_es_MX');
goog.provide('goog.i18n.CompactNumberFormatSymbols_es_US');
goog.provide('goog.i18n.CompactNumberFormatSymbols_et');
goog.provide('goog.i18n.CompactNumberFormatSymbols_eu');
goog.provide('goog.i18n.CompactNumberFormatSymbols_fa');
goog.provide('goog.i18n.CompactNumberFormatSymbols_fi');
goog.provide('goog.i18n.CompactNumberFormatSymbols_fil');
goog.provide('goog.i18n.CompactNumberFormatSymbols_fr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_fr_CA');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ga');
goog.provide('goog.i18n.CompactNumberFormatSymbols_gl');
goog.provide('goog.i18n.CompactNumberFormatSymbols_gsw');
goog.provide('goog.i18n.CompactNumberFormatSymbols_gu');
goog.provide('goog.i18n.CompactNumberFormatSymbols_haw');
goog.provide('goog.i18n.CompactNumberFormatSymbols_he');
goog.provide('goog.i18n.CompactNumberFormatSymbols_hi');
goog.provide('goog.i18n.CompactNumberFormatSymbols_hr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_hu');
goog.provide('goog.i18n.CompactNumberFormatSymbols_hy');
goog.provide('goog.i18n.CompactNumberFormatSymbols_id');
goog.provide('goog.i18n.CompactNumberFormatSymbols_in');
goog.provide('goog.i18n.CompactNumberFormatSymbols_is');
goog.provide('goog.i18n.CompactNumberFormatSymbols_it');
goog.provide('goog.i18n.CompactNumberFormatSymbols_iw');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ja');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ka');
goog.provide('goog.i18n.CompactNumberFormatSymbols_kk');
goog.provide('goog.i18n.CompactNumberFormatSymbols_km');
goog.provide('goog.i18n.CompactNumberFormatSymbols_kn');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ko');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ky');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ln');
goog.provide('goog.i18n.CompactNumberFormatSymbols_lo');
goog.provide('goog.i18n.CompactNumberFormatSymbols_lt');
goog.provide('goog.i18n.CompactNumberFormatSymbols_lv');
goog.provide('goog.i18n.CompactNumberFormatSymbols_mk');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ml');
goog.provide('goog.i18n.CompactNumberFormatSymbols_mn');
goog.provide('goog.i18n.CompactNumberFormatSymbols_mo');
goog.provide('goog.i18n.CompactNumberFormatSymbols_mr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ms');
goog.provide('goog.i18n.CompactNumberFormatSymbols_mt');
goog.provide('goog.i18n.CompactNumberFormatSymbols_my');
goog.provide('goog.i18n.CompactNumberFormatSymbols_nb');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ne');
goog.provide('goog.i18n.CompactNumberFormatSymbols_nl');
goog.provide('goog.i18n.CompactNumberFormatSymbols_no');
goog.provide('goog.i18n.CompactNumberFormatSymbols_no_NO');
goog.provide('goog.i18n.CompactNumberFormatSymbols_or');
goog.provide('goog.i18n.CompactNumberFormatSymbols_pa');
goog.provide('goog.i18n.CompactNumberFormatSymbols_pl');
goog.provide('goog.i18n.CompactNumberFormatSymbols_pt');
goog.provide('goog.i18n.CompactNumberFormatSymbols_pt_BR');
goog.provide('goog.i18n.CompactNumberFormatSymbols_pt_PT');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ro');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ru');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sh');
goog.provide('goog.i18n.CompactNumberFormatSymbols_si');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sk');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sl');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sq');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sr_Latn');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sv');
goog.provide('goog.i18n.CompactNumberFormatSymbols_sw');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ta');
goog.provide('goog.i18n.CompactNumberFormatSymbols_te');
goog.provide('goog.i18n.CompactNumberFormatSymbols_th');
goog.provide('goog.i18n.CompactNumberFormatSymbols_tl');
goog.provide('goog.i18n.CompactNumberFormatSymbols_tr');
goog.provide('goog.i18n.CompactNumberFormatSymbols_uk');
goog.provide('goog.i18n.CompactNumberFormatSymbols_ur');
goog.provide('goog.i18n.CompactNumberFormatSymbols_uz');
goog.provide('goog.i18n.CompactNumberFormatSymbols_vi');
goog.provide('goog.i18n.CompactNumberFormatSymbols_zh');
goog.provide('goog.i18n.CompactNumberFormatSymbols_zh_CN');
goog.provide('goog.i18n.CompactNumberFormatSymbols_zh_HK');
goog.provide('goog.i18n.CompactNumberFormatSymbols_zh_TW');
goog.provide('goog.i18n.CompactNumberFormatSymbols_zu');


/**
 * Compact number formatting symbols for locale af.
 */
goog.i18n.CompactNumberFormatSymbols_af = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 k'
    },
    '10000': {
      'other': '00 k'
    },
    '100000': {
      'other': '000 k'
    },
    '1000000': {
      'other': '0 m'
    },
    '10000000': {
      'other': '00 m'
    },
    '100000000': {
      'other': '000 m'
    },
    '1000000000': {
      'other': '0 mjd'
    },
    '10000000000': {
      'other': '00 mjd'
    },
    '100000000000': {
      'other': '000 mjd'
    },
    '1000000000000': {
      'other': '0 bn'
    },
    '10000000000000': {
      'other': '00 bn'
    },
    '100000000000000': {
      'other': '000 bn'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 duisend'
    },
    '10000': {
      'other': '00 duisend'
    },
    '100000': {
      'other': '000 duisend'
    },
    '1000000': {
      'other': '0 miljoen'
    },
    '10000000': {
      'other': '00 miljoen'
    },
    '100000000': {
      'other': '000 miljoen'
    },
    '1000000000': {
      'other': '0 miljard'
    },
    '10000000000': {
      'other': '00 miljard'
    },
    '100000000000': {
      'other': '000 miljard'
    },
    '1000000000000': {
      'other': '0 biljoen'
    },
    '10000000000000': {
      'other': '00 biljoen'
    },
    '100000000000000': {
      'other': '000 biljoen'
    }
  }
};


/**
 * Compact number formatting symbols for locale am.
 */
goog.i18n.CompactNumberFormatSymbols_am = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ሺ'
    },
    '10000': {
      'other': '00 ሺ'
    },
    '100000': {
      'other': '000 ሺ'
    },
    '1000000': {
      'other': '0 ሚ'
    },
    '10000000': {
      'other': '00 ሚ'
    },
    '100000000': {
      'other': '000 ሚ'
    },
    '1000000000': {
      'other': '0 ቢ'
    },
    '10000000000': {
      'other': '00 ቢ'
    },
    '100000000000': {
      'other': '000 ቢ'
    },
    '1000000000000': {
      'other': '0 ት'
    },
    '10000000000000': {
      'other': '00 ት'
    },
    '100000000000000': {
      'other': '000 ት'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ሺ'
    },
    '10000': {
      'other': '00 ሺ'
    },
    '100000': {
      'other': '000 ሺ'
    },
    '1000000': {
      'other': '0 ሚሊዮን'
    },
    '10000000': {
      'other': '00 ሚሊዮን'
    },
    '100000000': {
      'other': '000 ሚሊዮን'
    },
    '1000000000': {
      'other': '0 ቢሊዮን'
    },
    '10000000000': {
      'other': '00 ቢሊዮን'
    },
    '100000000000': {
      'other': '000 ቢሊዮን'
    },
    '1000000000000': {
      'other': '0 ትሪሊዮን'
    },
    '10000000000000': {
      'other': '00 ትሪሊዮን'
    },
    '100000000000000': {
      'other': '000 ትሪሊዮን'
    }
  }
};


/**
 * Compact number formatting symbols for locale ar.
 */
goog.i18n.CompactNumberFormatSymbols_ar = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ألف'
    },
    '10000': {
      'other': '00 ألف'
    },
    '100000': {
      'other': '000 ألف'
    },
    '1000000': {
      'other': '0 مليون'
    },
    '10000000': {
      'other': '00 مليون'
    },
    '100000000': {
      'other': '000 مليون'
    },
    '1000000000': {
      'other': '0 مليار'
    },
    '10000000000': {
      'other': '00 مليار'
    },
    '100000000000': {
      'other': '000 مليار'
    },
    '1000000000000': {
      'other': '0 ترليون'
    },
    '10000000000000': {
      'other': '00 ترليون'
    },
    '100000000000000': {
      'other': '000 ترليون'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ألف'
    },
    '10000': {
      'other': '00 ألف'
    },
    '100000': {
      'other': '000 ألف'
    },
    '1000000': {
      'other': '0 مليون'
    },
    '10000000': {
      'other': '00 مليون'
    },
    '100000000': {
      'other': '000 مليون'
    },
    '1000000000': {
      'other': '0 مليار'
    },
    '10000000000': {
      'other': '00 مليار'
    },
    '100000000000': {
      'other': '000 مليار'
    },
    '1000000000000': {
      'other': '0 ترليون'
    },
    '10000000000000': {
      'other': '00 ترليون'
    },
    '100000000000000': {
      'other': '000 ترليون'
    }
  }
};


/**
 * Compact number formatting symbols for locale ar_DZ.
 */
goog.i18n.CompactNumberFormatSymbols_ar_DZ = goog.i18n.CompactNumberFormatSymbols_ar;


/**
 * Compact number formatting symbols for locale ar_EG.
 */
goog.i18n.CompactNumberFormatSymbols_ar_EG = goog.i18n.CompactNumberFormatSymbols_ar;


/**
 * Compact number formatting symbols for locale az.
 */
goog.i18n.CompactNumberFormatSymbols_az = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0 mln'
    },
    '10000000': {
      'other': '00 mln'
    },
    '100000000': {
      'other': '000 mln'
    },
    '1000000000': {
      'other': '0 mlrd'
    },
    '10000000000': {
      'other': '00 mlrd'
    },
    '100000000000': {
      'other': '000 mlrd'
    },
    '1000000000000': {
      'other': '0 trln'
    },
    '10000000000000': {
      'other': '00 trln'
    },
    '100000000000000': {
      'other': '000 trln'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 min'
    },
    '10000': {
      'other': '00 min'
    },
    '100000': {
      'other': '000 min'
    },
    '1000000': {
      'other': '0 milyon'
    },
    '10000000': {
      'other': '00 milyon'
    },
    '100000000': {
      'other': '000 milyon'
    },
    '1000000000': {
      'other': '0 milyard'
    },
    '10000000000': {
      'other': '00 milyard'
    },
    '100000000000': {
      'other': '000 milyard'
    },
    '1000000000000': {
      'other': '0 trilyon'
    },
    '10000000000000': {
      'other': '00 trilyon'
    },
    '100000000000000': {
      'other': '000 trilyon'
    }
  }
};


/**
 * Compact number formatting symbols for locale be.
 */
goog.i18n.CompactNumberFormatSymbols_be = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 тыс.'
    },
    '10000': {
      'other': '00 тыс.'
    },
    '100000': {
      'other': '000 тыс.'
    },
    '1000000': {
      'other': '0 млн'
    },
    '10000000': {
      'other': '00 млн'
    },
    '100000000': {
      'other': '000 млн'
    },
    '1000000000': {
      'other': '0 млрд'
    },
    '10000000000': {
      'other': '00 млрд'
    },
    '100000000000': {
      'other': '000 млрд'
    },
    '1000000000000': {
      'other': '0 трлн'
    },
    '10000000000000': {
      'other': '00 трлн'
    },
    '100000000000000': {
      'other': '000 трлн'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 тысячы'
    },
    '10000': {
      'other': '00 тысячы'
    },
    '100000': {
      'other': '000 тысячы'
    },
    '1000000': {
      'other': '0 мільёна'
    },
    '10000000': {
      'other': '00 мільёна'
    },
    '100000000': {
      'other': '000 мільёна'
    },
    '1000000000': {
      'other': '0 мільярда'
    },
    '10000000000': {
      'other': '00 мільярда'
    },
    '100000000000': {
      'other': '000 мільярда'
    },
    '1000000000000': {
      'other': '0 трыльёна'
    },
    '10000000000000': {
      'other': '00 трыльёна'
    },
    '100000000000000': {
      'other': '000 трыльёна'
    }
  }
};


/**
 * Compact number formatting symbols for locale bg.
 */
goog.i18n.CompactNumberFormatSymbols_bg = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 хил.'
    },
    '10000': {
      'other': '00 хил.'
    },
    '100000': {
      'other': '000 хил.'
    },
    '1000000': {
      'other': '0 млн.'
    },
    '10000000': {
      'other': '00 млн.'
    },
    '100000000': {
      'other': '000 млн.'
    },
    '1000000000': {
      'other': '0 млрд.'
    },
    '10000000000': {
      'other': '00 млрд.'
    },
    '100000000000': {
      'other': '000 млрд.'
    },
    '1000000000000': {
      'other': '0 трлн.'
    },
    '10000000000000': {
      'other': '00 трлн.'
    },
    '100000000000000': {
      'other': '000 трлн.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 хиляди'
    },
    '10000': {
      'other': '00 хиляди'
    },
    '100000': {
      'other': '000 хиляди'
    },
    '1000000': {
      'other': '0 милиона'
    },
    '10000000': {
      'other': '00 милиона'
    },
    '100000000': {
      'other': '000 милиона'
    },
    '1000000000': {
      'other': '0 милиарда'
    },
    '10000000000': {
      'other': '00 милиарда'
    },
    '100000000000': {
      'other': '000 милиарда'
    },
    '1000000000000': {
      'other': '0 трилиона'
    },
    '10000000000000': {
      'other': '00 трилиона'
    },
    '100000000000000': {
      'other': '000 трилиона'
    }
  }
};


/**
 * Compact number formatting symbols for locale bn.
 */
goog.i18n.CompactNumberFormatSymbols_bn = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 হা'
    },
    '10000': {
      'other': '00 হা'
    },
    '100000': {
      'other': '0 লা'
    },
    '1000000': {
      'other': '00 লা'
    },
    '10000000': {
      'other': '0 কো'
    },
    '100000000': {
      'other': '00 কো'
    },
    '1000000000': {
      'other': '000 কো'
    },
    '10000000000': {
      'other': '00শত কো'
    },
    '100000000000': {
      'other': '000কো'
    },
    '1000000000000': {
      'other': '0 লা.কো.'
    },
    '10000000000000': {
      'other': '00 লা.কো.'
    },
    '100000000000000': {
      'other': '000 লা.কো.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 হাজার'
    },
    '10000': {
      'other': '00 হাজার'
    },
    '100000': {
      'other': '0 লাখ'
    },
    '1000000': {
      'other': '00 লাখ'
    },
    '10000000': {
      'other': '0 কোটি'
    },
    '100000000': {
      'other': '00 কোটি'
    },
    '1000000000': {
      'other': '000 কোটি'
    },
    '10000000000': {
      'other': '0000 কোটি'
    },
    '100000000000': {
      'other': '00000 কোটি'
    },
    '1000000000000': {
      'other': '0 লাখ কোটি'
    },
    '10000000000000': {
      'other': '00 লাখ কোটি'
    },
    '100000000000000': {
      'other': '000 লাখ কোটি'
    }
  }
};


/**
 * Compact number formatting symbols for locale br.
 */
goog.i18n.CompactNumberFormatSymbols_br = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0k'
    },
    '10000': {
      'other': '00k'
    },
    '100000': {
      'other': '000k'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0G'
    },
    '10000000000': {
      'other': '00G'
    },
    '100000000000': {
      'other': '000G'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 miliad'
    },
    '10000': {
      'other': '00 miliad'
    },
    '100000': {
      'other': '000 miliad'
    },
    '1000000': {
      'other': '0 milion'
    },
    '10000000': {
      'other': '00 milion'
    },
    '100000000': {
      'other': '000 milion'
    },
    '1000000000': {
      'other': '0 miliard'
    },
    '10000000000': {
      'other': '00 miliard'
    },
    '100000000000': {
      'other': '000 miliard'
    },
    '1000000000000': {
      'other': '0 bilion'
    },
    '10000000000000': {
      'other': '00 bilion'
    },
    '100000000000000': {
      'other': '000 bilion'
    }
  }
};


/**
 * Compact number formatting symbols for locale bs.
 */
goog.i18n.CompactNumberFormatSymbols_bs = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 hilj.'
    },
    '10000': {
      'other': '00 hilj.'
    },
    '100000': {
      'other': '000 hilj.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mlr.'
    },
    '10000000000': {
      'other': '00 mlr.'
    },
    '100000000000': {
      'other': '000 mlr.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 hiljada'
    },
    '10000': {
      'other': '00 hiljada'
    },
    '100000': {
      'other': '000 hiljada'
    },
    '1000000': {
      'other': '0 miliona'
    },
    '10000000': {
      'other': '00 miliona'
    },
    '100000000': {
      'other': '000 miliona'
    },
    '1000000000': {
      'other': '0 milijardi'
    },
    '10000000000': {
      'other': '00 milijardi'
    },
    '100000000000': {
      'other': '000 milijardi'
    },
    '1000000000000': {
      'other': '0 biliona'
    },
    '10000000000000': {
      'other': '00 biliona'
    },
    '100000000000000': {
      'other': '000 biliona'
    }
  }
};


/**
 * Compact number formatting symbols for locale ca.
 */
goog.i18n.CompactNumberFormatSymbols_ca = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0m'
    },
    '10000': {
      'other': '00m'
    },
    '100000': {
      'other': '000m'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00mM'
    },
    '100000000000': {
      'other': '000mM'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 milers'
    },
    '10000': {
      'other': '00 milers'
    },
    '100000': {
      'other': '000 milers'
    },
    '1000000': {
      'other': '0 milions'
    },
    '10000000': {
      'other': '00 milions'
    },
    '100000000': {
      'other': '000 milions'
    },
    '1000000000': {
      'other': '0 milers de milions'
    },
    '10000000000': {
      'other': '00 milers de milions'
    },
    '100000000000': {
      'other': '000 milers de milions'
    },
    '1000000000000': {
      'other': '0 bilions'
    },
    '10000000000000': {
      'other': '00 bilions'
    },
    '100000000000000': {
      'other': '000 bilions'
    }
  }
};


/**
 * Compact number formatting symbols for locale chr.
 */
goog.i18n.CompactNumberFormatSymbols_chr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ᎢᏯᎦᏴᎵ'
    },
    '10000': {
      'other': '00 ᎢᏯᎦᏴᎵ'
    },
    '100000': {
      'other': '000 ᎢᏯᎦᏴᎵ'
    },
    '1000000': {
      'other': '0 ᎢᏳᏆᏗᏅᏛ'
    },
    '10000000': {
      'other': '00 ᎢᏳᏆᏗᏅᏛ'
    },
    '100000000': {
      'other': '000 ᎢᏳᏆᏗᏅᏛ'
    },
    '1000000000': {
      'other': '0 ᎢᏯᏔᎳᏗᏅᏛ'
    },
    '10000000000': {
      'other': '00 ᎢᏯᏔᎳᏗᏅᏛ'
    },
    '100000000000': {
      'other': '000 ᎢᏯᏔᎳᏗᏅᏛ'
    },
    '1000000000000': {
      'other': '0 ᎢᏯᏦᎠᏗᏅᏛ'
    },
    '10000000000000': {
      'other': '00 ᎢᏯᏦᎠᏗᏅᏛ'
    },
    '100000000000000': {
      'other': '000 ᎢᏯᏦᎠᏗᏅᏛ'
    }
  }
};


/**
 * Compact number formatting symbols for locale cs.
 */
goog.i18n.CompactNumberFormatSymbols_cs = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tis.'
    },
    '10000': {
      'other': '00 tis.'
    },
    '100000': {
      'other': '000 tis.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mld.'
    },
    '10000000000': {
      'other': '00 mld.'
    },
    '100000000000': {
      'other': '000 mld.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tisíc'
    },
    '10000': {
      'other': '00 tisíc'
    },
    '100000': {
      'other': '000 tisíc'
    },
    '1000000': {
      'other': '0 milionů'
    },
    '10000000': {
      'other': '00 milionů'
    },
    '100000000': {
      'other': '000 milionů'
    },
    '1000000000': {
      'other': '0 miliard'
    },
    '10000000000': {
      'other': '00 miliard'
    },
    '100000000000': {
      'other': '000 miliard'
    },
    '1000000000000': {
      'other': '0 bilionů'
    },
    '10000000000000': {
      'other': '00 bilionů'
    },
    '100000000000000': {
      'other': '000 bilionů'
    }
  }
};


/**
 * Compact number formatting symbols for locale cy.
 */
goog.i18n.CompactNumberFormatSymbols_cy = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 miliwn'
    },
    '10000000': {
      'other': '00 miliwn'
    },
    '100000000': {
      'other': '000 miliwn'
    },
    '1000000000': {
      'other': '0 biliwn'
    },
    '10000000000': {
      'other': '00 biliwn'
    },
    '100000000000': {
      'other': '000 biliwn'
    },
    '1000000000000': {
      'other': '0 triliwn'
    },
    '10000000000000': {
      'other': '00 triliwn'
    },
    '100000000000000': {
      'other': '000 triliwn'
    }
  }
};


/**
 * Compact number formatting symbols for locale da.
 */
goog.i18n.CompactNumberFormatSymbols_da = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 t'
    },
    '10000': {
      'other': '00 t'
    },
    '100000': {
      'other': '000 t'
    },
    '1000000': {
      'other': '0 mio.'
    },
    '10000000': {
      'other': '00 mio.'
    },
    '100000000': {
      'other': '000 mio.'
    },
    '1000000000': {
      'other': '0 mia.'
    },
    '10000000000': {
      'other': '00 mia.'
    },
    '100000000000': {
      'other': '000 mia.'
    },
    '1000000000000': {
      'other': '0 bio.'
    },
    '10000000000000': {
      'other': '00 bio.'
    },
    '100000000000000': {
      'other': '000 bio.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tusind'
    },
    '10000': {
      'other': '00 tusind'
    },
    '100000': {
      'other': '000 tusind'
    },
    '1000000': {
      'other': '0 millioner'
    },
    '10000000': {
      'other': '00 millioner'
    },
    '100000000': {
      'other': '000 millioner'
    },
    '1000000000': {
      'other': '0 milliarder'
    },
    '10000000000': {
      'other': '00 milliarder'
    },
    '100000000000': {
      'other': '000 milliarder'
    },
    '1000000000000': {
      'other': '0 billioner'
    },
    '10000000000000': {
      'other': '00 billioner'
    },
    '100000000000000': {
      'other': '000 billioner'
    }
  }
};


/**
 * Compact number formatting symbols for locale de.
 */
goog.i18n.CompactNumberFormatSymbols_de = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 Mio.'
    },
    '10000000': {
      'other': '00 Mio.'
    },
    '100000000': {
      'other': '000 Mio.'
    },
    '1000000000': {
      'other': '0 Mrd.'
    },
    '10000000000': {
      'other': '00 Mrd.'
    },
    '100000000000': {
      'other': '000 Mrd.'
    },
    '1000000000000': {
      'other': '0 Bio.'
    },
    '10000000000000': {
      'other': '00 Bio.'
    },
    '100000000000000': {
      'other': '000 Bio.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 Tausend'
    },
    '10000': {
      'other': '00 Tausend'
    },
    '100000': {
      'other': '000 Tausend'
    },
    '1000000': {
      'other': '0 Millionen'
    },
    '10000000': {
      'other': '00 Millionen'
    },
    '100000000': {
      'other': '000 Millionen'
    },
    '1000000000': {
      'other': '0 Milliarden'
    },
    '10000000000': {
      'other': '00 Milliarden'
    },
    '100000000000': {
      'other': '000 Milliarden'
    },
    '1000000000000': {
      'other': '0 Billionen'
    },
    '10000000000000': {
      'other': '00 Billionen'
    },
    '100000000000000': {
      'other': '000 Billionen'
    }
  }
};


/**
 * Compact number formatting symbols for locale de_AT.
 */
goog.i18n.CompactNumberFormatSymbols_de_AT = goog.i18n.CompactNumberFormatSymbols_de;


/**
 * Compact number formatting symbols for locale de_CH.
 */
goog.i18n.CompactNumberFormatSymbols_de_CH = goog.i18n.CompactNumberFormatSymbols_de;


/**
 * Compact number formatting symbols for locale el.
 */
goog.i18n.CompactNumberFormatSymbols_el = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 χιλ.'
    },
    '10000': {
      'other': '00 χιλ.'
    },
    '100000': {
      'other': '000 χιλ.'
    },
    '1000000': {
      'other': '0 εκ.'
    },
    '10000000': {
      'other': '00 εκ.'
    },
    '100000000': {
      'other': '000 εκ.'
    },
    '1000000000': {
      'other': '0 δισ.'
    },
    '10000000000': {
      'other': '00 δισ.'
    },
    '100000000000': {
      'other': '000 δισ.'
    },
    '1000000000000': {
      'other': '0 τρισ.'
    },
    '10000000000000': {
      'other': '00 τρισ.'
    },
    '100000000000000': {
      'other': '000 τρισ.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 χιλιάδες'
    },
    '10000': {
      'other': '00 χιλιάδες'
    },
    '100000': {
      'other': '000 χιλιάδες'
    },
    '1000000': {
      'other': '0 εκατομμύρια'
    },
    '10000000': {
      'other': '00 εκατομμύρια'
    },
    '100000000': {
      'other': '000 εκατομμύρια'
    },
    '1000000000': {
      'other': '0 δισεκατομμύρια'
    },
    '10000000000': {
      'other': '00 δισεκατομμύρια'
    },
    '100000000000': {
      'other': '000 δισεκατομμύρια'
    },
    '1000000000000': {
      'other': '0 τρισεκατομμύρια'
    },
    '10000000000000': {
      'other': '00 τρισεκατομμύρια'
    },
    '100000000000000': {
      'other': '000 τρισεκατομμύρια'
    }
  }
};


/**
 * Compact number formatting symbols for locale en.
 */
goog.i18n.CompactNumberFormatSymbols_en = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 thousand'
    },
    '10000': {
      'other': '00 thousand'
    },
    '100000': {
      'other': '000 thousand'
    },
    '1000000': {
      'other': '0 million'
    },
    '10000000': {
      'other': '00 million'
    },
    '100000000': {
      'other': '000 million'
    },
    '1000000000': {
      'other': '0 billion'
    },
    '10000000000': {
      'other': '00 billion'
    },
    '100000000000': {
      'other': '000 billion'
    },
    '1000000000000': {
      'other': '0 trillion'
    },
    '10000000000000': {
      'other': '00 trillion'
    },
    '100000000000000': {
      'other': '000 trillion'
    }
  }
};


/**
 * Compact number formatting symbols for locale en_AU.
 */
goog.i18n.CompactNumberFormatSymbols_en_AU = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_CA.
 */
goog.i18n.CompactNumberFormatSymbols_en_CA = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_GB.
 */
goog.i18n.CompactNumberFormatSymbols_en_GB = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_IE.
 */
goog.i18n.CompactNumberFormatSymbols_en_IE = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_IN.
 */
goog.i18n.CompactNumberFormatSymbols_en_IN = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0T'
    },
    '10000': {
      'other': '00T'
    },
    '100000': {
      'other': '0L'
    },
    '1000000': {
      'other': '00L'
    },
    '10000000': {
      'other': '0Cr'
    },
    '100000000': {
      'other': '00Cr'
    },
    '1000000000': {
      'other': '000Cr'
    },
    '10000000000': {
      'other': '0TCr'
    },
    '100000000000': {
      'other': '00TCr'
    },
    '1000000000000': {
      'other': '0LCr'
    },
    '10000000000000': {
      'other': '00LCr'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 thousand'
    },
    '10000': {
      'other': '00 thousand'
    },
    '100000': {
      'other': '000 thousand'
    },
    '1000000': {
      'other': '0 million'
    },
    '10000000': {
      'other': '00 million'
    },
    '100000000': {
      'other': '000 million'
    },
    '1000000000': {
      'other': '0 billion'
    },
    '10000000000': {
      'other': '00 billion'
    },
    '100000000000': {
      'other': '000 billion'
    },
    '1000000000000': {
      'other': '0 trillion'
    },
    '10000000000000': {
      'other': '00 trillion'
    },
    '100000000000000': {
      'other': '000 trillion'
    }
  }
};


/**
 * Compact number formatting symbols for locale en_SG.
 */
goog.i18n.CompactNumberFormatSymbols_en_SG = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_US.
 */
goog.i18n.CompactNumberFormatSymbols_en_US = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale en_ZA.
 */
goog.i18n.CompactNumberFormatSymbols_en_ZA = goog.i18n.CompactNumberFormatSymbols_en;


/**
 * Compact number formatting symbols for locale es.
 */
goog.i18n.CompactNumberFormatSymbols_es = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00 mil M'
    },
    '100000000000': {
      'other': '000 mil M'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 millones'
    },
    '10000000': {
      'other': '00 millones'
    },
    '100000000': {
      'other': '000 millones'
    },
    '1000000000': {
      'other': '0 mil millones'
    },
    '10000000000': {
      'other': '00 mil millones'
    },
    '100000000000': {
      'other': '000 mil millones'
    },
    '1000000000000': {
      'other': '0 billones'
    },
    '10000000000000': {
      'other': '00 billones'
    },
    '100000000000000': {
      'other': '000 billones'
    }
  }
};


/**
 * Compact number formatting symbols for locale es_419.
 */
goog.i18n.CompactNumberFormatSymbols_es_419 = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 K'
    },
    '10000': {
      'other': '00 k'
    },
    '100000': {
      'other': '000 k'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00 mil M'
    },
    '100000000000': {
      'other': '000 mil M'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 millones'
    },
    '10000000': {
      'other': '00 millones'
    },
    '100000000': {
      'other': '000 millones'
    },
    '1000000000': {
      'other': '0 mil millones'
    },
    '10000000000': {
      'other': '00 mil millones'
    },
    '100000000000': {
      'other': '000 mil millones'
    },
    '1000000000000': {
      'other': '0 billón'
    },
    '10000000000000': {
      'other': '00 billones'
    },
    '100000000000000': {
      'other': '000 billones'
    }
  }
};


/**
 * Compact number formatting symbols for locale es_ES.
 */
goog.i18n.CompactNumberFormatSymbols_es_ES = goog.i18n.CompactNumberFormatSymbols_es;


/**
 * Compact number formatting symbols for locale es_MX.
 */
goog.i18n.CompactNumberFormatSymbols_es_MX = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 k'
    },
    '10000': {
      'other': '00 k'
    },
    '100000': {
      'other': '000 k'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00 mil M'
    },
    '100000000000': {
      'other': '000 mil M'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 millones'
    },
    '10000000': {
      'other': '00 millones'
    },
    '100000000': {
      'other': '000 millones'
    },
    '1000000000': {
      'other': '0 mil millones'
    },
    '10000000000': {
      'other': '00 mil millones'
    },
    '100000000000': {
      'other': '000 mil millones'
    },
    '1000000000000': {
      'other': '0 billones'
    },
    '10000000000000': {
      'other': '00 billones'
    },
    '100000000000000': {
      'other': '000 billones'
    }
  }
};


/**
 * Compact number formatting symbols for locale es_US.
 */
goog.i18n.CompactNumberFormatSymbols_es_US = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 K'
    },
    '10000': {
      'other': '00 K'
    },
    '100000': {
      'other': '000 K'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0 B'
    },
    '10000000000': {
      'other': '00 B'
    },
    '100000000000': {
      'other': '000 B'
    },
    '1000000000000': {
      'other': '0 T'
    },
    '10000000000000': {
      'other': '00 T'
    },
    '100000000000000': {
      'other': '000 T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 millones'
    },
    '10000000': {
      'other': '00 millones'
    },
    '100000000': {
      'other': '000 millones'
    },
    '1000000000': {
      'other': '0 billones'
    },
    '10000000000': {
      'other': '00 billones'
    },
    '100000000000': {
      'other': '000 billones'
    },
    '1000000000000': {
      'other': '0 trillones'
    },
    '10000000000000': {
      'other': '00 trillones'
    },
    '100000000000000': {
      'other': '000 trillones'
    }
  }
};


/**
 * Compact number formatting symbols for locale et.
 */
goog.i18n.CompactNumberFormatSymbols_et = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tuh'
    },
    '10000': {
      'other': '00 tuh'
    },
    '100000': {
      'other': '000 tuh'
    },
    '1000000': {
      'other': '0 mln'
    },
    '10000000': {
      'other': '00 mln'
    },
    '100000000': {
      'other': '000 mln'
    },
    '1000000000': {
      'other': '0 mld'
    },
    '10000000000': {
      'other': '00 mld'
    },
    '100000000000': {
      'other': '000 mld'
    },
    '1000000000000': {
      'other': '0 trl'
    },
    '10000000000000': {
      'other': '00 trl'
    },
    '100000000000000': {
      'other': '000 trl'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tuhat'
    },
    '10000': {
      'other': '00 tuhat'
    },
    '100000': {
      'other': '000 tuhat'
    },
    '1000000': {
      'other': '0 miljonit'
    },
    '10000000': {
      'other': '00 miljonit'
    },
    '100000000': {
      'other': '000 miljonit'
    },
    '1000000000': {
      'other': '0 miljardit'
    },
    '10000000000': {
      'other': '00 miljardit'
    },
    '100000000000': {
      'other': '000 miljardit'
    },
    '1000000000000': {
      'other': '0 triljonit'
    },
    '10000000000000': {
      'other': '00 triljonit'
    },
    '100000000000000': {
      'other': '000 triljonit'
    }
  }
};


/**
 * Compact number formatting symbols for locale eu.
 */
goog.i18n.CompactNumberFormatSymbols_eu = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00000 M'
    },
    '100000000000': {
      'other': '000000 M'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 milioi'
    },
    '10000000': {
      'other': '00 milioi'
    },
    '100000000': {
      'other': '000 milioi'
    },
    '1000000000': {
      'other': '0000 milioi'
    },
    '10000000000': {
      'other': '00000 milioi'
    },
    '100000000000': {
      'other': '000000 milioi'
    },
    '1000000000000': {
      'other': '0 bilioi'
    },
    '10000000000000': {
      'other': '00 bilioi'
    },
    '100000000000000': {
      'other': '000 bilioi'
    }
  }
};


/**
 * Compact number formatting symbols for locale fa.
 */
goog.i18n.CompactNumberFormatSymbols_fa = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 هزار'
    },
    '10000': {
      'other': '00 هزار'
    },
    '100000': {
      'other': '000 هزار'
    },
    '1000000': {
      'other': '0 میلیون'
    },
    '10000000': {
      'other': '00 میلیون'
    },
    '100000000': {
      'other': '000 م'
    },
    '1000000000': {
      'other': '0 م'
    },
    '10000000000': {
      'other': '00 م'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0 تریلیون'
    },
    '10000000000000': {
      'other': '00 ت'
    },
    '100000000000000': {
      'other': '000 ت'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 هزار'
    },
    '10000': {
      'other': '00 هزار'
    },
    '100000': {
      'other': '000 هزار'
    },
    '1000000': {
      'other': '0 میلیون'
    },
    '10000000': {
      'other': '00 میلیون'
    },
    '100000000': {
      'other': '000 میلیون'
    },
    '1000000000': {
      'other': '0 میلیارد'
    },
    '10000000000': {
      'other': '00 میلیارد'
    },
    '100000000000': {
      'other': '000 میلیارد'
    },
    '1000000000000': {
      'other': '0 هزارمیلیارد'
    },
    '10000000000000': {
      'other': '00 هزارمیلیارد'
    },
    '100000000000000': {
      'other': '000 هزارمیلیارد'
    }
  }
};


/**
 * Compact number formatting symbols for locale fi.
 */
goog.i18n.CompactNumberFormatSymbols_fi = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 t.'
    },
    '10000': {
      'other': '00 t.'
    },
    '100000': {
      'other': '000 t.'
    },
    '1000000': {
      'other': '0 milj.'
    },
    '10000000': {
      'other': '00 milj.'
    },
    '100000000': {
      'other': '000 milj.'
    },
    '1000000000': {
      'other': '0 mrd.'
    },
    '10000000000': {
      'other': '00 mrd.'
    },
    '100000000000': {
      'other': '000 mrd.'
    },
    '1000000000000': {
      'other': '0 bilj.'
    },
    '10000000000000': {
      'other': '00 bilj.'
    },
    '100000000000000': {
      'other': '000 bilj.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tuhatta'
    },
    '10000': {
      'other': '00 tuhatta'
    },
    '100000': {
      'other': '000 tuhatta'
    },
    '1000000': {
      'other': '0 miljoonaa'
    },
    '10000000': {
      'other': '00 miljoonaa'
    },
    '100000000': {
      'other': '000 miljoonaa'
    },
    '1000000000': {
      'other': '0 miljardia'
    },
    '10000000000': {
      'other': '00 miljardia'
    },
    '100000000000': {
      'other': '000 miljardia'
    },
    '1000000000000': {
      'other': '0 biljoonaa'
    },
    '10000000000000': {
      'other': '00 biljoonaa'
    },
    '100000000000000': {
      'other': '000 biljoonaa'
    }
  }
};


/**
 * Compact number formatting symbols for locale fil.
 */
goog.i18n.CompactNumberFormatSymbols_fil = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 na libo'
    },
    '10000': {
      'other': '00 na libo'
    },
    '100000': {
      'other': '000 na libo'
    },
    '1000000': {
      'other': '0 na milyon'
    },
    '10000000': {
      'other': '00 na milyon'
    },
    '100000000': {
      'other': '000 na milyon'
    },
    '1000000000': {
      'other': '0 na bilyon'
    },
    '10000000000': {
      'other': '00 na bilyon'
    },
    '100000000000': {
      'other': '000 na bilyon'
    },
    '1000000000000': {
      'other': '0 na trilyon'
    },
    '10000000000000': {
      'other': '00 na trilyon'
    },
    '100000000000000': {
      'other': '000 na trilyon'
    }
  }
};


/**
 * Compact number formatting symbols for locale fr.
 */
goog.i18n.CompactNumberFormatSymbols_fr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 k'
    },
    '10000': {
      'other': '00 k'
    },
    '100000': {
      'other': '000 k'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0 Md'
    },
    '10000000000': {
      'other': '00 Md'
    },
    '100000000000': {
      'other': '000 Md'
    },
    '1000000000000': {
      'other': '0 Bn'
    },
    '10000000000000': {
      'other': '00 Bn'
    },
    '100000000000000': {
      'other': '000 Bn'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mille'
    },
    '10000': {
      'other': '00 mille'
    },
    '100000': {
      'other': '000 mille'
    },
    '1000000': {
      'other': '0 millions'
    },
    '10000000': {
      'other': '00 millions'
    },
    '100000000': {
      'other': '000 millions'
    },
    '1000000000': {
      'other': '0 milliards'
    },
    '10000000000': {
      'other': '00 milliards'
    },
    '100000000000': {
      'other': '000 milliards'
    },
    '1000000000000': {
      'other': '0 billions'
    },
    '10000000000000': {
      'other': '00 billions'
    },
    '100000000000000': {
      'other': '000 billions'
    }
  }
};


/**
 * Compact number formatting symbols for locale fr_CA.
 */
goog.i18n.CompactNumberFormatSymbols_fr_CA = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 k'
    },
    '10000': {
      'other': '00 k'
    },
    '100000': {
      'other': '000 k'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0 G'
    },
    '10000000000': {
      'other': '00 G'
    },
    '100000000000': {
      'other': '000 G'
    },
    '1000000000000': {
      'other': '0 T'
    },
    '10000000000000': {
      'other': '00 T'
    },
    '100000000000000': {
      'other': '000 T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mille'
    },
    '10000': {
      'other': '00 mille'
    },
    '100000': {
      'other': '000 mille'
    },
    '1000000': {
      'other': '0 millions'
    },
    '10000000': {
      'other': '00 millions'
    },
    '100000000': {
      'other': '000 millions'
    },
    '1000000000': {
      'other': '0 milliards'
    },
    '10000000000': {
      'other': '00 milliards'
    },
    '100000000000': {
      'other': '000 milliards'
    },
    '1000000000000': {
      'other': '0 billions'
    },
    '10000000000000': {
      'other': '00 billions'
    },
    '100000000000000': {
      'other': '000 billions'
    }
  }
};


/**
 * Compact number formatting symbols for locale ga.
 */
goog.i18n.CompactNumberFormatSymbols_ga = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0k'
    },
    '10000': {
      'other': '00k'
    },
    '100000': {
      'other': '000k'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 míle'
    },
    '10000': {
      'other': '00 míle'
    },
    '100000': {
      'other': '000 míle'
    },
    '1000000': {
      'other': '0 milliún'
    },
    '10000000': {
      'other': '00 milliún'
    },
    '100000000': {
      'other': '000 milliún'
    },
    '1000000000': {
      'other': '0 billiún'
    },
    '10000000000': {
      'other': '00 billiún'
    },
    '100000000000': {
      'other': '000 billiún'
    },
    '1000000000000': {
      'other': '0 trilliún'
    },
    '10000000000000': {
      'other': '00 trilliún'
    },
    '100000000000000': {
      'other': '000 trilliún'
    }
  }
};


/**
 * Compact number formatting symbols for locale gl.
 */
goog.i18n.CompactNumberFormatSymbols_gl = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0000 M'
    },
    '10000000000': {
      'other': '00000 M'
    },
    '100000000000': {
      'other': '000000 M'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 millóns'
    },
    '10000000': {
      'other': '00 millóns'
    },
    '100000000': {
      'other': '000 millóns'
    },
    '1000000000': {
      'other': '0000 millóns'
    },
    '10000000000': {
      'other': '00000 millóns'
    },
    '100000000000': {
      'other': '000000 millóns'
    },
    '1000000000000': {
      'other': '0 billóns'
    },
    '10000000000000': {
      'other': '00 billóns'
    },
    '100000000000000': {
      'other': '000 billóns'
    }
  }
};


/**
 * Compact number formatting symbols for locale gsw.
 */
goog.i18n.CompactNumberFormatSymbols_gsw = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 Tsg.'
    },
    '10000': {
      'other': '00 Tsg.'
    },
    '100000': {
      'other': '000 Tsg.'
    },
    '1000000': {
      'other': '0 Mio.'
    },
    '10000000': {
      'other': '00 Mio.'
    },
    '100000000': {
      'other': '000 Mio.'
    },
    '1000000000': {
      'other': '0 Mrd.'
    },
    '10000000000': {
      'other': '00 Mrd.'
    },
    '100000000000': {
      'other': '000 Mrd.'
    },
    '1000000000000': {
      'other': '0 Bio.'
    },
    '10000000000000': {
      'other': '00 Bio.'
    },
    '100000000000000': {
      'other': '000 Bio.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 Tuusig'
    },
    '10000': {
      'other': '00 Tuusig'
    },
    '100000': {
      'other': '000 Tuusig'
    },
    '1000000': {
      'other': '0 Millioone'
    },
    '10000000': {
      'other': '00 Millioone'
    },
    '100000000': {
      'other': '000 Millioone'
    },
    '1000000000': {
      'other': '0 Milliarde'
    },
    '10000000000': {
      'other': '00 Milliarde'
    },
    '100000000000': {
      'other': '000 Milliarde'
    },
    '1000000000000': {
      'other': '0 Billioone'
    },
    '10000000000000': {
      'other': '00 Billioone'
    },
    '100000000000000': {
      'other': '000 Billioone'
    }
  }
};


/**
 * Compact number formatting symbols for locale gu.
 */
goog.i18n.CompactNumberFormatSymbols_gu = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 હજાર'
    },
    '10000': {
      'other': '00 હજાર'
    },
    '100000': {
      'other': '0 લાખ'
    },
    '1000000': {
      'other': '00 લાખ'
    },
    '10000000': {
      'other': '0 કરોડ'
    },
    '100000000': {
      'other': '00 કરોડ'
    },
    '1000000000': {
      'other': '0 અબજ'
    },
    '10000000000': {
      'other': '00 અબજ'
    },
    '100000000000': {
      'other': '0 નિખર્વ'
    },
    '1000000000000': {
      'other': '0 મહાપદ્મ'
    },
    '10000000000000': {
      'other': '0 શંકુ'
    },
    '100000000000000': {
      'other': '0 જલધિ'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 હજાર'
    },
    '10000': {
      'other': '00 હજાર'
    },
    '100000': {
      'other': '0 લાખ'
    },
    '1000000': {
      'other': '00 લાખ'
    },
    '10000000': {
      'other': '0 કરોડ'
    },
    '100000000': {
      'other': '00 કરોડ'
    },
    '1000000000': {
      'other': '0 અબજ'
    },
    '10000000000': {
      'other': '00 અબજ'
    },
    '100000000000': {
      'other': '0 નિખર્વ'
    },
    '1000000000000': {
      'other': '0 મહાપદ્મ'
    },
    '10000000000000': {
      'other': '0 શંકુ'
    },
    '100000000000000': {
      'other': '0 જલધિ'
    }
  }
};


/**
 * Compact number formatting symbols for locale haw.
 */
goog.i18n.CompactNumberFormatSymbols_haw = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0G'
    },
    '10000000000': {
      'other': '00G'
    },
    '100000000000': {
      'other': '000G'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  }
};


/**
 * Compact number formatting symbols for locale he.
 */
goog.i18n.CompactNumberFormatSymbols_he = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K‏'
    },
    '10000': {
      'other': '00K‏'
    },
    '100000': {
      'other': '000K‏'
    },
    '1000000': {
      'other': '0M‏'
    },
    '10000000': {
      'other': '00M‏'
    },
    '100000000': {
      'other': '000M‏'
    },
    '1000000000': {
      'other': '0B‏'
    },
    '10000000000': {
      'other': '00B‏'
    },
    '100000000000': {
      'other': '000B‏'
    },
    '1000000000000': {
      'other': '0T‏'
    },
    '10000000000000': {
      'other': '00T‏'
    },
    '100000000000000': {
      'other': '000T‏'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '‏0 אלף'
    },
    '10000': {
      'other': '‏00 אלף'
    },
    '100000': {
      'other': '‏000 אלף'
    },
    '1000000': {
      'other': '‏0 מיליון'
    },
    '10000000': {
      'other': '‏00 מיליון'
    },
    '100000000': {
      'other': '‏000 מיליון'
    },
    '1000000000': {
      'other': '‏0 מיליארד'
    },
    '10000000000': {
      'other': '‏00 מיליארד'
    },
    '100000000000': {
      'other': '‏000 מיליארד'
    },
    '1000000000000': {
      'other': '‏0 טריליון'
    },
    '10000000000000': {
      'other': '‏00 טריליון'
    },
    '100000000000000': {
      'other': '‏000 טריליון'
    }
  }
};


/**
 * Compact number formatting symbols for locale hi.
 */
goog.i18n.CompactNumberFormatSymbols_hi = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 हज़ार'
    },
    '10000': {
      'other': '00 हज़ार'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '00 लाख'
    },
    '10000000': {
      'other': '0 क॰'
    },
    '100000000': {
      'other': '00 क॰'
    },
    '1000000000': {
      'other': '0 अ॰'
    },
    '10000000000': {
      'other': '00 अ॰'
    },
    '100000000000': {
      'other': '0 ख॰'
    },
    '1000000000000': {
      'other': '00 ख॰'
    },
    '10000000000000': {
      'other': '0 नील'
    },
    '100000000000000': {
      'other': '00 नील'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 हज़ार'
    },
    '10000': {
      'other': '00 हज़ार'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '00 लाख'
    },
    '10000000': {
      'other': '0 करोड़'
    },
    '100000000': {
      'other': '00 करोड़'
    },
    '1000000000': {
      'other': '0 अरब'
    },
    '10000000000': {
      'other': '00 अरब'
    },
    '100000000000': {
      'other': '0 खरब'
    },
    '1000000000000': {
      'other': '00 खरब'
    },
    '10000000000000': {
      'other': '000 खरब'
    },
    '100000000000000': {
      'other': '0000 खरब'
    }
  }
};


/**
 * Compact number formatting symbols for locale hr.
 */
goog.i18n.CompactNumberFormatSymbols_hr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tis.'
    },
    '10000': {
      'other': '00 tis.'
    },
    '100000': {
      'other': '000 tis.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mlr.'
    },
    '10000000000': {
      'other': '00 mlr.'
    },
    '100000000000': {
      'other': '000 mlr.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tisuća'
    },
    '10000': {
      'other': '00 tisuća'
    },
    '100000': {
      'other': '000 tisuća'
    },
    '1000000': {
      'other': '0 milijuna'
    },
    '10000000': {
      'other': '00 milijuna'
    },
    '100000000': {
      'other': '000 milijuna'
    },
    '1000000000': {
      'other': '0 milijardi'
    },
    '10000000000': {
      'other': '00 milijardi'
    },
    '100000000000': {
      'other': '000 milijardi'
    },
    '1000000000000': {
      'other': '0 bilijuna'
    },
    '10000000000000': {
      'other': '00 bilijuna'
    },
    '100000000000000': {
      'other': '000 bilijuna'
    }
  }
};


/**
 * Compact number formatting symbols for locale hu.
 */
goog.i18n.CompactNumberFormatSymbols_hu = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 E'
    },
    '10000': {
      'other': '00 E'
    },
    '100000': {
      'other': '000 E'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0 Mrd'
    },
    '10000000000': {
      'other': '00 Mrd'
    },
    '100000000000': {
      'other': '000 Mrd'
    },
    '1000000000000': {
      'other': '0 B'
    },
    '10000000000000': {
      'other': '00 B'
    },
    '100000000000000': {
      'other': '000 B'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ezer'
    },
    '10000': {
      'other': '00 ezer'
    },
    '100000': {
      'other': '000 ezer'
    },
    '1000000': {
      'other': '0 millió'
    },
    '10000000': {
      'other': '00 millió'
    },
    '100000000': {
      'other': '000 millió'
    },
    '1000000000': {
      'other': '0 milliárd'
    },
    '10000000000': {
      'other': '00 milliárd'
    },
    '100000000000': {
      'other': '000 milliárd'
    },
    '1000000000000': {
      'other': '0 billió'
    },
    '10000000000000': {
      'other': '00 billió'
    },
    '100000000000000': {
      'other': '000 billió'
    }
  }
};


/**
 * Compact number formatting symbols for locale hy.
 */
goog.i18n.CompactNumberFormatSymbols_hy = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 հզր'
    },
    '10000': {
      'other': '00 հզր'
    },
    '100000': {
      'other': '000 հզր'
    },
    '1000000': {
      'other': '0 մլն'
    },
    '10000000': {
      'other': '00 մլն'
    },
    '100000000': {
      'other': '000 մլն'
    },
    '1000000000': {
      'other': '0 մլրդ'
    },
    '10000000000': {
      'other': '00 մլրդ'
    },
    '100000000000': {
      'other': '000 մլրդ'
    },
    '1000000000000': {
      'other': '0 տրլն'
    },
    '10000000000000': {
      'other': '00 տրլն'
    },
    '100000000000000': {
      'other': '000 տրլն'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 հազար'
    },
    '10000': {
      'other': '00 հազար'
    },
    '100000': {
      'other': '000 հազար'
    },
    '1000000': {
      'other': '0 միլիոն'
    },
    '10000000': {
      'other': '00 միլիոն'
    },
    '100000000': {
      'other': '000 միլիոն'
    },
    '1000000000': {
      'other': '0 միլիարդ'
    },
    '10000000000': {
      'other': '00 միլիարդ'
    },
    '100000000000': {
      'other': '000 միլիարդ'
    },
    '1000000000000': {
      'other': '0 տրիլիոն'
    },
    '10000000000000': {
      'other': '00 տրիլիոն'
    },
    '100000000000000': {
      'other': '000 տրիլիոն'
    }
  }
};


/**
 * Compact number formatting symbols for locale id.
 */
goog.i18n.CompactNumberFormatSymbols_id = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 rb'
    },
    '10000': {
      'other': '00 rb'
    },
    '100000': {
      'other': '000 rb'
    },
    '1000000': {
      'other': '0 jt'
    },
    '10000000': {
      'other': '00 jt'
    },
    '100000000': {
      'other': '000 jt'
    },
    '1000000000': {
      'other': '0 M'
    },
    '10000000000': {
      'other': '00 M'
    },
    '100000000000': {
      'other': '000 M'
    },
    '1000000000000': {
      'other': '0 T'
    },
    '10000000000000': {
      'other': '00 T'
    },
    '100000000000000': {
      'other': '000 T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ribu'
    },
    '10000': {
      'other': '00 ribu'
    },
    '100000': {
      'other': '000 ribu'
    },
    '1000000': {
      'other': '0 juta'
    },
    '10000000': {
      'other': '00 juta'
    },
    '100000000': {
      'other': '000 juta'
    },
    '1000000000': {
      'other': '0 miliar'
    },
    '10000000000': {
      'other': '00 miliar'
    },
    '100000000000': {
      'other': '000 miliar'
    },
    '1000000000000': {
      'other': '0 triliun'
    },
    '10000000000000': {
      'other': '00 triliun'
    },
    '100000000000000': {
      'other': '000 triliun'
    }
  }
};


/**
 * Compact number formatting symbols for locale in.
 */
goog.i18n.CompactNumberFormatSymbols_in = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 rb'
    },
    '10000': {
      'other': '00 rb'
    },
    '100000': {
      'other': '000 rb'
    },
    '1000000': {
      'other': '0 jt'
    },
    '10000000': {
      'other': '00 jt'
    },
    '100000000': {
      'other': '000 jt'
    },
    '1000000000': {
      'other': '0 M'
    },
    '10000000000': {
      'other': '00 M'
    },
    '100000000000': {
      'other': '000 M'
    },
    '1000000000000': {
      'other': '0 T'
    },
    '10000000000000': {
      'other': '00 T'
    },
    '100000000000000': {
      'other': '000 T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ribu'
    },
    '10000': {
      'other': '00 ribu'
    },
    '100000': {
      'other': '000 ribu'
    },
    '1000000': {
      'other': '0 juta'
    },
    '10000000': {
      'other': '00 juta'
    },
    '100000000': {
      'other': '000 juta'
    },
    '1000000000': {
      'other': '0 miliar'
    },
    '10000000000': {
      'other': '00 miliar'
    },
    '100000000000': {
      'other': '000 miliar'
    },
    '1000000000000': {
      'other': '0 triliun'
    },
    '10000000000000': {
      'other': '00 triliun'
    },
    '100000000000000': {
      'other': '000 triliun'
    }
  }
};


/**
 * Compact number formatting symbols for locale is.
 */
goog.i18n.CompactNumberFormatSymbols_is = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 þ.'
    },
    '10000': {
      'other': '00 þ.'
    },
    '100000': {
      'other': '000 þ.'
    },
    '1000000': {
      'other': '0 m.'
    },
    '10000000': {
      'other': '00 m.'
    },
    '100000000': {
      'other': '000 m.'
    },
    '1000000000': {
      'other': '0 ma.'
    },
    '10000000000': {
      'other': '00 ma.'
    },
    '100000000000': {
      'other': '000 ma.'
    },
    '1000000000000': {
      'other': '0 bn'
    },
    '10000000000000': {
      'other': '00 bn'
    },
    '100000000000000': {
      'other': '000 bn'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 þúsund'
    },
    '10000': {
      'other': '00 þúsund'
    },
    '100000': {
      'other': '000 þúsund'
    },
    '1000000': {
      'other': '0 milljónir'
    },
    '10000000': {
      'other': '00 milljónir'
    },
    '100000000': {
      'other': '000 milljónir'
    },
    '1000000000': {
      'other': '0 milljarðar'
    },
    '10000000000': {
      'other': '00 milljarðar'
    },
    '100000000000': {
      'other': '000 milljarðar'
    },
    '1000000000000': {
      'other': '0 billjónir'
    },
    '10000000000000': {
      'other': '00 billjónir'
    },
    '100000000000000': {
      'other': '000 billjónir'
    }
  }
};


/**
 * Compact number formatting symbols for locale it.
 */
goog.i18n.CompactNumberFormatSymbols_it = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0'
    },
    '100000': {
      'other': '0'
    },
    '1000000': {
      'other': '0 Mln'
    },
    '10000000': {
      'other': '00 Mln'
    },
    '100000000': {
      'other': '000 Mln'
    },
    '1000000000': {
      'other': '0 Mrd'
    },
    '10000000000': {
      'other': '00 Mrd'
    },
    '100000000000': {
      'other': '000 Mrd'
    },
    '1000000000000': {
      'other': '0 Bln'
    },
    '10000000000000': {
      'other': '00 Bln'
    },
    '100000000000000': {
      'other': '000 Bln'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mila'
    },
    '10000': {
      'other': '00 mila'
    },
    '100000': {
      'other': '000 mila'
    },
    '1000000': {
      'other': '0 milioni'
    },
    '10000000': {
      'other': '00 milioni'
    },
    '100000000': {
      'other': '000 milioni'
    },
    '1000000000': {
      'other': '0 miliardi'
    },
    '10000000000': {
      'other': '00 miliardi'
    },
    '100000000000': {
      'other': '000 miliardi'
    },
    '1000000000000': {
      'other': '0 mila miliardi'
    },
    '10000000000000': {
      'other': '00 mila miliardi'
    },
    '100000000000000': {
      'other': '000 mila miliardi'
    }
  }
};


/**
 * Compact number formatting symbols for locale iw.
 */
goog.i18n.CompactNumberFormatSymbols_iw = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K‏'
    },
    '10000': {
      'other': '00K‏'
    },
    '100000': {
      'other': '000K‏'
    },
    '1000000': {
      'other': '0M‏'
    },
    '10000000': {
      'other': '00M‏'
    },
    '100000000': {
      'other': '000M‏'
    },
    '1000000000': {
      'other': '0B‏'
    },
    '10000000000': {
      'other': '00B‏'
    },
    '100000000000': {
      'other': '000B‏'
    },
    '1000000000000': {
      'other': '0T‏'
    },
    '10000000000000': {
      'other': '00T‏'
    },
    '100000000000000': {
      'other': '000T‏'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '‏0 אלף'
    },
    '10000': {
      'other': '‏00 אלף'
    },
    '100000': {
      'other': '‏000 אלף'
    },
    '1000000': {
      'other': '‏0 מיליון'
    },
    '10000000': {
      'other': '‏00 מיליון'
    },
    '100000000': {
      'other': '‏000 מיליון'
    },
    '1000000000': {
      'other': '‏0 מיליארד'
    },
    '10000000000': {
      'other': '‏00 מיליארד'
    },
    '100000000000': {
      'other': '‏000 מיליארד'
    },
    '1000000000000': {
      'other': '‏0 טריליון'
    },
    '10000000000000': {
      'other': '‏00 טריליון'
    },
    '100000000000000': {
      'other': '‏000 טריליון'
    }
  }
};


/**
 * Compact number formatting symbols for locale ja.
 */
goog.i18n.CompactNumberFormatSymbols_ja = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0万'
    },
    '100000': {
      'other': '00万'
    },
    '1000000': {
      'other': '000万'
    },
    '10000000': {
      'other': '0000万'
    },
    '100000000': {
      'other': '0億'
    },
    '1000000000': {
      'other': '00億'
    },
    '10000000000': {
      'other': '000億'
    },
    '100000000000': {
      'other': '0000億'
    },
    '1000000000000': {
      'other': '0兆'
    },
    '10000000000000': {
      'other': '00兆'
    },
    '100000000000000': {
      'other': '000兆'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0万'
    },
    '100000': {
      'other': '00万'
    },
    '1000000': {
      'other': '000万'
    },
    '10000000': {
      'other': '0000万'
    },
    '100000000': {
      'other': '0億'
    },
    '1000000000': {
      'other': '00億'
    },
    '10000000000': {
      'other': '000億'
    },
    '100000000000': {
      'other': '0000億'
    },
    '1000000000000': {
      'other': '0兆'
    },
    '10000000000000': {
      'other': '00兆'
    },
    '100000000000000': {
      'other': '000兆'
    }
  }
};


/**
 * Compact number formatting symbols for locale ka.
 */
goog.i18n.CompactNumberFormatSymbols_ka = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ათ.'
    },
    '10000': {
      'other': '00 ათ.'
    },
    '100000': {
      'other': '000 ათ.'
    },
    '1000000': {
      'other': '0 მლნ.'
    },
    '10000000': {
      'other': '00 მლნ.'
    },
    '100000000': {
      'other': '000 მლნ.'
    },
    '1000000000': {
      'other': '0 მლრდ.'
    },
    '10000000000': {
      'other': '00 მლრდ.'
    },
    '100000000000': {
      'other': '000 მლრ.'
    },
    '1000000000000': {
      'other': '0 ტრლ.'
    },
    '10000000000000': {
      'other': '00 ტრლ.'
    },
    '100000000000000': {
      'other': '000 ტრლ.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ათასი'
    },
    '10000': {
      'other': '00 ათასი'
    },
    '100000': {
      'other': '000 ათასი'
    },
    '1000000': {
      'other': '0 მილიონი'
    },
    '10000000': {
      'other': '00 მილიონი'
    },
    '100000000': {
      'other': '000 მილიონი'
    },
    '1000000000': {
      'other': '0 მილიარდი'
    },
    '10000000000': {
      'other': '00 მილიარდი'
    },
    '100000000000': {
      'other': '000 მილიარდი'
    },
    '1000000000000': {
      'other': '0 ტრილიონი'
    },
    '10000000000000': {
      'other': '00 ტრილიონი'
    },
    '100000000000000': {
      'other': '000 ტრილიონი'
    }
  }
};


/**
 * Compact number formatting symbols for locale kk.
 */
goog.i18n.CompactNumberFormatSymbols_kk = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 мың'
    },
    '10000': {
      'other': '00 мың'
    },
    '100000': {
      'other': '000 м.'
    },
    '1000000': {
      'other': '0 млн'
    },
    '10000000': {
      'other': '00 млн'
    },
    '100000000': {
      'other': '000 млн'
    },
    '1000000000': {
      'other': '0 млрд'
    },
    '10000000000': {
      'other': '00 млрд'
    },
    '100000000000': {
      'other': '000 млрд'
    },
    '1000000000000': {
      'other': '0 трлн'
    },
    '10000000000000': {
      'other': '00 трлн'
    },
    '100000000000000': {
      'other': '000 трлн'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 мың'
    },
    '10000': {
      'other': '00 мың'
    },
    '100000': {
      'other': '000 мың'
    },
    '1000000': {
      'other': '0 миллион'
    },
    '10000000': {
      'other': '00 миллион'
    },
    '100000000': {
      'other': '000 миллион'
    },
    '1000000000': {
      'other': '0 миллиард'
    },
    '10000000000': {
      'other': '00 миллиард'
    },
    '100000000000': {
      'other': '000 миллиард'
    },
    '1000000000000': {
      'other': '0 триллион'
    },
    '10000000000000': {
      'other': '00 триллион'
    },
    '100000000000000': {
      'other': '000 триллион'
    }
  }
};


/**
 * Compact number formatting symbols for locale km.
 */
goog.i18n.CompactNumberFormatSymbols_km = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0ពាន់'
    },
    '10000': {
      'other': '00 ពាន់'
    },
    '100000': {
      'other': '000 ពាន់'
    },
    '1000000': {
      'other': '0 លាន'
    },
    '10000000': {
      'other': '00 លាន'
    },
    '100000000': {
      'other': '000 លាន'
    },
    '1000000000': {
      'other': '0 ប៊ីលាន'
    },
    '10000000000': {
      'other': '00 ប៊ីលាន'
    },
    '100000000000': {
      'other': '000 ប៊ីលាន'
    },
    '1000000000000': {
      'other': '0 ទ្រីលាន'
    },
    '10000000000000': {
      'other': '00 ទ្រីលាន'
    },
    '100000000000000': {
      'other': '000 ទ្រីលាន'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ពាន់'
    },
    '10000': {
      'other': '00 ពាន់'
    },
    '100000': {
      'other': '000ពាន់'
    },
    '1000000': {
      'other': '0 លាន'
    },
    '10000000': {
      'other': '00 លាន'
    },
    '100000000': {
      'other': '000 លាន'
    },
    '1000000000': {
      'other': '0 ប៊ីលាន'
    },
    '10000000000': {
      'other': '00 ប៊ីលាន'
    },
    '100000000000': {
      'other': '000 ប៊ីលាន'
    },
    '1000000000000': {
      'other': '0 ទ្រីលាន'
    },
    '10000000000000': {
      'other': '00 ទ្រីលាន'
    },
    '100000000000000': {
      'other': '000 ទ្រីលាន'
    }
  }
};


/**
 * Compact number formatting symbols for locale kn.
 */
goog.i18n.CompactNumberFormatSymbols_kn = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0ಸಾ'
    },
    '10000': {
      'other': '00ಸಾ'
    },
    '100000': {
      'other': '000ಸಾ'
    },
    '1000000': {
      'other': '0ಮಿ'
    },
    '10000000': {
      'other': '00ಮಿ'
    },
    '100000000': {
      'other': '000ಮಿ'
    },
    '1000000000': {
      'other': '0ಬಿ'
    },
    '10000000000': {
      'other': '00ಬಿ'
    },
    '100000000000': {
      'other': '000ಬಿ'
    },
    '1000000000000': {
      'other': '0ಟ್ರಿ'
    },
    '10000000000000': {
      'other': '00ಟ್ರಿ'
    },
    '100000000000000': {
      'other': '000ಟ್ರಿ'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ಸಾವಿರ'
    },
    '10000': {
      'other': '00 ಸಾವಿರ'
    },
    '100000': {
      'other': '000 ಸಾವಿರ'
    },
    '1000000': {
      'other': '0 ಮಿಲಿಯನ್'
    },
    '10000000': {
      'other': '00 ಮಿಲಿಯನ್'
    },
    '100000000': {
      'other': '000 ಮಿಲಿಯನ್'
    },
    '1000000000': {
      'other': '0 ಬಿಲಿಯನ್'
    },
    '10000000000': {
      'other': '00 ಬಿಲಿಯನ್'
    },
    '100000000000': {
      'other': '000 ಬಿಲಿಯನ್'
    },
    '1000000000000': {
      'other': '0 ಟ್ರಿಲಿಯನ್‌'
    },
    '10000000000000': {
      'other': '00 ಟ್ರಿಲಿಯನ್‌'
    },
    '100000000000000': {
      'other': '000 ಟ್ರಿಲಿಯನ್‌'
    }
  }
};


/**
 * Compact number formatting symbols for locale ko.
 */
goog.i18n.CompactNumberFormatSymbols_ko = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0천'
    },
    '10000': {
      'other': '0만'
    },
    '100000': {
      'other': '00만'
    },
    '1000000': {
      'other': '000만'
    },
    '10000000': {
      'other': '0000만'
    },
    '100000000': {
      'other': '0억'
    },
    '1000000000': {
      'other': '00억'
    },
    '10000000000': {
      'other': '000억'
    },
    '100000000000': {
      'other': '0000억'
    },
    '1000000000000': {
      'other': '0조'
    },
    '10000000000000': {
      'other': '00조'
    },
    '100000000000000': {
      'other': '000조'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0천'
    },
    '10000': {
      'other': '0만'
    },
    '100000': {
      'other': '00만'
    },
    '1000000': {
      'other': '000만'
    },
    '10000000': {
      'other': '0000만'
    },
    '100000000': {
      'other': '0억'
    },
    '1000000000': {
      'other': '00억'
    },
    '10000000000': {
      'other': '000억'
    },
    '100000000000': {
      'other': '0000억'
    },
    '1000000000000': {
      'other': '0조'
    },
    '10000000000000': {
      'other': '00조'
    },
    '100000000000000': {
      'other': '000조'
    }
  }
};


/**
 * Compact number formatting symbols for locale ky.
 */
goog.i18n.CompactNumberFormatSymbols_ky = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 миң'
    },
    '10000': {
      'other': '00 миң'
    },
    '100000': {
      'other': '000 миң'
    },
    '1000000': {
      'other': '0 млн'
    },
    '10000000': {
      'other': '00 млн'
    },
    '100000000': {
      'other': '000 млн'
    },
    '1000000000': {
      'other': '0 млд'
    },
    '10000000000': {
      'other': '00 млд'
    },
    '100000000000': {
      'other': '000 млд'
    },
    '1000000000000': {
      'other': '0 трлн'
    },
    '10000000000000': {
      'other': '00 трлн'
    },
    '100000000000000': {
      'other': '000 трлн'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 миң'
    },
    '10000': {
      'other': '00 миң'
    },
    '100000': {
      'other': '000 миң'
    },
    '1000000': {
      'other': '0 миллион'
    },
    '10000000': {
      'other': '00 миллион'
    },
    '100000000': {
      'other': '000 миллион'
    },
    '1000000000': {
      'other': '0 миллиард'
    },
    '10000000000': {
      'other': '00 миллиард'
    },
    '100000000000': {
      'other': '000 миллиард'
    },
    '1000000000000': {
      'other': '0 триллион'
    },
    '10000000000000': {
      'other': '00 триллион'
    },
    '100000000000000': {
      'other': '000 триллион'
    }
  }
};


/**
 * Compact number formatting symbols for locale ln.
 */
goog.i18n.CompactNumberFormatSymbols_ln = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0G'
    },
    '10000000000': {
      'other': '00G'
    },
    '100000000000': {
      'other': '000G'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  }
};


/**
 * Compact number formatting symbols for locale lo.
 */
goog.i18n.CompactNumberFormatSymbols_lo = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ພັນ'
    },
    '10000': {
      'other': '00 ພັນ'
    },
    '100000': {
      'other': '000 ກີບ'
    },
    '1000000': {
      'other': '0 ລ້ານ'
    },
    '10000000': {
      'other': '00 ລ້ານ'
    },
    '100000000': {
      'other': '000 ລ້ານ'
    },
    '1000000000': {
      'other': '0 ຕື້'
    },
    '10000000000': {
      'other': '00 ຕື້'
    },
    '100000000000': {
      'other': '000 ຕື້'
    },
    '1000000000000': {
      'other': '0 ລ້ານລ້ານ'
    },
    '10000000000000': {
      'other': '00ລລ'
    },
    '100000000000000': {
      'other': '000ລລ'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ພັນ'
    },
    '10000': {
      'other': '00 ພັນ'
    },
    '100000': {
      'other': '0 ແສນ'
    },
    '1000000': {
      'other': '0 ລ້ານ'
    },
    '10000000': {
      'other': '00 ລ້ານ'
    },
    '100000000': {
      'other': '000 ລ້ານ'
    },
    '1000000000': {
      'other': '0 ຕື້'
    },
    '10000000000': {
      'other': '00 ຕື້'
    },
    '100000000000': {
      'other': '000 ຕື້'
    },
    '1000000000000': {
      'other': '0 ລ້ານລ້ານ'
    },
    '10000000000000': {
      'other': '00 ລ້ານລ້ານ'
    },
    '100000000000000': {
      'other': '000 ລ້ານລ້ານ'
    }
  }
};


/**
 * Compact number formatting symbols for locale lt.
 */
goog.i18n.CompactNumberFormatSymbols_lt = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tūkst.'
    },
    '10000': {
      'other': '00 tūkst.'
    },
    '100000': {
      'other': '000 tūkst.'
    },
    '1000000': {
      'other': '0 mln.'
    },
    '10000000': {
      'other': '00 mln.'
    },
    '100000000': {
      'other': '000 mln.'
    },
    '1000000000': {
      'other': '0 mlrd.'
    },
    '10000000000': {
      'other': '00 mlrd.'
    },
    '100000000000': {
      'other': '000 mlrd.'
    },
    '1000000000000': {
      'other': '0 trln.'
    },
    '10000000000000': {
      'other': '00 trln.'
    },
    '100000000000000': {
      'other': '000 trln.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tūkstančių'
    },
    '10000': {
      'other': '00 tūkstančių'
    },
    '100000': {
      'other': '000 tūkstančių'
    },
    '1000000': {
      'other': '0 milijonų'
    },
    '10000000': {
      'other': '00 milijonų'
    },
    '100000000': {
      'other': '000 milijonų'
    },
    '1000000000': {
      'other': '0 milijardų'
    },
    '10000000000': {
      'other': '00 milijardų'
    },
    '100000000000': {
      'other': '000 milijardų'
    },
    '1000000000000': {
      'other': '0 trilijonų'
    },
    '10000000000000': {
      'other': '00 trilijonų'
    },
    '100000000000000': {
      'other': '000 trilijonų'
    }
  }
};


/**
 * Compact number formatting symbols for locale lv.
 */
goog.i18n.CompactNumberFormatSymbols_lv = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tūkst.'
    },
    '10000': {
      'other': '00 tūkst.'
    },
    '100000': {
      'other': '000 tūkst.'
    },
    '1000000': {
      'other': '0 milj.'
    },
    '10000000': {
      'other': '00 milj.'
    },
    '100000000': {
      'other': '000 milj.'
    },
    '1000000000': {
      'other': '0 mljrd.'
    },
    '10000000000': {
      'other': '00 mljrd.'
    },
    '100000000000': {
      'other': '000 mljrd.'
    },
    '1000000000000': {
      'other': '0 trilj.'
    },
    '10000000000000': {
      'other': '00 trilj.'
    },
    '100000000000000': {
      'other': '000 trilj.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tūkstoši'
    },
    '10000': {
      'other': '00 tūkstoši'
    },
    '100000': {
      'other': '000 tūkstoši'
    },
    '1000000': {
      'other': '0 miljoni'
    },
    '10000000': {
      'other': '00 miljoni'
    },
    '100000000': {
      'other': '000 miljoni'
    },
    '1000000000': {
      'other': '0 miljardi'
    },
    '10000000000': {
      'other': '00 miljardi'
    },
    '100000000000': {
      'other': '000 miljardi'
    },
    '1000000000000': {
      'other': '0 triljoni'
    },
    '10000000000000': {
      'other': '00 triljoni'
    },
    '100000000000000': {
      'other': '000 triljoni'
    }
  }
};


/**
 * Compact number formatting symbols for locale mk.
 */
goog.i18n.CompactNumberFormatSymbols_mk = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 илј.'
    },
    '10000': {
      'other': '00 илј.'
    },
    '100000': {
      'other': '000 илј.'
    },
    '1000000': {
      'other': '0 мил.'
    },
    '10000000': {
      'other': '00 мил.'
    },
    '100000000': {
      'other': '000 М'
    },
    '1000000000': {
      'other': '0 милј.'
    },
    '10000000000': {
      'other': '00 милј.'
    },
    '100000000000': {
      'other': '000 ми.'
    },
    '1000000000000': {
      'other': '0 бил.'
    },
    '10000000000000': {
      'other': '00 бил.'
    },
    '100000000000000': {
      'other': '000 бил.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 илјади'
    },
    '10000': {
      'other': '00 илјади'
    },
    '100000': {
      'other': '000 илјади'
    },
    '1000000': {
      'other': '0 милиони'
    },
    '10000000': {
      'other': '00 милиони'
    },
    '100000000': {
      'other': '000 милиони'
    },
    '1000000000': {
      'other': '0 милијарди'
    },
    '10000000000': {
      'other': '00 милијарди'
    },
    '100000000000': {
      'other': '000 милијарди'
    },
    '1000000000000': {
      'other': '0 билиони'
    },
    '10000000000000': {
      'other': '00 билиони'
    },
    '100000000000000': {
      'other': '000 билиони'
    }
  }
};


/**
 * Compact number formatting symbols for locale ml.
 */
goog.i18n.CompactNumberFormatSymbols_ml = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ആയിരം'
    },
    '10000': {
      'other': '00 ആയിരം'
    },
    '100000': {
      'other': '000 ആയിരം'
    },
    '1000000': {
      'other': '0 ദശലക്ഷം'
    },
    '10000000': {
      'other': '00 ദശലക്ഷം'
    },
    '100000000': {
      'other': '000 ദശലക്ഷം'
    },
    '1000000000': {
      'other': '0 ലക്ഷം കോടി'
    },
    '10000000000': {
      'other': '00 ലക്ഷം കോടി'
    },
    '100000000000': {
      'other': '000 ലക്ഷം കോടി'
    },
    '1000000000000': {
      'other': '0 ട്രില്യൺ'
    },
    '10000000000000': {
      'other': '00 ട്രില്യൺ'
    },
    '100000000000000': {
      'other': '000 ട്രില്യൺ'
    }
  }
};


/**
 * Compact number formatting symbols for locale mn.
 */
goog.i18n.CompactNumberFormatSymbols_mn = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 мянга'
    },
    '10000': {
      'other': '00 мянга'
    },
    '100000': {
      'other': '000 мянга'
    },
    '1000000': {
      'other': '0 сая'
    },
    '10000000': {
      'other': '00 сая'
    },
    '100000000': {
      'other': '000 сая'
    },
    '1000000000': {
      'other': '0 тэрбум'
    },
    '10000000000': {
      'other': '00 тэрбум'
    },
    '100000000000': {
      'other': '000Т'
    },
    '1000000000000': {
      'other': '0ИН'
    },
    '10000000000000': {
      'other': '00ИН'
    },
    '100000000000000': {
      'other': '000ИН'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 мянга'
    },
    '10000': {
      'other': '00 мянга'
    },
    '100000': {
      'other': '000 мянга'
    },
    '1000000': {
      'other': '0 сая'
    },
    '10000000': {
      'other': '00 сая'
    },
    '100000000': {
      'other': '000 сая'
    },
    '1000000000': {
      'other': '0 тэрбум'
    },
    '10000000000': {
      'other': '00 тэрбум'
    },
    '100000000000': {
      'other': '000 тэрбум'
    },
    '1000000000000': {
      'other': '0 их наяд'
    },
    '10000000000000': {
      'other': '00 их наяд'
    },
    '100000000000000': {
      'other': '000 их наяд'
    }
  }
};


/**
 * Compact number formatting symbols for locale mo.
 */
goog.i18n.CompactNumberFormatSymbols_mo = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 K'
    },
    '10000': {
      'other': '00 K'
    },
    '100000': {
      'other': '000 K'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mld.'
    },
    '10000000000': {
      'other': '00 mld.'
    },
    '100000000000': {
      'other': '000 mld.'
    },
    '1000000000000': {
      'other': '0 tril.'
    },
    '10000000000000': {
      'other': '00 tril.'
    },
    '100000000000000': {
      'other': '000 tril.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 de mii'
    },
    '10000': {
      'other': '00 de mii'
    },
    '100000': {
      'other': '000 de mii'
    },
    '1000000': {
      'other': '0 de milioane'
    },
    '10000000': {
      'other': '00 de milioane'
    },
    '100000000': {
      'other': '000 de milioane'
    },
    '1000000000': {
      'other': '0 de miliarde'
    },
    '10000000000': {
      'other': '00 de miliarde'
    },
    '100000000000': {
      'other': '000 de miliarde'
    },
    '1000000000000': {
      'other': '0 de trilioane'
    },
    '10000000000000': {
      'other': '00 de trilioane'
    },
    '100000000000000': {
      'other': '000 de trilioane'
    }
  }
};


/**
 * Compact number formatting symbols for locale mr.
 */
goog.i18n.CompactNumberFormatSymbols_mr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ह'
    },
    '10000': {
      'other': '00 ह'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '00 लाख'
    },
    '10000000': {
      'other': '0 कोटी'
    },
    '100000000': {
      'other': '00 कोटी'
    },
    '1000000000': {
      'other': '0 अब्ज'
    },
    '10000000000': {
      'other': '00 अब्ज'
    },
    '100000000000': {
      'other': '0 खर्व'
    },
    '1000000000000': {
      'other': '00 खर्व'
    },
    '10000000000000': {
      'other': '0 पद्म'
    },
    '100000000000000': {
      'other': '00 पद्म'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 हजार'
    },
    '10000': {
      'other': '00 हजार'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '00 लाख'
    },
    '10000000': {
      'other': '0 कोटी'
    },
    '100000000': {
      'other': '00 कोटी'
    },
    '1000000000': {
      'other': '0 अब्ज'
    },
    '10000000000': {
      'other': '00 अब्ज'
    },
    '100000000000': {
      'other': '0 खर्व'
    },
    '1000000000000': {
      'other': '00 खर्व'
    },
    '10000000000000': {
      'other': '0 पद्म'
    },
    '100000000000000': {
      'other': '00 पद्म'
    }
  }
};


/**
 * Compact number formatting symbols for locale ms.
 */
goog.i18n.CompactNumberFormatSymbols_ms = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0J'
    },
    '10000000': {
      'other': '00J'
    },
    '100000000': {
      'other': '000J'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ribu'
    },
    '10000': {
      'other': '00 ribu'
    },
    '100000': {
      'other': '000 ribu'
    },
    '1000000': {
      'other': '0 juta'
    },
    '10000000': {
      'other': '00 juta'
    },
    '100000000': {
      'other': '000 juta'
    },
    '1000000000': {
      'other': '0 bilion'
    },
    '10000000000': {
      'other': '00 bilion'
    },
    '100000000000': {
      'other': '000 bilion'
    },
    '1000000000000': {
      'other': '0 trilion'
    },
    '10000000000000': {
      'other': '00 trilion'
    },
    '100000000000000': {
      'other': '000 trilion'
    }
  }
};


/**
 * Compact number formatting symbols for locale mt.
 */
goog.i18n.CompactNumberFormatSymbols_mt = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0G'
    },
    '10000000000': {
      'other': '00G'
    },
    '100000000000': {
      'other': '000G'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  }
};


/**
 * Compact number formatting symbols for locale my.
 */
goog.i18n.CompactNumberFormatSymbols_my = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0ထောင်'
    },
    '10000': {
      'other': '0သောင်း'
    },
    '100000': {
      'other': '0သိန်း'
    },
    '1000000': {
      'other': '0သန်း'
    },
    '10000000': {
      'other': '0ကုဋေ'
    },
    '100000000': {
      'other': '00ကုဋေ'
    },
    '1000000000': {
      'other': 'ကုဋေ000'
    },
    '10000000000': {
      'other': 'ကုဋေ0ထ'
    },
    '100000000000': {
      'other': 'ကုဋေ0သ'
    },
    '1000000000000': {
      'other': 'ဋေ0သိန်း'
    },
    '10000000000000': {
      'other': 'ဋေ0သန်း'
    },
    '100000000000000': {
      'other': '0ကောဋိ'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0ထောင်'
    },
    '10000': {
      'other': '0သောင်း'
    },
    '100000': {
      'other': '0သိန်း'
    },
    '1000000': {
      'other': '0သန်း'
    },
    '10000000': {
      'other': '0ကုဋေ'
    },
    '100000000': {
      'other': '00ကုဋေ'
    },
    '1000000000': {
      'other': 'ကုဋေ000'
    },
    '10000000000': {
      'other': 'ကုဋေ0000'
    },
    '100000000000': {
      'other': 'ကုဋေ0သောင်း'
    },
    '1000000000000': {
      'other': 'ကုဋေ0သိန်း'
    },
    '10000000000000': {
      'other': 'ကုဋေ0သန်း'
    },
    '100000000000000': {
      'other': '0ကောဋိ'
    }
  }
};


/**
 * Compact number formatting symbols for locale nb.
 */
goog.i18n.CompactNumberFormatSymbols_nb = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0k'
    },
    '10000': {
      'other': '00k'
    },
    '100000': {
      'other': '000k'
    },
    '1000000': {
      'other': '0 mill.'
    },
    '10000000': {
      'other': '00 mill.'
    },
    '100000000': {
      'other': '000 mill.'
    },
    '1000000000': {
      'other': '0 mrd.'
    },
    '10000000000': {
      'other': '00 mrd.'
    },
    '100000000000': {
      'other': '000 mrd.'
    },
    '1000000000000': {
      'other': '0 bill.'
    },
    '10000000000000': {
      'other': '00 bill.'
    },
    '100000000000000': {
      'other': '000 bill.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tusen'
    },
    '10000': {
      'other': '00 tusen'
    },
    '100000': {
      'other': '000 tusen'
    },
    '1000000': {
      'other': '0 millioner'
    },
    '10000000': {
      'other': '00 millioner'
    },
    '100000000': {
      'other': '000 millioner'
    },
    '1000000000': {
      'other': '0 milliarder'
    },
    '10000000000': {
      'other': '00 milliarder'
    },
    '100000000000': {
      'other': '000 milliarder'
    },
    '1000000000000': {
      'other': '0 billioner'
    },
    '10000000000000': {
      'other': '00 billioner'
    },
    '100000000000000': {
      'other': '000 billioner'
    }
  }
};


/**
 * Compact number formatting symbols for locale ne.
 */
goog.i18n.CompactNumberFormatSymbols_ne = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 हजार'
    },
    '10000': {
      'other': '00 हजार'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '00 लाख'
    },
    '10000000': {
      'other': '0 करोड'
    },
    '100000000': {
      'other': '00 करोड'
    },
    '1000000000': {
      'other': '0 अरब'
    },
    '10000000000': {
      'other': '00 अरब'
    },
    '100000000000': {
      'other': '0 खरब'
    },
    '1000000000000': {
      'other': '00 खरब'
    },
    '10000000000000': {
      'other': '0 शंख'
    },
    '100000000000000': {
      'other': '00 शंख'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 हजार'
    },
    '10000': {
      'other': '00 हजार'
    },
    '100000': {
      'other': '0 लाख'
    },
    '1000000': {
      'other': '0 करोड'
    },
    '10000000': {
      'other': '00 करोड'
    },
    '100000000': {
      'other': '000 करोड'
    },
    '1000000000': {
      'other': '0 अरब'
    },
    '10000000000': {
      'other': '00 अरब'
    },
    '100000000000': {
      'other': '000 अरब'
    },
    '1000000000000': {
      'other': '00 खरब'
    },
    '10000000000000': {
      'other': '0 शंख'
    },
    '100000000000000': {
      'other': '00 शंख'
    }
  }
};


/**
 * Compact number formatting symbols for locale nl.
 */
goog.i18n.CompactNumberFormatSymbols_nl = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0 mln.'
    },
    '10000000': {
      'other': '00 mln.'
    },
    '100000000': {
      'other': '000 mln.'
    },
    '1000000000': {
      'other': '0 mld.'
    },
    '10000000000': {
      'other': '00 mld.'
    },
    '100000000000': {
      'other': '000 mld.'
    },
    '1000000000000': {
      'other': '0 bln.'
    },
    '10000000000000': {
      'other': '00 bln.'
    },
    '100000000000000': {
      'other': '000 bln.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 duizend'
    },
    '10000': {
      'other': '00 duizend'
    },
    '100000': {
      'other': '000 duizend'
    },
    '1000000': {
      'other': '0 miljoen'
    },
    '10000000': {
      'other': '00 miljoen'
    },
    '100000000': {
      'other': '000 miljoen'
    },
    '1000000000': {
      'other': '0 miljard'
    },
    '10000000000': {
      'other': '00 miljard'
    },
    '100000000000': {
      'other': '000 miljard'
    },
    '1000000000000': {
      'other': '0 biljoen'
    },
    '10000000000000': {
      'other': '00 biljoen'
    },
    '100000000000000': {
      'other': '000 biljoen'
    }
  }
};


/**
 * Compact number formatting symbols for locale no.
 */
goog.i18n.CompactNumberFormatSymbols_no = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0k'
    },
    '10000': {
      'other': '00k'
    },
    '100000': {
      'other': '000k'
    },
    '1000000': {
      'other': '0 mill.'
    },
    '10000000': {
      'other': '00 mill.'
    },
    '100000000': {
      'other': '000 mill.'
    },
    '1000000000': {
      'other': '0 mrd.'
    },
    '10000000000': {
      'other': '00 mrd.'
    },
    '100000000000': {
      'other': '000 mrd.'
    },
    '1000000000000': {
      'other': '0 bill.'
    },
    '10000000000000': {
      'other': '00 bill.'
    },
    '100000000000000': {
      'other': '000 bill.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tusen'
    },
    '10000': {
      'other': '00 tusen'
    },
    '100000': {
      'other': '000 tusen'
    },
    '1000000': {
      'other': '0 millioner'
    },
    '10000000': {
      'other': '00 millioner'
    },
    '100000000': {
      'other': '000 millioner'
    },
    '1000000000': {
      'other': '0 milliarder'
    },
    '10000000000': {
      'other': '00 milliarder'
    },
    '100000000000': {
      'other': '000 milliarder'
    },
    '1000000000000': {
      'other': '0 billioner'
    },
    '10000000000000': {
      'other': '00 billioner'
    },
    '100000000000000': {
      'other': '000 billioner'
    }
  }
};


/**
 * Compact number formatting symbols for locale no_NO.
 */
goog.i18n.CompactNumberFormatSymbols_no_NO = goog.i18n.CompactNumberFormatSymbols_no;


/**
 * Compact number formatting symbols for locale or.
 */
goog.i18n.CompactNumberFormatSymbols_or = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0ହ'
    },
    '10000': {
      'other': '00ହ'
    },
    '100000': {
      'other': '000ହ'
    },
    '1000000': {
      'other': '0ନି'
    },
    '10000000': {
      'other': '00ନି'
    },
    '100000000': {
      'other': '000ନି'
    },
    '1000000000': {
      'other': '0ବି'
    },
    '10000000000': {
      'other': '00ବି'
    },
    '100000000000': {
      'other': '000ବି'
    },
    '1000000000000': {
      'other': '0ଟ୍ରି'
    },
    '10000000000000': {
      'other': '00ଟ୍ରି'
    },
    '100000000000000': {
      'other': '000ଟ୍ରି'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ହଜାର'
    },
    '10000': {
      'other': '00 ହଜାର'
    },
    '100000': {
      'other': '000 ହଜାର'
    },
    '1000000': {
      'other': '0 ନିୟୁତ'
    },
    '10000000': {
      'other': '00 ନିୟୁତ'
    },
    '100000000': {
      'other': '000 ନିୟୁତ'
    },
    '1000000000': {
      'other': '0 ଶହକୋଟି'
    },
    '10000000000': {
      'other': '00 ଶହକୋଟି'
    },
    '100000000000': {
      'other': '000 ଶହକୋଟି'
    },
    '1000000000000': {
      'other': '0 ଲକ୍ଷକୋଟି'
    },
    '10000000000000': {
      'other': '00 ଲକ୍ଷକୋଟି'
    },
    '100000000000000': {
      'other': '000 ଲକ୍ଷକୋଟି'
    }
  }
};


/**
 * Compact number formatting symbols for locale pa.
 */
goog.i18n.CompactNumberFormatSymbols_pa = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ਹਜ਼ਾਰ'
    },
    '10000': {
      'other': '00 ਹਜ਼ਾਰ'
    },
    '100000': {
      'other': '0 ਲੱਖ'
    },
    '1000000': {
      'other': '00 ਲੱਖ'
    },
    '10000000': {
      'other': '0 ਕਰੋੜ'
    },
    '100000000': {
      'other': '00 ਕਰੋੜ'
    },
    '1000000000': {
      'other': '0 ਅਰਬ'
    },
    '10000000000': {
      'other': '00 ਅਰਬ'
    },
    '100000000000': {
      'other': '0 ਖਰਬ'
    },
    '1000000000000': {
      'other': '00 ਖਰਬ'
    },
    '10000000000000': {
      'other': '0 ਨੀਲ'
    },
    '100000000000000': {
      'other': '00 ਨੀਲ'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ਹਜ਼ਾਰ'
    },
    '10000': {
      'other': '00 ਹਜ਼ਾਰ'
    },
    '100000': {
      'other': '0 ਲੱਖ'
    },
    '1000000': {
      'other': '00 ਲੱਖ'
    },
    '10000000': {
      'other': '0 ਕਰੋੜ'
    },
    '100000000': {
      'other': '00 ਕਰੋੜ'
    },
    '1000000000': {
      'other': '0 ਅਰਬ'
    },
    '10000000000': {
      'other': '00 ਅਰਬ'
    },
    '100000000000': {
      'other': '0 ਖਰਬ'
    },
    '1000000000000': {
      'other': '00 ਖਰਬ'
    },
    '10000000000000': {
      'other': '0 ਨੀਲ'
    },
    '100000000000000': {
      'other': '00 ਨੀਲ'
    }
  }
};


/**
 * Compact number formatting symbols for locale pl.
 */
goog.i18n.CompactNumberFormatSymbols_pl = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tys.'
    },
    '10000': {
      'other': '00 tys.'
    },
    '100000': {
      'other': '000 tys.'
    },
    '1000000': {
      'other': '0 mln'
    },
    '10000000': {
      'other': '00 mln'
    },
    '100000000': {
      'other': '000 mln'
    },
    '1000000000': {
      'other': '0 mld'
    },
    '10000000000': {
      'other': '00 mld'
    },
    '100000000000': {
      'other': '000 mld'
    },
    '1000000000000': {
      'other': '0 bln'
    },
    '10000000000000': {
      'other': '00 bln'
    },
    '100000000000000': {
      'other': '000 bln'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tysiąca'
    },
    '10000': {
      'other': '00 tysiąca'
    },
    '100000': {
      'other': '000 tysiąca'
    },
    '1000000': {
      'other': '0 miliona'
    },
    '10000000': {
      'other': '00 miliona'
    },
    '100000000': {
      'other': '000 miliona'
    },
    '1000000000': {
      'other': '0 miliarda'
    },
    '10000000000': {
      'other': '00 miliarda'
    },
    '100000000000': {
      'other': '000 miliarda'
    },
    '1000000000000': {
      'other': '0 biliona'
    },
    '10000000000000': {
      'other': '00 biliona'
    },
    '100000000000000': {
      'other': '000 biliona'
    }
  }
};


/**
 * Compact number formatting symbols for locale pt.
 */
goog.i18n.CompactNumberFormatSymbols_pt = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 mi'
    },
    '10000000': {
      'other': '00 mi'
    },
    '100000000': {
      'other': '000 mi'
    },
    '1000000000': {
      'other': '0 bi'
    },
    '10000000000': {
      'other': '00 bi'
    },
    '100000000000': {
      'other': '000 bi'
    },
    '1000000000000': {
      'other': '0 tri'
    },
    '10000000000000': {
      'other': '00 tri'
    },
    '100000000000000': {
      'other': '000 tri'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 milhões'
    },
    '10000000': {
      'other': '00 milhões'
    },
    '100000000': {
      'other': '000 milhões'
    },
    '1000000000': {
      'other': '0 bilhões'
    },
    '10000000000': {
      'other': '00 bilhões'
    },
    '100000000000': {
      'other': '000 bilhões'
    },
    '1000000000000': {
      'other': '0 trilhões'
    },
    '10000000000000': {
      'other': '00 trilhões'
    },
    '100000000000000': {
      'other': '000 trilhões'
    }
  }
};


/**
 * Compact number formatting symbols for locale pt_BR.
 */
goog.i18n.CompactNumberFormatSymbols_pt_BR = goog.i18n.CompactNumberFormatSymbols_pt;


/**
 * Compact number formatting symbols for locale pt_PT.
 */
goog.i18n.CompactNumberFormatSymbols_pt_PT = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 M'
    },
    '10000000': {
      'other': '00 M'
    },
    '100000000': {
      'other': '000 M'
    },
    '1000000000': {
      'other': '0 mM'
    },
    '10000000000': {
      'other': '00 mM'
    },
    '100000000000': {
      'other': '000 mM'
    },
    '1000000000000': {
      'other': '0 Bi'
    },
    '10000000000000': {
      'other': '00 Bi'
    },
    '100000000000000': {
      'other': '000 Bi'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mil'
    },
    '10000': {
      'other': '00 mil'
    },
    '100000': {
      'other': '000 mil'
    },
    '1000000': {
      'other': '0 milhões'
    },
    '10000000': {
      'other': '00 milhões'
    },
    '100000000': {
      'other': '000 milhões'
    },
    '1000000000': {
      'other': '0 mil milhões'
    },
    '10000000000': {
      'other': '00 mil milhões'
    },
    '100000000000': {
      'other': '000 mil milhões'
    },
    '1000000000000': {
      'other': '0 biliões'
    },
    '10000000000000': {
      'other': '00 biliões'
    },
    '100000000000000': {
      'other': '000 biliões'
    }
  }
};


/**
 * Compact number formatting symbols for locale ro.
 */
goog.i18n.CompactNumberFormatSymbols_ro = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 K'
    },
    '10000': {
      'other': '00 K'
    },
    '100000': {
      'other': '000 K'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mld.'
    },
    '10000000000': {
      'other': '00 mld.'
    },
    '100000000000': {
      'other': '000 mld.'
    },
    '1000000000000': {
      'other': '0 tril.'
    },
    '10000000000000': {
      'other': '00 tril.'
    },
    '100000000000000': {
      'other': '000 tril.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 de mii'
    },
    '10000': {
      'other': '00 de mii'
    },
    '100000': {
      'other': '000 de mii'
    },
    '1000000': {
      'other': '0 de milioane'
    },
    '10000000': {
      'other': '00 de milioane'
    },
    '100000000': {
      'other': '000 de milioane'
    },
    '1000000000': {
      'other': '0 de miliarde'
    },
    '10000000000': {
      'other': '00 de miliarde'
    },
    '100000000000': {
      'other': '000 de miliarde'
    },
    '1000000000000': {
      'other': '0 de trilioane'
    },
    '10000000000000': {
      'other': '00 de trilioane'
    },
    '100000000000000': {
      'other': '000 de trilioane'
    }
  }
};


/**
 * Compact number formatting symbols for locale ru.
 */
goog.i18n.CompactNumberFormatSymbols_ru = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 тыс.'
    },
    '10000': {
      'other': '00 тыс.'
    },
    '100000': {
      'other': '000 тыс.'
    },
    '1000000': {
      'other': '0 млн'
    },
    '10000000': {
      'other': '00 млн'
    },
    '100000000': {
      'other': '000 млн'
    },
    '1000000000': {
      'other': '0 млрд'
    },
    '10000000000': {
      'other': '00 млрд'
    },
    '100000000000': {
      'other': '000 млрд'
    },
    '1000000000000': {
      'other': '0 трлн'
    },
    '10000000000000': {
      'other': '00 трлн'
    },
    '100000000000000': {
      'other': '000 трлн'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 тысячи'
    },
    '10000': {
      'other': '00 тысячи'
    },
    '100000': {
      'other': '000 тысячи'
    },
    '1000000': {
      'other': '0 миллиона'
    },
    '10000000': {
      'other': '00 миллиона'
    },
    '100000000': {
      'other': '000 миллиона'
    },
    '1000000000': {
      'other': '0 миллиарда'
    },
    '10000000000': {
      'other': '00 миллиарда'
    },
    '100000000000': {
      'other': '000 миллиарда'
    },
    '1000000000000': {
      'other': '0 триллиона'
    },
    '10000000000000': {
      'other': '00 триллиона'
    },
    '100000000000000': {
      'other': '000 триллиона'
    }
  }
};


/**
 * Compact number formatting symbols for locale sh.
 */
goog.i18n.CompactNumberFormatSymbols_sh = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 hilj.'
    },
    '10000': {
      'other': '00 hilj.'
    },
    '100000': {
      'other': '000 hilj.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mlrd.'
    },
    '10000000000': {
      'other': '00 mlrd.'
    },
    '100000000000': {
      'other': '000 mlrd.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 hiljada'
    },
    '10000': {
      'other': '00 hiljada'
    },
    '100000': {
      'other': '000 hiljada'
    },
    '1000000': {
      'other': '0 miliona'
    },
    '10000000': {
      'other': '00 miliona'
    },
    '100000000': {
      'other': '000 miliona'
    },
    '1000000000': {
      'other': '0 milijardi'
    },
    '10000000000': {
      'other': '00 milijardi'
    },
    '100000000000': {
      'other': '000 milijardi'
    },
    '1000000000000': {
      'other': '0 biliona'
    },
    '10000000000000': {
      'other': '00 biliona'
    },
    '100000000000000': {
      'other': '000 biliona'
    }
  }
};


/**
 * Compact number formatting symbols for locale si.
 */
goog.i18n.CompactNumberFormatSymbols_si = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': 'ද0'
    },
    '10000': {
      'other': 'ද00'
    },
    '100000': {
      'other': 'ද000'
    },
    '1000000': {
      'other': 'මි0'
    },
    '10000000': {
      'other': 'මි00'
    },
    '100000000': {
      'other': 'මි000'
    },
    '1000000000': {
      'other': 'බි0'
    },
    '10000000000': {
      'other': 'බි00'
    },
    '100000000000': {
      'other': 'බි000'
    },
    '1000000000000': {
      'other': 'ට්‍රි0'
    },
    '10000000000000': {
      'other': 'ට්‍රි00'
    },
    '100000000000000': {
      'other': 'ට්‍රි000'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': 'දහස 0'
    },
    '10000': {
      'other': 'දහස 00'
    },
    '100000': {
      'other': 'දහස 000'
    },
    '1000000': {
      'other': 'මිලියන 0'
    },
    '10000000': {
      'other': 'මිලියන 00'
    },
    '100000000': {
      'other': 'මිලියන 000'
    },
    '1000000000': {
      'other': 'බිලියන 0'
    },
    '10000000000': {
      'other': 'බිලියන 00'
    },
    '100000000000': {
      'other': 'බිලියන 000'
    },
    '1000000000000': {
      'other': 'ට්‍රිලියන 0'
    },
    '10000000000000': {
      'other': 'ට්‍රිලියන 00'
    },
    '100000000000000': {
      'other': 'ට්‍රිලියන 000'
    }
  }
};


/**
 * Compact number formatting symbols for locale sk.
 */
goog.i18n.CompactNumberFormatSymbols_sk = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tis.'
    },
    '10000': {
      'other': '00 tis.'
    },
    '100000': {
      'other': '000 tis.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mld.'
    },
    '10000000000': {
      'other': '00 mld.'
    },
    '100000000000': {
      'other': '000 mld.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tisíc'
    },
    '10000': {
      'other': '00 tisíc'
    },
    '100000': {
      'other': '000 tisíc'
    },
    '1000000': {
      'other': '0 miliónov'
    },
    '10000000': {
      'other': '00 miliónov'
    },
    '100000000': {
      'other': '000 miliónov'
    },
    '1000000000': {
      'other': '0 miliárd'
    },
    '10000000000': {
      'other': '00 miliárd'
    },
    '100000000000': {
      'other': '000 miliárd'
    },
    '1000000000000': {
      'other': '0 biliónov'
    },
    '10000000000000': {
      'other': '00 biliónov'
    },
    '100000000000000': {
      'other': '000 biliónov'
    }
  }
};


/**
 * Compact number formatting symbols for locale sl.
 */
goog.i18n.CompactNumberFormatSymbols_sl = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tis.'
    },
    '10000': {
      'other': '00 tis.'
    },
    '100000': {
      'other': '000 tis.'
    },
    '1000000': {
      'other': '0 mio.'
    },
    '10000000': {
      'other': '00 mio.'
    },
    '100000000': {
      'other': '000 mio.'
    },
    '1000000000': {
      'other': '0 mrd.'
    },
    '10000000000': {
      'other': '00 mrd.'
    },
    '100000000000': {
      'other': '000 mrd.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tisoč'
    },
    '10000': {
      'other': '00 tisoč'
    },
    '100000': {
      'other': '000 tisoč'
    },
    '1000000': {
      'other': '0 milijonov'
    },
    '10000000': {
      'other': '00 milijonov'
    },
    '100000000': {
      'other': '000 milijonov'
    },
    '1000000000': {
      'other': '0 milijard'
    },
    '10000000000': {
      'other': '00 milijard'
    },
    '100000000000': {
      'other': '000 milijard'
    },
    '1000000000000': {
      'other': '0 bilijonov'
    },
    '10000000000000': {
      'other': '00 bilijonov'
    },
    '100000000000000': {
      'other': '000 bilijonov'
    }
  }
};


/**
 * Compact number formatting symbols for locale sq.
 */
goog.i18n.CompactNumberFormatSymbols_sq = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 mijë'
    },
    '10000': {
      'other': '00 mijë'
    },
    '100000': {
      'other': '000 mijë'
    },
    '1000000': {
      'other': '0 mln'
    },
    '10000000': {
      'other': '00 mln'
    },
    '100000000': {
      'other': '000 mln'
    },
    '1000000000': {
      'other': '0 mld'
    },
    '10000000000': {
      'other': '00 mld'
    },
    '100000000000': {
      'other': '000 mld'
    },
    '1000000000000': {
      'other': '0 bln'
    },
    '10000000000000': {
      'other': '00 bln'
    },
    '100000000000000': {
      'other': '000 bln'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 mijë'
    },
    '10000': {
      'other': '00 mijë'
    },
    '100000': {
      'other': '000 mijë'
    },
    '1000000': {
      'other': '0 milion'
    },
    '10000000': {
      'other': '00 milion'
    },
    '100000000': {
      'other': '000 milion'
    },
    '1000000000': {
      'other': '0 miliard'
    },
    '10000000000': {
      'other': '00 miliard'
    },
    '100000000000': {
      'other': '000 miliard'
    },
    '1000000000000': {
      'other': '0 bilion'
    },
    '10000000000000': {
      'other': '00 bilion'
    },
    '100000000000000': {
      'other': '000 bilion'
    }
  }
};


/**
 * Compact number formatting symbols for locale sr.
 */
goog.i18n.CompactNumberFormatSymbols_sr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 хиљ.'
    },
    '10000': {
      'other': '00 хиљ.'
    },
    '100000': {
      'other': '000 хиљ.'
    },
    '1000000': {
      'other': '0 мил.'
    },
    '10000000': {
      'other': '00 мил.'
    },
    '100000000': {
      'other': '000 мил.'
    },
    '1000000000': {
      'other': '0 млрд.'
    },
    '10000000000': {
      'other': '00 млрд.'
    },
    '100000000000': {
      'other': '000 млрд.'
    },
    '1000000000000': {
      'other': '0 бил.'
    },
    '10000000000000': {
      'other': '00 бил.'
    },
    '100000000000000': {
      'other': '000 бил.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 хиљада'
    },
    '10000': {
      'other': '00 хиљада'
    },
    '100000': {
      'other': '000 хиљада'
    },
    '1000000': {
      'other': '0 милиона'
    },
    '10000000': {
      'other': '00 милиона'
    },
    '100000000': {
      'other': '000 милиона'
    },
    '1000000000': {
      'other': '0 милијарди'
    },
    '10000000000': {
      'other': '00 милијарди'
    },
    '100000000000': {
      'other': '000 милијарди'
    },
    '1000000000000': {
      'other': '0 билиона'
    },
    '10000000000000': {
      'other': '00 билиона'
    },
    '100000000000000': {
      'other': '000 билиона'
    }
  }
};


/**
 * Compact number formatting symbols for locale sr_Latn.
 */
goog.i18n.CompactNumberFormatSymbols_sr_Latn = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 hilj.'
    },
    '10000': {
      'other': '00 hilj.'
    },
    '100000': {
      'other': '000 hilj.'
    },
    '1000000': {
      'other': '0 mil.'
    },
    '10000000': {
      'other': '00 mil.'
    },
    '100000000': {
      'other': '000 mil.'
    },
    '1000000000': {
      'other': '0 mlrd.'
    },
    '10000000000': {
      'other': '00 mlrd.'
    },
    '100000000000': {
      'other': '000 mlrd.'
    },
    '1000000000000': {
      'other': '0 bil.'
    },
    '10000000000000': {
      'other': '00 bil.'
    },
    '100000000000000': {
      'other': '000 bil.'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 hiljada'
    },
    '10000': {
      'other': '00 hiljada'
    },
    '100000': {
      'other': '000 hiljada'
    },
    '1000000': {
      'other': '0 miliona'
    },
    '10000000': {
      'other': '00 miliona'
    },
    '100000000': {
      'other': '000 miliona'
    },
    '1000000000': {
      'other': '0 milijardi'
    },
    '10000000000': {
      'other': '00 milijardi'
    },
    '100000000000': {
      'other': '000 milijardi'
    },
    '1000000000000': {
      'other': '0 biliona'
    },
    '10000000000000': {
      'other': '00 biliona'
    },
    '100000000000000': {
      'other': '000 biliona'
    }
  }
};


/**
 * Compact number formatting symbols for locale sv.
 */
goog.i18n.CompactNumberFormatSymbols_sv = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 tn'
    },
    '10000': {
      'other': '00 tn'
    },
    '100000': {
      'other': '000 tn'
    },
    '1000000': {
      'other': '0 mn'
    },
    '10000000': {
      'other': '00 mn'
    },
    '100000000': {
      'other': '000 mn'
    },
    '1000000000': {
      'other': '0 md'
    },
    '10000000000': {
      'other': '00 md'
    },
    '100000000000': {
      'other': '000 md'
    },
    '1000000000000': {
      'other': '0 bn'
    },
    '10000000000000': {
      'other': '00 bn'
    },
    '100000000000000': {
      'other': '000 bn'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 tusen'
    },
    '10000': {
      'other': '00 tusen'
    },
    '100000': {
      'other': '000 tusen'
    },
    '1000000': {
      'other': '0 miljoner'
    },
    '10000000': {
      'other': '00 miljoner'
    },
    '100000000': {
      'other': '000 miljoner'
    },
    '1000000000': {
      'other': '0 miljarder'
    },
    '10000000000': {
      'other': '00 miljarder'
    },
    '100000000000': {
      'other': '000 miljarder'
    },
    '1000000000000': {
      'other': '0 biljoner'
    },
    '10000000000000': {
      'other': '00 biljoner'
    },
    '100000000000000': {
      'other': '000 biljoner'
    }
  }
};


/**
 * Compact number formatting symbols for locale sw.
 */
goog.i18n.CompactNumberFormatSymbols_sw = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': 'elfu 0;elfu -0'
    },
    '10000': {
      'other': 'elfu 00;elfu -00'
    },
    '100000': {
      'other': 'elfu 000;elfu -000'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B;-0B'
    },
    '10000000000': {
      'other': '00B;-00B'
    },
    '100000000000': {
      'other': '000B;-000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': 'elfu 0;elfu -0'
    },
    '10000': {
      'other': 'elfu 00;elfu -00'
    },
    '100000': {
      'other': 'elfu 000;elfu -000'
    },
    '1000000': {
      'other': 'milioni 0;milioni -0'
    },
    '10000000': {
      'other': 'milioni 00;milioni -00'
    },
    '100000000': {
      'other': 'milioni 000;milioni -000'
    },
    '1000000000': {
      'other': 'bilioni 0;bilioni -0'
    },
    '10000000000': {
      'other': 'bilioni 00;bilioni -00'
    },
    '100000000000': {
      'other': 'bilioni 000;bilioni -000'
    },
    '1000000000000': {
      'other': 'trilioni 0;trilioni -0'
    },
    '10000000000000': {
      'other': 'trilioni 00;trilioni -00'
    },
    '100000000000000': {
      'other': 'trilioni 000;trilioni -000'
    }
  }
};


/**
 * Compact number formatting symbols for locale ta.
 */
goog.i18n.CompactNumberFormatSymbols_ta = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0ஆ'
    },
    '10000': {
      'other': '00ஆ'
    },
    '100000': {
      'other': '000ஆ'
    },
    '1000000': {
      'other': '0மி'
    },
    '10000000': {
      'other': '00மி'
    },
    '100000000': {
      'other': '000மி'
    },
    '1000000000': {
      'other': '0பி'
    },
    '10000000000': {
      'other': '00பி'
    },
    '100000000000': {
      'other': '000பி'
    },
    '1000000000000': {
      'other': '0டி'
    },
    '10000000000000': {
      'other': '00டி'
    },
    '100000000000000': {
      'other': '000டி'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ஆயிரம்'
    },
    '10000': {
      'other': '00 ஆயிரம்'
    },
    '100000': {
      'other': '000 ஆயிரம்'
    },
    '1000000': {
      'other': '0 மில்லியன்'
    },
    '10000000': {
      'other': '00 மில்லியன்'
    },
    '100000000': {
      'other': '000 மில்லியன்'
    },
    '1000000000': {
      'other': '0 பில்லியன்'
    },
    '10000000000': {
      'other': '00 பில்லியன்'
    },
    '100000000000': {
      'other': '000 பில்லியன்'
    },
    '1000000000000': {
      'other': '0 டிரில்லியன்'
    },
    '10000000000000': {
      'other': '00 டிரில்லியன்'
    },
    '100000000000000': {
      'other': '000 டிரில்லியன்'
    }
  }
};


/**
 * Compact number formatting symbols for locale te.
 */
goog.i18n.CompactNumberFormatSymbols_te = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0వే'
    },
    '10000': {
      'other': '00వే'
    },
    '100000': {
      'other': '000వే'
    },
    '1000000': {
      'other': '0మి'
    },
    '10000000': {
      'other': '00మి'
    },
    '100000000': {
      'other': '000మి'
    },
    '1000000000': {
      'other': '0బి'
    },
    '10000000000': {
      'other': '00బి'
    },
    '100000000000': {
      'other': '000బి'
    },
    '1000000000000': {
      'other': '0ట్రి'
    },
    '10000000000000': {
      'other': '00ట్రి'
    },
    '100000000000000': {
      'other': '000ట్రి'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 వేలు'
    },
    '10000': {
      'other': '00 వేలు'
    },
    '100000': {
      'other': '000 వేలు'
    },
    '1000000': {
      'other': '0 మిలియన్లు'
    },
    '10000000': {
      'other': '00 మిలియన్లు'
    },
    '100000000': {
      'other': '000 మిలియన్లు'
    },
    '1000000000': {
      'other': '0 బిలియన్లు'
    },
    '10000000000': {
      'other': '00 బిలియన్లు'
    },
    '100000000000': {
      'other': '000 బిలియన్లు'
    },
    '1000000000000': {
      'other': '0 ట్రిలియన్లు'
    },
    '10000000000000': {
      'other': '00 ట్రిలియన్లు'
    },
    '100000000000000': {
      'other': '000 ట్రిలియన్లు'
    }
  }
};


/**
 * Compact number formatting symbols for locale th.
 */
goog.i18n.CompactNumberFormatSymbols_th = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 พัน'
    },
    '10000': {
      'other': '0 หมื่น'
    },
    '100000': {
      'other': '0 แสน'
    },
    '1000000': {
      'other': '0 ล้าน'
    },
    '10000000': {
      'other': '00 ล้าน'
    },
    '100000000': {
      'other': '000 ล้าน'
    },
    '1000000000': {
      'other': '0 พันล้าน'
    },
    '10000000000': {
      'other': '0 หมื่นล้าน'
    },
    '100000000000': {
      'other': '0 แสนล้าน'
    },
    '1000000000000': {
      'other': '0 ล้านล้าน'
    },
    '10000000000000': {
      'other': '00 ล้านล้าน'
    },
    '100000000000000': {
      'other': '000 ล้านล้าน'
    }
  }
};


/**
 * Compact number formatting symbols for locale tl.
 */
goog.i18n.CompactNumberFormatSymbols_tl = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 na libo'
    },
    '10000': {
      'other': '00 na libo'
    },
    '100000': {
      'other': '000 na libo'
    },
    '1000000': {
      'other': '0 na milyon'
    },
    '10000000': {
      'other': '00 na milyon'
    },
    '100000000': {
      'other': '000 na milyon'
    },
    '1000000000': {
      'other': '0 na bilyon'
    },
    '10000000000': {
      'other': '00 na bilyon'
    },
    '100000000000': {
      'other': '000 na bilyon'
    },
    '1000000000000': {
      'other': '0 na trilyon'
    },
    '10000000000000': {
      'other': '00 na trilyon'
    },
    '100000000000000': {
      'other': '000 na trilyon'
    }
  }
};


/**
 * Compact number formatting symbols for locale tr.
 */
goog.i18n.CompactNumberFormatSymbols_tr = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 B'
    },
    '10000': {
      'other': '00 B'
    },
    '100000': {
      'other': '000 B'
    },
    '1000000': {
      'other': '0 Mn'
    },
    '10000000': {
      'other': '00 Mn'
    },
    '100000000': {
      'other': '000 Mn'
    },
    '1000000000': {
      'other': '0 Mr'
    },
    '10000000000': {
      'other': '00 Mr'
    },
    '100000000000': {
      'other': '000 Mr'
    },
    '1000000000000': {
      'other': '0 Tn'
    },
    '10000000000000': {
      'other': '00 Tn'
    },
    '100000000000000': {
      'other': '000 Tn'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 bin'
    },
    '10000': {
      'other': '00 bin'
    },
    '100000': {
      'other': '000 bin'
    },
    '1000000': {
      'other': '0 milyon'
    },
    '10000000': {
      'other': '00 milyon'
    },
    '100000000': {
      'other': '000 milyon'
    },
    '1000000000': {
      'other': '0 milyar'
    },
    '10000000000': {
      'other': '00 milyar'
    },
    '100000000000': {
      'other': '000 milyar'
    },
    '1000000000000': {
      'other': '0 trilyon'
    },
    '10000000000000': {
      'other': '00 trilyon'
    },
    '100000000000000': {
      'other': '000 trilyon'
    }
  }
};


/**
 * Compact number formatting symbols for locale uk.
 */
goog.i18n.CompactNumberFormatSymbols_uk = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 тис.'
    },
    '10000': {
      'other': '00 тис.'
    },
    '100000': {
      'other': '000 тис.'
    },
    '1000000': {
      'other': '0 млн'
    },
    '10000000': {
      'other': '00 млн'
    },
    '100000000': {
      'other': '000 млн'
    },
    '1000000000': {
      'other': '0 млрд'
    },
    '10000000000': {
      'other': '00 млрд'
    },
    '100000000000': {
      'other': '000 млрд'
    },
    '1000000000000': {
      'other': '0 трлн'
    },
    '10000000000000': {
      'other': '00 трлн'
    },
    '100000000000000': {
      'other': '000 трлн'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 тисячі'
    },
    '10000': {
      'other': '00 тисячі'
    },
    '100000': {
      'other': '000 тисячі'
    },
    '1000000': {
      'other': '0 мільйона'
    },
    '10000000': {
      'other': '00 мільйона'
    },
    '100000000': {
      'other': '000 мільйона'
    },
    '1000000000': {
      'other': '0 мільярда'
    },
    '10000000000': {
      'other': '00 мільярда'
    },
    '100000000000': {
      'other': '000 мільярда'
    },
    '1000000000000': {
      'other': '0 трильйона'
    },
    '10000000000000': {
      'other': '00 трильйона'
    },
    '100000000000000': {
      'other': '000 трильйона'
    }
  }
};


/**
 * Compact number formatting symbols for locale ur.
 */
goog.i18n.CompactNumberFormatSymbols_ur = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ہزار'
    },
    '10000': {
      'other': '00 ہزار'
    },
    '100000': {
      'other': '0 لاکھ'
    },
    '1000000': {
      'other': '00 لاکھ'
    },
    '10000000': {
      'other': '0 کروڑ'
    },
    '100000000': {
      'other': '00 کروڑ'
    },
    '1000000000': {
      'other': '0 ارب'
    },
    '10000000000': {
      'other': '00 ارب'
    },
    '100000000000': {
      'other': '0 کھرب'
    },
    '1000000000000': {
      'other': '00 کھرب'
    },
    '10000000000000': {
      'other': '00 ٹریلین'
    },
    '100000000000000': {
      'other': '000 ٹریلین'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ہزار'
    },
    '10000': {
      'other': '00 ہزار'
    },
    '100000': {
      'other': '0 لاکھ'
    },
    '1000000': {
      'other': '00 لاکھ'
    },
    '10000000': {
      'other': '0 کروڑ'
    },
    '100000000': {
      'other': '00 کروڑ'
    },
    '1000000000': {
      'other': '0 ارب'
    },
    '10000000000': {
      'other': '00 ارب'
    },
    '100000000000': {
      'other': '0 کھرب'
    },
    '1000000000000': {
      'other': '00 کھرب'
    },
    '10000000000000': {
      'other': '00 ٹریلین'
    },
    '100000000000000': {
      'other': '000 ٹریلین'
    }
  }
};


/**
 * Compact number formatting symbols for locale uz.
 */
goog.i18n.CompactNumberFormatSymbols_uz = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 ming'
    },
    '10000': {
      'other': '00 ming'
    },
    '100000': {
      'other': '000 ming'
    },
    '1000000': {
      'other': '0 mln'
    },
    '10000000': {
      'other': '00 mln'
    },
    '100000000': {
      'other': '000 mln'
    },
    '1000000000': {
      'other': '0 mlrd'
    },
    '10000000000': {
      'other': '00 mlrd'
    },
    '100000000000': {
      'other': '000 mlrd'
    },
    '1000000000000': {
      'other': '0 trln'
    },
    '10000000000000': {
      'other': '00 trln'
    },
    '100000000000000': {
      'other': '000 trln'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 ming'
    },
    '10000': {
      'other': '00 ming'
    },
    '100000': {
      'other': '000 ming'
    },
    '1000000': {
      'other': '0 million'
    },
    '10000000': {
      'other': '00 million'
    },
    '100000000': {
      'other': '000 million'
    },
    '1000000000': {
      'other': '0 milliard'
    },
    '10000000000': {
      'other': '00 milliard'
    },
    '100000000000': {
      'other': '000 milliard'
    },
    '1000000000000': {
      'other': '0 trillion'
    },
    '10000000000000': {
      'other': '00 trillion'
    },
    '100000000000000': {
      'other': '000 trillion'
    }
  }
};


/**
 * Compact number formatting symbols for locale vi.
 */
goog.i18n.CompactNumberFormatSymbols_vi = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0 N'
    },
    '10000': {
      'other': '00 N'
    },
    '100000': {
      'other': '000 N'
    },
    '1000000': {
      'other': '0 Tr'
    },
    '10000000': {
      'other': '00 Tr'
    },
    '100000000': {
      'other': '000 Tr'
    },
    '1000000000': {
      'other': '0 T'
    },
    '10000000000': {
      'other': '00 T'
    },
    '100000000000': {
      'other': '000 T'
    },
    '1000000000000': {
      'other': '0 NT'
    },
    '10000000000000': {
      'other': '00 NT'
    },
    '100000000000000': {
      'other': '000 NT'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 nghìn'
    },
    '10000': {
      'other': '00 nghìn'
    },
    '100000': {
      'other': '000 nghìn'
    },
    '1000000': {
      'other': '0 triệu'
    },
    '10000000': {
      'other': '00 triệu'
    },
    '100000000': {
      'other': '000 triệu'
    },
    '1000000000': {
      'other': '0 tỷ'
    },
    '10000000000': {
      'other': '00 tỷ'
    },
    '100000000000': {
      'other': '000 tỷ'
    },
    '1000000000000': {
      'other': '0 nghìn tỷ'
    },
    '10000000000000': {
      'other': '00 nghìn tỷ'
    },
    '100000000000000': {
      'other': '000 nghìn tỷ'
    }
  }
};


/**
 * Compact number formatting symbols for locale zh.
 */
goog.i18n.CompactNumberFormatSymbols_zh = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0万'
    },
    '100000': {
      'other': '00万'
    },
    '1000000': {
      'other': '000万'
    },
    '10000000': {
      'other': '0000万'
    },
    '100000000': {
      'other': '0亿'
    },
    '1000000000': {
      'other': '00亿'
    },
    '10000000000': {
      'other': '000亿'
    },
    '100000000000': {
      'other': '0000亿'
    },
    '1000000000000': {
      'other': '0万亿'
    },
    '10000000000000': {
      'other': '00万亿'
    },
    '100000000000000': {
      'other': '000万亿'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0万'
    },
    '100000': {
      'other': '00万'
    },
    '1000000': {
      'other': '000万'
    },
    '10000000': {
      'other': '0000万'
    },
    '100000000': {
      'other': '0亿'
    },
    '1000000000': {
      'other': '00亿'
    },
    '10000000000': {
      'other': '000亿'
    },
    '100000000000': {
      'other': '0000亿'
    },
    '1000000000000': {
      'other': '0万亿'
    },
    '10000000000000': {
      'other': '00万亿'
    },
    '100000000000000': {
      'other': '000万亿'
    }
  }
};


/**
 * Compact number formatting symbols for locale zh_CN.
 */
goog.i18n.CompactNumberFormatSymbols_zh_CN = goog.i18n.CompactNumberFormatSymbols_zh;


/**
 * Compact number formatting symbols for locale zh_HK.
 */
goog.i18n.CompactNumberFormatSymbols_zh_HK = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0萬'
    },
    '100000': {
      'other': '00萬'
    },
    '1000000': {
      'other': '000萬'
    },
    '10000000': {
      'other': '0000萬'
    },
    '100000000': {
      'other': '0億'
    },
    '1000000000': {
      'other': '00億'
    },
    '10000000000': {
      'other': '000億'
    },
    '100000000000': {
      'other': '0000億'
    },
    '1000000000000': {
      'other': '0兆'
    },
    '10000000000000': {
      'other': '00兆'
    },
    '100000000000000': {
      'other': '000兆'
    }
  }
};


/**
 * Compact number formatting symbols for locale zh_TW.
 */
goog.i18n.CompactNumberFormatSymbols_zh_TW = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0萬'
    },
    '100000': {
      'other': '00萬'
    },
    '1000000': {
      'other': '000萬'
    },
    '10000000': {
      'other': '0000萬'
    },
    '100000000': {
      'other': '0億'
    },
    '1000000000': {
      'other': '00億'
    },
    '10000000000': {
      'other': '000億'
    },
    '100000000000': {
      'other': '0000億'
    },
    '1000000000000': {
      'other': '0兆'
    },
    '10000000000000': {
      'other': '00兆'
    },
    '100000000000000': {
      'other': '000兆'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0'
    },
    '10000': {
      'other': '0萬'
    },
    '100000': {
      'other': '00萬'
    },
    '1000000': {
      'other': '000萬'
    },
    '10000000': {
      'other': '0000萬'
    },
    '100000000': {
      'other': '0億'
    },
    '1000000000': {
      'other': '00億'
    },
    '10000000000': {
      'other': '000億'
    },
    '100000000000': {
      'other': '0000億'
    },
    '1000000000000': {
      'other': '0兆'
    },
    '10000000000000': {
      'other': '00兆'
    },
    '100000000000000': {
      'other': '000兆'
    }
  }
};


/**
 * Compact number formatting symbols for locale zu.
 */
goog.i18n.CompactNumberFormatSymbols_zu = {
  COMPACT_DECIMAL_SHORT_PATTERN: {
    '1000': {
      'other': '0K'
    },
    '10000': {
      'other': '00K'
    },
    '100000': {
      'other': '000K'
    },
    '1000000': {
      'other': '0M'
    },
    '10000000': {
      'other': '00M'
    },
    '100000000': {
      'other': '000M'
    },
    '1000000000': {
      'other': '0B'
    },
    '10000000000': {
      'other': '00B'
    },
    '100000000000': {
      'other': '000B'
    },
    '1000000000000': {
      'other': '0T'
    },
    '10000000000000': {
      'other': '00T'
    },
    '100000000000000': {
      'other': '000T'
    }
  },
  COMPACT_DECIMAL_LONG_PATTERN: {
    '1000': {
      'other': '0 inkulungwane'
    },
    '10000': {
      'other': '00 inkulungwane'
    },
    '100000': {
      'other': '000 inkulungwane'
    },
    '1000000': {
      'other': '0 isigidi'
    },
    '10000000': {
      'other': '00 isigidi'
    },
    '100000000': {
      'other': '000 isigidi'
    },
    '1000000000': {
      'other': '0 isigidi sezigidi'
    },
    '10000000000': {
      'other': '00 isigidi sezigidi'
    },
    '100000000000': {
      'other': '000 isigidi sezigidi'
    },
    '1000000000000': {
      'other': '0 isigidintathu'
    },
    '10000000000000': {
      'other': '00 isigidintathu'
    },
    '100000000000000': {
      'other': '000 isigidintathu'
    }
  }
};


/**
 * Select compact number formatting symbols by locale.
 */
goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en;

switch (goog.LOCALE) {
  case 'af':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_af;
    break;
  case 'am':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_am;
    break;
  case 'ar':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ar;
    break;
  case 'ar_DZ':
  case 'ar-DZ':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ar_DZ;
    break;
  case 'ar_EG':
  case 'ar-EG':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ar_EG;
    break;
  case 'az':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_az;
    break;
  case 'be':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_be;
    break;
  case 'bg':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_bg;
    break;
  case 'bn':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_bn;
    break;
  case 'br':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_br;
    break;
  case 'bs':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_bs;
    break;
  case 'ca':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ca;
    break;
  case 'chr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_chr;
    break;
  case 'cs':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_cs;
    break;
  case 'cy':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_cy;
    break;
  case 'da':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_da;
    break;
  case 'de':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_de;
    break;
  case 'de_AT':
  case 'de-AT':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_de_AT;
    break;
  case 'de_CH':
  case 'de-CH':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_de_CH;
    break;
  case 'el':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_el;
    break;
  case 'en':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en;
    break;
  case 'en_AU':
  case 'en-AU':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_AU;
    break;
  case 'en_CA':
  case 'en-CA':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_CA;
    break;
  case 'en_GB':
  case 'en-GB':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_GB;
    break;
  case 'en_IE':
  case 'en-IE':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_IE;
    break;
  case 'en_IN':
  case 'en-IN':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_IN;
    break;
  case 'en_SG':
  case 'en-SG':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_SG;
    break;
  case 'en_US':
  case 'en-US':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_US;
    break;
  case 'en_ZA':
  case 'en-ZA':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_en_ZA;
    break;
  case 'es':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_es;
    break;
  case 'es_419':
  case 'es-419':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_es_419;
    break;
  case 'es_ES':
  case 'es-ES':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_es_ES;
    break;
  case 'es_MX':
  case 'es-MX':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_es_MX;
    break;
  case 'es_US':
  case 'es-US':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_es_US;
    break;
  case 'et':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_et;
    break;
  case 'eu':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_eu;
    break;
  case 'fa':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_fa;
    break;
  case 'fi':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_fi;
    break;
  case 'fil':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_fil;
    break;
  case 'fr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_fr;
    break;
  case 'fr_CA':
  case 'fr-CA':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_fr_CA;
    break;
  case 'ga':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ga;
    break;
  case 'gl':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_gl;
    break;
  case 'gsw':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_gsw;
    break;
  case 'gu':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_gu;
    break;
  case 'haw':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_haw;
    break;
  case 'he':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_he;
    break;
  case 'hi':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_hi;
    break;
  case 'hr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_hr;
    break;
  case 'hu':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_hu;
    break;
  case 'hy':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_hy;
    break;
  case 'id':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_id;
    break;
  case 'in':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_in;
    break;
  case 'is':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_is;
    break;
  case 'it':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_it;
    break;
  case 'iw':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_iw;
    break;
  case 'ja':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ja;
    break;
  case 'ka':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ka;
    break;
  case 'kk':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_kk;
    break;
  case 'km':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_km;
    break;
  case 'kn':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_kn;
    break;
  case 'ko':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ko;
    break;
  case 'ky':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ky;
    break;
  case 'ln':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ln;
    break;
  case 'lo':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_lo;
    break;
  case 'lt':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_lt;
    break;
  case 'lv':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_lv;
    break;
  case 'mk':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_mk;
    break;
  case 'ml':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ml;
    break;
  case 'mn':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_mn;
    break;
  case 'mo':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_mo;
    break;
  case 'mr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_mr;
    break;
  case 'ms':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ms;
    break;
  case 'mt':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_mt;
    break;
  case 'my':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_my;
    break;
  case 'nb':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_nb;
    break;
  case 'ne':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ne;
    break;
  case 'nl':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_nl;
    break;
  case 'no':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_no;
    break;
  case 'no_NO':
  case 'no-NO':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_no_NO;
    break;
  case 'or':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_or;
    break;
  case 'pa':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_pa;
    break;
  case 'pl':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_pl;
    break;
  case 'pt':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_pt;
    break;
  case 'pt_BR':
  case 'pt-BR':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_pt_BR;
    break;
  case 'pt_PT':
  case 'pt-PT':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_pt_PT;
    break;
  case 'ro':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ro;
    break;
  case 'ru':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ru;
    break;
  case 'sh':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sh;
    break;
  case 'si':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_si;
    break;
  case 'sk':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sk;
    break;
  case 'sl':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sl;
    break;
  case 'sq':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sq;
    break;
  case 'sr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sr;
    break;
  case 'sr_Latn':
  case 'sr-Latn':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sr_Latn;
    break;
  case 'sv':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sv;
    break;
  case 'sw':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_sw;
    break;
  case 'ta':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ta;
    break;
  case 'te':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_te;
    break;
  case 'th':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_th;
    break;
  case 'tl':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_tl;
    break;
  case 'tr':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_tr;
    break;
  case 'uk':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_uk;
    break;
  case 'ur':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_ur;
    break;
  case 'uz':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_uz;
    break;
  case 'vi':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_vi;
    break;
  case 'zh':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_zh;
    break;
  case 'zh_CN':
  case 'zh-CN':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_zh_CN;
    break;
  case 'zh_HK':
  case 'zh-HK':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_zh_HK;
    break;
  case 'zh_TW':
  case 'zh-TW':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_zh_TW;
    break;
  case 'zu':
    goog.i18n.CompactNumberFormatSymbols = goog.i18n.CompactNumberFormatSymbols_zu;
    break;
}

//third_party/javascript/closure/i18n/currency.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * @fileoverview A utility to get better currency format pattern.
 *
 * This module implements a new currency format representation model. It
 * provides 3 currency representation forms: global, portable and local. Local
 * format is the most popular format people use to represent currency in its
 * circulating country without worrying about how it should be distinguished
 * from other currencies.  Global format is a formal representation in context
 * of multiple currencies in same page, it is ISO 4217 currency code. Portable
 * format is a compromise between global and local. It looks similar to how
 * people would like to see how their currency is being represented in other
 * media. While at the same time, it should be distinguishable to world's
 * popular currencies (like USD, EUR) and currencies somewhat relevant in the
 * area (like CNY in HK, though native currency is HKD). There is no guarantee
 * of uniqueness.
 */


goog.provide('goog.i18n.currency');
goog.provide('goog.i18n.currency.CurrencyInfo');
goog.provide('goog.i18n.currency.CurrencyInfoTier2');


/**
 * The mask of precision field.
 * @private
 */
goog.i18n.currency.PRECISION_MASK_ = 0x07;


/**
 * Whether the currency sign should be positioned after the number.
 * @private
 */
goog.i18n.currency.POSITION_FLAG_ = 0x10;


/**
 * Whether a space should be inserted between the number and currency sign.
 * @private
 */
goog.i18n.currency.SPACE_FLAG_ = 0x20;


/**
 * Whether tier2 was enabled already by calling addTier2Support().
 * @private
 */
goog.i18n.currency.tier2Enabled_ = false;


/**
 * Tests if currency is available.
 *
 * Note: If the currency is not available it might be in the tier2 currency set:
 * {@link goog.i18n.currency.CurrencyInfoTier2}. If that is the case call
 * {@link goog.i18n.currency.addTier2Support} before calling any other function
 * in this namespace.
 *
 * @param {string} currencyCode Currency code to tested.
 * @return {boolean} If the currency is available.
 */
goog.i18n.currency.isAvailable = function(currencyCode) {
  'use strict';
  return currencyCode in goog.i18n.currency.CurrencyInfo;
};

/**
 * This function will add tier2 currency support. Be default, only tier1
 * (most popular currencies) are supported. If an application really needs
 * to support some of the rarely used currencies, it should call this function
 * before any other functions in this namespace.
 */
goog.i18n.currency.addTier2Support = function() {
  'use strict';
  // Protection from executing this these again and again.
  if (!goog.i18n.currency.tier2Enabled_) {
    for (const key in goog.i18n.currency.CurrencyInfoTier2) {
      goog.i18n.currency.CurrencyInfo[key] =
          goog.i18n.currency.CurrencyInfoTier2[key];
    }
    goog.i18n.currency.tier2Enabled_ = true;
  }
};


/**
 * Deprecated.
 * Global currency pattern always uses ISO-4217 currency code as prefix. Local
 * currency sign is added if it is different from currency code. Each currency
 * is unique in this form. The negative side is that ISO code looks weird in
 * some countries as people normally do not use it. Local currency sign
 * alleviates the problem, but also makes it a little verbose.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Global currency pattern string for given currency.
 * @deprecated Format numbers using {@link goog.i18n.NumberFormat} with
 *   {@link goog.i18n.NumberFormat.Format.CURRENCY} and
 *   {@link goog.i18n.NumberFormat.CurrencyStyle.GLOBAL}
 */
goog.i18n.currency.getGlobalCurrencyPattern = function(currencyCode) {
  'use strict';
  const info = goog.i18n.currency.CurrencyInfo[currencyCode];
  const patternNum = info[0];
  if (currencyCode == info[1]) {
    return goog.i18n.currency.getCurrencyPattern_(patternNum, info[1]);
  }
  return currencyCode + ' ' +
      goog.i18n.currency.getCurrencyPattern_(patternNum, info[1]);
};


/**
 * Return global currency sign string for those applications
 * that want to handle currency sign themselves.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Global currency sign for given currency.
 */
goog.i18n.currency.getGlobalCurrencySign = function(currencyCode) {
  'use strict';
  const info = goog.i18n.currency.CurrencyInfo[currencyCode];
  return (currencyCode == info[1]) ? currencyCode :
                                     currencyCode + ' ' + info[1];
};


/**
 * Return global currency sign string for those applications
 * that want to handle currency sign themselves.
 *
 * This function does not throw an exception if there is no data for the
 * currency. Instead, it falls back to the ISO code.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Global currency sign for given currency.
 */
goog.i18n.currency.getGlobalCurrencySignWithFallback = function(currencyCode) {
  'use strict';
  var info = goog.i18n.currency.CurrencyInfo[currencyCode];
  if (!info) {
    return currencyCode;
  }
  return (currencyCode == info[1]) ? currencyCode :
                                     currencyCode + ' ' + info[1];
};


/**
 * Deprecated.
 * Local currency pattern is the most frequently used pattern in currency's
 * native region. It does not care about how it is distinguished from other
 * currencies.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Local currency pattern string for given currency.
 * @deprecated Format numbers using {@link goog.i18n.NumberFormat} with
 *   {@link goog.i18n.NumberFormat.Format.CURRENCY} and
 *   {@link goog.i18n.NumberFormat.CurrencyStyle.LOCAL}
 */
goog.i18n.currency.getLocalCurrencyPattern = function(currencyCode) {
  'use strict';
  const info = goog.i18n.currency.CurrencyInfo[currencyCode];
  return goog.i18n.currency.getCurrencyPattern_(info[0], info[1]);
};


/**
 * Returns local currency sign string for those applications that need to
 * handle currency sign separately.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Local currency sign for given currency.
 */
goog.i18n.currency.getLocalCurrencySign = function(currencyCode) {
  'use strict';
  return goog.i18n.currency.CurrencyInfo[currencyCode][1];
};


/**
 * Returns local currency sign string for those applications that need to
 * handle currency sign separately.
 *
 * This function does not throw an exception if there is no data for the
 * currency. Instead, it falls back to the ISO code.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Local currency sign for given currency.
 */
goog.i18n.currency.getLocalCurrencySignWithFallback = function(currencyCode) {
  'use strict';
  if (currencyCode in goog.i18n.currency.CurrencyInfo) {
    return goog.i18n.currency.CurrencyInfo[currencyCode][1];
  } else {
    return currencyCode;
  }
};


/**
 * Deprecated.
 * Portable currency pattern is a compromise between local and global. It is
 * not a mere blend or mid-way between the two. Currency sign is chosen so that
 * it looks familiar to native users. It also has enough information to
 * distinguish itself from other popular currencies in its native region.
 * In this pattern, currency sign symbols that has availability problem in
 * popular fonts are also avoided.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Portable currency pattern string for given currency.
 * @deprecated Format numbers using {@link goog.i18n.NumberFormat} with
 *   {@link goog.i18n.NumberFormat.Format.CURRENCY} and
 *   {@link goog.i18n.NumberFormat.CurrencyStyle.PORTABLE}
 */
goog.i18n.currency.getPortableCurrencyPattern = function(currencyCode) {
  'use strict';
  const info = goog.i18n.currency.CurrencyInfo[currencyCode];
  return goog.i18n.currency.getCurrencyPattern_(info[0], info[2]);
};


/**
 * Return portable currency sign string for those applications that need to
 * handle currency sign themselves.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Portable currency sign for given currency.
 */
goog.i18n.currency.getPortableCurrencySign = function(currencyCode) {
  'use strict';
  return goog.i18n.currency.CurrencyInfo[currencyCode][2];
};


/**
 * Returns whether the string represents a valid ISO-4217 currency code.
 *
 * @param {string} currencyCode String to check.
 * @return {boolean} Whether currencyCode is a 3-letter currency code.
 */
goog.i18n.currency.isValid = function(currencyCode) {
  'use strict';
  if (!currencyCode || currencyCode.length !== 3) {
    return false;
  }
  for (let i = 0; i < 3; i++) {
    const c = currencyCode[i];
    if (c < 'A' || (c > 'Z' && c < 'a') || c > 'z') {
      return false;
    }
  }
  return true;
};


/**
 * Return portable currency sign string for those applications that need to
 * handle currency sign themselves.
 *
 * This function does not throw an exception if there is no data for the
 * currency. Instead, it falls back to the ISO code.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {string} Portable currency sign for given currency.
 */
goog.i18n.currency.getPortableCurrencySignWithFallback = function(
    currencyCode) {
  'use strict';
  if (currencyCode in goog.i18n.currency.CurrencyInfo) {
    return goog.i18n.currency.CurrencyInfo[currencyCode][2];
  } else {
    return currencyCode;
  }
};


/**
 * This function returns the default currency sign's position. Some applications
 * may want to handle currency sign and currency amount separately. This
 * function can be used in such situations to correctly position the currency
 * sign relative to the amount.
 *
 * Use {@link goog.i18n.NumberFormat#isCurrencyCodeBeforeValue} for a locale
 * aware version of this API (recommended). isPrefixSignPosition() returns the
 * default currency sign's position in the currency's default locale (e.g. 'en'
 * for 'USD'), but most commonly the position is needed for the locale in which
 * the number is going to be displayed. For example, in 'fr' 10.10 USD would be
 * displayed as '10,10 $'.
 *
 * @param {string} currencyCode ISO-4217 3-letter currency code.
 * @return {boolean} true if currency should be positioned before amount field.
 */
goog.i18n.currency.isPrefixSignPosition = function(currencyCode) {
  'use strict';
  return (goog.i18n.currency.CurrencyInfo[currencyCode][0] &
          goog.i18n.currency.POSITION_FLAG_) == 0;
};


/**
 * This function constructs the currency pattern. Currency sign is provided. The
 * pattern information is encoded in patternNum.
 *
 * @param {number} patternNum Encoded pattern number that has
 *     currency pattern information.
 * @param {string} sign The currency sign that will be used in pattern.
 * @return {string} currency pattern string.
 * @private
 */
goog.i18n.currency.getCurrencyPattern_ = function(patternNum, sign) {
  'use strict';
  const strParts = ['#,##0'];
  const precision = patternNum & goog.i18n.currency.PRECISION_MASK_;
  if (precision > 0) {
    strParts.push('.');
    for (let i = 0; i < precision; i++) {
      strParts.push('0');
    }
  }
  if ((patternNum & goog.i18n.currency.POSITION_FLAG_) == 0) {
    strParts.unshift(
        (patternNum & goog.i18n.currency.SPACE_FLAG_) ? "' " : "'");
    strParts.unshift(sign);
    strParts.unshift("'");
  } else {
    strParts.push(
        (patternNum & goog.i18n.currency.SPACE_FLAG_) ? " '" : "'", sign, "'");
  }
  return strParts.join('');
};


/**
 * Modify currency pattern string by adjusting precision for given currency.
 * Standard currency pattern will have 2 digit after decimal point.
 * Examples:
 *   $#,##0.00 ->  $#,##0    (precision == 0)
 *   $#,##0.00 ->  $#,##0.0  (precision == 1)
 *   $#,##0.00 ->  $#,##0.000  (precision == 3)
 *
 * @param {string} pattern currency pattern string.
 * @param {string} currencyCode 3-letter currency code.
 * @return {string} modified currency pattern string.
 */
goog.i18n.currency.adjustPrecision = function(pattern, currencyCode) {
  'use strict';
  const strParts = ['0'];
  const info = goog.i18n.currency.CurrencyInfo[currencyCode];
  if (!info) {
    // If the currency code is unknown, do not modify the pattern.
    return pattern;
  }
  const precision = info[0] & goog.i18n.currency.PRECISION_MASK_;
  if (precision > 0) {
    strParts.push('.');
    for (let i = 0; i < precision; i++) {
      strParts.push('0');
    }
  }
  return pattern.replace(/0.00/g, strParts.join(''));
};


/**
 * Tier 1 currency information.
 *
 * Format of the info array:
 *     0. {number} the sum of "decimal precision", the "space" bit, and the
 *        "currency sign last" bit.
 *     1. {string} The global currency sign. See `getGlobalCurrencySign`.
 *     2. {string} The portable currency sign. See `getPortableCurrencySign`.
 *
 * "Decimal precision" is an integer [0..7]; the count of digits to display past
 * the decimal point.
 *
 * "Space" bit mask = 32; whether a space should be inserted between the
 * currency sign and number.
 *
 * "Currency sign last" bit mask = 16; whether the currency sign should be
 * positioned after the number.
 *
 * Examples for info[0]:
 *     0: no precision (0), currency sign first (0), no space (0)
 *     2: two decimals precision (2), currency sign first (0), no space (0)
 *     18: two decimals precision (2), currency sign last (16), no space (0)
 *     50: two decimals precision (2), currency sign last (16), space (32)
 *
 * It's not recommended to read this data directly. Format numbers using
 * {@link goog.i18n.NumberFormat} with
 * {@link goog.i18n.NumberFormat.Format.CURRENCY} instead.
 *
 * @const {!Object<!Array<?>>}
 */
goog.i18n.currency.CurrencyInfo = {
  'AED': [2, 'dh', '\u062f.\u0625.'],
  'ALL': [0, 'Lek', 'Lek'],
  'AUD': [2, '$', 'AU$'],
  'BDT': [2, '\u09F3', 'Tk'],
  'BGN': [2, 'lev', 'lev'],
  'BRL': [2, 'R$', 'R$'],
  'CAD': [2, '$', 'C$'],
  'CDF': [2, 'FrCD', 'CDF'],
  'CHF': [2, 'CHF', 'CHF'],
  'CLP': [0, '$', 'CL$'],
  'CNY': [2, '¥', 'RMB¥'],
  'COP': [32, '$', 'COL$'],
  'CRC': [0, '\u20a1', 'CR\u20a1'],
  'CZK': [50, 'K\u010d', 'K\u010d'],
  'DKK': [50, 'kr.', 'kr.'],
  'DOP': [2, 'RD$', 'RD$'],
  'EGP': [2, '£', 'LE'],
  'ETB': [2, 'Birr', 'Birr'],
  'EUR': [2, '€', '€'],
  'GBP': [2, '£', 'GB£'],
  'HKD': [2, '$', 'HK$'],
  'HRK': [2, 'kn', 'kn'],
  'HUF': [34, 'Ft', 'Ft'],
  'IDR': [0, 'Rp', 'Rp'],
  'ILS': [34, '\u20AA', 'IL\u20AA'],
  'INR': [2, '\u20B9', 'Rs'],
  'IRR': [0, 'Rial', 'IRR'],
  'ISK': [0, 'kr', 'kr'],
  'JMD': [2, '$', 'JA$'],
  'JPY': [0, '¥', 'JP¥'],
  'KRW': [0, '\u20A9', 'KR₩'],
  'LKR': [2, 'Rs', 'SLRs'],
  'LTL': [2, 'Lt', 'Lt'],
  'MNT': [0, '\u20AE', 'MN₮'],
  'MVR': [2, 'Rf', 'MVR'],
  'MXN': [2, '$', 'Mex$'],
  'MYR': [2, 'RM', 'RM'],
  'NOK': [50, 'kr', 'NOkr'],
  'PAB': [2, 'B/.', 'B/.'],
  'PEN': [2, 'S/.', 'S/.'],
  'PHP': [2, '\u20B1', 'PHP'],
  'PKR': [0, 'Rs', 'PKRs.'],
  'PLN': [50, 'z\u0142', 'z\u0142'],
  'RON': [2, 'RON', 'RON'],
  'RSD': [0, 'din', 'RSD'],
  'RUB': [50, '\u20bd', 'RUB'],
  'SAR': [2, 'Rial', 'Rial'],
  'SEK': [50, 'kr', 'kr'],
  'SGD': [2, '$', 'S$'],
  'THB': [2, '\u0e3f', 'THB'],
  'TRY': [2, '₺', 'TRY'],
  'TWD': [2, '$', 'NT$'],
  'TZS': [0, 'TSh', 'TSh'],
  'UAH': [2, 'грн.', 'UAH'],
  'USD': [2, '$', 'US$'],
  'UYU': [2, '$', '$U'],
  'VND': [48, '\u20AB', 'VN\u20AB'],
  'YER': [0, 'Rial', 'Rial'],
  'ZAR': [2, 'R', 'ZAR']
};


/**
 * Tier 2 currency information.
 *
 * It's not recommended to read this data directly. Format numbers using
 * {@link goog.i18n.NumberFormat} with
 * {@link goog.i18n.NumberFormat.Format.CURRENCY} instead.
 *
 * @const {!Object<!Array<?>>}
 */
goog.i18n.currency.CurrencyInfoTier2 = {
  'AFN': [48, 'Af.', 'AFN'],
  'AMD': [32, 'Dram', 'dram'],
  'ANG': [2, 'NAf.', 'ANG'],
  'AOA': [2, 'Kz', 'Kz'],
  'ARS': [34, '$', 'AR$'],
  'AWG': [2, 'Afl.', 'Afl.'],
  'AZN': [34, '\u20bc', 'AZN'],
  'BAM': [2, 'KM', 'KM'],
  'BBD': [2, '$', 'Bds$'],
  'BHD': [3, 'din', 'din'],
  'BIF': [0, 'FBu', 'FBu'],
  'BMD': [2, '$', 'BD$'],
  'BND': [2, '$', 'B$'],
  'BOB': [2, 'Bs', 'Bs'],
  'BSD': [2, '$', 'BS$'],
  'BTN': [2, 'Nu.', 'Nu.'],
  'BWP': [2, 'P', 'pula'],
  'BYN': [50, '\u0440.', 'BYN'],
  'BYR': [48, '\u0440.', 'BYR'],
  'BZD': [2, '$', 'BZ$'],
  'CLF': [4, 'UF', 'CLF'],
  'CNH': [2, '¥', 'RMB¥'],
  'CUC': [1, '$', 'CUC$'],
  'CUP': [2, '$', 'CU$'],
  'CVE': [2, 'CVE', 'Esc'],
  'DJF': [0, 'Fdj', 'Fdj'],
  'DZD': [2, 'din', 'din'],
  'ERN': [2, 'Nfk', 'Nfk'],
  'FJD': [2, '$', 'FJ$'],
  'FKP': [2, '£', 'FK£'],
  'GEL': [2, 'GEL', 'GEL'],
  'GHS': [2, 'GHS', 'GHS'],
  'GIP': [2, '£', 'GI£'],
  'GMD': [2, 'GMD', 'GMD'],
  'GNF': [0, 'FG', 'FG'],
  'GTQ': [2, 'Q', 'GTQ'],
  'GYD': [0, '$', 'GY$'],
  'HNL': [2, 'L', 'HNL'],
  'HTG': [2, 'HTG', 'HTG'],
  'IQD': [0, 'din', 'IQD'],
  'JOD': [3, 'din', 'JOD'],
  'KES': [2, 'Ksh', 'Ksh'],
  'KGS': [2, 'KGS', 'KGS'],
  'KHR': [2, 'Riel', 'KHR'],
  'KMF': [0, 'CF', 'KMF'],
  'KPW': [0, '\u20A9KP', 'KPW'],
  'KWD': [3, 'din', 'KWD'],
  'KYD': [2, '$', 'KY$'],
  'KZT': [2, '\u20B8', 'KZT'],
  'LAK': [0, '\u20AD', '\u20AD'],
  'LBP': [0, 'L£', 'LBP'],
  'LRD': [2, '$', 'L$'],
  'LSL': [2, 'LSL', 'LSL'],
  'LYD': [3, 'din', 'LD'],
  'MAD': [2, 'dh', 'MAD'],
  'MDL': [2, 'MDL', 'MDL'],
  'MGA': [0, 'Ar', 'MGA'],
  'MKD': [2, 'din', 'MKD'],
  'MMK': [0, 'K', 'MMK'],
  'MOP': [2, 'MOP', 'MOP$'],
  'MRO': [0, 'MRO', 'MRO'],
  'MUR': [0, 'MURs', 'MURs'],
  'MWK': [2, 'MWK', 'MWK'],
  'MZN': [2, 'MTn', 'MTn'],
  'NAD': [2, '$', 'N$'],
  'NGN': [2, '\u20A6', 'NG\u20A6'],
  'NIO': [2, 'C$', 'C$'],
  'NPR': [2, 'Rs', 'NPRs'],
  'NZD': [2, '$', 'NZ$'],
  'OMR': [3, 'Rial', 'OMR'],
  'PGK': [2, 'PGK', 'PGK'],
  'PYG': [16, 'Gs.', 'PYG'],
  'QAR': [2, 'Rial', 'QR'],
  'RWF': [0, 'RF', 'RF'],
  'SBD': [2, '$', 'SI$'],
  'SCR': [2, 'SCR', 'SCR'],
  'SDG': [2, 'SDG', 'SDG'],
  'SHP': [2, '£', 'SH£'],
  'SLL': [0, 'SLL', 'SLL'],
  'SOS': [0, 'SOS', 'SOS'],
  'SRD': [2, '$', 'SR$'],
  'SSP': [2, '£', 'SSP'],
  'STD': [0, 'Db', 'Db'],
  'SYP': [0, '£', 'SY£'],
  'SZL': [2, 'SZL', 'SZL'],
  'TJS': [2, 'Som', 'TJS'],
  'TMT': [50, 'm', 'TMT'],
  'TND': [3, 'din', 'DT'],
  'TOP': [2, 'T$', 'T$'],
  'TTD': [2, '$', 'TT$'],
  'UGX': [0, 'UGX', 'UGX'],
  'UZS': [0, 'so\u02bcm', 'UZS'],
  'VEF': [2, 'Bs', 'Bs'],
  'VES': [2, 'Bs', 'Bs'],
  'VUV': [0, 'VUV', 'VUV'],
  'WST': [2, 'WST', 'WST'],
  'XAF': [0, 'FCFA', 'FCFA'],
  'XCD': [2, '$', 'EC$'],
  'XOF': [0, 'CFA', 'CFA'],
  'XPF': [48, 'FCFP', 'FCFP'],
  'ZMW': [0, 'ZMW', 'ZMW'],
  'ZWD': [0, '$', 'Z$']
};

//third_party/javascript/closure/i18n/numberformatsymbols.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Number formatting symbols.
 *
 * File generated from CLDR ver. 39
 * MOE:begin_intracomment_strip
 * This file is generated by
 *   //depot/google3/java/com/google/i18n/tools/generators/locale:locale
 *
 * See {@link go/js-locale-data-update} for details.
 *
 * To fix bugs here, you should follow the procedure detailed at
 * go/i-think-locale-data-is-wrong instead of sending a CL for this file.
 * MOE:end_intracomment_strip
 *
 * To reduce the file size (which may cause issues in some JS
 * developing environments), this file will only contain locales
 * that are frequently used by web applications. This is defined as
 * proto/closure_locales_data.txt and will change (most likely addition)
 * over time.  Rest of the data can be found in another file named
 * "numberformatsymbolsext.js", which will be generated at
 * the same time together with this file.
 *
 * @suppress {const,useOfGoogProvide}
 */

// clang-format off

goog.provide('goog.i18n.NumberFormatSymbols');
goog.provide('goog.i18n.NumberFormatSymbols_af');
goog.provide('goog.i18n.NumberFormatSymbols_am');
goog.provide('goog.i18n.NumberFormatSymbols_ar');
goog.provide('goog.i18n.NumberFormatSymbols_ar_DZ');
goog.provide('goog.i18n.NumberFormatSymbols_ar_EG');
goog.provide('goog.i18n.NumberFormatSymbols_ar_EG_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_az');
goog.provide('goog.i18n.NumberFormatSymbols_be');
goog.provide('goog.i18n.NumberFormatSymbols_bg');
goog.provide('goog.i18n.NumberFormatSymbols_bn');
goog.provide('goog.i18n.NumberFormatSymbols_bn_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_br');
goog.provide('goog.i18n.NumberFormatSymbols_bs');
goog.provide('goog.i18n.NumberFormatSymbols_ca');
goog.provide('goog.i18n.NumberFormatSymbols_chr');
goog.provide('goog.i18n.NumberFormatSymbols_cs');
goog.provide('goog.i18n.NumberFormatSymbols_cy');
goog.provide('goog.i18n.NumberFormatSymbols_da');
goog.provide('goog.i18n.NumberFormatSymbols_de');
goog.provide('goog.i18n.NumberFormatSymbols_de_AT');
goog.provide('goog.i18n.NumberFormatSymbols_de_CH');
goog.provide('goog.i18n.NumberFormatSymbols_el');
goog.provide('goog.i18n.NumberFormatSymbols_en');
goog.provide('goog.i18n.NumberFormatSymbols_en_AU');
goog.provide('goog.i18n.NumberFormatSymbols_en_CA');
goog.provide('goog.i18n.NumberFormatSymbols_en_GB');
goog.provide('goog.i18n.NumberFormatSymbols_en_IE');
goog.provide('goog.i18n.NumberFormatSymbols_en_IN');
goog.provide('goog.i18n.NumberFormatSymbols_en_SG');
goog.provide('goog.i18n.NumberFormatSymbols_en_US');
goog.provide('goog.i18n.NumberFormatSymbols_en_ZA');
goog.provide('goog.i18n.NumberFormatSymbols_es');
goog.provide('goog.i18n.NumberFormatSymbols_es_419');
goog.provide('goog.i18n.NumberFormatSymbols_es_ES');
goog.provide('goog.i18n.NumberFormatSymbols_es_MX');
goog.provide('goog.i18n.NumberFormatSymbols_es_US');
goog.provide('goog.i18n.NumberFormatSymbols_et');
goog.provide('goog.i18n.NumberFormatSymbols_eu');
goog.provide('goog.i18n.NumberFormatSymbols_fa');
goog.provide('goog.i18n.NumberFormatSymbols_fa_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_fi');
goog.provide('goog.i18n.NumberFormatSymbols_fil');
goog.provide('goog.i18n.NumberFormatSymbols_fr');
goog.provide('goog.i18n.NumberFormatSymbols_fr_CA');
goog.provide('goog.i18n.NumberFormatSymbols_ga');
goog.provide('goog.i18n.NumberFormatSymbols_gl');
goog.provide('goog.i18n.NumberFormatSymbols_gsw');
goog.provide('goog.i18n.NumberFormatSymbols_gu');
goog.provide('goog.i18n.NumberFormatSymbols_haw');
goog.provide('goog.i18n.NumberFormatSymbols_he');
goog.provide('goog.i18n.NumberFormatSymbols_hi');
goog.provide('goog.i18n.NumberFormatSymbols_hr');
goog.provide('goog.i18n.NumberFormatSymbols_hu');
goog.provide('goog.i18n.NumberFormatSymbols_hy');
goog.provide('goog.i18n.NumberFormatSymbols_id');
goog.provide('goog.i18n.NumberFormatSymbols_in');
goog.provide('goog.i18n.NumberFormatSymbols_is');
goog.provide('goog.i18n.NumberFormatSymbols_it');
goog.provide('goog.i18n.NumberFormatSymbols_iw');
goog.provide('goog.i18n.NumberFormatSymbols_ja');
goog.provide('goog.i18n.NumberFormatSymbols_ka');
goog.provide('goog.i18n.NumberFormatSymbols_kk');
goog.provide('goog.i18n.NumberFormatSymbols_km');
goog.provide('goog.i18n.NumberFormatSymbols_kn');
goog.provide('goog.i18n.NumberFormatSymbols_ko');
goog.provide('goog.i18n.NumberFormatSymbols_ky');
goog.provide('goog.i18n.NumberFormatSymbols_ln');
goog.provide('goog.i18n.NumberFormatSymbols_lo');
goog.provide('goog.i18n.NumberFormatSymbols_lt');
goog.provide('goog.i18n.NumberFormatSymbols_lv');
goog.provide('goog.i18n.NumberFormatSymbols_mk');
goog.provide('goog.i18n.NumberFormatSymbols_ml');
goog.provide('goog.i18n.NumberFormatSymbols_mn');
goog.provide('goog.i18n.NumberFormatSymbols_mo');
goog.provide('goog.i18n.NumberFormatSymbols_mr');
goog.provide('goog.i18n.NumberFormatSymbols_mr_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_ms');
goog.provide('goog.i18n.NumberFormatSymbols_mt');
goog.provide('goog.i18n.NumberFormatSymbols_my');
goog.provide('goog.i18n.NumberFormatSymbols_my_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_nb');
goog.provide('goog.i18n.NumberFormatSymbols_ne');
goog.provide('goog.i18n.NumberFormatSymbols_ne_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_nl');
goog.provide('goog.i18n.NumberFormatSymbols_no');
goog.provide('goog.i18n.NumberFormatSymbols_no_NO');
goog.provide('goog.i18n.NumberFormatSymbols_or');
goog.provide('goog.i18n.NumberFormatSymbols_pa');
goog.provide('goog.i18n.NumberFormatSymbols_pl');
goog.provide('goog.i18n.NumberFormatSymbols_pt');
goog.provide('goog.i18n.NumberFormatSymbols_pt_BR');
goog.provide('goog.i18n.NumberFormatSymbols_pt_PT');
goog.provide('goog.i18n.NumberFormatSymbols_ro');
goog.provide('goog.i18n.NumberFormatSymbols_ru');
goog.provide('goog.i18n.NumberFormatSymbols_sh');
goog.provide('goog.i18n.NumberFormatSymbols_si');
goog.provide('goog.i18n.NumberFormatSymbols_sk');
goog.provide('goog.i18n.NumberFormatSymbols_sl');
goog.provide('goog.i18n.NumberFormatSymbols_sq');
goog.provide('goog.i18n.NumberFormatSymbols_sr');
goog.provide('goog.i18n.NumberFormatSymbols_sr_Latn');
goog.provide('goog.i18n.NumberFormatSymbols_sv');
goog.provide('goog.i18n.NumberFormatSymbols_sw');
goog.provide('goog.i18n.NumberFormatSymbols_ta');
goog.provide('goog.i18n.NumberFormatSymbols_te');
goog.provide('goog.i18n.NumberFormatSymbols_th');
goog.provide('goog.i18n.NumberFormatSymbols_tl');
goog.provide('goog.i18n.NumberFormatSymbols_tr');
goog.provide('goog.i18n.NumberFormatSymbols_u_nu_latn');
goog.provide('goog.i18n.NumberFormatSymbols_uk');
goog.provide('goog.i18n.NumberFormatSymbols_ur');
goog.provide('goog.i18n.NumberFormatSymbols_uz');
goog.provide('goog.i18n.NumberFormatSymbols_vi');
goog.provide('goog.i18n.NumberFormatSymbols_zh');
goog.provide('goog.i18n.NumberFormatSymbols_zh_CN');
goog.provide('goog.i18n.NumberFormatSymbols_zh_HK');
goog.provide('goog.i18n.NumberFormatSymbols_zh_TW');
goog.provide('goog.i18n.NumberFormatSymbols_zu');


/**
 * Number formatting symbols for locale af.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_af = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'ZAR'
};


/**
 * Number formatting symbols for locale am.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_am = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'ETB'
};


/**
 * Number formatting symbols for locale ar.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ar = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '‎%‎',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ليس رقمًا',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'EGP'
};


/**
 * Number formatting symbols for locale ar_DZ.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ar_DZ = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '‎%‎',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ليس رقمًا',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'DZD'
};


/**
 * Number formatting symbols for locale ar_EG.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ar_EG = {
  DECIMAL_SEP: '٫',
  GROUP_SEP: '٬',
  PERCENT: '٪؜',
  ZERO_DIGIT: '٠',
  PLUS_SIGN: '؜+',
  MINUS_SIGN: '؜-',
  EXP_SYMBOL: 'اس',
  PERMILL: '؉',
  INFINITY: '∞',
  NAN: 'ليس رقم',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EGP'
};


/**
 * Number formatting symbols for locale ar_EG_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ar_EG_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '‎%‎',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ليس رقمًا',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'EGP'
};


/**
 * Number formatting symbols for locale az.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_az = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'AZN'
};


/**
 * Number formatting symbols for locale be.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_be = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'BYN'
};


/**
 * Number formatting symbols for locale bg.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_bg = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '0.00 ¤',
  DEF_CURRENCY_CODE: 'BGN'
};


/**
 * Number formatting symbols for locale bn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_bn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '০',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##,##0.00¤',
  DEF_CURRENCY_CODE: 'BDT'
};


/**
 * Number formatting symbols for locale bn_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_bn_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '#,##,##0.00¤',
  DEF_CURRENCY_CODE: 'BDT'
};


/**
 * Number formatting symbols for locale br.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_br = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale bs.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_bs = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'BAM'
};


/**
 * Number formatting symbols for locale ca.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ca = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale chr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_chr = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'USD'
};


/**
 * Number formatting symbols for locale cs.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_cs = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'CZK'
};


/**
 * Number formatting symbols for locale cy.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_cy = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'GBP'
};


/**
 * Number formatting symbols for locale da.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_da = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'DKK'
};


/**
 * Number formatting symbols for locale de.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_de = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale de_AT.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_de_AT = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale de_CH.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_de_CH = {
  DECIMAL_SEP: '.',
  GROUP_SEP: '’',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00;¤-#,##0.00',
  DEF_CURRENCY_CODE: 'CHF'
};


/**
 * Number formatting symbols for locale el.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_el = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'e',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale en.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'USD'
};


/**
 * Number formatting symbols for locale en_AU.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_AU = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'e',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'AUD'
};


/**
 * Number formatting symbols for locale en_CA.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_CA = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'e',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'CAD'
};


/**
 * Number formatting symbols for locale en_GB.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_GB = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'GBP'
};


/**
 * Number formatting symbols for locale en_IE.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_IE = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale en_IN.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_IN = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤#,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale en_SG.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_SG = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'SGD'
};


/**
 * Number formatting symbols for locale en_US.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_US = goog.i18n.NumberFormatSymbols_en;


/**
 * Number formatting symbols for locale en_ZA.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_en_ZA = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'ZAR'
};


/**
 * Number formatting symbols for locale es.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_es = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale es_419.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_es_419 = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'MXN'
};


/**
 * Number formatting symbols for locale es_ES.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_es_ES = goog.i18n.NumberFormatSymbols_es;


/**
 * Number formatting symbols for locale es_MX.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_es_MX = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'MXN'
};


/**
 * Number formatting symbols for locale es_US.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_es_US = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'USD'
};


/**
 * Number formatting symbols for locale et.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_et = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: '×10^',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale eu.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_eu = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '% #,##0',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale fa.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fa = {
  DECIMAL_SEP: '٫',
  GROUP_SEP: '٬',
  PERCENT: '٪',
  ZERO_DIGIT: '۰',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎−',
  EXP_SYMBOL: '×۱۰^',
  PERMILL: '؉',
  INFINITY: '∞',
  NAN: 'ناعدد',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '‎¤#,##0.00',
  DEF_CURRENCY_CODE: 'IRR'
};


/**
 * Number formatting symbols for locale fa_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fa_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ناعدد',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '‎¤ #,##0.00',
  DEF_CURRENCY_CODE: 'IRR'
};


/**
 * Number formatting symbols for locale fi.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fi = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'epäluku',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale fil.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fil = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'PHP'
};


/**
 * Number formatting symbols for locale fr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fr = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale fr_CA.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_fr_CA = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'CAD'
};


/**
 * Number formatting symbols for locale ga.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ga = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'Nuimh',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale gl.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_gl = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale gsw.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_gsw = {
  DECIMAL_SEP: '.',
  GROUP_SEP: '’',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'CHF'
};


/**
 * Number formatting symbols for locale gu.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_gu = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '[#E0]',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤#,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale haw.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_haw = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'USD'
};


/**
 * Number formatting symbols for locale he.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_he = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '‏#,##0.00 ¤;‏-#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'ILS'
};


/**
 * Number formatting symbols for locale hi.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_hi = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '[#E0]',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤#,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale hr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_hr = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'HRK'
};


/**
 * Number formatting symbols for locale hu.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_hu = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'HUF'
};


/**
 * Number formatting symbols for locale hy.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_hy = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ՈչԹ',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'AMD'
};


/**
 * Number formatting symbols for locale id.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_id = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'IDR'
};


/**
 * Number formatting symbols for locale in.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_in = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'IDR'
};


/**
 * Number formatting symbols for locale is.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_is = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'ISK'
};


/**
 * Number formatting symbols for locale it.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_it = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale iw.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_iw = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '‏#,##0.00 ¤;‏-#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'ILS'
};


/**
 * Number formatting symbols for locale ja.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ja = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'JPY'
};


/**
 * Number formatting symbols for locale ka.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ka = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'არ არის რიცხვი',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'GEL'
};


/**
 * Number formatting symbols for locale kk.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_kk = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'сан емес',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'KZT'
};


/**
 * Number formatting symbols for locale km.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_km = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00¤',
  DEF_CURRENCY_CODE: 'KHR'
};


/**
 * Number formatting symbols for locale kn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_kn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale ko.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ko = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'KRW'
};


/**
 * Number formatting symbols for locale ky.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ky = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'сан эмес',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'KGS'
};


/**
 * Number formatting symbols for locale ln.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ln = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'CDF'
};


/**
 * Number formatting symbols for locale lo.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_lo = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ບໍ່​ແມ່ນ​ໂຕ​ເລກ',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00;¤-#,##0.00',
  DEF_CURRENCY_CODE: 'LAK'
};


/**
 * Number formatting symbols for locale lt.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_lt = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: '×10^',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale lv.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_lv = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NS',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale mk.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mk = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'MKD'
};


/**
 * Number formatting symbols for locale ml.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ml = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale mn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'MNT'
};


/**
 * Number formatting symbols for locale mo.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mo = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'MDL'
};


/**
 * Number formatting symbols for locale mr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mr = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '०',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '[#E0]',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale mr_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mr_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '[#E0]',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale ms.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ms = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'MYR'
};


/**
 * Number formatting symbols for locale mt.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_mt = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale my.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_my = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '၀',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ဂဏန်းမဟုတ်သော',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'MMK'
};


/**
 * Number formatting symbols for locale my_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_my_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'ဂဏန်းမဟုတ်သော',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'MMK'
};


/**
 * Number formatting symbols for locale nb.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_nb = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'NOK'
};


/**
 * Number formatting symbols for locale ne.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ne = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '०',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤ #,##,##0.00',
  DEF_CURRENCY_CODE: 'NPR'
};


/**
 * Number formatting symbols for locale ne_u_nu_latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ne_u_nu_latn = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤ #,##,##0.00',
  DEF_CURRENCY_CODE: 'NPR'
};


/**
 * Number formatting symbols for locale nl.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_nl = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00;¤ -#,##0.00',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale no.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_no = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'NOK'
};


/**
 * Number formatting symbols for locale no_NO.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_no_NO = goog.i18n.NumberFormatSymbols_no;


/**
 * Number formatting symbols for locale or.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_or = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale pa.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_pa = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '[#E0]',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤ #,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale pl.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_pl = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'PLN'
};


/**
 * Number formatting symbols for locale pt.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_pt = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'BRL'
};


/**
 * Number formatting symbols for locale pt_BR.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_pt_BR = goog.i18n.NumberFormatSymbols_pt;


/**
 * Number formatting symbols for locale pt_PT.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_pt_PT = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale ro.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ro = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'RON'
};


/**
 * Number formatting symbols for locale ru.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ru = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'не число',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'RUB'
};


/**
 * Number formatting symbols for locale sh.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sh = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'RSD'
};


/**
 * Number formatting symbols for locale si.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_si = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'LKR'
};


/**
 * Number formatting symbols for locale sk.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sk = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'e',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale sl.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sl = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: 'e',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'EUR'
};


/**
 * Number formatting symbols for locale sq.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sq = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'ALL'
};


/**
 * Number formatting symbols for locale sr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sr = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'RSD'
};


/**
 * Number formatting symbols for locale sr_Latn.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sr_Latn = goog.i18n.NumberFormatSymbols_sr;


/**
 * Number formatting symbols for locale sv.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sv = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '−',
  EXP_SYMBOL: '×10^',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0 %',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'SEK'
};


/**
 * Number formatting symbols for locale sw.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_sw = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'TZS'
};


/**
 * Number formatting symbols for locale ta.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ta = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##,##0%',
  CURRENCY_PATTERN: '¤ #,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale te.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_te = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##,##0.00',
  DEF_CURRENCY_CODE: 'INR'
};


/**
 * Number formatting symbols for locale th.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_th = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'THB'
};


/**
 * Number formatting symbols for locale tl.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_tl = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'PHP'
};


/**
 * Number formatting symbols for locale tr.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_tr = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '%#,##0',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'TRY'
};


/**
 * Number formatting symbols for locale uk.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_uk = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'Е',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'UAH'
};


/**
 * Number formatting symbols for locale ur.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_ur = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '‎+',
  MINUS_SIGN: '‎-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤ #,##0.00',
  DEF_CURRENCY_CODE: 'PKR'
};


/**
 * Number formatting symbols for locale uz.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_uz = {
  DECIMAL_SEP: ',',
  GROUP_SEP: ' ',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'son emas',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'UZS'
};


/**
 * Number formatting symbols for locale vi.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_vi = {
  DECIMAL_SEP: ',',
  GROUP_SEP: '.',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '#,##0.00 ¤',
  DEF_CURRENCY_CODE: 'VND'
};


/**
 * Number formatting symbols for locale zh.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_zh = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'CNY'
};


/**
 * Number formatting symbols for locale zh_CN.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_zh_CN = goog.i18n.NumberFormatSymbols_zh;


/**
 * Number formatting symbols for locale zh_HK.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_zh_HK = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: '非數值',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'HKD'
};


/**
 * Number formatting symbols for locale zh_TW.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_zh_TW = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: '非數值',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'TWD'
};


/**
 * Number formatting symbols for locale zu.
 * @enum {string}
 */
goog.i18n.NumberFormatSymbols_zu = {
  DECIMAL_SEP: '.',
  GROUP_SEP: ',',
  PERCENT: '%',
  ZERO_DIGIT: '0',
  PLUS_SIGN: '+',
  MINUS_SIGN: '-',
  EXP_SYMBOL: 'E',
  PERMILL: '‰',
  INFINITY: '∞',
  NAN: 'NaN',
  DECIMAL_PATTERN: '#,##0.###',
  SCIENTIFIC_PATTERN: '#E0',
  PERCENT_PATTERN: '#,##0%',
  CURRENCY_PATTERN: '¤#,##0.00',
  DEF_CURRENCY_CODE: 'ZAR'
};


/**
 * Selected number formatting symbols by locale.
 */
goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en;
goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en;

switch (goog.LOCALE) {
  case 'af':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_af;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_af;
    break;
  case 'am':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_am;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_am;
    break;
  case 'ar':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ar;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ar;
    break;
  case 'ar_DZ':
  case 'ar-DZ':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ar_DZ;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ar_DZ;
    break;
  case 'ar_EG':
  case 'ar-EG':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ar_EG;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ar_EG_u_nu_latn;
    break;
  case 'az':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_az;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_az;
    break;
  case 'be':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_be;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_be;
    break;
  case 'bg':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_bg;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_bg;
    break;
  case 'bn':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_bn;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_bn_u_nu_latn;
    break;
  case 'br':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_br;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_br;
    break;
  case 'bs':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_bs;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_bs;
    break;
  case 'ca':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ca;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ca;
    break;
  case 'chr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_chr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_chr;
    break;
  case 'cs':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_cs;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_cs;
    break;
  case 'cy':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_cy;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_cy;
    break;
  case 'da':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_da;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_da;
    break;
  case 'de':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_de;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_de;
    break;
  case 'de_AT':
  case 'de-AT':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_de_AT;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_de_AT;
    break;
  case 'de_CH':
  case 'de-CH':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_de_CH;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_de_CH;
    break;
  case 'el':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_el;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_el;
    break;
  case 'en':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en;
    break;
  case 'en_AU':
  case 'en-AU':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_AU;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_AU;
    break;
  case 'en_CA':
  case 'en-CA':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_CA;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_CA;
    break;
  case 'en_GB':
  case 'en-GB':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_GB;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_GB;
    break;
  case 'en_IE':
  case 'en-IE':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_IE;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_IE;
    break;
  case 'en_IN':
  case 'en-IN':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_IN;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_IN;
    break;
  case 'en_SG':
  case 'en-SG':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_SG;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_SG;
    break;
  case 'en_US':
  case 'en-US':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_US;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_US;
    break;
  case 'en_ZA':
  case 'en-ZA':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_en_ZA;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_en_ZA;
    break;
  case 'es':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_es;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_es;
    break;
  case 'es_419':
  case 'es-419':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_es_419;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_es_419;
    break;
  case 'es_ES':
  case 'es-ES':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_es_ES;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_es_ES;
    break;
  case 'es_MX':
  case 'es-MX':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_es_MX;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_es_MX;
    break;
  case 'es_US':
  case 'es-US':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_es_US;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_es_US;
    break;
  case 'et':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_et;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_et;
    break;
  case 'eu':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_eu;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_eu;
    break;
  case 'fa':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_fa;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_fa_u_nu_latn;
    break;
  case 'fi':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_fi;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_fi;
    break;
  case 'fil':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_fil;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_fil;
    break;
  case 'fr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_fr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_fr;
    break;
  case 'fr_CA':
  case 'fr-CA':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_fr_CA;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_fr_CA;
    break;
  case 'ga':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ga;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ga;
    break;
  case 'gl':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_gl;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_gl;
    break;
  case 'gsw':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_gsw;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_gsw;
    break;
  case 'gu':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_gu;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_gu;
    break;
  case 'haw':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_haw;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_haw;
    break;
  case 'he':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_he;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_he;
    break;
  case 'hi':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_hi;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_hi;
    break;
  case 'hr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_hr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_hr;
    break;
  case 'hu':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_hu;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_hu;
    break;
  case 'hy':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_hy;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_hy;
    break;
  case 'id':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_id;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_id;
    break;
  case 'in':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_in;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_in;
    break;
  case 'is':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_is;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_is;
    break;
  case 'it':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_it;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_it;
    break;
  case 'iw':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_iw;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_iw;
    break;
  case 'ja':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ja;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ja;
    break;
  case 'ka':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ka;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ka;
    break;
  case 'kk':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_kk;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_kk;
    break;
  case 'km':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_km;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_km;
    break;
  case 'kn':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_kn;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_kn;
    break;
  case 'ko':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ko;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ko;
    break;
  case 'ky':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ky;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ky;
    break;
  case 'ln':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ln;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ln;
    break;
  case 'lo':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_lo;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_lo;
    break;
  case 'lt':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_lt;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_lt;
    break;
  case 'lv':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_lv;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_lv;
    break;
  case 'mk':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_mk;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_mk;
    break;
  case 'ml':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ml;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ml;
    break;
  case 'mn':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_mn;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_mn;
    break;
  case 'mo':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_mo;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_mo;
    break;
  case 'mr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_mr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_mr_u_nu_latn;
    break;
  case 'ms':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ms;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ms;
    break;
  case 'mt':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_mt;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_mt;
    break;
  case 'my':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_my;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_my_u_nu_latn;
    break;
  case 'nb':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_nb;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_nb;
    break;
  case 'ne':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ne;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ne_u_nu_latn;
    break;
  case 'nl':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_nl;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_nl;
    break;
  case 'no':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_no;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_no;
    break;
  case 'no_NO':
  case 'no-NO':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_no_NO;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_no_NO;
    break;
  case 'or':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_or;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_or;
    break;
  case 'pa':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_pa;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_pa;
    break;
  case 'pl':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_pl;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_pl;
    break;
  case 'pt':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_pt;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_pt;
    break;
  case 'pt_BR':
  case 'pt-BR':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_pt_BR;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_pt_BR;
    break;
  case 'pt_PT':
  case 'pt-PT':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_pt_PT;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_pt_PT;
    break;
  case 'ro':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ro;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ro;
    break;
  case 'ru':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ru;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ru;
    break;
  case 'sh':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sh;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sh;
    break;
  case 'si':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_si;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_si;
    break;
  case 'sk':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sk;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sk;
    break;
  case 'sl':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sl;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sl;
    break;
  case 'sq':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sq;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sq;
    break;
  case 'sr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sr;
    break;
  case 'sr_Latn':
  case 'sr-Latn':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sr_Latn;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sr_Latn;
    break;
  case 'sv':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sv;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sv;
    break;
  case 'sw':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_sw;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_sw;
    break;
  case 'ta':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ta;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ta;
    break;
  case 'te':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_te;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_te;
    break;
  case 'th':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_th;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_th;
    break;
  case 'tl':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_tl;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_tl;
    break;
  case 'tr':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_tr;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_tr;
    break;
  case 'uk':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_uk;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_uk;
    break;
  case 'ur':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_ur;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_ur;
    break;
  case 'uz':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_uz;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_uz;
    break;
  case 'vi':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_vi;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_vi;
    break;
  case 'zh':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_zh;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_zh;
    break;
  case 'zh_CN':
  case 'zh-CN':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_zh_CN;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_zh_CN;
    break;
  case 'zh_HK':
  case 'zh-HK':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_zh_HK;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_zh_HK;
    break;
  case 'zh_TW':
  case 'zh-TW':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_zh_TW;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_zh_TW;
    break;
  case 'zu':
    goog.i18n.NumberFormatSymbols = goog.i18n.NumberFormatSymbols_zu;
    goog.i18n.NumberFormatSymbols_u_nu_latn = goog.i18n.NumberFormatSymbols_zu;
    break;
}

//third_party/javascript/closure/i18n/numberformat.js
/**
 * @license
 * Copyright The Closure Library Authors.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Number format/parse library with locale support.
 */


/**
 * Namespace for locale number format functions
 */
goog.provide('goog.i18n.NumberFormat');
goog.provide('goog.i18n.NumberFormat.CurrencyStyle');
goog.provide('goog.i18n.NumberFormat.Format');

goog.require('goog.asserts');
goog.require('goog.i18n.CompactNumberFormatSymbols');
goog.require('goog.i18n.NumberFormatSymbols');
goog.require('goog.i18n.NumberFormatSymbols_u_nu_latn');
goog.require('goog.i18n.currency');
goog.require('goog.math');
goog.require('goog.string');



/**
 * Constructor of NumberFormat.
 * @param {number|string} pattern The number that indicates a predefined
 *     number format pattern.
 * @param {string=} opt_currency Optional international currency
 *     code. This determines the currency code/symbol used in format/parse. If
 *     not given, the currency code for the current locale will be used.
 * @param {number=} opt_currencyStyle currency style, value defined in
 *     goog.i18n.NumberFormat.CurrencyStyle. If not given, the currency style
 *     for the current locale will be used.
 * @param {!Object<string, string>=} opt_symbols Optional number format symbols
 *     map, analogous to goog.i18n.NumberFormatSymbols. If present, this
 *     overrides the symbols from the current locale, such as the percent sign
 *     and minus sign.
 * @constructor
 */
goog.i18n.NumberFormat = function(
    pattern, opt_currency, opt_currencyStyle, opt_symbols) {
  'use strict';
  if (opt_currency && !goog.i18n.currency.isValid(opt_currency)) {
    throw new TypeError('Currency must be valid ISO code');
  }

  /** @const @private {?string} */
  this.intlCurrencyCode_ = opt_currency ? opt_currency.toUpperCase() : null;

  /** @const @private {number} */
  this.currencyStyle_ =
      opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;

  /** @const @private {?Object<string, string>} */
  this.overrideNumberFormatSymbols_ = opt_symbols || null;

  /** @private {number} */
  this.maximumIntegerDigits_ = 40;
  /** @private {number} */
  this.minimumIntegerDigits_ = 1;
  /** @private {number} */
  this.significantDigits_ = 0;  // invariant, <= maximumFractionDigits
  /** @private {number} */
  this.maximumFractionDigits_ = 3;  // invariant, >= minFractionDigits
  /** @private {number} */
  this.minimumFractionDigits_ = 0;
  /** @private {number} */
  this.minExponentDigits_ = 0;
  /** @private {boolean} */
  this.useSignForPositiveExponent_ = false;

  /**
   * Whether to show trailing zeros in the fraction when significantDigits_ is
   * positive.
   * @private {boolean}
   */
  this.showTrailingZeros_ = false;

  /** @private {string} */
  this.positivePrefix_ = '';
  /** @private {string} */
  this.positiveSuffix_ = '';
  /** @private {string} */
  this.negativePrefix_ = this.getNumberFormatSymbols_().MINUS_SIGN;
  /** @private {string} */
  this.negativeSuffix_ = '';

  // The multiplier for use in percent, per mille, etc.
  /** @private {number} */
  this.multiplier_ = 1;

  /**
   * True if the percent/permill sign of the negative pattern is expected.
   * @private {boolean}
   */
  this.negativePercentSignExpected_ = false;

  /**
   * The grouping array is used to store the values of each number group
   * following left of the decimal place. For example, a number group with
   * goog.i18n.NumberFormat('#,##,###') should have [3,2] where 2 is the
   * repeated number group following a fixed number grouping of size 3.
   * @private {!Array<number>}
   */
  this.groupingArray_ = [];

  /** @private {boolean} */
  this.decimalSeparatorAlwaysShown_ = false;
  /** @private {boolean} */
  this.useExponentialNotation_ = false;
  /** @private {goog.i18n.NumberFormat.CompactStyle} */
  this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;

  /**
   * The number to base the formatting on when using compact styles, or null
   * if formatting should not be based on another number.
   * @type {?number}
   * @private
   */
  this.baseFormattingNumber_ = null;

  /** @private {string} */
  this.pattern_;

  if (typeof pattern == 'number') {
    this.applyStandardPattern_(pattern);
  } else {
    this.applyPattern_(pattern);
  }
};


/**
 * Standard number formatting patterns.
 * @enum {number}
 */
goog.i18n.NumberFormat.Format = {
  DECIMAL: 1,
  SCIENTIFIC: 2,
  PERCENT: 3,
  CURRENCY: 4,
  COMPACT_SHORT: 5,
  COMPACT_LONG: 6
};


/**
 * Currency styles.
 * @enum {number}
 */
goog.i18n.NumberFormat.CurrencyStyle = {
  LOCAL: 0,     // currency style as it is used in its circulating country.
  PORTABLE: 1,  // currency style that differentiate it from other popular ones.
  GLOBAL: 2     // currency style that is unique among all currencies.
};


/**
 * Compacting styles.
 * @enum {number}
 */
goog.i18n.NumberFormat.CompactStyle = {
  NONE: 0,   // Don't compact.
  SHORT: 1,  // Short compact form, such as 1.2B.
  LONG: 2    // Long compact form, such as 1.2 billion.
};


/**
 * If the usage of Ascii digits should be enforced.
 * @type {boolean}
 * @private
 */
goog.i18n.NumberFormat.enforceAsciiDigits_ = false;


/**
 * Set if the usage of Ascii digits in formatting should be enforced.
 * NOTE: This function must be called before constructing NumberFormat.
 *
 * @param {boolean} doEnforce Boolean value about if Ascii digits should be
 *     enforced.
 */
goog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {
  'use strict';
  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;
};


/**
 * Return if Ascii digits is enforced.
 * @return {boolean} If Ascii digits is enforced.
 */
goog.i18n.NumberFormat.isEnforceAsciiDigits = function() {
  'use strict';
  return goog.i18n.NumberFormat.enforceAsciiDigits_;
};


/**
 * Returns the current NumberFormatSymbols.
 * @return {?}
 * @private
 */
goog.i18n.NumberFormat.prototype.getNumberFormatSymbols_ = function() {
  'use strict';
  return this.overrideNumberFormatSymbols_ ||
      (goog.i18n.NumberFormat.enforceAsciiDigits_ ?
           goog.i18n.NumberFormatSymbols_u_nu_latn :
           goog.i18n.NumberFormatSymbols);
};


/**
 * Returns the currency code.
 * @return {string}
 * @private
 */
goog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {
  'use strict';
  return this.intlCurrencyCode_ ||
      this.getNumberFormatSymbols_().DEF_CURRENCY_CODE;
};


/**
 * Sets minimum number of fraction digits.
 * @param {number} min the minimum.
 * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.
 */
goog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {
  'use strict';
  if (this.significantDigits_ > 0 && min > 0) {
    throw new Error(
        'Can\'t combine significant digits and minimum fraction digits');
  }
  this.minimumFractionDigits_ = min;
  return this;
};


/**
 * Gets minimum number of fraction digits.
 * @return {number} The number of minimum fraction digits.
 */
goog.i18n.NumberFormat.prototype.getMinimumFractionDigits = function() {
  'use strict';
  return this.minimumFractionDigits_;
};


/**
 * Sets maximum number of fraction digits.
 * @param {number} max the maximum.
 * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.
 */
goog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {
  'use strict';
  if (max > 308) {
    // Math.pow(10, 309) becomes Infinity which breaks the logic in this class.
    throw new Error('Unsupported maximum fraction digits: ' + max);
  }
  this.maximumFractionDigits_ = max;
  return this;
};


/**
 * Gets maximum number of fraction digits.
 * @return {number} The number of maximum fraction digits.
 */
goog.i18n.NumberFormat.prototype.getMaximumFractionDigits = function() {
  'use strict';
  return this.maximumFractionDigits_;
};

/**
 * Sets number of significant digits to show. Only fractions will be rounded.
 * Regardless of the number of significant digits set, the number of fractional
 * digits shown will always be capped by the maximum number of fractional digits
 * set on {@link #setMaximumFractionDigits}.
 * @param {number} number The number of significant digits to include.
 * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.
 */
goog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {
  'use strict';
  if (this.minimumFractionDigits_ > 0 && number >= 0) {
    throw new Error(
        'Can\'t combine significant digits and minimum fraction digits');
  }
  this.significantDigits_ = number;
  return this;
};


/**
 * Gets number of significant digits to show. Only fractions will be rounded.
 * @return {number} The number of significant digits to include.
 */
goog.i18n.NumberFormat.prototype.getSignificantDigits = function() {
  'use strict';
  return this.significantDigits_;
};


/**
 * Sets whether trailing fraction zeros should be shown when significantDigits_
 * is positive. If this is true and significantDigits_ is 2, 1 will be formatted
 * as '1.0'.
 * @param {boolean} showTrailingZeros Whether trailing zeros should be shown.
 * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.
 */
goog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(
    showTrailingZeros) {
  'use strict';
  this.showTrailingZeros_ = showTrailingZeros;
  return this;
};


/**
 * Sets a number to base the formatting on when compact style formatting is
 * used. If this is null, the formatting should be based only on the number to
 * be formatting.
 *
 * This base formatting number can be used to format the target number as
 * another number would be formatted. For example, 100,000 is normally formatted
 * as "100K" in the COMPACT_SHORT format. To instead format it as '0.1M', the
 * base number could be set to 1,000,000 in order to force all numbers to be
 * formatted in millions. Similarly, 1,000,000,000 would normally be formatted
 * as '1B' and setting the base formatting number to 1,000,000, would cause it
 * to be formatted instead as '1,000M'.
 *
 * @param {?number} baseFormattingNumber The number to base formatting on, or
 * null if formatting should not be based on another number.
 * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.
 */
goog.i18n.NumberFormat.prototype.setBaseFormatting = function(
    baseFormattingNumber) {
  'use strict';
  goog.asserts.assert(
      baseFormattingNumber === null || isFinite(baseFormattingNumber));
  this.baseFormattingNumber_ = baseFormattingNumber;
  return this;
};


/**
 * Gets the number on which compact formatting is currently based, or null if
 * no such number is set. See setBaseFormatting() for more information.
 * @return {?number}
 */
goog.i18n.NumberFormat.prototype.getBaseFormatting = function() {
  'use strict';
  return this.baseFormattingNumber_;
};


/**
 * Apply provided pattern, result are stored in member variables.
 *
 * @param {string} pattern String pattern being applied.
 * @private
 */
goog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {
  'use strict';
  this.pattern_ = pattern.replace(/ /g, '\u00a0');
  var pos = [0];

  this.positivePrefix_ = this.parseAffix_(pattern, pos);
  var trunkStart = pos[0];
  this.parseTrunk_(pattern, pos);
  var trunkLen = pos[0] - trunkStart;
  this.positiveSuffix_ = this.parseAffix_(pattern, pos);
  if (pos[0] < pattern.length &&
      pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {
    pos[0]++;
    if (this.multiplier_ != 1) this.negativePercentSignExpected_ = true;
    this.negativePrefix_ = this.parseAffix_(pattern, pos);
    // we assume this part is identical to positive part.
    // user must make sure the pattern is correctly constructed.
    pos[0] += trunkLen;
    this.negativeSuffix_ = this.parseAffix_(pattern, pos);
  } else {
    // if no negative affix specified, they share the same positive affix
    this.negativePrefix_ += this.positivePrefix_;
    this.negativeSuffix_ += this.positiveSuffix_;
  }
};


/**
 * Apply a predefined pattern to NumberFormat object.
 * @param {number} patternType The number that indicates a predefined number
 *     format pattern.
 * @private
 */
goog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {
  'use strict';
  switch (patternType) {
    case goog.i18n.NumberFormat.Format.DECIMAL:
      this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);
      break;
    case goog.i18n.NumberFormat.Format.SCIENTIFIC:
      this.applyPattern_(this.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);
      break;
    case goog.i18n.NumberFormat.Format.PERCENT:
      this.applyPattern_(this.getNumberFormatSymbols_().PERCENT_PATTERN);
      break;
    case goog.i18n.NumberFormat.Format.CURRENCY:
      this.applyPattern_(goog.i18n.currency.adjustPrecision(
          this.getNumberFormatSymbols_().CURRENCY_PATTERN,
          this.getCurrencyCode_()));
      break;
    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:
      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);
      break;
    case goog.i18n.NumberFormat.Format.COMPACT_LONG:
      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);
      break;
    default:
      throw new Error('Unsupported pattern type.');
  }
};


/**
 * Apply a predefined pattern for shorthand formats.
 * @param {goog.i18n.NumberFormat.CompactStyle} style the compact style to
 *     set defaults for.
 * @private
 */
goog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {
  'use strict';
  this.compactStyle_ = style;
  this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);
  this.setMinimumFractionDigits(0);
  this.setMaximumFractionDigits(2);
  this.setSignificantDigits(2);
};


/**
 * Parses text string to produce a Number.
 *
 * This method attempts to parse text starting from position "opt_pos" if it
 * is given. Otherwise the parse will start from the beginning of the text.
 * When opt_pos presents, opt_pos will be updated to the character next to where
 * parsing stops after the call. If an error occurs, opt_pos won't be updated.
 *
 * @param {string} text The string to be parsed.
 * @param {Array<number>=} opt_pos Position to pass in and get back.
 * @return {number} Parsed number. This throws an error if the text cannot be
 *     parsed.
 */
goog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {
  'use strict';
  var pos = opt_pos || [0];

  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {
    throw new Error('Parsing of compact numbers is unimplemented');
  }

  var ret = NaN;

  // We don't want to handle multiple kinds of space in parsing, normalize the
  // regular and narrow nbsp to nbsp.
  text = text.replace(/ |\u202f/g, '\u00a0');

  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];
  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];

  // check for the longest match
  if (gotPositive && gotNegative) {
    if (this.positivePrefix_.length > this.negativePrefix_.length) {
      gotNegative = false;
    } else if (this.positivePrefix_.length < this.negativePrefix_.length) {
      gotPositive = false;
    }
  }

  if (gotPositive) {
    pos[0] += this.positivePrefix_.length;
  } else if (gotNegative) {
    pos[0] += this.negativePrefix_.length;
  }

  // process digits or Inf, find decimal position
  if (text.indexOf(this.getNumberFormatSymbols_().INFINITY, pos[0]) == pos[0]) {
    pos[0] += this.getNumberFormatSymbols_().INFINITY.length;
    ret = Infinity;
  } else {
    ret = this.parseNumber_(text, pos);
  }

  // check for suffix
  if (gotPositive) {
    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {
      return NaN;
    }
    pos[0] += this.positiveSuffix_.length;
  } else if (gotNegative) {
    if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {
      return NaN;
    }
    pos[0] += this.negativeSuffix_.length;
  }

  return gotNegative ? -ret : ret;
};


/**
 * This function will parse a "localized" text into a Number. It needs to
 * handle locale specific decimal, grouping, exponent and digits.
 *
 * @param {string} text The text that need to be parsed.
 * @param {Array<number>} pos  In/out parsing position. In case of failure,
 *    pos value won't be changed.
 * @return {number} Number value, or NaN if nothing can be parsed.
 * @private
 */
goog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {
  'use strict';
  var sawDecimal = false;
  var sawExponent = false;
  var sawDigit = false;
  var exponentPos = -1;
  var scale = 1;
  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;
  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;
  var exponentChar = this.getNumberFormatSymbols_().EXP_SYMBOL;

  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {
    throw new Error('Parsing of compact style numbers is not implemented');
  }

  // We don't want to handle multiple kinds of space in parsing, normalize the
  // narrow nbsp to nbsp.
  grouping = grouping.replace(/\u202f/g, '\u00a0');

  var normalizedText = '';
  for (; pos[0] < text.length; pos[0]++) {
    var ch = text.charAt(pos[0]);
    var digit = this.getDigit_(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText += digit;
      sawDigit = true;
    } else if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText += '.';
      sawDecimal = true;
    } else if (
        ch == grouping.charAt(0) &&
        ('\u00a0' != grouping.charAt(0) ||
         pos[0] + 1 < text.length &&
             this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {
      // Got a grouping character here. When grouping character is nbsp, need
      // to make sure the character following it is a digit.
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    } else if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText += 'E';
      sawExponent = true;
      exponentPos = pos[0];
    } else if (ch == '+' || ch == '-') {
      // Stop parsing if a '+' or '-' sign is found after digits have been found
      // but it's not located right after an exponent sign.
      if (sawDigit && exponentPos != pos[0] - 1) {
        break;
      }
      normalizedText += ch;
    } else if (
        this.multiplier_ == 1 &&
        ch == this.getNumberFormatSymbols_().PERCENT.charAt(0)) {
      // Parse the percent character as part of the number only when it's
      // not already included in the pattern.
      if (scale != 1) {
        break;
      }
      scale = 100;
      if (sawDigit) {
        pos[0]++;  // eat this character if parse end here
        break;
      }
    } else if (
        this.multiplier_ == 1 &&
        ch == this.getNumberFormatSymbols_().PERMILL.charAt(0)) {
      // Parse the permill character as part of the number only when it's
      // not already included in the pattern.
      if (scale != 1) {
        break;
      }
      scale = 1000;
      if (sawDigit) {
        pos[0]++;  // eat this character if parse end here
        break;
      }
    } else {
      break;
    }
  }

  // Scale the number when the percent/permill character was included in
  // the pattern.
  if (this.multiplier_ != 1) {
    scale = this.multiplier_;
  }

  return parseFloat(normalizedText) / scale;
};


/**
 * Formats a Number to produce a string.
 *
 * @param {number} number The Number to be formatted.
 * @return {string} The formatted number string.
 */
goog.i18n.NumberFormat.prototype.format = function(number) {
  'use strict';
  if (isNaN(number)) {
    return this.getNumberFormatSymbols_().NAN;
  }

  var parts = [];
  var baseFormattingNumber = (this.baseFormattingNumber_ === null) ?
      number :
      this.baseFormattingNumber_;
  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);
  number = goog.i18n.NumberFormat.decimalShift_(number, -unit.divisorBase);

  // in icu code, it is commented that certain computation need to keep the
  // negative sign for 0.
  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;

  if (isNegative) {
    // Also handle compact number formats
    if (unit.negative_prefix) {
      // Compact form includes the negative sign
      parts.push(unit.negative_prefix);
    } else {
      parts.push(unit.prefix);
      parts.push(this.negativePrefix_);
    }
  } else {
    parts.push(unit.prefix);
    parts.push(this.positivePrefix_);
  }


  if (!isFinite(number)) {
    parts.push(this.getNumberFormatSymbols_().INFINITY);
  } else {
    // convert number to non-negative value
    number *= isNegative ? -1 : 1;

    number *= this.multiplier_;
    this.useExponentialNotation_ ?
        this.subformatExponential_(number, parts) :
        this.subformatFixed_(number, this.minimumIntegerDigits_, parts);
  }

  if (isNegative) {
    // Also handle compact number formats
    if (unit.negative_suffix) {
      // Compact form includes the negative sign
      parts.push(unit.negative_suffix);
    } else {
      if (isFinite(number)) {
        // Add scientific or compact suffix only for finite values.
        // Infinity does not have a scientific or compact suffix in ECMA-402.
        parts.push(unit.suffix);
      }
      parts.push(this.negativeSuffix_);
    }
  } else {
    if (isFinite(number)) {
      // Add scientific or compact suffix only for finite values.
      parts.push(unit.suffix);
    }
    parts.push(this.positiveSuffix_);
  }
  return parts.join('');
};


/**
 * Round a number into an integer and fractional part
 * based on the rounding rules for this NumberFormat.
 * @param {number} number The number to round.
 * @return {{intValue: number, fracValue: number}} The integer and fractional
 *     part after rounding.
 * @private
 */
goog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {
  'use strict';
  var shift = goog.i18n.NumberFormat.decimalShift_;

  var shiftedNumber = shift(number, this.maximumFractionDigits_);
  if (this.significantDigits_ > 0) {
    shiftedNumber = this.roundToSignificantDigits_(
        shiftedNumber, this.significantDigits_, this.maximumFractionDigits_);
  }
  shiftedNumber = Math.round(shiftedNumber);

  var intValue, fracValue;
  if (isFinite(shiftedNumber)) {
    intValue = Math.floor(shift(shiftedNumber, -this.maximumFractionDigits_));
    fracValue = Math.floor(
        shiftedNumber - shift(intValue, this.maximumFractionDigits_));
  } else {
    intValue = number;
    fracValue = 0;
  }
  return {intValue: intValue, fracValue: fracValue};
};


/**
 * Formats a number with the appropriate groupings when there are repeating
 * digits present. Repeating digits exists when the length of the digits left
 * of the decimal place exceeds the number of non-repeating digits.
 *
 * Formats a number by iterating through the integer number (intPart) from the
 * most left of the decimal place by inserting the appropriate number grouping
 * separator for the repeating digits until all of the repeating digits is
 * iterated. Then iterate through the non-repeating digits by inserting the
 * appropriate number grouping separator until all the non-repeating digits
 * is iterated through.
 *
 * In the number grouping concept, anything left of the decimal
 * place is followed by non-repeating digits and then repeating digits. If the
 * pattern is #,##,###, then we first (from the left of the decimal place) have
 * a non-repeating digit of size 3 followed by repeating digits of size 2
 * separated by a thousand separator. If the length of the digits are six or
 * more, there may be repeating digits required. For example, the value of
 * 12345678 would format as 1,23,45,678 where the repeating digit is length 2.
 *
 * @param {!Array<string>} parts An array to build the 'parts' of the formatted
 *  number including the values and separators.
 * @param {number} zeroCode The value of the zero digit whether or not
 *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.
 * @param {string} intPart The integer representation of the number to be
 *  formatted and referenced.
 * @param {!Array<number>} groupingArray The array of numbers to determine the
 *  grouping of repeated and non-repeated digits.
 * @param {number} repeatedDigitLen The length of the repeated digits left of
 *  the non-repeating digits left of the decimal.
 * @return {!Array<string>} Returns the resulting parts variable containing
 *  how numbers are to be grouped and appear.
 * @private
 */
goog.i18n.NumberFormat.prototype.formatNumberGroupingRepeatingDigitsParts_ =
    function(parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {
  'use strict';
  // Keep track of how much has been completed on the non repeated groups
  var nonRepeatedGroupCompleteCount = 0;
  var currentGroupSizeIndex = 0;
  var currentGroupSize = 0;

  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;
  var digitLen = intPart.length;

  // There are repeating digits and non-repeating digits
  for (var i = 0; i < digitLen; i++) {
    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));
    if (digitLen - i > 1) {
      currentGroupSize = groupingArray[currentGroupSizeIndex];
      if (i < repeatedDigitLen) {
        // Process the left side (the repeated number groups)
        var repeatedDigitIndex = repeatedDigitLen - i;
        // Edge case if there's a number grouping asking for "1" group at
        // a time; otherwise, if the remainder is 1, there's the separator
        if (currentGroupSize === 1 ||
            (currentGroupSize > 0 &&
             (repeatedDigitIndex % currentGroupSize) === 1)) {
          parts.push(grouping);
        }
      } else if (currentGroupSizeIndex < groupingArray.length) {
        // Process the right side (the non-repeated fixed number groups)
        if (i === repeatedDigitLen) {
          // Increase the group index because a separator
          // has previously added in the earlier logic
          currentGroupSizeIndex += 1;
        } else if (
            currentGroupSize ===
            i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {
          // Otherwise, just iterate to the right side and
          // add a separator once the length matches to the expected
          parts.push(grouping);
          // Keep track of what has been completed on the right
          nonRepeatedGroupCompleteCount += currentGroupSize;
          currentGroupSizeIndex += 1;  // Get to the next number grouping
        }
      }
    }
  }
  return parts;
};


/**
 * Formats a number with the appropriate groupings when there are no repeating
 * digits present. Non-repeating digits exists when the length of the digits
 * left of the decimal place is equal or lesser than the length of
 * non-repeating digits.
 *
 * Formats a number by iterating through the integer number (intPart) from the
 * right most non-repeating number group of the decimal place. For each group,
 * inserting the appropriate number grouping separator for the non-repeating
 * digits until the number is completely iterated.
 *
 * In the number grouping concept, anything left of the decimal
 * place is followed by non-repeating digits and then repeating digits. If the
 * pattern is #,##,###, then we first (from the left of the decimal place) have
 * a non-repeating digit of size 3 followed by repeating digits of size 2
 * separated by a thousand separator. If the length of the digits are five or
 * less, there won't be any repeating digits required. For example, the value
 * of 12345 would be formatted as 12,345 where the non-repeating digit is of
 * length 3.
 *
 * @param {!Array<string>} parts An array to build the 'parts' of the formatted
 *  number including the values and separators.
 * @param {number} zeroCode The value of the zero digit whether or not
 *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.
 * @param {string} intPart The integer representation of the number to be
 *  formatted and referenced.
 * @param {!Array<number>} groupingArray The array of numbers to determine the
 *  grouping of repeated and non-repeated digits.
 * @return {!Array<string>} Returns the resulting parts variable containing
 *  how numbers are to be grouped and appear.
 * @private
 */
goog.i18n.NumberFormat.prototype.formatNumberGroupingNonRepeatingDigitsParts_ =
    function(parts, zeroCode, intPart, groupingArray) {
  'use strict';
  // Keep track of how much has been completed on the non repeated groups
  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;
  var currentGroupSizeIndex;
  var currentGroupSize = 0;
  var digitLenLeft = intPart.length;
  var rightToLeftParts = [];

  // Start from the right most non-repeating group and work inwards
  for (currentGroupSizeIndex = groupingArray.length - 1;
       currentGroupSizeIndex >= 0 && digitLenLeft > 0;
       currentGroupSizeIndex--) {
    currentGroupSize = groupingArray[currentGroupSizeIndex];
    // Iterate from the right most digit
    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize &&
         ((digitLenLeft - rightDigitIndex - 1) >= 0);
         rightDigitIndex++) {
      rightToLeftParts.push(String.fromCharCode(
          zeroCode +
          Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));
    }
    // Update the number of digits left
    digitLenLeft -= currentGroupSize;
    if (digitLenLeft > 0) {
      rightToLeftParts.push(grouping);
    }
  }
  // Reverse and push onto the remaining parts
  parts.push.apply(parts, rightToLeftParts.reverse());

  return parts;
};


/**
 * Formats a Number in fraction format.
 *
 * @param {number} number
 * @param {number} minIntDigits Minimum integer digits.
 * @param {Array<string>} parts
 *     This array holds the pieces of formatted string.
 *     This function will add its formatted pieces to the array.
 * @private
 */
goog.i18n.NumberFormat.prototype.subformatFixed_ = function(
    number, minIntDigits, parts) {
  'use strict';
  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {
    throw new Error('Min value must be less than max value');
  }

  if (!parts) {
    parts = [];
  }

  var rounded = this.roundNumber_(number);
  var intValue = rounded.intValue;
  var fracValue = rounded.fracValue;

  var numIntDigits = (intValue == 0) ? 0 : this.intLog10_(intValue) + 1;
  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 ||
      (this.showTrailingZeros_ && numIntDigits < this.significantDigits_);
  var minimumFractionDigits = this.minimumFractionDigits_;
  if (fractionPresent) {
    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {
      minimumFractionDigits = this.significantDigits_ - numIntDigits;
    } else {
      minimumFractionDigits = this.minimumFractionDigits_;
    }
  }

  var intPart = '';
  var translatableInt = intValue;
  while (translatableInt > 1E20) {
    // here it goes beyond double precision, add '0' make it look better
    intPart = '0' + intPart;
    translatableInt =
        Math.round(goog.i18n.NumberFormat.decimalShift_(translatableInt, -1));
  }
  intPart = translatableInt + intPart;

  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;
  var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);
  var digitLen = intPart.length;
  var nonRepeatedGroupCount = 0;

  if (intValue > 0 || minIntDigits > 0) {
    for (var i = digitLen; i < minIntDigits; i++) {
      parts.push(String.fromCharCode(zeroCode));
    }

    // If there's more than 1 number grouping,
    // figure out the length of the non-repeated groupings (on the right)
    if (this.groupingArray_.length >= 2) {
      for (var j = 1; j < this.groupingArray_.length; j++) {
        nonRepeatedGroupCount += this.groupingArray_[j];
      }
    }

    // Anything left of the fixed number grouping is repeated,
    // figure out the length of repeated groupings (on the left)
    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;
    if (repeatedDigitLen > 0) {
      // There are repeating digits and non-repeating digits
      parts = this.formatNumberGroupingRepeatingDigitsParts_(
          parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);
    } else {
      // There are no repeating digits and only non-repeating digits
      parts = this.formatNumberGroupingNonRepeatingDigitsParts_(
          parts, zeroCode, intPart, this.groupingArray_);
    }
  } else if (!fractionPresent) {
    // If there is no fraction present, and we haven't printed any
    // integer digits, then print a zero.
    parts.push(String.fromCharCode(zeroCode));
  }

  // Output the decimal separator if we always do so.
  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {
    parts.push(decimal);
  }

  var fracPart = String(fracValue);
  // Handle case where fracPart is in scientific notation.
  var fracPartSplit = fracPart.split('e+');
  if (fracPartSplit.length == 2) {
    // Only keep significant digits.
    var floatFrac = parseFloat(fracPartSplit[0]);
    fracPart = String(
        this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));
    fracPart = fracPart.replace('.', '');
    // Append zeroes based on the exponent.
    var exp = parseInt(fracPartSplit[1], 10);
    fracPart += goog.string.repeat('0', exp - fracPart.length + 1);
  }

  // Add Math.pow(10, this.maximumFractionDigits) to fracPart. Uses string ops
  // to avoid complexity with scientific notation and overflows.
  if (this.maximumFractionDigits_ + 1 > fracPart.length) {
    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;
    fracPart = '1' + goog.string.repeat('0', zeroesToAdd) + fracPart;
  }

  var fracLen = fracPart.length;
  while (fracPart.charAt(fracLen - 1) == '0' &&
         fracLen > minimumFractionDigits + 1) {
    fracLen--;
  }

  for (var i = 1; i < fracLen; i++) {
    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));
  }
};


/**
 * Formats exponent part of a Number.
 *
 * @param {number} exponent Exponential value.
 * @param {Array<string>} parts The array that holds the pieces of formatted
 *     string. This function will append more formatted pieces to the array.
 * @private
 */
goog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {
  'use strict';
  parts.push(this.getNumberFormatSymbols_().EXP_SYMBOL);

  if (exponent < 0) {
    exponent = -exponent;
    parts.push(this.getNumberFormatSymbols_().MINUS_SIGN);
  } else if (this.useSignForPositiveExponent_) {
    parts.push(this.getNumberFormatSymbols_().PLUS_SIGN);
  }

  var exponentDigits = '' + exponent;
  var zeroChar = this.getNumberFormatSymbols_().ZERO_DIGIT;
  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {
    parts.push(zeroChar);
  }
  parts.push(exponentDigits);
};

/**
 * Returns the mantissa for the given value and its exponent.
 *
 * @param {number} value
 * @param {number} exponent
 * @return {number}
 * @private
 */
goog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {
  'use strict';
  return goog.i18n.NumberFormat.decimalShift_(value, -exponent);
};

/**
 * Formats Number in exponential format.
 *
 * @param {number} number Value need to be formatted.
 * @param {Array<string>} parts The array that holds the pieces of formatted
 *     string. This function will append more formatted pieces to the array.
 * @private
 */
goog.i18n.NumberFormat.prototype.subformatExponential_ = function(
    number, parts) {
  'use strict';
  if (number == 0.0) {
    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);
    this.addExponentPart_(0, parts);
    return;
  }

  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));
  number = this.getMantissa_(number, exponent);

  var minIntDigits = this.minimumIntegerDigits_;
  if (this.maximumIntegerDigits_ > 1 &&
      this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {
    // A repeating range is defined; adjust to it as follows.
    // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;
    // -3,-4,-5=>-6, etc. This takes into account that the
    // exponent we have here is off by one from what we expect;
    // it is for the format 0.MMMMMx10^n.
    var remainder = exponent % this.maximumIntegerDigits_;
    if (remainder < 0) {
      remainder = this.maximumIntegerDigits_ + remainder;
    }

    number = goog.i18n.NumberFormat.decimalShift_(number, remainder);
    exponent -= remainder;

    minIntDigits = 1;
  } else {
    // No repeating range is defined; use minimum integer digits.
    if (this.minimumIntegerDigits_ < 1) {
      exponent++;
      number = goog.i18n.NumberFormat.decimalShift_(number, -1);
    } else {
      exponent -= this.minimumIntegerDigits_ - 1;
      number = goog.i18n.NumberFormat.decimalShift_(
          number, this.minimumIntegerDigits_ - 1);
    }
  }
  this.subformatFixed_(number, minIntDigits, parts);
  this.addExponentPart_(exponent, parts);
};


/**
 * Returns the digit value of current character. The character could be either
 * '0' to '9', or a locale specific digit.
 *
 * @param {string} ch Character that represents a digit.
 * @return {number} The digit value, or -1 on error.
 * @private
 */
goog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {
  'use strict';
  var code = ch.charCodeAt(0);
  // between '0' to '9'
  if (48 <= code && code < 58) {
    return code - 48;
  } else {
    var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);
    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;
  }
};


// ----------------------------------------------------------------------
// CONSTANTS
// ----------------------------------------------------------------------
// Constants for characters used in programmatic (unlocalized) patterns.
/**
 * A zero digit character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = '0';


/**
 * A grouping separator character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = ',';


/**
 * A decimal separator character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = '.';


/**
 * A per mille character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_PER_MILLE_ = '\u2030';


/**
 * A percent character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_PERCENT_ = '%';


/**
 * A digit character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_DIGIT_ = '#';


/**
 * A separator character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_SEPARATOR_ = ';';


/**
 * An exponent character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_EXPONENT_ = 'E';


/**
 * A plus character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_PLUS_ = '+';


/**
 * A generic currency sign character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = '\u00A4';


/**
 * A quote character.
 * @type {string}
 * @private
 */
goog.i18n.NumberFormat.QUOTE_ = '\'';


/**
 * Parses affix part of pattern.
 *
 * @param {string} pattern Pattern string that need to be parsed.
 * @param {Array<number>} pos One element position array to set and receive
 *     parsing position.
 *
 * @return {string} Affix received from parsing.
 * @private
 */
goog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {
  'use strict';
  var affix = '';
  var inQuote = false;
  var len = pattern.length;

  for (; pos[0] < len; pos[0]++) {
    var ch = pattern.charAt(pos[0]);
    if (ch == goog.i18n.NumberFormat.QUOTE_) {
      if (pos[0] + 1 < len &&
          pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {
        pos[0]++;
        affix += '\'';  // 'don''t'
      } else {
        inQuote = !inQuote;
      }
      continue;
    }

    if (inQuote) {
      affix += ch;
    } else {
      switch (ch) {
        case goog.i18n.NumberFormat.PATTERN_DIGIT_:
        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:
        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:
        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:
        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:
          return affix;
        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:
          if ((pos[0] + 1) < len &&
              pattern.charAt(pos[0] + 1) ==
                  goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {
            pos[0]++;
            affix += this.getCurrencyCode_();
          } else {
            switch (this.currencyStyle_) {
              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:
                affix += goog.i18n.currency.getLocalCurrencySignWithFallback(
                    this.getCurrencyCode_());
                break;
              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:
                affix += goog.i18n.currency.getGlobalCurrencySignWithFallback(
                    this.getCurrencyCode_());
                break;
              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:
                affix += goog.i18n.currency.getPortableCurrencySignWithFallback(
                    this.getCurrencyCode_());
                break;
              default:
                break;
            }
          }
          break;
        case goog.i18n.NumberFormat.PATTERN_PERCENT_:
          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {
            throw new Error('Too many percent/permill');
          } else if (
              this.negativePercentSignExpected_ && this.multiplier_ != 100) {
            throw new Error('Inconsistent use of percent/permill characters');
          }
          this.multiplier_ = 100;
          this.negativePercentSignExpected_ = false;
          affix += this.getNumberFormatSymbols_().PERCENT;
          break;
        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:
          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {
            throw new Error('Too many percent/permill');
          } else if (
              this.negativePercentSignExpected_ && this.multiplier_ != 1000) {
            throw new Error('Inconsistent use of percent/permill characters');
          }
          this.multiplier_ = 1000;
          this.negativePercentSignExpected_ = false;
          affix += this.getNumberFormatSymbols_().PERMILL;
          break;
        default:
          affix += ch;
      }
    }
  }

  return affix;
};


/**
 * Parses the trunk part of a pattern.
 *
 * @param {string} pattern Pattern string that need to be parsed.
 * @param {Array<number>} pos One element position array to set and receive
 *     parsing position.
 * @private
 */
goog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {
  'use strict';
  var decimalPos = -1;
  var digitLeftCount = 0;
  var zeroDigitCount = 0;
  var digitRightCount = 0;
  var groupingCount = -1;
  var len = pattern.length;
  for (var loop = true; pos[0] < len && loop; pos[0]++) {
    var ch = pattern.charAt(pos[0]);
    switch (ch) {
      case goog.i18n.NumberFormat.PATTERN_DIGIT_:
        if (zeroDigitCount > 0) {
          digitRightCount++;
        } else {
          digitLeftCount++;
        }
        if (groupingCount >= 0 && decimalPos < 0) {
          groupingCount++;
        }
        break;
      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:
        if (digitRightCount > 0) {
          throw new Error('Unexpected "0" in pattern "' + pattern + '"');
        }
        zeroDigitCount++;
        if (groupingCount >= 0 && decimalPos < 0) {
          groupingCount++;
        }
        break;
      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:
        if (groupingCount > 0) {
          this.groupingArray_.push(groupingCount);
        }
        groupingCount = 0;
        break;
      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:
        if (decimalPos >= 0) {
          throw new Error(
              'Multiple decimal separators in pattern "' + pattern + '"');
        }
        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;
        break;
      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:
        if (this.useExponentialNotation_) {
          throw new Error(
              'Multiple exponential symbols in pattern "' + pattern + '"');
        }
        this.useExponentialNotation_ = true;
        this.minExponentDigits_ = 0;

        // exponent pattern can have a optional '+'.
        if ((pos[0] + 1) < len &&
            pattern.charAt(pos[0] + 1) ==
                goog.i18n.NumberFormat.PATTERN_PLUS_) {
          pos[0]++;
          this.useSignForPositiveExponent_ = true;
        }

        // Use lookahead to parse out the exponential part
        // of the pattern, then jump into phase 2.
        while ((pos[0] + 1) < len &&
               pattern.charAt(pos[0] + 1) ==
                   goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {
          pos[0]++;
          this.minExponentDigits_++;
        }

        if ((digitLeftCount + zeroDigitCount) < 1 ||
            this.minExponentDigits_ < 1) {
          throw new Error('Malformed exponential pattern "' + pattern + '"');
        }
        loop = false;
        break;
      default:
        pos[0]--;
        loop = false;
        break;
    }
  }

  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {
    // Handle '###.###' and '###.' and '.###'
    var n = decimalPos;
    if (n == 0) {  // Handle '.###'
      n++;
    }
    digitRightCount = digitLeftCount - n;
    digitLeftCount = n - 1;
    zeroDigitCount = 1;
  }

  // Do syntax checking on the digits.
  if (decimalPos < 0 && digitRightCount > 0 ||
      decimalPos >= 0 && (decimalPos < digitLeftCount ||
                          decimalPos > digitLeftCount + zeroDigitCount) ||
      groupingCount == 0) {
    throw new Error('Malformed pattern "' + pattern + '"');
  }
  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;

  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;
  if (decimalPos >= 0) {
    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;
    if (this.minimumFractionDigits_ < 0) {
      this.minimumFractionDigits_ = 0;
    }
  }

  // The effectiveDecimalPos is the position the decimal is at or would be at
  // if there is no decimal. Note that if decimalPos<0, then digitTotalCount ==
  // digitLeftCount + zeroDigitCount.
  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;
  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;
  if (this.useExponentialNotation_) {
    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;

    // in exponential display, we need to at least show something.
    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {
      this.minimumIntegerDigits_ = 1;
    }
  }

  // Add another number grouping at the end
  this.groupingArray_.push(Math.max(0, groupingCount));
  this.decimalSeparatorAlwaysShown_ =
      decimalPos == 0 || decimalPos == totalDigits;
};


/**
 * Alias for the compact format 'unit' object.
 * @typedef {{
 *     divisorBase: number,
 *     negative_prefix: string,
 *     negative_suffix: string,
 *     prefix: string,
 *     suffix: string
 * }}
 */
goog.i18n.NumberFormat.CompactNumberUnit;


/**
 * The empty unit, corresponding to a base of 0.
 * @private {!goog.i18n.NumberFormat.CompactNumberUnit}
 */
goog.i18n.NumberFormat.NULL_UNIT_ = {
  divisorBase: 0,
  negative_prefix: '',
  negative_suffix: '',
  prefix: '',
  suffix: ''
};


/**
 * Get compact unit for a certain number of digits
 *
 * @param {number} base The number of digits to get the unit for.
 * @param {string} plurality The plurality of the number.
 * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The compact unit.
 * @private
 */
goog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {
  'use strict';
  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ?
      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN :
      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;

  if (table == null) {
    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;
  }

  if (base < 3) {
    return goog.i18n.NumberFormat.NULL_UNIT_;
  } else {
    var shift = goog.i18n.NumberFormat.decimalShift_;

    base = Math.min(14, base);
    var patterns = table[shift(1, base)];
    var previousNonNullBase = base - 1;
    while (!patterns && previousNonNullBase >= 3) {
      patterns = table[shift(1, previousNonNullBase)];
      previousNonNullBase--;
    }
    if (!patterns) {
      return goog.i18n.NumberFormat.NULL_UNIT_;
    }

    var pattern = patterns[plurality];

    // Return pattern for negative formatting, if present
    var neg_prefix = '';
    var neg_suffix = '';
    var index_of_neg_part = pattern.indexOf(';');
    var neg_pattern = null;
    if (index_of_neg_part >= 0) {
      // Trim positive pattern
      pattern = pattern.substring(0, index_of_neg_part);
      neg_pattern = pattern.substring(index_of_neg_part + 1);
      if (neg_pattern) {
        var neg_parts = /([^0]*)(0+)(.*)/.exec(neg_pattern);
        neg_prefix = neg_parts[1];
        neg_suffix = neg_parts[3];
      }
    }

    if (!pattern || pattern == '0') {
      return goog.i18n.NumberFormat.NULL_UNIT_;
    }

    var parts = /([^0]*)(0+)(.*)/.exec(pattern);
    if (!parts) {
      return goog.i18n.NumberFormat.NULL_UNIT_;
    }

    return {
      divisorBase: (previousNonNullBase + 1) - (parts[2].length - 1),
      negative_prefix: neg_prefix,
      negative_suffix: neg_suffix,
      prefix: parts[1],
      suffix: parts[3]
    };
  }
};


/**
 * Get the compact unit divisor, accounting for rounding of the quantity.
 *
 * @param {number} formattingNumber The number to base the formatting on. The
 *     unit will be calculated from this number.
 * @param {number} pluralityNumber The number to use for calculating the
 *     plurality.
 * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The unit after rounding.
 * @private
 */
goog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(
    formattingNumber, pluralityNumber) {
  'use strict';
  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {
    return goog.i18n.NumberFormat.NULL_UNIT_;
  }

  formattingNumber = Math.abs(formattingNumber);
  pluralityNumber = Math.abs(pluralityNumber);

  var initialPlurality = this.pluralForm_(formattingNumber);
  // Compute the exponent from the formattingNumber, to compute the unit.
  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);
  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;
  // Round both numbers based on the unit used.
  var pluralityAttempt =
      goog.i18n.NumberFormat.decimalShift_(pluralityNumber, -initialDivisor);
  var pluralityRounded = this.roundNumber_(pluralityAttempt);
  var formattingAttempt =
      goog.i18n.NumberFormat.decimalShift_(formattingNumber, -initialDivisor);
  var formattingRounded = this.roundNumber_(formattingAttempt);
  // Compute the plurality of the pluralityNumber when formatted using the name
  // units as the formattingNumber.
  var finalPlurality =
      this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);
  // Get the final unit, using the rounded formatting number to get the correct
  // unit, and the plurality computed from the pluralityNumber.
  return this.getUnitFor_(
      initialDivisor + this.intLog10_(formattingRounded.intValue),
      finalPlurality);
};


/**
 * Get the integer base 10 logarithm of a number.
 *
 * @param {number} number The number to log.
 * @return {number} The lowest integer n such that 10^n >= number.
 * @private
 */
goog.i18n.NumberFormat.prototype.intLog10_ = function(number) {
  'use strict';
  // Handle infinity.
  if (!isFinite(number)) {
    return number > 0 ? number : 0;
  }
  // Turns out Math.log(1000000)/Math.LN10 is strictly less than 6.
  // TODO(nickreid): Make this use `decimalShift_` or use another more effecient
  // string-based method.
  var i = 0;
  while ((number /= 10) >= 1) i++;
  return i;
};

/**
 * Shifts `number` by `digitCount` decimal digits.
 *
 * This function corrects for rounding error that may occur when naively
 * multiplying or dividing by a power of 10. See:
 * https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems
 * Example: `1.1e27 / Math.pow(10, 12)  != 1.1e15`.
 *
 * This function does not correct for inherent limitations in the precision of
 * JavaScript numbers.
 *
 * @param {number} number The number to shift.
 * @param {number} digitCount The number of places by which to shift number.
 *     Must be an integer. May be positive or negative.
 * @return {number}
 * @private
 */
goog.i18n.NumberFormat.decimalShift_ = function(number, digitCount) {
  'use strict';
  goog.asserts.assert(
      digitCount % 1 == 0, 'Cannot shift by fractional digits "%s".',
      digitCount);

  // Make sure to cover all numbers that stringify to something that doesn't
  // look like a number.
  if (!number || !isFinite(number) || digitCount == 0) {
    return number;
  }

  // This method isn't efficient, but it has the exact behaviour we want without
  // worrying about floating-point math edge cases.
  var numParts = String(number).split('e');
  var magnitude = parseInt(numParts[1] || 0, 10) + digitCount;
  return parseFloat(numParts[0] + 'e' + magnitude);
};

/**
 * Rounds `number` to `decimalCount` decimal places.
 *
 * Negative values of `decimalCount` will eliminate integeral digits.
 *
 * This function corrects for rounding error that may occur when naively
 * multiplying by a power of 10.
 *
 * This function does not correct for inherent limitations in the precision of
 * JavaScript numbers.
 *
 * @param {number} number The number to round.
 * @param {number} decimalCount The number of decimal places to retain.
 *     Must be an integer. May be positive or negative.
 * @return {number}
 * @private
 */
goog.i18n.NumberFormat.decimalRound_ = function(number, decimalCount) {
  'use strict';
  goog.asserts.assert(
      decimalCount % 1 == 0, 'Cannot round to fractional digits "%s".',
      decimalCount);

  if (!number || !isFinite(number)) {
    return number;
  }

  var shift = goog.i18n.NumberFormat.decimalShift_;
  return shift(Math.round(shift(number, decimalCount)), -decimalCount);
};


/**
 * Round to a certain number of significant digits.
 *
 * @param {number} number The number to round.
 * @param {number} significantDigits The number of significant digits
 *     to round to.
 * @param {number} scale Treat number as fixed point times 10^scale.
 * @return {number} The rounded number.
 * @private
 */
goog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(
    number, significantDigits, scale) {
  'use strict';
  if (!number) return number;

  var digits = this.intLog10_(number);
  var magnitude = significantDigits - digits - 1;

  // Only round fraction, not (potentially shifted) integers.
  if (magnitude < -scale) {
    return goog.i18n.NumberFormat.decimalRound_(number, -scale);
  } else {
    return goog.i18n.NumberFormat.decimalRound_(number, magnitude);
  }
};


/**
 * Get the plural form of a number.
 * @param {number} quantity The quantity to find plurality of.
 * @return {string} One of 'zero', 'one', 'two', 'few', 'many', 'other'.
 * @private
 */
goog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {
  'use strict';
  /* TODO: Implement */
  return 'other';
};


/**
 * Checks if the currency symbol comes before the value ($12) or after (12$)
 * Handy for applications that need to have separate UI fields for the currency
 * value and symbol, especially for input: Price: [USD] [123.45]
 * The currency symbol might be a combo box, or a label.
 *
 * @return {boolean} true if currency is before value.
 */
goog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {
  'use strict';
  var posCurrSymbol = this.pattern_.indexOf('\u00A4');  // '¤' Currency sign
  var posPound = this.pattern_.indexOf('#');
  var posZero = this.pattern_.indexOf('0');

  // posCurrValue is the first '#' or '0' found.
  // If none of them is found (not possible, but still),
  // the result is true (postCurrSymbol < MAX_VALUE)
  // That is OK, matches the en_US and ROOT locales.
  var posCurrValue = Number.MAX_VALUE;
  if (posPound >= 0 && posPound < posCurrValue) {
    posCurrValue = posPound;
  }
  if (posZero >= 0 && posZero < posCurrValue) {
    posCurrValue = posZero;
  }

  // No need to test, it is guaranteed that both these symbols exist.
  // If not, we have bigger problems than this.
  return posCurrSymbol < posCurrValue;
};

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/translate.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview A simple filter to aid in translation.
 */

goog.module('recovery.translateModule');
goog.module.declareLegacyNamespace();
const NumberFormat = goog.require('goog.i18n.NumberFormat');
const appConfig = goog.require('recovery.appConfig');

/**
 * @type {!angular.Module} The translation module.
 */
var translateModule = angular.module('recoveryTranslate', []).config([
  '$controllerProvider',
  function($controllerProvider) {
    // Port legacy app from v1.2 to v1.3.
    $controllerProvider.allowGlobals();
  }
]);

translateModule.filter('translate', function() {
  return translateModule.translate_;
});
translateModule.filter('translateApiError', function() {
  return translateModule.translateApiError_;
});
translateModule.filter('decimal', function() {
  return translateModule.formatDecimal_;
});
translateModule.filter('percent', function() {
  return translateModule.formatPercent_;
});

/**
 * Translates a given API error code to a message with the given parameters.
 * If no message can be found then a general unknown error message will be
 * returned.
 * @param {string} apiErrorCode API error code
 * @param {Array} var_args Parameters for the message.
 * @return {string} The translated message.
 * @private
 */
translateModule.translateApiError_ = function(apiErrorCode, var_args) {
  if (!apiErrorCode) {
    return '';
  }

  var key = 'APIERRMSG_' + apiErrorCode;
  var apiErrorMsg = translateModule.translate_(key, var_args);
  if (apiErrorMsg == key) {
    apiErrorMsg =
        translateModule.translate_('APIERRMSG_UNKNOWN', [apiErrorCode]);
  }
  return apiErrorMsg;
};

/**
 * Translates the given message key to a message with the given parameters.
 * If the key is not found or the translation fails it will return the original
 * key untranslated.
 * @param {string} key Message key
 * @param {Array} var_args Parameters for the message.
 * @return {string} The translated message.
 * @private
 */
translateModule.translate_ = function(key, var_args) {
  if (!key) {
    return '';
  }

  var params = Array.prototype.slice.call(arguments, 1);
  var message;
  var postFix = appConfig.messageCatalogPostfix;
  if (postFix) {
    message = chrome.i18n.getMessage(key + postFix, params);
  }
  if (!message) {
    message = chrome.i18n.getMessage(key, params);
  }
  if (message) {
    return message;
  } else {
    recovery.logger.severe('Failed translation for the key ' + key +
        ' with parameters ' + params);
    return key;
  }
};

/**
 * Formats a number as a decimal string using NumberFormat.
 * @param {number} num Number to format
 * @param {number=} opt_sigfig Optional significant digits.
 * @return {string}
 * @private
 */
translateModule.formatDecimal_ = function(num, opt_sigfig) {
  var format = new NumberFormat(1);
  if (opt_sigfig != undefined) {
    format.setMinimumFractionDigits(opt_sigfig);
    format.setMaximumFractionDigits(opt_sigfig);
  }
  return format.format(num);
};

/**
 * Formats a number as a percentage string.
 * @param {number} num Number to format
 * @param {number=} opt_sigfig Optional significant digits.
 * @return {string}
 * @private
 */
translateModule.formatPercent_ = function(num, opt_sigfig) {
  var format = new NumberFormat(3);
  if (opt_sigfig != undefined) {
    format.setMinimumFractionDigits(opt_sigfig);
    format.setMaximumFractionDigits(opt_sigfig);
  }
  return format.format(num);
};

exports = translateModule;

;return exports;});

//googleclient/chrome/chromeos_recovery/chrome_app/recovery/module.js
goog.loadModule(function(exports) {'use strict';/**
 * @fileoverview The angular module that describes the main app.
 */

goog.module('recovery.module');
const ActivityIndicator = goog.require('ng.jfk.ActivityIndicator');
const Autocomplete = goog.require('ng.jfk.Autocomplete');
const Bubble = goog.require('ng.jfk.Bubble');
const Button = goog.require('ng.jfk.Button');
const Checkbox = goog.require('ng.jfk.Checkbox');
const Input = goog.require('ng.jfk.Input');
const Menu = goog.require('ng.jfk.Menu');
const MenuButton = goog.require('ng.jfk.MenuButton');
const SegmentedButtons = goog.require('ng.jfk.SegmentedButtons');
const Select = goog.require('ng.jfk.Select');
const directives = goog.require('recovery.directives');
const translateModule = goog.require('recovery.translateModule');

/**
 * The Angular module definition.
 * .
 */
const module =
    angular
        .module(
            'recovery',
            [
              'ngSanitize', directives.name, translateModule.name,
              Autocomplete.name, Bubble.name, Button.name, Checkbox.name,
              Input.name, Menu.name, MenuButton.name, SegmentedButtons.name,
              Select.name, ActivityIndicator.name
            ])
        .config([
          '$controllerProvider',
          function($controllerProvider) {
            // Port legacy app from v1.2 to v1.3.
            $controllerProvider.allowGlobals();
          }
        ]);
goog.exportSymbol('recovery.module', module);

/**
 * Set up various application configurations. Run once per app start.
 *
 * @param {!angular.$compileProvider} $compileProvider The Angular compile
 *    provider service.
 * @ngInject
 */
module.configure = function($compileProvider) {
  // Angular does not by default whitelist chrome-extension image URLs
  // so without this setting an <img> with a src coming from
  // chrome-extension will be deemed unsafe and will not be loaded by
  // chrome.
  $compileProvider.imgSrcSanitizationWhitelist(/^\s*chrome-extension:/);
};

module.config(['$compileProvider', module.configure]);

exports = {module};

;return exports;});

//third_party/javascript/angular/v1_6/goog_hardening/closureSceHelper.js
/**
 * @fileoverview Collection of helpers that link the Angular hardened build to
 *    the Closure goog.html types. This should be compiled alongside Closure,
 *    so that the functions defined here can be called in the hardened Angular
 *    {@code $sce} service.
 *
 * MOE:begin_intracomment_strip
 * @see go/angular-v15-migrate#dependency
 * MOE:end_intracomment_strip
 */

// MOE:begin_strip
// There is no goog.provide to keep JSCompiler from dead-code removing this.
// See http://google3/third_party/java_src/jscomp/java/com/google/javascript/jscomp/JSCompilerRunner.java&l=255&rcl=112285511
// Adding @license_presubmit_check_bypass (this helper is not open source).
// MOE:end_strip

goog.require('goog.html.SafeHtml');
goog.require('goog.html.SafeScript');
goog.require('goog.html.SafeStyle');
goog.require('goog.html.SafeUrl');
goog.require('goog.html.TrustedResourceUrl');


goog.exportSymbol(
    'ng.safehtml.googSceHelper.isGoogHtmlType',

    /**
     * @param {?} value
     * @return {*} true if value is a goog.html type.
     * @public
     */
    function isGoogHtmlType(value) {
      if (value && value.implementsGoogStringTypedString) {
        return true;
      } else {
        return false;
      }
    });

goog.exportSymbol(
    'ng.safehtml.googSceHelper.isCOMPILED',
    /**
     * @return {boolean} the value of COMPILED.
     * @public
     */
    function isCOMPILED() {
      return COMPILED;
    });

goog.exportSymbol(
    'ng.safehtml.googSceHelper.unwrapAny',
    /**
     * Unwraps the value given as a parameter, if it is a goog.html type.
     * Otherwise, returns the parameter. Note that this function will not try to
     * unwrap stock {@code $sce.trustAs} results, and that even though Angular
     * trusts by default  `null`, `undefined` and '', Closure does
     * not, so this function will throw on these values since they are not
     * `goog.html` types.
     * @param {*} value
     * @return {*} An unwrapped version of `value`.
     * @throws {!Error} If the value not of a type among the `goog.html`
     * supported types.
     * @public
     */
    function valueOf(value) {
      if (value instanceof goog.html.TrustedResourceUrl) {
        return goog.html.TrustedResourceUrl.unwrap(value);
      } else if (value instanceof goog.html.SafeHtml) {
        return goog.html.SafeHtml.unwrap(value);
      } else if (value instanceof goog.html.SafeUrl) {
        return goog.html.SafeUrl.unwrap(value);
      } else if (value instanceof goog.html.SafeStyle) {
        return goog.html.SafeStyle.unwrap(value);
      } else if (value instanceof goog.html.SafeScript) {
        return goog.html.SafeScript.unwrap(value);
      } else {
        throw new Error();  // should be caught by Angular
      }
    });

goog.exportSymbol(
    'ng.safehtml.googSceHelper.unwrapGivenContext',
    /**
     * Try to unwrap `maybeTrusted` as a `goog.html` type for {@code
     * type}, then return the value or throw if it failed.
     *
     * @param {string} type Either 'url', 'resourceUrl', 'html', 'js' or 'css'.
     * @param {!goog.html.SafeHtml|!goog.html.SafeUrl|
               !goog.html.TrustedResourceUrl|!goog.html.SafeScript|
               !goog.html.SafeStyle} maybeTrusted Instance of a goog.html type.
     * @return {string} `maybeTrusted` unwrapped to string.
     * @throws {!Error} If maybeTrusted cannot be unwrapped in the given context.
     * @public
     */
    function unwrapGivenContext(type, maybeTrusted) {
      // TODO(rjamet): Is there any good way to get to constants defined
      // in $sce? It seems like we'd need a circular dependency for that.
      if (type == 'html') {  // $sce.HTML
        return goog.html.SafeHtml.unwrap(
            /** @type {!goog.html.SafeHtml} */ (maybeTrusted));
      } else if (type == 'resourceUrl' || type == 'templateUrl') {
        // either $sce.RESOURCE_URL or our new $sce.TEMPLATE_URL
        return goog.html.TrustedResourceUrl.unwrap(
            /** @type {!goog.html.TrustedResourceUrl} */ (maybeTrusted));
      } else if (type == 'url') {  // $sce.URL
        // Angular allows $sce.RESOURCE_URL wherever $sce.URL is allowed.
        if (maybeTrusted instanceof goog.html.TrustedResourceUrl) {
          return goog.html.TrustedResourceUrl.unwrap(maybeTrusted);
        }  // Else assume it's a SafeUrl
        return goog.html.SafeUrl.unwrap(
            /** @type {!goog.html.SafeUrl} */ (maybeTrusted));
      } else if (type == 'css') {  // $sce.CSS
        return goog.html.SafeStyle.unwrap(
            /** @type {!goog.html.SafeStyle} */ (maybeTrusted));
      } else if (type == 'js') {  // $sce.JS
        return goog.html.SafeScript.unwrap(
            /** @type {!goog.html.SafeScript} */ (maybeTrusted));
      }
      throw new Error();  // should be caught by Angular
    });

