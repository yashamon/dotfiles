function e(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function t(e,t=0,r=e.byteLength-t,s=!1){let i="";for(const n of new Uint8Array(e,t,r)){const e=n.toString(16).toUpperCase();1===e.length&&(i+="0"),i+=e,s&&(i+=" ")}return i.trim()}function r(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function s(e,t){let r=0;if(1===e.length)return e[0];for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function i(e,t,r=-1){const s=r;let i=e,n=0,a=Math.pow(2,t);for(let r=1;r<8;r++){if(e<a){let e;if(s<0)e=new ArrayBuffer(r),n=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),n=s}const a=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);a[n-e-1]=Math.floor(i/r),i-=a[n-e-1]*r}return e}a*=Math.pow(2,t)}return new ArrayBuffer(0)}function n(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),i=new Uint8Array(s);for(const t of e)i.set(new Uint8Array(t),r),r+=t.byteLength;return s}function a(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),i=new Uint8Array(s);for(const t of e)i.set(t,r),r+=t.length;return i}function o(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const i=s(r,8),n=new ArrayBuffer(this.valueHex.byteLength),a=new Uint8Array(n);for(let t=0;t<this.valueHex.byteLength;t++)a[t]=e[t];a[0]&=127;return s(a,8)-i}function l(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=i(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let n=i(t,8,s),a=new Uint8Array(n);if(128&a[0]){const e=n.slice(0),t=new Uint8Array(e);n=new ArrayBuffer(n.byteLength+1),a=new Uint8Array(n);for(let r=0;r<e.byteLength;r++)a[r+1]=t[r];a[0]=0}return n}r*=Math.pow(2,8)}return new ArrayBuffer(0)}function c(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function h(e,t){const r=e.toString(10);if(t<r.length)return"";const s=t-r.length,i=new Array(s);for(let e=0;e<s;e++)i[e]="0";return i.join("").concat(r)}const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function f(e,t=!1,r=!1,s=!1){let i=0,n=0,a=0,o="";const l=t?m:u;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;i<e.length;){const t=e.charCodeAt(i++);i>=e.length&&(n=1);const s=e.charCodeAt(i++);i>=e.length&&(a=1);const c=e.charCodeAt(i++),h=t>>2,u=(3&t)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===n?m=f=64:1===a&&(f=64),o+=r?64===m?`${l.charAt(h)}${l.charAt(u)}`:64===f?`${l.charAt(h)}${l.charAt(u)}${l.charAt(m)}`:`${l.charAt(h)}${l.charAt(u)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(h)}${l.charAt(u)}${l.charAt(m)}${l.charAt(f)}`}return o}function d(e,t=!1,r=!1){const s=t?m:u;function i(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let a=0,o="";for(;a<e.length;){const t=i(e.charAt(a++)),r=a>=e.length?0:i(e.charAt(a++)),s=a>=e.length?0:i(e.charAt(a++)),l=a>=e.length?0:i(e.charAt(a++)),c=n(t)<<2|n(r)>>4,h=(15&n(r))<<4|n(s)>>2,u=(3&n(s))<<6|n(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(h)),64!==l&&(o+=String.fromCharCode(u))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}o=-1!==e?o.slice(0,e+1):""}return o}function g(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function p(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const b=Math.log(2);function y(e){const t=Math.log(e)/b,r=Math.floor(t),s=Math.round(t);return r===s?r:s}function v(e,t){for(const r of t)delete e[r]}const w=[new Uint8Array([1])];class k{constructor(t={}){this.blockLength=e(t,"blockLength",0),this.error=e(t,"error",""),this.warnings=e(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:t(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const B=s=>class extends s{constructor(t={}){super(t),this.isHexOnly=e(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;return 0===new Uint8Array(e,t,s).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+s),this.blockLength=s,t+s)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}};class A extends(B(k)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=e(t.idBlock,"isHexOnly",!1),this.valueHex=e(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=e(t.idBlock,"tagClass",-1),this.tagNumber=e(t.idBlock,"tagNumber",-1),this.isConstructed=e(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;e&=31,s|=e,r[0]=s}return t}if(!1===this.isHexOnly){const n=i(this.tagNumber,7),a=new Uint8Array(n),o=n.byteLength;if(t=new ArrayBuffer(o+1),r=new Uint8Array(t),r[0]=31|s,!e){for(let e=0;e<o-1;e++)r[e+1]=128|a[e];r[o]=a[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(t),r[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const a=31&n[0];if(31!==a)this.tagNumber=a,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],e++,e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const i=new ArrayBuffer(e),a=new Uint8Array(i);for(let t=0;t<e;t++)a[t]=r[t];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex),r.set(a),this.blockLength<=9?this.tagNumber=s(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class S extends k{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=e(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=e(t.lenBlock,"longFormUsed",!1),this.length=e(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const a=127&n[0];if(a>8)return this.error="Too big integer",-1;if(a+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(a);for(let e=0;e<a;e++)o[e]=n[e+1];return 0===o[a-1]&&this.warnings.push("Needlessly long encoded length"),this.length=s(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=a+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(!0===this.longFormUsed){const s=i(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const n=new Uint8Array(s);r=new Uint8Array(t),r[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=n[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class C extends k{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class x extends k{constructor(e={},t=C){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new A(e),this.lenBlock=new S(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;let i;if(t=n(r,this.lenBlock.toBER(e)),i=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length),t=n(t,i),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=n(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class N extends C{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=e(t,"isHexOnly",!0)}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;const i=new Uint8Array(e,t,s);if(0===i.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<i.length;e++)n[e]=i[e];return this.blockLength=s,t+s}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class L extends x{constructor(e={}){super(e,N),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class E extends C{constructor(t={}){super(t),this.value=e(t,"value",[]),this.isIndefiniteForm=e(t,"isIndefiniteForm",!1)}fromBER(e,t,s){const i=t,n=s;if(!1===r(this,e,t,s))return-1;if(0===new Uint8Array(e,t,s).length)return this.warnings.push("Zero buffer length"),t;let a=t;for(;o=this.isIndefiniteForm,l=s,(!0===o?1:l)>0;){const t=ke(e,a,s);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(a=t.offset,this.blockLength+=t.result.blockLength,s-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===H.blockName())break}var o,l;return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===H.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(i,i+n),a}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=n(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class P extends x{constructor(e={}){super(e,E),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class I extends C{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class H extends x{constructor(e={}){super(e,I),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class O extends C{constructor(t={}){if(super(t),this.value=e(t,"value",!1),this.isHexOnly=e(t,"isHexOnly",!1),"valueHex"in t)this.valueHex=t.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){new Uint8Array(this.valueHex)[0]=255}}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;const i=new Uint8Array(e,t,s);s>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<i.length;e++)n[e]=i[e];return 0!==o.call(this)?this.value=!0:this.value=!1,this.blockLength=s,t+s}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class U extends x{constructor(e={}){super(e,O),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class _ extends P{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class V extends P{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class D extends x{constructor(e={}){super(e,k),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class R extends(B(E)){constructor(t={}){super(t),this.isConstructed=e(t,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,s=E.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===H.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==j.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return E.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e||0===this.valueHex.byteLength||(t=this.valueHex.slice(0)),t}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class j extends x{constructor(e={}){super(e,R),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof j!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class K extends(B(E)){constructor(t={}){super(t),this.unusedBits=e(t,"unusedBits",0),this.isConstructed=e(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,s){if(0===s)return t;let i=-1;if(!0===this.isConstructed){if(i=E.prototype.fromBER.call(this,e,t,s),-1===i)return i;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===H.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==T.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return i}if(!1===r(this,e,t,s))return-1;const n=new Uint8Array(e,t,s);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const a=new Uint8Array(this.valueHex);for(let e=0;e<s-1;e++)a[e]=n[e+1];return this.blockLength=n.length,t+s}toBER(e=!1){if(!0===this.isConstructed)return E.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class T extends x{constructor(e={}){super(e,K),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof T!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class J extends(B(C)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=o.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=l(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const i=this.fromBER(e,t,r);if(-1===i)return i;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(n,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return i}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),i=new Uint8Array(t),n=s.slice(0);const o=n.length-1;let l=i.slice(0);const c=l.length-1;let h=0;let u=0;for(let e=c<o?o:c;e>=0;e--,u++){switch(!0){case u<l.length:h=n[o-u]+l[c-u]+r[0];break;default:h=n[o-u]+r[0]}switch(r[0]=h/10,!0){case u>=n.length:n=a(new Uint8Array([h%10]),n);break;default:n[o-u]=h%10}}return r[0]>0&&(n=a(r,n)),n.slice(0)}function t(e){if(e>=w.length)for(let t=w.length;t<=e;t++){const e=new Uint8Array([0]);let r=w[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=a(e,r)),w.push(r)}return w[e]}function r(e,t){let r=0,s=new Uint8Array(e),i=new Uint8Array(t),n=s.slice(0);const a=n.length-1;let o=i.slice(0);const l=o.length-1;let c,h=0;for(let e=l;e>=0;e--,h++)switch(c=n[a-h]-o[l-h]-r,!0){case c<0:r=1,n[a-h]=c+10;break;default:r=0,n[a-h]=c}if(r>0)for(let e=a-l+1;e>=0;e--,h++){if(c=n[a-h]-r,!(c<0)){r=0,n[a-h]=c;break}r=1,n[a-h]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let i,n=new Uint8Array(8*this._valueHex.byteLength/3),o=0;const l=new Uint8Array(this._valueHex);let c="",h=!1;for(let a=this._valueHex.byteLength-1;a>=0;a--){i=l[a];for(let a=0;a<8;a++){if(1==(1&i))switch(o){case s:n=r(t(o),n),c="-";break;default:n=e(n,t(o))}o++,i>>=1}}for(let e=0;e<n.length;e++)n[e]&&(h=!0),h&&(c+="0123456789".charAt(n[e]));return!1===h&&(c+="0123456789".charAt(0)),c}}class F extends x{constructor(e={}){super(e,J),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof F?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?c(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&c(this.valueBlock.valueHex,e)}convertToDER(){const e=new F({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new F({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class M extends F{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class q extends(B(k)){constructor(t={}){super(t),this.valueDec=e(t,"valueDec",-1),this.isFirstSid=e(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let e=0;e<i&&(a[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=a[e];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=i(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=t(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class W extends C{constructor(t={}){super(t),this.fromString(e(t,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new q;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=n(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",i=!1;do{if(r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1,i){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,i=!1}else{const e=new q;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,i=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e+="."),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class G extends x{constructor(e={}){super(e,W),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class $ extends(B(k)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Q extends x{constructor(e={}){super(e,$),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class z extends(B(k)){constructor(t={}){super(t),this.valueDec=e(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let e=0;e<i&&(a[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=a[e];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=i(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";return e=!0===this.isHexOnly?t(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}}class Z extends C{constructor(t={}){super(t),this.fromString(e(t,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new z;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=n(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1;const i=new z;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e+="."),t?(s=`{${s}}`,e+=s):e+=s}return e}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class Y extends x{constructor(e={}){super(e,Z),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class X extends(B(k)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class ee extends x{constructor(e={}){super(e,X),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=i(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>2)continue;const a=2-n.length;for(let e=n.length-1;e>=0;e--)r[2*s+e+a]=n[e]}this.valueBlock.value=e}}class te extends(B(k)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class re extends x{constructor(e={}){super(e,te),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=i(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>4)continue;const a=4-n.length;for(let e=n.length-1;e>=0;e--)r[4*s+e+a]=n[e]}this.valueBlock.value=e}}class se extends(B(k)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class ie extends x{constructor(e={}){super(e,se),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class ne extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class ae extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class oe extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class le extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class ce extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class he extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class ue extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class me extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class fe extends ie{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class de extends ue{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=h(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=h(this.month,2),e[2]=h(this.day,2),e[3]=h(this.hour,2),e[4]=h(this.minute,2),e[5]=h(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class ge extends ue{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",i="",n=0,a=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let i=new Number(r.substr(0,2));if(isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");if(a=e*i,4===r.length){if(i=new Number(r.substr(2,2)),isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");o=e*i}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number("0"+s.substr(l));if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),i=s.substr(0,l)}else i=s;switch(!0){case 8===i.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(i);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+a;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(h(this.year,4)),e.push(h(this.month,2)),e.push(h(this.day,2)),e.push(h(this.hour,2)),e.push(h(this.minute,2)),e.push(h(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(h(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class pe extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class be extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class ye extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class ve extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class we extends Q{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}function ke(e,t,s){const i=t;let n=new x({},Object);const a=new k;if(!1===r(a,e,t,s))return n.error=a.error,{offset:-1,result:n};if(0===new Uint8Array(e,t,s).length)return this.error="Zero buffer length",{offset:-1,result:n};let o=n.idBlock.fromBER(e,t,s);if(n.warnings.concat(n.idBlock.warnings),-1===o)return n.error=n.idBlock.error,{offset:-1,result:n};if(t=o,s-=n.idBlock.blockLength,o=n.lenBlock.fromBER(e,t,s),n.warnings.concat(n.lenBlock.warnings),-1===o)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=o,s-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let l=x;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};l=H;break;case 1:l=U;break;case 2:l=F;break;case 3:l=T;break;case 4:l=j;break;case 5:l=D;break;case 6:l=G;break;case 10:l=M;break;case 12:l=Q;break;case 13:l=Y;break;case 14:l=we;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:l=_;break;case 17:l=V;break;case 18:l=ne;break;case 19:l=ae;break;case 20:l=oe;break;case 21:l=le;break;case 22:l=ce;break;case 23:l=de;break;case 24:l=ge;break;case 25:l=he;break;case 26:l=ue;break;case 27:l=me;break;case 28:l=re;break;case 29:l=fe;break;case 30:l=ee;break;case 31:l=pe;break;case 32:l=be;break;case 33:l=ye;break;case 34:l=ve;break;default:{let r;r=!0===n.idBlock.isConstructed?new P:new L,r.idBlock=n.idBlock,r.lenBlock=n.lenBlock,r.warnings=n.warnings,n=r,o=n.fromBER(e,t,s)}}break;case 2:case 3:case 4:default:l=!0===n.idBlock.isConstructed?P:L}return n=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(n,l),o=n.fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?s:n.lenBlock.length),n.valueBeforeDecode=e.slice(i,i+n.blockLength),{offset:o,result:n}}const Be=[new Uint8Array([1])];class Ae{constructor(t={}){this.blockLength=e(t,"blockLength",0),this.error=e(t,"error",""),this.warnings=e(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:t(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const Se=s=>class extends s{constructor(t={}){super(t),this.isHexOnly=e(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;return 0===new Uint8Array(e,t,s).length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+s),this.blockLength=s,t+s)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}};class Ce extends(Se(Ae)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=e(t.idBlock,"isHexOnly",!1),this.valueHex=e(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=e(t.idBlock,"tagClass",-1),this.tagNumber=e(t.idBlock,"tagNumber",-1),this.isConstructed=e(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;e&=31,s|=e,r[0]=s}return t}if(!1===this.isHexOnly){const n=i(this.tagNumber,7),a=new Uint8Array(n),o=n.byteLength;if(t=new ArrayBuffer(o+1),r=new Uint8Array(t),r[0]=31|s,!e){for(let e=0;e<o-1;e++)r[e+1]=128|a[e];r[o]=a[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(t),r[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const a=31&n[0];if(31!==a)this.tagNumber=a,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],e++,e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const i=new ArrayBuffer(e),a=new Uint8Array(i);for(let t=0;t<e;t++)a[t]=r[t];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex),r.set(a),this.blockLength<=9?this.tagNumber=s(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class xe extends Ae{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=e(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=e(t.lenBlock,"longFormUsed",!1),this.length=e(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,i){if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const a=127&n[0];if(a>8)return this.error="Too big integer",-1;if(a+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(a);for(let e=0;e<a;e++)o[e]=n[e+1];return 0===o[a-1]&&this.warnings.push("Needlessly long encoded length"),this.length=s(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=a+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(!0===this.longFormUsed){const s=i(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const n=new Uint8Array(s);r=new Uint8Array(t),r[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=n[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class Ne extends Ae{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class Le extends Ae{constructor(e={},t=Ne){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new Ce(e),this.lenBlock=new xe(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;let i;if(t=n(r,this.lenBlock.toBER(e)),i=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length),t=n(t,i),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=n(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class Ee extends Ne{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=e(t,"isHexOnly",!0)}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;const i=new Uint8Array(e,t,s);if(0===i.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<i.length;e++)n[e]=i[e];return this.blockLength=s,t+s}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class Pe extends Le{constructor(e={}){super(e,Ee),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class Ie extends Ne{constructor(t={}){super(t),this.value=e(t,"value",[]),this.isIndefiniteForm=e(t,"isIndefiniteForm",!1)}fromBER(e,t,s){const i=t,n=s;if(!1===r(this,e,t,s))return-1;if(0===new Uint8Array(e,t,s).length)return this.warnings.push("Zero buffer length"),t;let a=t;for(;o=this.isIndefiniteForm,l=s,(!0===o?1:l)>0;){const t=Nt(e,a,s);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(a=t.offset,this.blockLength+=t.result.blockLength,s-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===Ue.blockName())break}var o,l;return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===Ue.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(i,i+n),a}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=n(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class He extends Le{constructor(e={}){super(e,Ie),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class Oe extends Ne{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class Ue extends Le{constructor(e={}){super(e,Oe),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class _e extends Ne{constructor(t={}){if(super(t),this.value=e(t,"value",!1),this.isHexOnly=e(t,"isHexOnly",!1),"valueHex"in t)this.valueHex=t.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){new Uint8Array(this.valueHex)[0]=255}}fromBER(e,t,s){if(!1===r(this,e,t,s))return-1;const i=new Uint8Array(e,t,s);s>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(i.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<i.length;e++)n[e]=i[e];return 0!==o.call(this)?this.value=!0:this.value=!1,this.blockLength=s,t+s}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class Ve extends Le{constructor(e={}){super(e,_e),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class De extends He{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class Re extends He{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class je extends Le{constructor(e={}){super(e,Ae),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class Ke extends(Se(Ie)){constructor(t={}){super(t),this.isConstructed=e(t,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,s=Ie.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Ue.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==Te.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return Ie.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e||0===this.valueHex.byteLength||(t=this.valueHex.slice(0)),t}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class Te extends Le{constructor(e={}){super(e,Ke),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof Te!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class Je extends(Se(Ie)){constructor(t={}){super(t),this.unusedBits=e(t,"unusedBits",0),this.isConstructed=e(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(e,t,s){if(0===s)return t;let i=-1;if(!0===this.isConstructed){if(i=Ie.prototype.fromBER.call(this,e,t,s),-1===i)return i;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Ue.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==Fe.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return i}if(!1===r(this,e,t,s))return-1;const n=new Uint8Array(e,t,s);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const a=new Uint8Array(this.valueHex);for(let e=0;e<s-1;e++)a[e]=n[e+1];return this.blockLength=n.length,t+s}toBER(e=!1){if(!0===this.isConstructed)return Ie.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=t(this.valueHex,0,this.valueHex.byteLength),e}}class Fe extends Le{constructor(e={}){super(e,Je),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof Fe!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class Me extends(Se(Ne)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=o.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=l(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const i=this.fromBER(e,t,r);if(-1===i)return i;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(n,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return i}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),i=new Uint8Array(t),n=s.slice(0);const o=n.length-1;let l=i.slice(0);const c=l.length-1;let h=0;let u=0;for(let e=c<o?o:c;e>=0;e--,u++){switch(!0){case u<l.length:h=n[o-u]+l[c-u]+r[0];break;default:h=n[o-u]+r[0]}switch(r[0]=h/10,!0){case u>=n.length:n=a(new Uint8Array([h%10]),n);break;default:n[o-u]=h%10}}return r[0]>0&&(n=a(r,n)),n.slice(0)}function t(e){if(e>=Be.length)for(let t=Be.length;t<=e;t++){const e=new Uint8Array([0]);let r=Be[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=a(e,r)),Be.push(r)}return Be[e]}function r(e,t){let r=0,s=new Uint8Array(e),i=new Uint8Array(t),n=s.slice(0);const a=n.length-1;let o=i.slice(0);const l=o.length-1;let c,h=0;for(let e=l;e>=0;e--,h++)switch(c=n[a-h]-o[l-h]-r,!0){case c<0:r=1,n[a-h]=c+10;break;default:r=0,n[a-h]=c}if(r>0)for(let e=a-l+1;e>=0;e--,h++){if(c=n[a-h]-r,!(c<0)){r=0,n[a-h]=c;break}r=1,n[a-h]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let i,n=new Uint8Array(8*this._valueHex.byteLength/3),o=0;const l=new Uint8Array(this._valueHex);let c="",h=!1;for(let a=this._valueHex.byteLength-1;a>=0;a--){i=l[a];for(let a=0;a<8;a++){if(1==(1&i))switch(o){case s:n=r(t(o),n),c="-";break;default:n=e(n,t(o))}o++,i>>=1}}for(let e=0;e<n.length;e++)n[e]&&(h=!0),h&&(c+="0123456789".charAt(n[e]));return!1===h&&(c+="0123456789".charAt(0)),c}}class qe extends Le{constructor(e={}){super(e,Me),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof qe?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?c(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&c(this.valueBlock.valueHex,e)}convertToDER(){const e=new qe({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new qe({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class We extends qe{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class Ge extends(Se(Ae)){constructor(t={}){super(t),this.valueDec=e(t,"valueDec",-1),this.isFirstSid=e(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let e=0;e<i&&(a[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=a[e];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=i(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=t(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class $e extends Ne{constructor(t={}){super(t),this.fromString(e(t,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new Ge;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=n(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",i=!1;do{if(r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1,i){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,i=!1}else{const e=new Ge;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,i=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e+="."),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class Qe extends Le{constructor(e={}){super(e,$e),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class ze extends(Se(Ae)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Ze extends Le{constructor(e={}){super(e,ze),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class Ye extends(Se(Ae)){constructor(t={}){super(t),this.valueDec=e(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(e,t,i){if(0===i)return t;if(!1===r(this,e,t,i))return-1;const n=new Uint8Array(e,t,i);this.valueHex=new ArrayBuffer(i);let a=new Uint8Array(this.valueHex);for(let e=0;e<i&&(a[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=a[e];return this.valueHex=o.slice(0),a=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=s(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=i(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";return e=!0===this.isHexOnly?t(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}}class Xe extends Ne{constructor(t={}){super(t),this.fromString(e(t,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new Ye;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=n(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),s=-1===r?e.substr(t):e.substr(t,r-t),t=r+1;const i=new Ye;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e+="."),t?(s=`{${s}}`,e+=s):e+=s}return e}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class et extends Le{constructor(e={}){super(e,Xe),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class tt extends(Se(Ae)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class rt extends Le{constructor(e={}){super(e,tt),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=i(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>2)continue;const a=2-n.length;for(let e=n.length-1;e>=0;e--)r[2*s+e+a]=n[e]}this.valueBlock.value=e}}class st extends(Se(Ae)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class it extends Le{constructor(e={}){super(e,st),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=i(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>4)continue;const a=4-n.length;for(let e=n.length-1;e>=0;e--)r[4*s+e+a]=n[e]}this.valueBlock.value=e}}class nt extends(Se(Ae)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class at extends Le{constructor(e={}){super(e,nt),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class ot extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class lt extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class ct extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class ht extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class ut extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class mt extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class ft extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class dt extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class gt extends at{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class pt extends ft{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for convertion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(){const e=new Array(7);return e[0]=h(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=h(this.month,2),e[2]=h(this.day,2),e[3]=h(this.hour,2),e[4]=h(this.minute,2),e[5]=h(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class bt extends ft{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",i="",n=0,a=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let i=new Number(r.substr(0,2));if(isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");if(a=e*i,4===r.length){if(i=new Number(r.substr(2,2)),isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");o=e*i}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number("0"+s.substr(l));if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),i=s.substr(0,l)}else i=s;switch(!0){case 8===i.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===i.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(i);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+a;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(h(this.year,4)),e.push(h(this.month,2)),e.push(h(this.day,2)),e.push(h(this.hour,2)),e.push(h(this.minute,2)),e.push(h(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(h(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class yt extends Ze{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class vt extends Ze{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class wt extends Ze{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class kt extends Ze{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class Bt extends Ze{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class At{constructor(t={}){this.value=e(t,"value",[]),this.optional=e(t,"optional",!1)}}class St{constructor(t={}){this.name=e(t,"name",""),this.optional=e(t,"optional",!1)}}class Ct{constructor(t={}){this.name=e(t,"name",""),this.optional=e(t,"optional",!1),this.value=e(t,"value",new St),this.local=e(t,"local",!1)}}class xt{constructor(t={}){this.data=e(t,"data",new ArrayBuffer(0))}fromBER(e,t,r){return this.data=e.slice(t,r),t+r}toBER(e=!1){return this.data}}function Nt(e,t,s){const i=t;let n=new Le({},Object);const a=new Ae;if(!1===r(a,e,t,s))return n.error=a.error,{offset:-1,result:n};if(0===new Uint8Array(e,t,s).length)return this.error="Zero buffer length",{offset:-1,result:n};let o=n.idBlock.fromBER(e,t,s);if(n.warnings.concat(n.idBlock.warnings),-1===o)return n.error=n.idBlock.error,{offset:-1,result:n};if(t=o,s-=n.idBlock.blockLength,o=n.lenBlock.fromBER(e,t,s),n.warnings.concat(n.lenBlock.warnings),-1===o)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=o,s-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let l=Le;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};l=Ue;break;case 1:l=Ve;break;case 2:l=qe;break;case 3:l=Fe;break;case 4:l=Te;break;case 5:l=je;break;case 6:l=Qe;break;case 10:l=We;break;case 12:l=Ze;break;case 13:l=et;break;case 14:l=Bt;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:l=De;break;case 17:l=Re;break;case 18:l=ot;break;case 19:l=lt;break;case 20:l=ct;break;case 21:l=ht;break;case 22:l=ut;break;case 23:l=pt;break;case 24:l=bt;break;case 25:l=mt;break;case 26:l=ft;break;case 27:l=dt;break;case 28:l=it;break;case 29:l=gt;break;case 30:l=rt;break;case 31:l=yt;break;case 32:l=vt;break;case 33:l=wt;break;case 34:l=kt;break;default:{let r;r=!0===n.idBlock.isConstructed?new He:new Pe,r.idBlock=n.idBlock,r.lenBlock=n.lenBlock,r.warnings=n.warnings,n=r,o=n.fromBER(e,t,s)}}break;case 2:case 3:case 4:default:l=!0===n.idBlock.isConstructed?He:Pe}return n=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(n,l),o=n.fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?s:n.lenBlock.length),n.valueBeforeDecode=e.slice(i,i+n.blockLength),{offset:o,result:n}}function Lt(e){if(0===e.byteLength){const e=new Le({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Nt(e,0,e.byteLength)}function Et(e,t,r){if(r instanceof At){for(let s=0;s<r.value.length;s++){if(!0===Et(e,t,r.value[s]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof St)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=new Uint8Array(r.idBlock.valueHex),i=new Uint8Array(t.idBlock.valueHex);if(s.length!==i.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==i[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let s=0,i={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof Ct&&(n=t.valueBlock.value.length),0===n)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let a=0;a<n;a++)if(a-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[a].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof Ct){if(i=Et(e,t.valueBlock.value[a],r.valueBlock.value[0].value),!1===i.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),i;s++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};s="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e,void 0===s[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[a])}}else if(i=Et(e,t.valueBlock.value[a-s],r.valueBlock.value[a]),!1===i.verified){if(!0!==r.valueBlock.value[a].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),i;s++}if(!1===i.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const s=Lt(t.valueBlock.valueHex);if(-1===s.offset){const t={verified:!1,result:s.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return Et(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}class Pt{constructor(t={}){this.algorithmId=e(t,"algorithmId",Pt.defaultValues("algorithmId")),"algorithmParams"in t&&(this.algorithmParams=e(t,"algorithmParams",Pt.defaultValues("algorithmParams"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new St;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof St;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",optional:r.optional||!1,value:[new Qe({name:r.algorithmIdentifier||""}),new St({name:r.algorithmParams||"",optional:!0})]})}fromSchema(e){v(e,["algorithm","params"]);const t=Et(e,e,Pt.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new Qe({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof St==!1&&e.push(this.algorithmParams),new De({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof St==!1&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof Pt!=!1&&(this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e)))}}class It{constructor(t={}){this.x=e(t,"x",It.defaultValues("x")),this.y=e(t,"y",It.defaultValues("y")),this.namedCurve=e(t,"namedCurve",It.defaultValues("namedCurve")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return c(t,It.defaultValues(e));case"namedCurve":return""===t;default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static schema(e={}){return new xt}fromSchema(e){if(e instanceof ArrayBuffer==!1)throw new Error("Object's schema was not verified against input data for ECPublicKey");if(4!==new Uint8Array(e)[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let t;switch(this.namedCurve){case"1.2.840.10045.3.1.7":t=32;break;case"1.3.132.0.34":t=48;break;case"1.3.132.0.35":t=66;break;default:throw new Error("Incorrect curve OID: "+this.namedCurve)}if(e.byteLength!==2*t+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,t+1),this.y=e.slice(1+t,2*t+1)}toSchema(){return new xt({data:n(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:f(g(this.x),!0,!0,!1),y:f(g(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const r=p(d(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(s,1)}else this.x=r.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const r=p(d(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(r);e.set(s,1)}else this.y=r.slice(0,t)}}}class Ht{constructor(t={}){this.modulus=e(t,"modulus",Ht.defaultValues("modulus")),this.publicExponent=e(t,"publicExponent",Ht.defaultValues("publicExponent")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new qe;default:throw new Error("Invalid member name for RSAPublicKey class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new qe({name:r.modulus||""}),new qe({name:r.publicExponent||""})]})}fromSchema(e){v(e,["modulus","publicExponent"]);const t=Et(e,e,Ht.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new De({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:f(g(this.modulus.valueBlock.valueHex),!0,!0,!0),e:f(g(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=p(d(e.n,!0));this.modulus=new qe({valueHex:t.slice(0,Math.pow(2,y(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new qe({valueHex:p(d(e.e,!0)).slice(0,3)})}}class Ot{constructor(t={}){this.algorithm=e(t,"algorithm",Ot.defaultValues("algorithm")),this.subjectPublicKey=e(t,"subjectPublicKey",Ot.defaultValues("subjectPublicKey")),"parsedKey"in t&&(this.parsedKey=e(t,"parsedKey",Ot.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"algorithm":return new Pt;case"subjectPublicKey":return new Fe;default:throw new Error("Invalid member name for PublicKeyInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[Pt.schema(r.algorithm||{}),new Fe({name:r.subjectPublicKey||""})]})}fromSchema(e){v(e,["algorithm","subjectPublicKey"]);const t=Et(e,e,Ot.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PublicKeyInfo");switch(this.algorithm=new Pt({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===Qe.blockName())try{this.parsedKey=new It({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=Lt(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new Ht({schema:e.result})}catch(e){}}}}toSchema(){return new De({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==!1)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new It({json:e}),this.algorithm=new Pt({algorithmId:"1.2.840.10045.2.1",algorithmParams:new Qe({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ht({json:e}),this.algorithm=new Pt({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new je});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.subjectPublicKey=new Fe({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const r=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const s=Gt();return void 0===s?Promise.reject("Unable to create WebCrypto object"):(t=t.then(()=>s.exportKey("spki",e)),t=t.then(e=>{const t=Lt(e);try{r.fromSchema(t.result)}catch(e){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject("Error during exporting public key: "+e)),t)}}class Ut{constructor(t={}){this.type=e(t,"type",Ut.defaultValues("type")),this.values=e(t,"values",Ut.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error("Invalid member name for Attribute class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error("Invalid member name for Attribute class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.type||""}),new Re({name:r.setName||"",value:[new Ct({name:r.values||"",value:new St})]})]})}fromSchema(e){v(e,["type","values"]);const t=Et(e,e,Ut.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Attribute");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new De({value:[new Qe({value:this.type}),new Re({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class _t{constructor(t={}){this.version=e(t,"version",_t.defaultValues("version")),this.privateKey=e(t,"privateKey",_t.defaultValues("privateKey")),"namedCurve"in t&&(this.namedCurve=e(t,"namedCurve",_t.defaultValues("namedCurve"))),"publicKey"in t&&(this.publicKey=e(t,"publicKey",_t.defaultValues("publicKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new Te;case"namedCurve":return"";case"publicKey":return new It;default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"version":return t===_t.defaultValues(e);case"privateKey":return t.isEqual(_t.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return It.compareWithDefault("namedCurve",t.namedCurve)&&It.compareWithDefault("x",t.x)&&It.compareWithDefault("y",t.y);default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new qe({name:r.version||""}),new Te({name:r.privateKey||""}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Qe({name:r.namedCurve||""})]}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Fe({name:r.publicKey||""})]})]})}fromSchema(e){v(e,["version","privateKey","namedCurve","publicKey"]);const t=Et(e,e,_t.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new It(e)}}toSchema(){const e=[new qe({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:0},value:[new Qe({value:this.namedCurve})]})),"publicKey"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:1},value:[new Fe({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new De({value:e})}toJSON(){if("namedCurve"in this==!1||_t.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:f(g(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const r=p(d(e.d,!0));if(r.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),i=new Uint8Array(r);s.set(i,1),this.privateKey=new Te({valueHex:e})}else this.privateKey=new Te({valueHex:r.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new It({json:e}))}}class Vt{constructor(t={}){this.prime=e(t,"prime",Vt.defaultValues("prime")),this.exponent=e(t,"exponent",Vt.defaultValues("exponent")),this.coefficient=e(t,"coefficient",Vt.defaultValues("coefficient")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new qe;default:throw new Error("Invalid member name for OtherPrimeInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new qe({name:r.prime||""}),new qe({name:r.exponent||""}),new qe({name:r.coefficient||""})]})}fromSchema(e){v(e,["prime","exponent","coefficient"]);const t=Et(e,e,Vt.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new De({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:f(g(this.prime.valueBlock.valueHex),!0,!0),d:f(g(this.exponent.valueBlock.valueHex),!0,!0),t:f(g(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new qe({valueHex:p(d(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new qe({valueHex:p(d(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new qe({valueHex:p(d(e.t,!0))})}}class Dt{constructor(t={}){this.version=e(t,"version",Dt.defaultValues("version")),this.modulus=e(t,"modulus",Dt.defaultValues("modulus")),this.publicExponent=e(t,"publicExponent",Dt.defaultValues("publicExponent")),this.privateExponent=e(t,"privateExponent",Dt.defaultValues("privateExponent")),this.prime1=e(t,"prime1",Dt.defaultValues("prime1")),this.prime2=e(t,"prime2",Dt.defaultValues("prime2")),this.exponent1=e(t,"exponent1",Dt.defaultValues("exponent1")),this.exponent2=e(t,"exponent2",Dt.defaultValues("exponent2")),this.coefficient=e(t,"coefficient",Dt.defaultValues("coefficient")),"otherPrimeInfos"in t&&(this.otherPrimeInfos=e(t,"otherPrimeInfos",Dt.defaultValues("otherPrimeInfos"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new qe;case"otherPrimeInfos":return[];default:throw new Error("Invalid member name for RSAPrivateKey class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new qe({name:r.version||""}),new qe({name:r.modulus||""}),new qe({name:r.publicExponent||""}),new qe({name:r.privateExponent||""}),new qe({name:r.prime1||""}),new qe({name:r.prime2||""}),new qe({name:r.exponent1||""}),new qe({name:r.exponent2||""}),new qe({name:r.coefficient||""}),new De({optional:!0,value:[new Ct({name:r.otherPrimeInfosName||"",value:Vt.schema(r.otherPrimeInfo||{})})]})]})}fromSchema(e){v(e,["version","modulus","publicExponent","privateExponent","prime1","prime2","exponent1","exponent2","coefficient","otherPrimeInfos"]);const t=Et(e,e,Dt.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new Vt({schema:e})))}toSchema(){const e=[];return e.push(new qe({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new De({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new De({value:e})}toJSON(){const e={n:f(g(this.modulus.valueBlock.valueHex),!0,!0,!0),e:f(g(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:f(g(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:f(g(this.prime1.valueBlock.valueHex),!0,!0,!0),q:f(g(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:f(g(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:f(g(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:f(g(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new qe({valueHex:p(d(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new qe({valueHex:p(d(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new qe({valueHex:p(d(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new qe({valueHex:p(d(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new qe({valueHex:p(d(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new qe({valueHex:p(d(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new qe({valueHex:p(d(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new qe({valueHex:p(d(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new Vt({json:e})))}}class Rt{constructor(t={}){this.version=e(t,"version",Rt.defaultValues("version")),this.privateKeyAlgorithm=e(t,"privateKeyAlgorithm",Rt.defaultValues("privateKeyAlgorithm")),this.privateKey=e(t,"privateKey",Rt.defaultValues("privateKey")),"attributes"in t&&(this.attributes=e(t,"attributes",Rt.defaultValues("attributes"))),"parsedKey"in t&&(this.parsedKey=e(t,"parsedKey",Rt.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new Pt;case"privateKey":return new Te;case"attributes":return[];case"parsedKey":return{};default:throw new Error("Invalid member name for PrivateKeyInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new qe({name:r.version||""}),Pt.schema(r.privateKeyAlgorithm||{}),new Te({name:r.privateKey||""}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ct({name:r.attributes||"",value:Ut.schema()})]})]})}fromSchema(e){v(e,["version","privateKeyAlgorithm","privateKey","attributes"]);const t=Et(e,e,Rt.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Pt({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Ut({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=Lt(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Dt({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof Qe){const e=Lt(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new _t({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new qe({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new De({value:e})}toJSON(){if("parsedKey"in this==!1){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new _t({json:e}),this.privateKeyAlgorithm=new Pt({algorithmId:"1.2.840.10045.2.1",algorithmParams:new Qe({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Dt({json:e}),this.privateKeyAlgorithm=new Pt({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new je});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.privateKey=new Te({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class jt{constructor(t={}){if(this.contentType=e(t,"contentType",jt.defaultValues("contentType")),this.contentEncryptionAlgorithm=e(t,"contentEncryptionAlgorithm",jt.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in t&&(this.encryptedContent=t.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new Te({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),i=new ArrayBuffer(s.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=s[e];e.valueBlock.value.push(new Te({valueHex:i})),r-=s.length,t+=s.length}this.encryptedContent=e}"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new Pt;case"encryptedContent":return new Te;default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedContent":return t.isEqual(jt.defaultValues(e));default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.contentType||""}),Pt.schema(r.contentEncryptionAlgorithm||{}),new At({value:[new He({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new Ct({value:new Te})]}),new Pe({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){v(e,["contentType","contentEncryptionAlgorithm","encryptedContent"]);const t=Et(e,e,jt.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Pt({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new Qe({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new De({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Kt{constructor(t={}){this.hashAlgorithm=e(t,"hashAlgorithm",Kt.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=e(t,"maskGenAlgorithm",Kt.defaultValues("maskGenAlgorithm")),this.saltLength=e(t,"saltLength",Kt.defaultValues("saltLength")),this.trailerField=e(t,"trailerField",Kt.defaultValues("trailerField")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Pt({algorithmId:"1.3.14.3.2.26",algorithmParams:new je});case"maskGenAlgorithm":return new Pt({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Pt({algorithmId:"1.3.14.3.2.26",algorithmParams:new je}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error("Invalid member name for RSASSAPSSParams class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new He({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Pt.schema(r.hashAlgorithm||{})]}),new He({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Pt.schema(r.maskGenAlgorithm||{})]}),new He({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new qe({name:r.saltLength||""})]}),new He({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new qe({name:r.trailerField||""})]})]})}fromSchema(e){v(e,["hashAlgorithm","maskGenAlgorithm","saltLength","trailerField"]);const t=Et(e,e,Kt.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Pt({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Pt({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Kt.defaultValues("hashAlgorithm"))||e.push(new He({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Kt.defaultValues("maskGenAlgorithm"))||e.push(new He({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Kt.defaultValues("saltLength")&&e.push(new He({idBlock:{tagClass:3,tagNumber:2},value:[new qe({value:this.saltLength})]})),this.trailerField!==Kt.defaultValues("trailerField")&&e.push(new He({idBlock:{tagClass:3,tagNumber:3},value:[new qe({value:this.trailerField})]})),new De({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Kt.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Kt.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Kt.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Kt.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class Tt{constructor(t={}){this.salt=e(t,"salt",Tt.defaultValues("salt")),this.iterationCount=e(t,"iterationCount",Tt.defaultValues("iterationCount")),"keyLength"in t&&(this.keyLength=e(t,"keyLength",Tt.defaultValues("keyLength"))),"prf"in t&&(this.prf=e(t,"prf",Tt.defaultValues("prf"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Pt({algorithmId:"1.3.14.3.2.26",algorithmParams:new je});default:throw new Error("Invalid member name for PBKDF2Params class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new At({value:[new Te({name:r.saltPrimitive||""}),Pt.schema(r.saltConstructed||{})]}),new qe({name:r.iterationCount||""}),new qe({name:r.keyLength||"",optional:!0}),Pt.schema(r.prf||{names:{optional:!0}})]})}fromSchema(e){v(e,["salt","iterationCount","keyLength","prf"]);const t=Et(e,e,Tt.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2Params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new Pt({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new qe({value:this.iterationCount})),"keyLength"in this&&Tt.defaultValues("keyLength")!==this.keyLength&&e.push(new qe({value:this.keyLength})),"prf"in this&&!1===Tt.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new De({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Tt.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===Tt.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class Jt{constructor(t={}){this.keyDerivationFunc=e(t,"keyDerivationFunc",Jt.defaultValues("keyDerivationFunc")),this.encryptionScheme=e(t,"encryptionScheme",Jt.defaultValues("encryptionScheme")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new Pt;default:throw new Error("Invalid member name for PBES2Params class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[Pt.schema(r.keyDerivationFunc||{}),Pt.schema(r.encryptionScheme||{})]})}fromSchema(e){v(e,["keyDerivationFunc","encryptionScheme"]);const t=Et(e,e,Jt.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2Params");this.keyDerivationFunc=new Pt({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new Pt({schema:t.result.encryptionScheme})}toSchema(){return new De({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Ft(e,t,r,s,i,n){let a,o;const l=[];switch(t.toUpperCase()){case"SHA-1":a=20,o=64;break;case"SHA-256":a=32,o=64;break;case"SHA-384":a=48,o=128;break;case"SHA-512":a=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const c=new Uint8Array(s),h=new ArrayBuffer(2*s.byteLength+2),u=new Uint8Array(h);for(let e=0;e<c.length;e++)u[2*e]=0,u[2*e+1]=c[e];u[u.length-2]=0,u[u.length-1]=0,s=h.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;const d=i.byteLength,g=o*Math.ceil(d/o),p=new ArrayBuffer(g),b=new Uint8Array(p),y=new Uint8Array(i);for(let e=0;e<g;e++)b[e]=y[e%d];const v=s.byteLength,w=o*Math.ceil(v/o),k=new ArrayBuffer(w),B=new Uint8Array(k),A=new Uint8Array(s);for(let e=0;e<w;e++)B[e]=A[e%v];const S=p.byteLength+k.byteLength;let C=new ArrayBuffer(S),x=new Uint8Array(C);x.set(b),x.set(B,b.length);const N=Math.ceil((r>>3)/a);let L=Promise.resolve(C);for(let r=0;r<=N;r++){L=L.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),r=new Uint8Array(t);return r.set(f),r.set(x,f.length),t});for(let r=0;r<n;r++)L=L.then(r=>e.digest({name:t},new Uint8Array(r)));L=L.then(e=>{const t=new ArrayBuffer(o),r=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)r[s]=e[s%e.length];const s=Math.ceil(d/o)+Math.ceil(v/o),i=[];let n=0,a=o;for(let e=0;e<s;e++){const e=Array.from(new Uint8Array(C.slice(n,n+a)));n+=o,n+o>C.byteLength&&(a=C.byteLength-n);let s=511;for(let i=t.byteLength-1;i>=0;i--)s>>=8,s+=r[i]+e[i],e[i]=255&s;i.push(...e)}return C=new ArrayBuffer(i.length),x=new Uint8Array(C),x.set(i),l.push(...new Uint8Array(e)),C})}return L=L.then(()=>{const e=new ArrayBuffer(r>>3);return new Uint8Array(e).set(new Uint8Array(l).slice(0,r>>3)),e}),L}class Mt{constructor(t={}){this.crypto=e(t,"crypto",{}),this.subtle=e(t,"subtle",{}),this.name=e(t,"name","")}importKey(e,t,r,s,i){let n={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,i);case"spki":{const e=Lt(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const a=new Ot;try{a.fromSchema(e.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["verify"],n.kty="RSA",n.ext=s,n.key_ops=i,"1.2.840.113549.1.1.1"!==a.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+a.algorithm.algorithmId);if("alg"in n==!1)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const e=a.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"ECDSA":i=["verify"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==a.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+a.algorithm.algorithmId);const e=a.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=i,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const e=a.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;default:return Promise.reject("Incorrect algorithm name: "+r.name.toUpperCase())}}break;case"pkcs8":{const e=new Rt,a=Lt(t);if(-1===a.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(a.result)}catch(e){return Promise.reject("Incorrect keyData")}if("parsedKey"in e==!1)return Promise.reject("Incorrect keyData");switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["sign"],n.kty="RSA",n.ext=s,n.key_ops=i,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect private key algorithm: "+e.privateKeyAlgorithm.algorithmId);if("alg"in n==!1)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"ECDSA":i=["sign"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect algorithm: "+e.privateKeyAlgorithm.algorithmId);const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=i,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;default:return Promise.reject("Incorrect algorithm name: "+r.name.toUpperCase())}}break;case"jwk":n=t;break;default:return Promise.reject("Incorrect format: "+e)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",p(JSON.stringify(n)),r,s,i)).then(e=>e,()=>this.subtle.importKey("jwk",n,r,s,i)):this.subtle.importKey("jwk",n,r,s,i)}exportKey(e,t){let r=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(r=r.then(e=>e instanceof ArrayBuffer?JSON.parse(g(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":r=r.then(e=>{const t=new Ot;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(e=>{const t=new Rt;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject("Incorrect format: "+e)}return r}convert(e,t,r,s,i,n){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(r);default:return Promise.reject("Incorrect outputFormat: "+t)}default:return Promise.reject("Incorrect inputFormat: "+e)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==!1)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Kt({schema:e.algorithmParams});if("hashAlgorithm"in r){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in e==!1)return"";t=e.name}else t="SHA-1"}catch(e){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==!1)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==!1)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==!1)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===s)return Promise.reject('Incorrect value for "hmacHashAlgorithm": '+e.hmacHashAlgorithm);let i=Promise.resolve();const n=new ArrayBuffer(16),a=new Uint8Array(n);this.getRandomValues(a);const o=new ArrayBuffer(64),l=new Uint8Array(o);this.getRandomValues(l);const c=new Uint8Array(e.contentToEncrypt),h=new Tt({salt:new Te({valueHex:o}),iterationCount:e.iterationCount,prf:new Pt({algorithmId:s,algorithmParams:new je})});return i=i.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e)),i=i.then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e)),i=i.then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:a},t,c),e=>Promise.reject(e)),i=i.then(s=>{const i=new Jt({keyDerivationFunc:new Pt({algorithmId:r,algorithmParams:h.toSchema()}),encryptionScheme:new Pt({algorithmId:t,algorithmParams:new Te({valueHex:n})})});return new jt({contentType:e.contentType,contentEncryptionAlgorithm:new Pt({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:i.toSchema()}),encryptedContent:new Te({valueHex:s})})},e=>Promise.reject(e)),i}decryptEncryptedContentInfo(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==!1)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject('Unknown "contentEncryptionAlgorithm": '+e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);let t,r,s=Promise.resolve();try{t=new Jt({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}try{r=new Tt({schema:t.keyDerivationFunc.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const i=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in i==!1)return Promise.reject('Incorrect OID for "contentEncryptionAlgorithm": '+t.encryptionScheme.algorithmId);const a=t.encryptionScheme.algorithmParams.valueBlock.valueHex,o=new Uint8Array(a),l=r.salt.valueBlock.valueHex,c=new Uint8Array(l),h=r.iterationCount;let u="SHA-1";if("prf"in r){const e=this.getAlgorithmByOID(r.prf.algorithmId);if("name"in e==!1)return Promise.reject("Incorrect OID for HMAC hash algorithm");u=e.hash.name}return s=s.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e)),s=s.then(e=>this.deriveKey({name:"PBKDF2",hash:{name:u},salt:c,iterations:h},e,i,!1,["decrypt"]),e=>Promise.reject(e)),s=s.then(t=>{let r=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const t of e.encryptedContentInfo.encryptedContent.valueBlock.value)r=n(r,t.valueBlock.valueHex);return this.decrypt({name:i.name,iv:o},t,r)},e=>Promise.reject(e)),s}stampDataWithPassword(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==!1)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==!1)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==!1)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=r.then(()=>Ft(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),r=r.then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["sign"])),r=r.then(t=>this.sign(s,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e)),r}verifyDataStampedWithPassword(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==!1)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==!1)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==!1)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==!1)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=r.then(()=>Ft(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),r=r.then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["verify"])),r=r.then(t=>this.verify(s,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e)),r}getSignatureParameters(e,t="SHA-1"){if(""===this.getOIDByAlgorithm({name:t}))return Promise.reject("Unsupported hash algorithm: "+t);const r=new Pt,s=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(s.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":r.algorithmId=this.getOIDByAlgorithm(s.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":s.algorithm.saltLength=32;break;case"SHA-384":s.algorithm.saltLength=48;break;case"SHA-512":s.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject("Unsupported hash algorithm: "+t);e.hashAlgorithm=new Pt({algorithmId:r,algorithmParams:new je}),e.maskGenAlgorithm=new Pt({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==s.algorithm.saltLength&&(e.saltLength=s.algorithm.saltLength);const i=new Kt(e);r.algorithmId="1.2.840.113549.1.1.10",r.algorithmParams=i.toSchema()}break;default:return Promise.reject("Unsupported signature algorithm: "+e.algorithm.name)}return Promise.resolve().then(()=>({signatureAlgorithm:r,parameters:s}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new qe({valueHex:r}),i=new ArrayBuffer(t);new Uint8Array(i).set(new Uint8Array(e,t,t));const n=new qe({valueHex:i});return new De({value:[s.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject("Signing error: "+e))}fillPublicKeyParameters(e,t){const r={},s=this.getHashAlgorithm(t);if(""===s)return Promise.reject("Unsupported signature algorithm: "+t.algorithmId);let i;i="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const n=this.getAlgorithmByOID(i);if("name"in n==="")return Promise.reject("Unsupported public key algorithm: "+t.algorithmId);if(r.algorithm=this.getAlgorithmParameters(n.name,"importkey"),"hash"in r.algorithm.algorithm&&(r.algorithm.algorithm.hash.name=s),"ECDSA"===n.name){let t=!1;if("algorithmParams"in e.algorithm==!0&&"idBlock"in e.algorithm.algorithmParams&&1===e.algorithm.algorithmParams.idBlock.tagClass&&6===e.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(e.algorithm.algorithmParams.valueBlock.toString());if("name"in s==!1)return Promise.reject("Unsupported named curve algorithm: "+e.algorithm.algorithmParams.valueBlock.toString());r.algorithm.algorithm.namedCurve=s.name}return r}getPublicKey(e,t,r=null){null===r&&(r=this.fillPublicKeyParameters(e,t));const s=e.toSchema().toBER(!1),i=new Uint8Array(s);return this.importKey("spki",i,r.algorithm.algorithm,!0,r.algorithm.usages)}verifyWithPublicKey(e,t,r,s,i=null){let a=Promise.resolve();if(null===i){if(""===(i=this.getHashAlgorithm(s)))return Promise.reject("Unsupported signature algorithm: "+s.algorithmId);a=a.then(()=>this.getPublicKey(r,s))}else{const e={};let t;t="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:r.algorithm.algorithmId;const n=this.getAlgorithmByOID(t);if("name"in n==="")return Promise.reject("Unsupported public key algorithm: "+s.algorithmId);if(e.algorithm=this.getAlgorithmParameters(n.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=i),"ECDSA"===n.name){let t=!1;if("algorithmParams"in r.algorithm==!0&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==!1)return Promise.reject("Unsupported named curve algorithm: "+r.algorithm.algorithmParams.valueBlock.toString());e.algorithm.algorithm.namedCurve=s.name}a=a.then(()=>this.getPublicKey(r,null,e))}return a=a.then(r=>{const a=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in a.algorithm&&(a.algorithm.hash.name=i);let o=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name){o=function(e){if(e instanceof De==!1)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof qe==!1)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof qe==!1)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,n(i,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,n(t.valueBlock.valueHex,i)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);a.set(s,1),a[0]=0;const o=new Uint8Array(r.valueBlock.valueHex),l=new ArrayBuffer(e),c=new Uint8Array(l);return c.set(o,1),c[0]=0,n(i,l)}}return n(t.valueBlock.valueHex,r.valueBlock.valueHex)}(Lt(o).result)}if("RSA-PSS"===r.algorithm.name){let e;try{e=new Kt({schema:s.algorithmParams})}catch(e){return Promise.reject(e)}a.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const r=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in r==!1)return Promise.reject("Unrecognized hash algorithm: "+e.hashAlgorithm.algorithmId);t=r.name}a.algorithm.hash.name=t}return this.verify(a.algorithm,r,new Uint8Array(o),new Uint8Array(e))}),a}}let qt={name:"none",crypto:null,subtle:null};function Wt(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let e;try{e=global[process.pid].pkijs.engine}catch(e){throw new Error('Please call "setEngine" before call to "getEngine"')}return e}return qt}function Gt(){const e=Wt();if(null!==e.subtle)return e.subtle}function $t(e){let t=!1,r="";const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}!function(){if("undefined"!=typeof self&&"crypto"in self){let e="webcrypto";const t=self.crypto;let r;if("webkitSubtle"in self.crypto){try{r=self.crypto.webkitSubtle}catch(e){r=self.crypto.subtle}e="safari"}"subtle"in self.crypto&&(r=self.crypto.subtle),qt=void 0===r?{name:e,crypto:t,subtle:null}:{name:e,crypto:t,subtle:new Mt({name:e,crypto:self.crypto,subtle:r})}}!function(e,t,r){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:t,subtle:r}}else qt={name:e,crypto:t,subtle:r}}(qt.name,qt.crypto,qt.subtle)}();class Qt{constructor(t={}){this.type=e(t,"type",Qt.defaultValues("type")),this.value=e(t,"value",Qt.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error("Invalid member name for AttributeTypeAndValue class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.type||""}),new St({name:r.value||""})]})}static blockName(){return"AttributeTypeAndValue"}fromSchema(e){v(e,["type","typeValue"]);const t=Et(e,e,Qt.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new De({value:[new Qe({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){const t=[Ze.blockName(),rt.blockName(),it.blockName(),ot.blockName(),lt.blockName(),ct.blockName(),ht.blockName(),ut.blockName(),mt.blockName(),ft.blockName(),dt.blockName(),gt.blockName()];if(e.constructor.blockName()===Qt.blockName()){if(this.type!==e.type)return!1;let r=!1;const s=this.value.constructor.blockName();if(s===e.value.constructor.blockName())for(const e of t)if(s===e){r=!0;break}if(r){const t=$t(this.value.valueBlock.value),r=$t(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!1===c(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&c(this.value.valueBeforeDecode,e)}}class zt{constructor(t={}){this.typesAndValues=e(t,"typesAndValues",zt.defaultValues("typesAndValues")),this.valueBeforeDecode=e(t,"valueBeforeDecode",zt.defaultValues("valueBeforeDecode")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.repeatedSequence||"",value:new Re({value:[new Ct({name:r.repeatedSet||"",value:Qt.schema(r.typeAndValue||{})})]})})]})}fromSchema(e){v(e,["RDN","typesAndValues"]);const t=Et(e,e,zt.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Qt({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new De({value:[new Re({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});return Lt(this.valueBeforeDecode).result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof zt){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&c(this.valueBeforeDecode,e)}}function Zt(t={},r=!1){const s=e(t,"names",{});return new De({optional:r,value:[new He({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:s.country_name||"",value:[new At({value:[new ot,new lt]})]}),new He({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:s.administration_domain_name||"",value:[new At({value:[new ot,new lt]})]}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:s.network_address||"",isHexOnly:!0}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:s.terminal_identifier||"",isHexOnly:!0}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:s.private_domain_name||"",value:[new At({value:[new ot,new lt]})]}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:s.organization_name||"",isHexOnly:!0}),new Pe({optional:!0,name:s.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new He({optional:!0,name:s.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new Pe({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new He({optional:!0,name:s.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new Ct({value:new lt})]})]})}function Yt(e=!1){return new De({optional:e,value:[new lt,new lt]})}function Xt(e=!1){return new Re({optional:e,value:[new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new St]})]})}class er{constructor(t={}){this.type=e(t,"type",er.defaultValues("type")),this.value=e(t,"value",er.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error("Invalid member name for GeneralName class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return t===er.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error("Invalid member name for GeneralName class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new At({value:[new He({idBlock:{tagClass:3,tagNumber:0},name:r.blockName||"",value:[new Qe,new He({idBlock:{tagClass:3,tagNumber:0},value:[new St]})]}),new Pe({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new Pe({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new He({idBlock:{tagClass:3,tagNumber:3},name:r.blockName||"",value:[Zt(r.builtInStandardAttributes||{},!1),Yt(!0),Xt(!0)]}),new He({idBlock:{tagClass:3,tagNumber:4},name:r.blockName||"",value:[zt.schema(r.directoryName||{})]}),new He({idBlock:{tagClass:3,tagNumber:5},name:r.blockName||"",value:[new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new At({value:[new ct,new lt,new it,new Ze,new rt]})]}),new He({idBlock:{tagClass:3,tagNumber:1},value:[new At({value:[new ct,new lt,new it,new Ze,new rt]})]})]}),new Pe({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new Pe({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new Pe({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){v(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=Et(e,e,er.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralName");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=e.toBER(!1);this.value=Lt(r).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new zt({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new Te({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=e.toBER(!1);this.value=Lt(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new He({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new ut({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new He({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new Qe({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return er.schema()}}toJSON(){const e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}class tr{constructor(t={}){this.accessMethod=e(t,"accessMethod",tr.defaultValues("accessMethod")),this.accessLocation=e(t,"accessLocation",tr.defaultValues("accessLocation")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new er;default:throw new Error("Invalid member name for AccessDescription class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.accessMethod||""}),er.schema(r.accessLocation||{})]})}fromSchema(e){v(e,["accessMethod","accessLocation"]);const t=Et(e,e,tr.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new er({schema:t.result.accessLocation})}toSchema(){return new De({value:[new Qe({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class rr{constructor(t={}){this.altNames=e(t,"altNames",rr.defaultValues("altNames")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error("Invalid member name for AltName class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.altNames||"",value:er.schema()})]})}fromSchema(e){v(e,["altNames"]);const t=Et(e,e,rr.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new er({schema:e})))}toSchema(){return new De({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class sr{constructor(t={}){this.type=e(t,"type",sr.defaultValues("type")),this.value=e(t,"value",sr.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error("Invalid member name for Time class: "+e)}}static schema(t={},r=!1){const s=e(t,"names",{});return new At({optional:r,value:[new pt({name:s.utcTimeName||""}),new bt({name:s.generalTimeName||""})]})}fromSchema(e){v(e,["utcTimeName","generalTimeName"]);const t=Et(e,e,sr.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Time");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new pt({valueDate:this.value})),1===this.type&&(e=new bt({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class ir{constructor(t={}){this.attributes=e(t,"attributes",ir.defaultValues("attributes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error("Invalid member name for SubjectDirectoryAttributes class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.attributes||"",value:Ut.schema()})]})}fromSchema(e){v(e,["attributes"]);const t=Et(e,e,ir.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new Ut({schema:e}))}toSchema(){return new De({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class nr{constructor(t={}){"notBefore"in t&&(this.notBefore=e(t,"notBefore",nr.defaultValues("notBefore"))),"notAfter"in t&&(this.notAfter=e(t,"notAfter",nr.defaultValues("notAfter"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error("Invalid member name for PrivateKeyUsagePeriod class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Pe({name:r.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Pe({name:r.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){v(e,["notBefore","notAfter"]);const t=Et(e,e,nr.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new bt;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new bt({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:0},valueHex:new bt({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:1},valueHex:new bt({valueDate:this.notAfter}).valueBlock.valueHex})),new De({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}class ar{constructor(t={}){this.cA=e(t,"cA",!1),"pathLenConstraint"in t&&(this.pathLenConstraint=e(t,"pathLenConstraint",0)),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error("Invalid member name for BasicConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ve({optional:!0,name:r.cA||""}),new qe({optional:!0,name:r.pathLenConstraint||""})]})}fromSchema(e){v(e,["cA","pathLenConstraint"]);const t=Et(e,e,ar.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==ar.defaultValues("cA")&&e.push(new Ve({value:this.cA})),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof qe?e.push(this.pathLenConstraint):e.push(new qe({value:this.pathLenConstraint}))),new De({value:e})}toJSON(){const e={};return this.cA!==ar.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof qe?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}class or{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=e(t,"distributionPoint",or.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=e(t,"onlyContainsUserCerts",or.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=e(t,"onlyContainsCACerts",or.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in t&&(this.onlySomeReasons=e(t,"onlySomeReasons",or.defaultValues("onlySomeReasons"))),this.indirectCRL=e(t,"indirectCRL",or.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=e(t,"onlyContainsAttributeCerts",or.defaultValues("onlyContainsAttributeCerts")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error("Invalid member name for IssuingDistributionPoint class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new At({value:[new He({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new Ct({name:r.distributionPointNames||"",value:er.schema()})]}),new He({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:zt.schema().valueBlock.value})]})]}),new Pe({name:r.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Pe({name:r.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new Pe({name:r.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new Pe({name:r.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new Pe({name:r.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){v(e,["distributionPoint","distributionPointNames","onlyContainsUserCerts","onlyContainsCACerts","onlySomeReasons","indirectCRL","onlyContainsAttributeCerts"]);const t=Et(e,e,or.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new er({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new zt({schema:new De({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new He({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new He({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==or.defaultValues("onlyContainsUserCerts")&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==or.defaultValues("onlyContainsCACerts")&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new Pe({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==or.defaultValues("indirectCRL")&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==or.defaultValues("onlyContainsAttributeCerts")&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new De({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==or.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==or.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==or.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==or.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class lr{constructor(t={}){this.names=e(t,"names",lr.defaultValues("names")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error("Invalid member name for GeneralNames class: "+e)}}static schema(t={},r=!1){const s=e(t,"names",{});return new De({optional:r,name:s.blockName||"",value:[new Ct({name:s.generalNames||"",value:er.schema()})]})}fromSchema(e){v(e,["names","generalNames"]);const t=Et(e,e,lr.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new er({schema:e}))}toSchema(){return new De({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class cr{constructor(t={}){this.base=e(t,"base",cr.defaultValues("base")),this.minimum=e(t,"minimum",cr.defaultValues("minimum")),"maximum"in t&&(this.maximum=e(t,"maximum",cr.defaultValues("maximum"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"base":return new er;case"minimum":case"maximum":return 0;default:throw new Error("Invalid member name for GeneralSubtree class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[er.schema(r.base||{}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new qe({name:r.minimum||""})]}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new qe({name:r.maximum||""})]})]})}fromSchema(e){v(e,["base","minimum","maximum"]);const t=Et(e,e,cr.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralSubtree");this.base=new er({schema:t.result.base}),"minimum"in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof qe?this.minimum:new qe({value:this.minimum}),e.push(new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof qe?this.maximum:new qe({value:this.maximum}),e.push(new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new De({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),"maximum"in this&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}class hr{constructor(t={}){"permittedSubtrees"in t&&(this.permittedSubtrees=e(t,"permittedSubtrees",hr.defaultValues("permittedSubtrees"))),"excludedSubtrees"in t&&(this.excludedSubtrees=e(t,"excludedSubtrees",hr.defaultValues("excludedSubtrees"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error("Invalid member name for NameConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ct({name:r.permittedSubtrees||"",value:cr.schema()})]}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Ct({name:r.excludedSubtrees||"",value:cr.schema()})]})]})}fromSchema(e){v(e,["permittedSubtrees","excludedSubtrees"]);const t=Et(e,e,hr.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new cr({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new cr({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),"excludedSubtrees"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new De({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class ur{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=e(t,"distributionPoint",ur.defaultValues("distributionPoint"))),"reasons"in t&&(this.reasons=e(t,"reasons",ur.defaultValues("reasons"))),"cRLIssuer"in t&&(this.cRLIssuer=e(t,"cRLIssuer",ur.defaultValues("cRLIssuer"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new Fe;case"cRLIssuer":return[];default:throw new Error("Invalid member name for DistributionPoint class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new At({value:[new He({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Ct({name:r.distributionPointNames||"",value:er.schema()})]}),new He({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:zt.schema().valueBlock.value})]})]}),new Pe({name:r.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new He({name:r.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new Ct({name:r.cRLIssuerNames||"",value:er.schema()})]})]})}fromSchema(e){v(e,["distributionPoint","distributionPointNames","reasons","cRLIssuer","cRLIssuerNames"]);const t=Et(e,e,ur.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new er({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new zt({schema:new De({value:t.result.distributionPoint.valueBlock.value})}))),"reasons"in t.result&&(this.reasons=new Fe({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new er({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=this.distributionPoint instanceof Array?new He({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new He({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new He({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new De({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class mr{constructor(t={}){this.distributionPoints=e(t,"distributionPoints",mr.defaultValues("distributionPoints")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error("Invalid member name for CRLDistributionPoints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.distributionPoints||"",value:ur.schema()})]})}fromSchema(e){v(e,["distributionPoints"]);const t=Et(e,e,mr.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new ur({schema:e}))}toSchema(){return new De({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class fr{constructor(t={}){this.policyQualifierId=e(t,"policyQualifierId",fr.defaultValues("policyQualifierId")),this.qualifier=e(t,"qualifier",fr.defaultValues("qualifier")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new St;default:throw new Error("Invalid member name for PolicyQualifierInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.policyQualifierId||""}),new St({name:r.qualifier||""})]})}fromSchema(e){v(e,["policyQualifierId","qualifier"]);const t=Et(e,e,fr.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new De({value:[new Qe({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class dr{constructor(t={}){this.policyIdentifier=e(t,"policyIdentifier",dr.defaultValues("policyIdentifier")),"policyQualifiers"in t&&(this.policyQualifiers=e(t,"policyQualifiers",dr.defaultValues("policyQualifiers"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error("Invalid member name for PolicyInformation class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.policyIdentifier||""}),new De({optional:!0,value:[new Ct({name:r.policyQualifiers||"",value:fr.schema()})]})]})}fromSchema(e){v(e,["policyIdentifier","policyQualifiers"]);const t=Et(e,e,dr.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new fr({schema:e})))}toSchema(){const e=[];return e.push(new Qe({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new De({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new De({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class gr{constructor(t={}){this.certificatePolicies=e(t,"certificatePolicies",gr.defaultValues("certificatePolicies")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error("Invalid member name for CertificatePolicies class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.certificatePolicies||"",value:dr.schema()})]})}fromSchema(e){v(e,["certificatePolicies"]);const t=Et(e,e,gr.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new dr({schema:e}))}toSchema(){return new De({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class pr{constructor(t={}){this.issuerDomainPolicy=e(t,"issuerDomainPolicy",pr.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=e(t,"subjectDomainPolicy",pr.defaultValues("subjectDomainPolicy")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error("Invalid member name for PolicyMapping class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.issuerDomainPolicy||""}),new Qe({name:r.subjectDomainPolicy||""})]})}fromSchema(e){v(e,["issuerDomainPolicy","subjectDomainPolicy"]);const t=Et(e,e,pr.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new De({value:[new Qe({value:this.issuerDomainPolicy}),new Qe({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class br{constructor(t={}){this.mappings=e(t,"mappings",br.defaultValues("mappings")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error("Invalid member name for PolicyMappings class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.mappings||"",value:pr.schema()})]})}fromSchema(e){v(e,["mappings"]);const t=Et(e,e,br.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new pr({schema:e}))}toSchema(){return new De({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class yr{constructor(t={}){"keyIdentifier"in t&&(this.keyIdentifier=e(t,"keyIdentifier",yr.defaultValues("keyIdentifier"))),"authorityCertIssuer"in t&&(this.authorityCertIssuer=e(t,"authorityCertIssuer",yr.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in t&&(this.authorityCertSerialNumber=e(t,"authorityCertSerialNumber",yr.defaultValues("authorityCertSerialNumber"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new Te;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new qe;default:throw new Error("Invalid member name for AuthorityKeyIdentifier class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Pe({name:r.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Ct({name:r.authorityCertIssuer||"",value:er.schema()})]}),new Pe({name:r.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){v(e,["keyIdentifier","authorityCertIssuer","authorityCertSerialNumber"]);const t=Et(e,e,yr.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new Te({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new er({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new qe({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return"keyIdentifier"in this&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in this&&e.push(new He({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this&&e.push(new Pe({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHex})),new De({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class vr{constructor(t={}){"requireExplicitPolicy"in t&&(this.requireExplicitPolicy=e(t,"requireExplicitPolicy",vr.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in t&&(this.inhibitPolicyMapping=e(t,"inhibitPolicyMapping",vr.defaultValues("inhibitPolicyMapping"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error("Invalid member name for PolicyConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Pe({name:r.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Pe({name:r.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){v(e,["requireExplicitPolicy","inhibitPolicyMapping"]);const t=Et(e,e,vr.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=Lt(e.toBER(!1));this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=Lt(e.toBER(!1));this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new qe({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new qe({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new De({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class wr{constructor(t={}){this.keyPurposes=e(t,"keyPurposes",wr.defaultValues("keyPurposes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error("Invalid member name for ExtKeyUsage class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.keyPurposes||"",value:new Qe})]})}fromSchema(e){v(e,["keyPurposes"]);const t=Et(e,e,wr.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new De({value:Array.from(this.keyPurposes,e=>new Qe({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class kr{constructor(t={}){this.accessDescriptions=e(t,"accessDescriptions",kr.defaultValues("accessDescriptions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error("Invalid member name for InfoAccess class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.accessDescriptions||"",value:tr.schema()})]})}fromSchema(e){v(e,["accessDescriptions"]);const t=Et(e,e,kr.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new tr({schema:e}))}toSchema(){return new De({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class Br{constructor(e={}){this.clear();for(const t of Object.keys(e))switch(t){case"length":this.length=e.length;break;case"stub":for(let t=0;t<this._view.length;t++)this._view[t]=e.stub;break;case"view":this.fromUint8Array(e.view);break;case"buffer":this.fromArrayBuffer(e.buffer);break;case"string":this.fromString(e.string);break;case"hexstring":this.fromHexString(e.hexstring)}}set buffer(e){this._buffer=e.slice(0),this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this._buffer.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this.buffer=e}fromUint8Array(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}fromString(e){const t=e.length;this.length=t;for(let r=0;r<t;r++)this.view[r]=e.charCodeAt(r)}toString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++)r+=String.fromCharCode(this.view[s]);return r}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const r=new Map;r.set("0",0),r.set("1",1),r.set("2",2),r.set("3",3),r.set("4",4),r.set("5",5),r.set("6",6),r.set("7",7),r.set("8",8),r.set("9",9),r.set("A",10),r.set("a",10),r.set("B",11),r.set("b",11),r.set("C",12),r.set("c",12),r.set("D",13),r.set("d",13),r.set("E",14),r.set("e",14),r.set("F",15),r.set("f",15);let s=0,i=0;for(let n=0;n<t;n++)n%2?(i|=r.get(e.charAt(n)),this.view[s]=i,s++):i=r.get(e.charAt(n))<<4}toHexString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++){const e=this.view[s].toString(16).toUpperCase();r=r+(1==e.length?"0":"")+e}return r}copy(e=0,t=this._buffer.byteLength-e){if(0===e&&0===this._buffer.byteLength)return new Br;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const r=new Br;return r._buffer=this._buffer.slice(e,e+t),r._view=new Uint8Array(r._buffer),r}slice(e=0,t=this._buffer.byteLength){if(0===e&&0===this._buffer.byteLength)return new Br;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const r=new Br;return r._buffer=this._buffer.slice(e,t),r._view=new Uint8Array(r._buffer),r}realloc(e){const t=new ArrayBuffer(e),r=new Uint8Array(t);e>this._view.length?r.set(this._view):r.set(new Uint8Array(this._buffer,0,e)),this._buffer=t.slice(0),this._view=new Uint8Array(this._buffer)}append(e){const t=this._buffer.byteLength,r=e._buffer.byteLength,s=e._view.slice();this.realloc(t+r),this._view.set(s,t)}insert(e,t=0,r=this._buffer.byteLength-t){return!(t>this._buffer.byteLength-1)&&(r>this._buffer.byteLength-t&&(r=this._buffer.byteLength-t),r>e._buffer.byteLength&&(r=e._buffer.byteLength),r==e._buffer.byteLength?this._view.set(e._view,t):this._view.set(e._view.slice(0,r),t),!0)}isEqual(e){if(this._buffer.byteLength!=e._buffer.byteLength)return!1;for(let t=0;t<e._buffer.byteLength;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i=e.buffer.byteLength;if(i>r)return-1;const n=[];for(let t=0;t<i;t++)n.push(e.view[t]);for(let e=0;e<=r-i;e++){let r=!0;const a=s?t-i-e:t+e;for(let e=0;e<i;e++)if(this.view[e+a]!=n[e]){r=!1;break}if(r)return s?t-i-e:t+i+e}return-1}findFirstIn(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i={id:-1,position:s?0:t+r,length:0};for(let n=0;n<e.length;n++){const a=this.findPattern(e[n],t,r,s);if(-1!=a){let t=!1;const r=e[n].length;s?a-r>=i.position-i.length&&(t=!0):a-r<=i.position-i.length&&(t=!0),t&&(i.position=a,i.id=n,i.length=r)}}return i}findAllIn(e,t=0,r=this.buffer.byteLength-t){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={id:-1,position:t};for(;;){const t=i.position;if(i=this.findFirstIn(e,i.position,r),-1==i.id)break;r-=i.position-t,s.push({id:i.id,position:i.position})}return s}findAllPatternIn(e,t=0,r=this.buffer.byteLength-t){null==t&&(t=0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);const s=[],i=e.buffer.byteLength;if(i>r)return-1;const n=Array.from(e.view);for(let e=0;e<=r-i;e++){let r=!0;const a=t+e;for(let e=0;e<i;e++)if(this.view[e+a]!=n[e]){r=!1;break}r&&(s.push(t+i+e),e+=i-1)}return s}findFirstNotIn(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i={left:{id:-1,position:t},right:{id:-1,position:0},value:new Br};let n=r;for(;n>0;){if(i.right=this.findFirstIn(e,s?t-r+n:t+r-n,n,s),-1==i.right.id){r=n,s?t-=r:t=i.left.position,i.value=new Br,i.value._buffer=this._buffer.slice(t,t+r),i.value._view=new Uint8Array(i.value._buffer);break}if(i.right.position!=(s?i.left.position-e[i.right.id].buffer.byteLength:i.left.position+e[i.right.id].buffer.byteLength)){s?(t=i.right.position+e[i.right.id].buffer.byteLength,r=i.left.position-i.right.position-e[i.right.id].buffer.byteLength):(t=i.left.position,r=i.right.position-i.left.position-e[i.right.id].buffer.byteLength),i.value=new Br,i.value._buffer=this._buffer.slice(t,t+r),i.value._view=new Uint8Array(i.value._buffer);break}i.left=i.right,n-=e[i.right.id]._buffer.byteLength}if(s){const e=i.right;i.right=i.left,i.left=e}return i}findAllNotIn(e,t=null,r=null){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={left:{id:-1,position:t},right:{id:-1,position:t},value:new Br};do{const t=i.right.position;i=this.findFirstNotIn(e,i.right.position,r),r-=i.right.position-t,s.push({left:{id:i.left.id,position:i.left.position},right:{id:i.right.id,position:i.right.position},value:i.value})}while(-1!=i.right.id);return s}findFirstSequence(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i=this.skipNotPatterns(e,t,r,s);if(-1==i)return{position:-1,value:new Br};const n=this.skipPatterns(e,i,r-(s?t-i:i-t),s);s?(t=n,r=i-n):(t=i,r=n-i);const a=new Br;return a._buffer=this._buffer.slice(t,t+r),a._view=new Uint8Array(a._buffer),{position:n,value:a}}findAllSequences(e,t=null,r=null){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={position:t,value:new Br};do{const t=i.position;i=this.findFirstSequence(e,i.position,r),-1!=i.position&&(r-=i.position-t,s.push({position:i.position,value:i.value}))}while(-1!=i.position);return s}findPairedPatterns(e,t,r=null,s=null){const i=[];if(e.isEqual(t))return i;if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let n=0;const a=this.findAllPatternIn(e,r,s);if(0==a.length)return i;const o=this.findAllPatternIn(t,r,s);if(0==o.length)return i;for(;n<a.length&&0!=o.length;)if(a[0]!=o[0]){if(a[n]>o[0])break;for(;a[n]<o[0]&&(n++,!(n>=a.length)););i.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else i.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left-t.left),i}findPairedArrays(e,t,r=null,s=null){const i=[];if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let n=0;const a=this.findAllIn(e,r,s);if(0==a.length)return i;const o=this.findAllIn(t,r,s);if(0==o.length)return i;for(;n<a.length&&0!=o.length;)if(a[0].position!=o[0].position){if(a[n].position>o[0].position)break;for(;a[n].position<o[0].position&&(n++,!(n>=a.length)););i.push({left:a[n-1],right:o[0]}),a.splice(n-1,1),o.splice(0,1),n=0}else i.push({left:a[0],right:o[0]}),a.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left.position-t.left.position),i}replacePattern(e,t,r=null,s=null,i=null){let n,a;const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]};if(null==r&&(r=0),r>this.buffer.byteLength-1)return!1;if(null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r),null==i){if(n=this.findAllIn([e],r,s),0==n.length)return o}else n=i;o.searchPatternPositions.push(...Array.from(n,e=>e.position));const l=e.buffer.byteLength-t.buffer.byteLength,c=new ArrayBuffer(this.view.length-n.length*l),h=new Uint8Array(c);for(h.set(new Uint8Array(this.buffer,0,r)),a=0;a<n.length;a++){const s=0==a?r:n[a-1].position;h.set(new Uint8Array(this.buffer,s,n[a].position-e.buffer.byteLength-s),s-a*l),h.set(t.view,n[a].position-e.buffer.byteLength-a*l),o.replacePatternPositions.push(n[a].position-e.buffer.byteLength-a*l)}return a--,h.set(new Uint8Array(this.buffer,n[a].position,this.buffer.byteLength-n[a].position),n[a].position-e.buffer.byteLength+t.buffer.byteLength-a*l),this.buffer=c,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));let i=t;for(let n=0;n<e.length;n++){const a=e[n].buffer.byteLength,o=s?i-a:i;let l=!0;for(let t=0;t<a;t++)if(this.view[t+o]!=e[n].view[t]){l=!1;break}if(l)if(n=-1,s){if(i-=a,i<=0)return i}else if(i+=a,i>=t+r)return i}return i}skipNotPatterns(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));let i=-1;for(let n=0;n<r;n++){for(let r=0;r<e.length;r++){const a=e[r].buffer.byteLength,o=s?t-n-a:t+n;let l=!0;for(let t=0;t<a;t++)if(this.view[t+o]!=e[r].view[t]){l=!1;break}if(l){i=s?t-n:t+n;break}}if(-1!=i)break}return i}}class Ar{constructor(e={}){this.stream=new Br,this._length=0,this.backward=!1,this._start=0,this.appendBlock=0,this.prevLength=0,this.prevStart=0;for(const t of Object.keys(e))switch(t){case"stream":this.stream=e.stream;break;case"backward":this.backward=e.backward,this._start=this.stream.buffer.byteLength;break;case"length":this._length=e.length;break;case"start":this._start=e.start;break;case"appendBlock":this.appendBlock=e.appendBlock;break;case"view":this.stream=new Br({view:e.view});break;case"buffer":this.stream=new Br({buffer:e.buffer});break;case"string":this.stream=new Br({string:e.string});break;case"hexstring":this.stream=new Br({hexstring:e.hexstring})}}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e._buffer.byteLength,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.buffer.byteLength||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream._buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==r)return r;if(this.backward){if(r<this.start-e.buffer.byteLength-t)return-1}else if(r>this.start+e.buffer.byteLength+t)return-1;return this.start=r,r}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==r.id)return r;if(this.backward){if(r.position<this.start-e[r.id].buffer.byteLength-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(r.position>this.start+e[r.id].buffer.byteLength+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=r.position,r}findAllIn(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllIn(e,t,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const r=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==r.left.id&&-1==r.right.id)return r;if(this.backward){if(-1!=r.right.id&&r.right.position<this._start-e[r.right.id]._buffer.byteLength-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Br}}else if(-1!=r.left.id&&r.left.position>this._start+e[r.left.id]._buffer.byteLength+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new Br};return this.backward?-1==r.left.id?this.start=0:this.start=r.left.position:-1==r.right.id?this.start=this._start+this._length:this.start=r.right.position,r}findAllNotIn(e){const t=this.backward?this._start-this._length:this._start;return this._stream.findAllNotIn(e,t,this._length)}findFirstSequence(e,t=null,r=null){(null==t||t>this._length)&&(t=this._length),(null==r||r>t)&&(r=t);const s=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==s.value.buffer.byteLength)return s;if(this.backward){if(s.position<this._start-s.value._buffer.byteLength-r)return{position:-1,value:new Br}}else if(s.position>this._start+s.value._buffer.byteLength+r)return{position:-1,value:new Br};return this.start=s.position,s}findAllSequences(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllSequences(e,t,this.length)}findPairedPatterns(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,i=this.stream.findPairedPatterns(e,t,s,this.length);if(i.length)if(this.backward){if(i[0].right<this.start-t.buffer.byteLength-r)return[]}else if(i[0].left>this.start+e.buffer.byteLength+r)return[];return i}findPairedArrays(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,i=this.stream.findPairedArrays(e,t,s,this.length);if(i.length)if(this.backward){if(i[0].right.position<this.start-t[i[0].right.id].buffer.byteLength-r)return[]}else if(i[0].left.position>this.start+e[i[0].left.id].buffer.byteLength+r)return[];return i}replacePattern(e,t){const r=this.backward?this.start-this.length:this.start;return this.stream.replacePattern(e,t,r,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this._start+e._buffer.byteLength>this._stream._buffer.byteLength&&(e._buffer.byteLength>this.appendBlock&&(this.appendBlock=e._buffer.byteLength+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e._view,this._start),this._length+=2*e._buffer.byteLength,this.start=this._start+e._buffer.byteLength,this.prevLength-=2*e._buffer.byteLength}appendView(e){this._start+e.length>this._stream._buffer.byteLength&&(e.length>this.appendBlock&&(this.appendBlock=e.length+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this._start+1>this._stream._buffer.byteLength&&(1>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this._start+2>this._stream._buffer.byteLength&&(2>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint16Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[1],this._stream._view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this._start+3>this._stream._buffer.byteLength&&(3>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[2],this._stream._view[this._start+1]=r[1],this._stream._view[this._start+2]=r[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this._start+4>this._stream._buffer.byteLength&&(4>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[3],this._stream._view[this._start+1]=r[2],this._stream._view[this._start+2]=r[1],this._stream._view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return[];let r;if(this._length<e&&(e=this._length),this.backward){const t=this._stream._buffer.slice(this._length-e,this._length),s=new Uint8Array(t);r=new Array(e);for(let t=0;t<e;t++)r[e-1-t]=s[t]}else{const t=this._stream._buffer.slice(this._start,this._start+e);r=Array.from(new Uint8Array(t))}return t&&(this.start+=this.backward?-1*e:e),r}getUint16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const r=new Uint16Array(1),s=new Uint8Array(r.buffer);return s[0]=t[1],s[1]=t[0],r[0]}getInt16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const r=new Int16Array(1),s=new Uint8Array(r.buffer);return s[0]=t[1],s[1]=t[0],r[0]}getUint24(e=!0){const t=this.getBlock(3,e);if(t.length<3)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let e=3;e>=1;e--)s[3-e]=t[e-1];return r[0]}getUint32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let e=3;e>=0;e--)s[3-e]=t[e];return r[0]}getInt32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const r=new Int32Array(1),s=new Uint8Array(r.buffer);for(let e=3;e>=0;e--)s[3-e]=t[e];return r[0]}}class Sr{constructor(t={}){this.version=e(t,"version",Sr.defaultValues("version")),this.logID=e(t,"logID",Sr.defaultValues("logID")),this.timestamp=e(t,"timestamp",Sr.defaultValues("timestamp")),this.extensions=e(t,"extensions",Sr.defaultValues("extensions")),this.hashAlgorithm=e(t,"hashAlgorithm",Sr.defaultValues("hashAlgorithm")),this.signatureAlgorithm=e(t,"signatureAlgorithm",Sr.defaultValues("signatureAlgorithm")),this.signature=e(t,"signature",Sr.defaultValues("signature")),"schema"in t&&this.fromSchema(t.schema),"stream"in t&&this.fromStream(t.stream)}static defaultValues(e){switch(e){case"version":return 0;case"logID":case"extensions":return new ArrayBuffer(0);case"timestamp":return new Date(0);case"hashAlgorithm":case"signatureAlgorithm":return"";case"signature":return new St;default:throw new Error("Invalid member name for SignedCertificateTimestamp class: "+e)}}fromSchema(e){if(e instanceof xt==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new Ar({stream:new Br({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(s(new Uint8Array(e.getBlock(8)),8));const r=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(r)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm="none";break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm="sha1";break;case 3:this.hashAlgorithm="sha224";break;case 4:this.hashAlgorithm="sha256";break;case 5:this.hashAlgorithm="sha384";break;case 6:this.hashAlgorithm="sha512";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm="anonymous";break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm="ecdsa";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const i=e.getUint16(),n=Lt(new Uint8Array(e.getBlock(i)).buffer.slice(0));if(-1===n.offset)throw new Error("Object's stream was not correct for SignedCertificateTimestamp");if(this.signature=n.result,t!==47+r+i)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new xt({data:e.stream.buffer})}toStream(){const e=new Ar;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecode.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),r=new Uint8Array(t),s=i(this.timestamp.valueOf(),8);let n,a;switch(r.set(new Uint8Array(s),8-s.byteLength),e.appendView(r),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case"none":n=0;break;case"md5":n=1;break;case"sha1":n=2;break;case"sha224":n=3;break;case"sha256":n=4;break;case"sha384":n=5;break;case"sha512":n=6;break;default:throw new Error("Incorrect data for hashAlgorithm: "+this.hashAlgorithm)}switch(e.appendChar(n),this.signatureAlgorithm.toLowerCase()){case"anonymous":a=0;break;case"rsa":a=1;break;case"dsa":a=2;break;case"ecdsa":a=3;break;default:throw new Error("Incorrect data for signatureAlgorithm: "+this.signatureAlgorithm)}e.appendChar(a);const o=this.signature.toBER(!1);return e.appendUint16(o.byteLength),e.appendView(new Uint8Array(o)),e}toJSON(){return{version:this.version,logID:t(this.logID),timestamp:this.timestamp,extensions:t(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,r=0){let s,n=f(g(this.logID)),a=null,o=new Ar;for(const t of e)if(t.log_id===n){a=t.key;break}if(null===a)throw new Error("Public key not found for CT with logId: "+n);const l=Lt(p(d(a)));if(-1===l.offset)throw new Error("Incorrect key value for CT Log with logId: "+n);s=new Ot({schema:l.result}),o.appendChar(0),o.appendChar(0);const c=new ArrayBuffer(8),h=new Uint8Array(c),u=i(this.timestamp.valueOf(),8);return h.set(new Uint8Array(u),8-u.byteLength),o.appendView(h),o.appendUint16(r),0===r&&o.appendUint24(t.byteLength),o.appendView(new Uint8Array(t)),o.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&o.appendView(new Uint8Array(this.extensions)),Wt().subtle.verifyWithPublicKey(o._stream._buffer.slice(0,o._length),{valueBlock:{valueHex:this.signature.toBER(!1)}},s,{algorithmId:""},"SHA-256")}}class Cr{constructor(t={}){this.timestamps=e(t,"timestamps",Cr.defaultValues("timestamps")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"timestamps":return[];default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static compareWithDefault(e,t){switch(e){case"timestamps":return 0===t.length;default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static schema(t={}){const r=e(t,"names",{});return"optional"in r==!1&&(r.optional=!1),new Te({name:r.blockName||"SignedCertificateTimestampList",optional:r.optional})}fromSchema(e){if(e instanceof Te==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new Ar({stream:new Br({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new Sr({stream:t}))}toSchema(){const e=new Ar;let t=0;const r=[];for(const e of this.timestamps){const s=e.toStream();r.push(s),t+=s.stream.buffer.byteLength}e.appendUint16(t);for(const t of r)e.appendView(t.stream.view);return new Te({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}class xr{constructor(t={}){this.templateID=e(t,"templateID",xr.defaultValues("templateID")),"templateMajorVersion"in t&&(this.templateMajorVersion=e(t,"templateMajorVersion",xr.defaultValues("templateMajorVersion"))),"templateMinorVersion"in t&&(this.templateMinorVersion=e(t,"templateMinorVersion",xr.defaultValues("templateMinorVersion"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"templateID":return"";case"templateMajorVersion":case"templateMinorVersion":return 0;default:throw new Error("Invalid member name for CertificateTemplate class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.templateID||""}),new qe({name:r.templateMajorVersion||"",optional:!0}),new qe({name:r.templateMinorVersion||"",optional:!0})]})}fromSchema(e){v(e,["templateID","templateMajorVersion","templateMinorVersion"]);let t=Et(e,e,xr.schema({names:{templateID:"templateID",templateMajorVersion:"templateMajorVersion",templateMinorVersion:"templateMinorVersion"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificateTemplate");this.templateID=t.result.templateID.valueBlock.toString(),"templateMajorVersion"in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),"templateMinorVersion"in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new Qe({value:this.templateID})),"templateMajorVersion"in this&&e.push(new qe({value:this.templateMajorVersion})),"templateMinorVersion"in this&&e.push(new qe({value:this.templateMinorVersion})),new De({value:e})}toJSON(){const e={extnID:this.templateID};return"templateMajorVersion"in this&&(e.templateMajorVersion=this.templateMajorVersion),"templateMinorVersion"in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}class Nr{constructor(t={}){this.certificateIndex=e(t,"certificateIndex",Nr.defaultValues("certificateIndex")),this.keyIndex=e(t,"keyIndex",Nr.defaultValues("keyIndex")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"certificateIndex":case"keyIndex":return 0;default:throw new Error("Invalid member name for CAVersion class: "+e)}}static schema(e={}){return new qe}fromSchema(e){if(e.constructor.blockName()!==qe.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const r=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r.slice(0,4)),t=e.slice(0)}}const s=t.slice(0,2),i=new Uint8Array(s);let n=i[0];i[0]=i[1],i[1]=n;const a=new Uint16Array(s);this.keyIndex=a[0];const o=t.slice(2),l=new Uint8Array(o);n=l[0],l[0]=l[1],l[1]=n;const c=new Uint16Array(o);this.certificateIndex=c[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let r=t[0];t[0]=t[1],t[1]=r;const s=new ArrayBuffer(2);new Uint16Array(s)[0]=this.keyIndex;const i=new Uint8Array(s);return r=i[0],i[0]=i[1],i[1]=r,new qe({valueHex:n(s,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}class Lr{constructor(t={}){this.id=e(t,"id",Lr.defaultValues("id")),"type"in t&&(this.type=e(t,"type",Lr.defaultValues("type"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"id":return"";case"type":return new je;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case"type":return t instanceof je;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.id||""}),new St({name:r.type||"",optional:!0})]})}fromSchema(e){v(e,["id","type"]);const t=Et(e,e,Lr.schema({names:{id:"id",type:"type"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatement");this.id=t.result.id.valueBlock.toString(),"type"in t.result&&(this.type=t.result.type)}toSchema(){const e=[new Qe({value:this.id})];return"type"in this&&e.push(this.type),new De({value:e})}toJSON(){const e={id:this.id};return"type"in this&&(e.type=this.type.toJSON()),e}}class Er{constructor(t={}){this.values=e(t,"values",Er.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"values":return[];default:throw new Error("Invalid member name for QCStatements class: "+e)}}static compareWithDefault(e,t){switch(e){case"values":return 0===t.length;default:throw new Error("Invalid member name for QCStatements class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Ct({name:r.values||"",value:Lr.schema(r.value||{})})]})}fromSchema(e){v(e,["values"]);const t=Et(e,e,Er.schema({names:{values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatements");this.values=Array.from(t.result.values,e=>new Lr({schema:e}))}toSchema(){return new De({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.values,e=>e.toJSON())}}}class Pr{constructor(t={}){this.extnID=e(t,"extnID",Pr.defaultValues("extnID")),this.critical=e(t,"critical",Pr.defaultValues("critical")),this.extnValue="extnValue"in t?new Te({valueHex:t.extnValue}):Pr.defaultValues("extnValue"),"parsedValue"in t&&(this.parsedValue=e(t,"parsedValue",Pr.defaultValues("parsedValue"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new Te;case"parsedValue":return{};default:throw new Error("Invalid member name for Extension class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[new Qe({name:r.extnID||""}),new Ve({name:r.critical||"",optional:!0}),new Te({name:r.extnValue||""})]})}fromSchema(e){v(e,["extnID","critical","extnValue"]);let t=Et(e,e,Pr.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extension");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,t=Lt(this.extnValue.valueBlock.valueHex),-1!==t.offset)switch(this.extnID){case"2.5.29.9":try{this.parsedValue=new ir({schema:t.result})}catch(e){this.parsedValue=new ir,this.parsedValue.parsingError="Incorrectly formated SubjectDirectoryAttributes"}break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":try{this.parsedValue=new nr({schema:t.result})}catch(e){this.parsedValue=new nr,this.parsedValue.parsingError="Incorrectly formated PrivateKeyUsagePeriod"}break;case"2.5.29.17":case"2.5.29.18":try{this.parsedValue=new rr({schema:t.result})}catch(e){this.parsedValue=new rr,this.parsedValue.parsingError="Incorrectly formated AltName"}break;case"2.5.29.19":try{this.parsedValue=new ar({schema:t.result})}catch(e){this.parsedValue=new ar,this.parsedValue.parsingError="Incorrectly formated BasicConstraints"}break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":try{this.parsedValue=new or({schema:t.result})}catch(e){this.parsedValue=new or,this.parsedValue.parsingError="Incorrectly formated IssuingDistributionPoint"}break;case"2.5.29.29":try{this.parsedValue=new lr({schema:t.result})}catch(e){this.parsedValue=new lr,this.parsedValue.parsingError="Incorrectly formated GeneralNames"}break;case"2.5.29.30":try{this.parsedValue=new hr({schema:t.result})}catch(e){this.parsedValue=new hr,this.parsedValue.parsingError="Incorrectly formated NameConstraints"}break;case"2.5.29.31":case"2.5.29.46":try{this.parsedValue=new mr({schema:t.result})}catch(e){this.parsedValue=new mr,this.parsedValue.parsingError="Incorrectly formated CRLDistributionPoints"}break;case"2.5.29.32":case"1.3.6.1.4.1.311.21.10":try{this.parsedValue=new gr({schema:t.result})}catch(e){this.parsedValue=new gr,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.33":try{this.parsedValue=new br({schema:t.result})}catch(e){this.parsedValue=new br,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.35":try{this.parsedValue=new yr({schema:t.result})}catch(e){this.parsedValue=new yr,this.parsedValue.parsingError="Incorrectly formated AuthorityKeyIdentifier"}break;case"2.5.29.36":try{this.parsedValue=new vr({schema:t.result})}catch(e){this.parsedValue=new vr,this.parsedValue.parsingError="Incorrectly formated PolicyConstraints"}break;case"2.5.29.37":try{this.parsedValue=new wr({schema:t.result})}catch(e){this.parsedValue=new wr,this.parsedValue.parsingError="Incorrectly formated ExtKeyUsage"}break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":try{this.parsedValue=new kr({schema:t.result})}catch(e){this.parsedValue=new kr,this.parsedValue.parsingError="Incorrectly formated InfoAccess"}break;case"1.3.6.1.4.1.11129.2.4.2":try{this.parsedValue=new Cr({schema:t.result})}catch(e){this.parsedValue=new Cr,this.parsedValue.parsingError="Incorrectly formated SignedCertificateTimestampList"}break;case"1.3.6.1.4.1.311.20.2":case"1.3.6.1.4.1.311.21.2":this.parsedValue=t.result;break;case"1.3.6.1.4.1.311.21.7":try{this.parsedValue=new xr({schema:t.result})}catch(e){this.parsedValue=new xr,this.parsedValue.parsingError="Incorrectly formated CertificateTemplate"}break;case"1.3.6.1.4.1.311.21.1":try{this.parsedValue=new Nr({schema:t.result})}catch(e){this.parsedValue=new Nr,this.parsedValue.parsingError="Incorrectly formated CAVersion"}break;case"1.3.6.1.5.5.7.1.3":try{this.parsedValue=new Er({schema:t.result})}catch(e){this.parsedValue=new Er,this.parsedValue.parsingError="Incorrectly formated QCStatements"}}}toSchema(){const e=[];return e.push(new Qe({value:this.extnID})),this.critical!==Pr.defaultValues("critical")&&e.push(new Ve({value:this.critical})),e.push(this.extnValue),new De({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Pr.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&"toJSON"in this.parsedValue&&(e.parsedValue=this.parsedValue.toJSON()),e}}class Ir{constructor(t={}){this.extensions=e(t,"extensions",Ir.defaultValues("extensions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error("Invalid member name for Extensions class: "+e)}}static schema(t={},r=!1){const s=e(t,"names",{});return new De({optional:r,name:s.blockName||"",value:[new Ct({name:s.extensions||"",value:Pr.schema(s.extension||{})})]})}fromSchema(e){v(e,["extensions"]);const t=Et(e,e,Ir.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extensions");this.extensions=Array.from(t.result.extensions,e=>new Pr({schema:e}))}toSchema(){return new De({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}function Hr(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"tbsCertificate",value:[new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new qe({name:r.tbsCertificateVersion||"tbsCertificate.version"})]}),new qe({name:r.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),Pt.schema(r.signature||{names:{blockName:"tbsCertificate.signature"}}),zt.schema(r.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new De({name:r.tbsCertificateValidity||"tbsCertificate.validity",value:[sr.schema(r.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),sr.schema(r.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),zt.schema(r.subject||{names:{blockName:"tbsCertificate.subject"}}),Ot.schema(r.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new Pe({name:r.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Pe({name:r.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new He({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Ir.schema(r.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}class Or{constructor(t={}){this.tbs=e(t,"tbs",Or.defaultValues("tbs")),this.version=e(t,"version",Or.defaultValues("version")),this.serialNumber=e(t,"serialNumber",Or.defaultValues("serialNumber")),this.signature=e(t,"signature",Or.defaultValues("signature")),this.issuer=e(t,"issuer",Or.defaultValues("issuer")),this.notBefore=e(t,"notBefore",Or.defaultValues("notBefore")),this.notAfter=e(t,"notAfter",Or.defaultValues("notAfter")),this.subject=e(t,"subject",Or.defaultValues("subject")),this.subjectPublicKeyInfo=e(t,"subjectPublicKeyInfo",Or.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in t&&(this.issuerUniqueID=e(t,"issuerUniqueID",Or.defaultValues("issuerUniqueID"))),"subjectUniqueID"in t&&(this.subjectUniqueID=e(t,"subjectUniqueID",Or.defaultValues("subjectUniqueID"))),"extensions"in t&&(this.extensions=e(t,"extensions",Or.defaultValues("extensions"))),this.signatureAlgorithm=e(t,"signatureAlgorithm",Or.defaultValues("signatureAlgorithm")),this.signatureValue=e(t,"signatureValue",Or.defaultValues("signatureValue")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new qe;case"signature":return new Pt;case"issuer":return new zt;case"notBefore":case"notAfter":return new sr;case"subject":return new zt;case"subjectPublicKeyInfo":return new Ot;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new Pt;case"signatureValue":return new Fe;default:throw new Error("Invalid member name for Certificate class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new De({name:r.blockName||"",value:[Hr(r.tbsCertificate),Pt.schema(r.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new Fe({name:r.signatureValue||"signatureValue"})]})}fromSchema(e){v(e,["tbsCertificate","tbsCertificate.extensions","tbsCertificate.version","tbsCertificate.serialNumber","tbsCertificate.signature","tbsCertificate.issuer","tbsCertificate.notBefore","tbsCertificate.notAfter","tbsCertificate.subject","tbsCertificate.subjectPublicKeyInfo","tbsCertificate.issuerUniqueID","tbsCertificate.subjectUniqueID","signatureAlgorithm","signatureValue"]);const t=Et(e,e,Or.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Certificate");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new Pt({schema:t.result["tbsCertificate.signature"]}),this.issuer=new zt({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new sr({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new sr({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new zt({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new Ot({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.subjectUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new Pr({schema:e}))),this.signatureAlgorithm=new Pt({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==Or.defaultValues("version")&&e.push(new He({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new qe({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new De({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new Pe({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"extensions"in this&&e.push(new He({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new De({value:Array.from(this.extensions,e=>e.toSchema())})]})),new De({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return Or.schema().value[0];t=Lt(this.tbs).result}else t=this.encodeTBS();return new De({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:t(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==Or.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=t(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=t(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){return Wt().subtle.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}getKeyHash(e="SHA-1"){const t=Gt();return void 0===t?Promise.reject("Unable to create WebCrypto object"):t.digest({name:e},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const i=Wt();return s=s.then(()=>i.subtle.getSignatureParameters(e,t)),s=s.then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm}),s=s.then(()=>{this.tbs=this.encodeTBS().toBER(!1)}),s=s.then(()=>i.subtle.signWithPrivateKey(this.tbs,e,r)),s=s.then(e=>{this.signatureValue=new Fe({valueHex:e})}),s}verify(e=null){let t={};return null!==e?t=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(t=this.subjectPublicKeyInfo),t instanceof Ot==!1?Promise.reject("Please provide issuer certificate as a parameter"):Wt().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,t,this.signatureAlgorithm)}}const Ur=/[^\0-\x7E]/,_r=/[\x2E\u3002\uFF0E\uFF61]/g,Vr={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},Dr=Math.floor,Rr=String.fromCharCode;function jr(e){throw new RangeError(Vr[e])}const Kr=function(e,t){return e+22+75*(e<26)-((0!=t)<<5)},Tr=function(e,t,r){let s=0;for(e=r?Dr(e/700):e>>1,e+=Dr(e/t);e>455;s+=36)e=Dr(e/35);return Dr(s+36*e/(e+38))},Jr=new WeakMap,Fr=e=>"function"==typeof e&&Jr.has(e),Mr="undefined"!=typeof window&&null!=window.customElements&&void 0!==window.customElements.polyfillWrapFlushCallback,qr=(e,t,r=null)=>{for(;t!==r;){const r=t.nextSibling;e.removeChild(t),t=r}},Wr={},Gr={},$r=`{{lit-${String(Math.random()).slice(2)}}}`,Qr=`\x3c!--${$r}--\x3e`,zr=new RegExp(`${$r}|${Qr}`);class Zr{constructor(e,t){this.parts=[],this.element=t;const r=[],s=[],i=document.createTreeWalker(t.content,133,null,!1);let n=0,a=-1,o=0;const{strings:l,values:{length:c}}=e;for(;o<c;){const e=i.nextNode();if(null!==e){if(a++,1===e.nodeType){if(e.hasAttributes()){const t=e.attributes,{length:r}=t;let s=0;for(let e=0;e<r;e++)Yr(t[e].name,"$lit$")&&s++;for(;s-- >0;){const t=l[o],r=ts.exec(t)[2],s=r.toLowerCase()+"$lit$",i=e.getAttribute(s);e.removeAttribute(s);const n=i.split(zr);this.parts.push({type:"attribute",index:a,name:r,strings:n}),o+=n.length-1}}"TEMPLATE"===e.tagName&&(s.push(e),i.currentNode=e.content)}else if(3===e.nodeType){const t=e.data;if(t.indexOf($r)>=0){const s=e.parentNode,i=t.split(zr),n=i.length-1;for(let t=0;t<n;t++){let r,n=i[t];if(""===n)r=es();else{const e=ts.exec(n);null!==e&&Yr(e[2],"$lit$")&&(n=n.slice(0,e.index)+e[1]+e[2].slice(0,-"$lit$".length)+e[3]),r=document.createTextNode(n)}s.insertBefore(r,e),this.parts.push({type:"node",index:++a})}""===i[n]?(s.insertBefore(es(),e),r.push(e)):e.data=i[n],o+=n}}else if(8===e.nodeType)if(e.data===$r){const t=e.parentNode;null!==e.previousSibling&&a!==n||(a++,t.insertBefore(es(),e)),n=a,this.parts.push({type:"node",index:a}),null===e.nextSibling?e.data="":(r.push(e),a--),o++}else{let t=-1;for(;-1!==(t=e.data.indexOf($r,t+1));)this.parts.push({type:"node",index:-1}),o++}}else i.currentNode=s.pop()}for(const e of r)e.parentNode.removeChild(e)}}const Yr=(e,t)=>{const r=e.length-t.length;return r>=0&&e.slice(r)===t},Xr=e=>-1!==e.index,es=()=>document.createComment(""),ts=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class rs{constructor(e,t,r){this.__parts=[],this.template=e,this.processor=t,this.options=r}update(e){let t=0;for(const r of this.__parts)void 0!==r&&r.setValue(e[t]),t++;for(const e of this.__parts)void 0!==e&&e.commit()}_clone(){const e=Mr?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=[],r=this.template.parts,s=document.createTreeWalker(e,133,null,!1);let i,n=0,a=0,o=s.nextNode();for(;n<r.length;)if(i=r[n],Xr(i)){for(;a<i.index;)a++,"TEMPLATE"===o.nodeName&&(t.push(o),s.currentNode=o.content),null===(o=s.nextNode())&&(s.currentNode=t.pop(),o=s.nextNode());if("node"===i.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(o.previousSibling),this.__parts.push(e)}else this.__parts.push(...this.processor.handleAttributeExpressions(o,i.name,i.strings,this.options));n++}else this.__parts.push(void 0),n++;return Mr&&(document.adoptNode(e),customElements.upgrade(e)),e}}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const ss=` ${$r} `;class is{constructor(e,t,r,s){this.strings=e,this.values=t,this.type=r,this.processor=s}getHTML(){const e=this.strings.length-1;let t="",r=!1;for(let s=0;s<e;s++){const e=this.strings[s],i=e.lastIndexOf("\x3c!--");r=(i>-1||r)&&-1===e.indexOf("--\x3e",i+1);const n=ts.exec(e);t+=null===n?e+(r?ss:Qr):e.substr(0,n.index)+n[1]+n[2]+"$lit$"+n[3]+$r}return t+=this.strings[e],t}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const ns=e=>null===e||!("object"==typeof e||"function"==typeof e),as=e=>Array.isArray(e)||!(!e||!e[Symbol.iterator]);class os{constructor(e,t,r){this.dirty=!0,this.element=e,this.name=t,this.strings=r,this.parts=[];for(let e=0;e<r.length-1;e++)this.parts[e]=this._createPart()}_createPart(){return new ls(this)}_getValue(){const e=this.strings,t=e.length-1;let r="";for(let s=0;s<t;s++){r+=e[s];const t=this.parts[s];if(void 0!==t){const e=t.value;if(ns(e)||!as(e))r+="string"==typeof e?e:String(e);else for(const t of e)r+="string"==typeof t?t:String(t)}}return r+=e[t],r}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class ls{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===Wr||ns(e)&&e===this.value||(this.value=e,Fr(e)||(this.committer.dirty=!0))}commit(){for(;Fr(this.value);){const e=this.value;this.value=Wr,e(this)}this.value!==Wr&&this.committer.commit()}}class cs{constructor(e){this.value=void 0,this.__pendingValue=void 0,this.options=e}appendInto(e){this.startNode=e.appendChild(es()),this.endNode=e.appendChild(es())}insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}appendIntoPart(e){e.__insert(this.startNode=es()),e.__insert(this.endNode=es())}insertAfterPart(e){e.__insert(this.startNode=es()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this.__pendingValue=e}commit(){if(null===this.startNode.parentNode)return;for(;Fr(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=Wr,e(this)}const e=this.__pendingValue;e!==Wr&&(ns(e)?e!==this.value&&this.__commitText(e):e instanceof is?this.__commitTemplateResult(e):e instanceof Node?this.__commitNode(e):as(e)?this.__commitIterable(e):e===Gr?(this.value=Gr,this.clear()):this.__commitText(e))}__insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}__commitNode(e){this.value!==e&&(this.clear(),this.__insert(e),this.value=e)}__commitText(e){const t=this.startNode.nextSibling,r="string"==typeof(e=null==e?"":e)?e:String(e);t===this.endNode.previousSibling&&3===t.nodeType?t.data=r:this.__commitNode(document.createTextNode(r)),this.value=e}__commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof rs&&this.value.template===t)this.value.update(e.values);else{const r=new rs(t,e.processor,this.options),s=r._clone();r.update(e.values),this.__commitNode(s),this.value=r}}__commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());const t=this.value;let r,s=0;for(const i of e)r=t[s],void 0===r&&(r=new cs(this.options),t.push(r),0===s?r.appendIntoPart(this):r.insertAfterPart(t[s-1])),r.setValue(i),r.commit(),s++;s<t.length&&(t.length=s,this.clear(r&&r.endNode))}clear(e=this.startNode){qr(this.startNode.parentNode,e.nextSibling,this.endNode)}}class hs{constructor(e,t,r){if(this.value=void 0,this.__pendingValue=void 0,2!==r.length||""!==r[0]||""!==r[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=r}setValue(e){this.__pendingValue=e}commit(){for(;Fr(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=Wr,e(this)}if(this.__pendingValue===Wr)return;const e=!!this.__pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name),this.value=e),this.__pendingValue=Wr}}class us extends os{constructor(e,t,r){super(e,t,r),this.single=2===r.length&&""===r[0]&&""===r[1]}_createPart(){return new ms(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class ms extends ls{}let fs=!1;(()=>{try{const e={get capture(){return fs=!0,!1}};window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}})();class ds{constructor(e,t,r){this.value=void 0,this.__pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=r,this.__boundHandleEvent=e=>this.handleEvent(e)}setValue(e){this.__pendingValue=e}commit(){for(;Fr(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=Wr,e(this)}if(this.__pendingValue===Wr)return;const e=this.__pendingValue,t=this.value,r=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive),s=null!=e&&(null==t||r);r&&this.element.removeEventListener(this.eventName,this.__boundHandleEvent,this.__options),s&&(this.__options=gs(e),this.element.addEventListener(this.eventName,this.__boundHandleEvent,this.__options)),this.value=e,this.__pendingValue=Wr}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}const gs=e=>e&&(fs?{capture:e.capture,passive:e.passive,once:e.once}:e.capture)
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */;const ps=new class{handleAttributeExpressions(e,t,r,s){const i=t[0];if("."===i){return new us(e,t.slice(1),r).parts}if("@"===i)return[new ds(e,t.slice(1),s.eventContext)];if("?"===i)return[new hs(e,t.slice(1),r)];return new os(e,t,r).parts}handleTextExpression(e){return new cs(e)}};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function bs(e){let t=ys.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},ys.set(e.type,t));let r=t.stringsArray.get(e.strings);if(void 0!==r)return r;const s=e.strings.join($r);return r=t.keyString.get(s),void 0===r&&(r=new Zr(e,e.getTemplateElement()),t.keyString.set(s,r)),t.stringsArray.set(e.strings,r),r}const ys=new Map,vs=new WeakMap,ws=(e,t,r)=>{let s=vs.get(t);void 0===s&&(qr(t,t.firstChild),vs.set(t,s=new cs(Object.assign({templateFactory:bs},r))),s.appendInto(t)),s.setValue(e),s.commit()};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"undefined"!=typeof window&&(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.2.1");const ks=(Bs=e=>t=>{let r;if(t instanceof ds||t instanceof cs)throw new Error("The `live` directive is not allowed on text or event bindings");if(t instanceof hs)As(t.strings),r=t.element.hasAttribute(t.name),t.value=r;else{const{element:s,name:i,strings:n}=t.committer;if(As(n),t instanceof ms){if(r=s[i],r===e)return}else t instanceof ls&&(r=s.getAttribute(i));if(r===String(e))return}t.setValue(e)},(...e)=>{const t=Bs(...e);return Jr.set(t,!0),t});
/**
 * @license
 * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */var Bs;const As=e=>{if(2!==e.length||""!==e[0]||""!==e[1])throw new Error("`live` bindings can only contain a single expression")};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function Ss(e,t){const{element:{content:r},parts:s}=e,i=document.createTreeWalker(r,133,null,!1);let n=xs(s),a=s[n],o=-1,l=0;const c=[];let h=null;for(;i.nextNode();){o++;const e=i.currentNode;for(e.previousSibling===h&&(h=null),t.has(e)&&(c.push(e),null===h&&(h=e)),null!==h&&l++;void 0!==a&&a.index===o;)a.index=null!==h?-1:a.index-l,n=xs(s,n),a=s[n]}c.forEach(e=>e.parentNode.removeChild(e))}const Cs=e=>{let t=11===e.nodeType?0:1;const r=document.createTreeWalker(e,133,null,!1);for(;r.nextNode();)t++;return t},xs=(e,t=-1)=>{for(let r=t+1;r<e.length;r++){const t=e[r];if(Xr(t))return r}return-1};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const Ns=(e,t)=>`${e}--${t}`;let Ls=!0;void 0===window.ShadyCSS?Ls=!1:void 0===window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."),Ls=!1);const Es=e=>t=>{const r=Ns(t.type,e);let s=ys.get(r);void 0===s&&(s={stringsArray:new WeakMap,keyString:new Map},ys.set(r,s));let i=s.stringsArray.get(t.strings);if(void 0!==i)return i;const n=t.strings.join($r);if(i=s.keyString.get(n),void 0===i){const r=t.getTemplateElement();Ls&&window.ShadyCSS.prepareTemplateDom(r,e),i=new Zr(t,r),s.keyString.set(n,i)}return s.stringsArray.set(t.strings,i),i},Ps=["html","svg"],Is=new Set,Hs=(e,t,r)=>{Is.add(e);const s=r?r.element:document.createElement("template"),i=t.querySelectorAll("style"),{length:n}=i;if(0===n)return void window.ShadyCSS.prepareTemplateStyles(s,e);const a=document.createElement("style");for(let e=0;e<n;e++){const t=i[e];t.parentNode.removeChild(t),a.textContent+=t.textContent}(e=>{Ps.forEach(t=>{const r=ys.get(Ns(t,e));void 0!==r&&r.keyString.forEach(e=>{const{element:{content:t}}=e,r=new Set;Array.from(t.querySelectorAll("style")).forEach(e=>{r.add(e)}),Ss(e,r)})})})(e);const o=s.content;r?function(e,t,r=null){const{element:{content:s},parts:i}=e;if(null==r)return void s.appendChild(t);const n=document.createTreeWalker(s,133,null,!1);let a=xs(i),o=0,l=-1;for(;n.nextNode();){l++;for(n.currentNode===r&&(o=Cs(t),r.parentNode.insertBefore(t,r));-1!==a&&i[a].index===l;){if(o>0){for(;-1!==a;)i[a].index+=o,a=xs(i,a);return}a=xs(i,a)}}}(r,a,o.firstChild):o.insertBefore(a,o.firstChild),window.ShadyCSS.prepareTemplateStyles(s,e);const l=o.querySelector("style");if(window.ShadyCSS.nativeShadow&&null!==l)t.insertBefore(l.cloneNode(!0),t.firstChild);else if(r){o.insertBefore(a,o.firstChild);const e=new Set;e.add(a),Ss(r,e)}};window.JSCompiler_renameProperty=(e,t)=>e;const Os={toAttribute(e,t){switch(t){case Boolean:return e?"":null;case Object:case Array:return null==e?e:JSON.stringify(e)}return e},fromAttribute(e,t){switch(t){case Boolean:return null!==e;case Number:return null===e?null:Number(e);case Object:case Array:return JSON.parse(e)}return e}},Us=(e,t)=>t!==e&&(t==t||e==e),_s={attribute:!0,type:String,converter:Os,reflect:!1,hasChanged:Us};class Vs extends HTMLElement{constructor(){super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=new Promise(e=>this._enableUpdatingResolver=e),this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}static get observedAttributes(){this.finalize();const e=[];return this._classProperties.forEach((t,r)=>{const s=this._attributeNameForProperty(r,t);void 0!==s&&(this._attributeToPropertyMap.set(s,r),e.push(s))}),e}static _ensureClassProperties(){if(!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties",this))){this._classProperties=new Map;const e=Object.getPrototypeOf(this)._classProperties;void 0!==e&&e.forEach((e,t)=>this._classProperties.set(t,e))}}static createProperty(e,t=_s){if(this._ensureClassProperties(),this._classProperties.set(e,t),t.noAccessor||this.prototype.hasOwnProperty(e))return;const r="symbol"==typeof e?Symbol():"__"+e,s=this.getPropertyDescriptor(e,r,t);void 0!==s&&Object.defineProperty(this.prototype,e,s)}static getPropertyDescriptor(e,t,r){return{get(){return this[t]},set(r){const s=this[e];this[t]=r,this._requestUpdate(e,s)},configurable:!0,enumerable:!0}}static getPropertyOptions(e){return this._classProperties&&this._classProperties.get(e)||_s}static finalize(){const e=Object.getPrototypeOf(this);if(e.hasOwnProperty("finalized")||e.finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),..."function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[]];for(const r of t)this.createProperty(r,e[r])}}static _attributeNameForProperty(e,t){const r=t.attribute;return!1===r?void 0:"string"==typeof r?r:"string"==typeof e?e.toLowerCase():void 0}static _valueHasChanged(e,t,r=Us){return r(e,t)}static _propertyValueFromAttribute(e,t){const r=t.type,s=t.converter||Os,i="function"==typeof s?s:s.fromAttribute;return i?i(e,r):e}static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const r=t.type,s=t.converter;return(s&&s.toAttribute||Os.toAttribute)(e,r)}initialize(){this._saveInstanceProperties(),this._requestUpdate()}_saveInstanceProperties(){this.constructor._classProperties.forEach((e,t)=>{if(this.hasOwnProperty(t)){const e=this[t];delete this[t],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(t,e)}})}_applyInstanceProperties(){this._instanceProperties.forEach((e,t)=>this[t]=e),this._instanceProperties=void 0}connectedCallback(){this.enableUpdating()}enableUpdating(){void 0!==this._enableUpdatingResolver&&(this._enableUpdatingResolver(),this._enableUpdatingResolver=void 0)}disconnectedCallback(){}attributeChangedCallback(e,t,r){t!==r&&this._attributeToProperty(e,r)}_propertyToAttribute(e,t,r=_s){const s=this.constructor,i=s._attributeNameForProperty(e,r);if(void 0!==i){const e=s._propertyValueToAttribute(t,r);if(void 0===e)return;this._updateState=8|this._updateState,null==e?this.removeAttribute(i):this.setAttribute(i,e),this._updateState=-9&this._updateState}}_attributeToProperty(e,t){if(8&this._updateState)return;const r=this.constructor,s=r._attributeToPropertyMap.get(e);if(void 0!==s){const e=r.getPropertyOptions(s);this._updateState=16|this._updateState,this[s]=r._propertyValueFromAttribute(t,e),this._updateState=-17&this._updateState}}_requestUpdate(e,t){let r=!0;if(void 0!==e){const s=this.constructor,i=s.getPropertyOptions(e);s._valueHasChanged(this[e],t,i.hasChanged)?(this._changedProperties.has(e)||this._changedProperties.set(e,t),!0!==i.reflect||16&this._updateState||(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,i))):r=!1}!this._hasRequestedUpdate&&r&&(this._updatePromise=this._enqueueUpdate())}requestUpdate(e,t){return this._requestUpdate(e,t),this.updateComplete}async _enqueueUpdate(){this._updateState=4|this._updateState;try{await this._updatePromise}catch(e){}const e=this.performUpdate();return null!=e&&await e,!this._hasRequestedUpdate}get _hasRequestedUpdate(){return 4&this._updateState}get hasUpdated(){return 1&this._updateState}performUpdate(){this._instanceProperties&&this._applyInstanceProperties();let e=!1;const t=this._changedProperties;try{e=this.shouldUpdate(t),e?this.update(t):this._markUpdated()}catch(t){throw e=!1,this._markUpdated(),t}e&&(1&this._updateState||(this._updateState=1|this._updateState,this.firstUpdated(t)),this.updated(t))}_markUpdated(){this._changedProperties=new Map,this._updateState=-5&this._updateState}get updateComplete(){return this._getUpdateComplete()}_getUpdateComplete(){return this._updatePromise}shouldUpdate(e){return!0}update(e){void 0!==this._reflectingProperties&&this._reflectingProperties.size>0&&(this._reflectingProperties.forEach((e,t)=>this._propertyToAttribute(t,this[t],e)),this._reflectingProperties=void 0),this._markUpdated()}updated(e){}firstUpdated(e){}}Vs.finalized=!0;
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const Ds="adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,Rs=Symbol();class js{constructor(e,t){if(t!==Rs)throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=e}get styleSheet(){return void 0===this._styleSheet&&(Ds?(this._styleSheet=new CSSStyleSheet,this._styleSheet.replaceSync(this.cssText)):this._styleSheet=null),this._styleSheet}toString(){return this.cssText}}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
(window.litElementVersions||(window.litElementVersions=[])).push("2.3.1");const Ks={};class Ts extends Vs{static getStyles(){return this.styles}static _getUniqueStyles(){if(this.hasOwnProperty(JSCompiler_renameProperty("_styles",this)))return;const e=this.getStyles();if(void 0===e)this._styles=[];else if(Array.isArray(e)){const t=(e,r)=>e.reduceRight((e,r)=>Array.isArray(r)?t(r,e):(e.add(r),e),r),r=t(e,new Set),s=[];r.forEach(e=>s.unshift(e)),this._styles=s}else this._styles=[e]}initialize(){super.initialize(),this.constructor._getUniqueStyles(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}createRenderRoot(){return this.attachShadow({mode:"open"})}adoptStyles(){const e=this.constructor._styles;0!==e.length&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow?Ds?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName))}connectedCallback(){super.connectedCallback(),this.hasUpdated&&void 0!==window.ShadyCSS&&window.ShadyCSS.styleElement(this)}update(e){const t=this.render();super.update(e),t!==Ks&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._styles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}render(){return Ks}}Ts.finalized=!0,Ts.render=(e,t,r)=>{if(!r||"object"!=typeof r||!r.scopeName)throw new Error("The `scopeName` option is required.");const s=r.scopeName,i=vs.has(t),n=Ls&&11===t.nodeType&&!!t.host,a=n&&!Is.has(s),o=a?document.createDocumentFragment():t;if(ws(e,o,Object.assign({templateFactory:Es(s)},r)),a){const e=vs.get(o);vs.delete(o);const r=e.value instanceof rs?e.value.template:void 0;Hs(s,o,r),qr(t,t.firstChild),t.appendChild(o),vs.set(t,e)}!i&&n&&window.ShadyCSS.styleElement(t.host)};const Js={fromBER:function(e){if(0===e.byteLength){const e=new x({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ke(e,0,e.byteLength)}},Fs={Certificate:Or,ECPublicKey:It,RSAPublicKey:Ht},Ms={toASCII:function(e){return function(e,t){const r=e.split("@");let s="";r.length>1&&(s=r[0]+"@",e=r[1]);const i=function(e,t){const r=[];let s=e.length;for(;s--;)r[s]=t(e[s]);return r}((e=e.replace(_r,".")).split("."),t).join(".");return s+i}(e,(function(e){return Ur.test(e)?"xn--"+function(e){const t=[];let r=(e=function(e){const t=[];let r=0;const s=e.length;for(;r<s;){const i=e.charCodeAt(r++);if(i>=55296&&i<=56319&&r<s){const s=e.charCodeAt(r++);56320==(64512&s)?t.push(((1023&i)<<10)+(1023&s)+65536):(t.push(i),r--)}else t.push(i)}return t}(e)).length,s=128,i=0,n=72;for(const r of e)r<128&&t.push(Rr(r));let a=t.length,o=a;for(a&&t.push("-");o<r;){let r=2147483647;for(const t of e)t>=s&&t<r&&(r=t);const l=o+1;r-s>Dr((2147483647-i)/l)&&jr("overflow"),i+=(r-s)*l,s=r;for(const r of e)if(r<s&&++i>2147483647&&jr("overflow"),r==s){let e=i;for(let r=36;;r+=36){const s=r<=n?1:r>=n+26?26:r-n;if(e<s)break;const i=e-s,a=36-s;t.push(Rr(Kr(s+i%a,0))),e=Dr(i/a)}t.push(Rr(Kr(e,0))),n=Tr(i,l,o==a),i=0,++o}++i,++s}return t.join("")}(e):e}))}},qs={LitElement:Ts,render:ws,html:(e,...t)=>new is(e,t,"html",ps),css:(e,...t)=>{const r=t.reduce((t,r,s)=>t+(e=>{if(e instanceof js)return e.cssText;if("number"==typeof e)return e;throw new Error(`Value passed to 'css' function must be a 'css' function result: ${e}. Use 'unsafeCSS' to pass non-literal values, but\n            take care to ensure page security.`)})(r)+e[s+1],e[0]);return new js(r,Rs)},unsafeCSS:e=>new js(String(e),Rs),live:ks};export{Js as asn1js,qs as litelement,Fs as pkijs,Ms as punycode};
